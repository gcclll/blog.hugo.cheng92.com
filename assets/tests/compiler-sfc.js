/** jsx?|tsx? file header */let __BROWSER__ = typeof window !== 'undefined'let logs = {},  currentLogKey = 'cc'const babelPlugins = ['typescript']let w = {}let debugEle = nullif (__BROWSER__) {  w = typeof window !== 'undefined' ? window : {}}w.log = (msg, isLine = false) => {  if (debugEle) {    const cls = ['debug', isLine ? 'line' : ''].filter(Boolen)    ele.innerHTML = `${debugEl.innerHTML}<pre class="${cls.join(' ')}"><code>${      typeof msg === 'object' ? syntaxHighlight(msg) : msg    }</code></pre>`    return ele.innerHTML  }}function syntaxHighlight(json) {  if (typeof json != 'string') {    json = JSON.stringify(json, undefined, 2)  }  json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')  return json.replace(    /("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g,    function (match) {      var cls = 'number'      if (/^"/.test(match)) {        if (/:$/.test(match)) {          cls = 'key'        } else {          cls = 'string'        }      } else if (/true|false/.test(match)) {        cls = 'boolean'      } else if (/null/.test(match)) {        cls = 'null'      }      return '<span class="' + cls + '">' + match + '</span>'    }  )}let babelParserif (!__BROWSER__) {  babelParser = require(process.env.NODE_LIB + '/@babel/parser')}// The default decoder only provides escapes for characters reserved as part of// the template syntax, and is only used if the custom renderer did not provide// a platform-specific decoder.const decodeRE = /&(gt|lt|amp|apos|quot);/gconst decodeMap = {  gt: '>',  lt: '<',  amp: '&',  apos: "'",  quot: '"'}const EMPTY_OBJ = {}const NO = () => falseconst NOOP = () => {}const locStub = {  source: '',  start: { line: 1, column: 1, offset: 0 },  end: { line: 1, column: 1, offset: 0 }}const ConstantTypes = {  NOT_CONSTANT: 0,  CAN_SKIP_PATCH: 1,  CAN_HOIST: 2,  CAN_STRINGIFY: 3}const ElementTypes = {  ELEMENT: 0,  COMPONENT: 1,  SLOT: 2,  TEMPLATE: 3}const Namespaces = {  HTML: 0}const NodeTypes = {  ROOT: 0,  ELEMENT: 1,  TEXT: 2,  COMMENT: 3,  SIMPLE_EXPRESSION: 4,  INTERPOLATION: 5,  ATTRIBUTE: 6,  DIRECTIVE: 7,  // containers  COMPOUND_EXPRESSION: 8,  IF: 9,  IF_BRANCH: 10,  FOR: 11,  TEXT_CALL: 12,  // codegen  VNODE_CALL: 13,  JS_CALL_EXPRESSION: 14,  JS_OBJECT_EXPRESSION: 15,  JS_PROPERTY: 16,  JS_ARRAY_EXPRESSION: 17,  JS_FUNCTION_EXPRESSION: 18,  JS_CONDITIONAL_EXPRESSION: 19,  JS_CACHE_EXPRESSION: 20,  // ssr codegen  JS_BLOCK_STATEMENT: 21,  JS_TEMPLATE_LITERAL: 22,  JS_IF_STATEMENT: 23,  JS_ASSIGNMENT_EXPRESSION: 24,  JS_SEQUENCE_EXPRESSION: 25,  JS_RETURN_STATEMENT: 26}const __DEV__ = trueconst defaultParserOptions = {  delimiters: [`{{`, `}}`],  getNamespace: () => Namespaces.HTML,  getTextMode: () => TextModes.DATA,  isVoidTag: NO,  isPreTag: NO,  isCustomElement: NO,  decodeEntities: (rawText) =>    rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),  onError: defaultOnError,  onWarn: defaultOnWarn,  comments: __DEV__}const TagType = {  Start: 0,  End: 1}const TextModes = {  DATA: 0,  RCDATA: 1,  RAWTEXT: 2,  CDATA: 3,  ATTRIBUTE_VALUE: 4}let debugOn = trueconst log = (fn, message) => {  if (debugOn) {    if (message === undefined) {      console.log(fn)    } else {      console.log(`[${fn}] ${message}`)    }  }}const logOn = () => (debugOn = true)const logOff = () => (debugOn = false)const logEnd = (hint = 'END') => {  const m = `--------- ${hint} ---------`  if (debugOn) pushLog(m, 'title')  return m}const logBr = () => console.log('\n')let debugTraverseOn = falseconst logTraverseOn = () => (debugTraverseOn = true)const logTraverseOff = () => (debugTraverseOn = false)const logg = (hint, ...msg) => {  if (!debugTraverseOn && hint === 'traverseNode') return  if (debugOn) {    const m = logEnd(hint)    msg.forEach((m) => pushLog(m))  }}function pushLog(m, type = 'normal') {  ;(logs[currentLogKey] || (logs[currentLogKey] = [])).push({ value: m, type })  log(m)}function clearLog(key) {  if (key) {    logs[key] = []  } else {    logs = {}  }}const extend = Object.assignfunction defaultOnError(error) {  throw error}function defaultOnWarn(msg) {  __DEV__ && console.warn(`[Vue warn] ${msg.message}`)}function makeMap(str, expectsLowerCase) {  const map = Object.create(null)  const list = str.split(',')  for (let i = 0; i < list.length; i++) {    map[list[i]] = true  }  return expectsLowerCase    ? (val) => !!map[val.toLowerCase()]    : (val) => !!map[val]}const hasOwnProperty = Object.prototype.hasOwnPropertyconst hasOwn = (val, key) => hasOwnProperty.call(val, key)const isArray = Array.isArrayconst isMap = (val) => toTypeString(val) === '[object Map]'const isSet = (val) => toTypeString(val) === '[object Set]'const isDate = (val) => val instanceof Dateconst isFunction = (val) => typeof val === 'function'const isString = (val) => typeof val === 'string'const isSymbol = (val) => typeof val === 'symbol'const isObject = (val) => val !== null && typeof val === 'object'const onRE = /^on[^a-z]/const isOn = (key) => onRE.test(key)const isPromise = (val) => {  return isObject(val) && isFunction(val.then) && isFunction(val.catch)}const objectToString = Object.prototype.toStringconst toTypeString = (value) => objectToString.call(value)const toRawType = (value) => {  // extract "RawType" from strings like "[object RawType]"  return toTypeString(value).slice(8, -1)}function isText(node) {  return node.type === NodeTypes.INTERPOLATION || node.type === NodeTypes.TEXT}const isPlainObject = (val) => toTypeString(val) === '[object Object]'const isIntegerKey = (key) =>  isString(key) &&  key !== 'NaN' &&  key[0] !== '-' &&  '' + parseInt(key, 10) === keyconst isReservedProp = /*#__PURE__*/ makeMap(  // the leading comma is intentional so empty string "" is also included  ',key,ref,ref_for,ref_key,' +    'onVnodeBeforeMount,onVnodeMounted,' +    'onVnodeBeforeUpdate,onVnodeUpdated,' +    'onVnodeBeforeUnmount,onVnodeUnmounted')const GLOBALS_WHITE_LISTED =  'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +  'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +  'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt'const isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED)const nonIdentifierRE = /^\d|[^\$\w]/const isSimpleIdentifier = (name) => !nonIdentifierRE.test(name)const isBuiltInDirective = /*#__PURE__*/ makeMap(  'bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo')function getCursor(context) {  const { column, line, offset } = context  return { column, line, offset }}function getSelection(context, start, end) {  end = end || getCursor(context)  return {    start,    end,    source: context.originalSource.slice(start.offset, end.offset)  }}function last(xs) {  return xs[xs.length - 1]}function startsWith(source, searchString) {  return source.startsWith(searchString)}function advancePositionWithMutation(  pos,  source,  numberOfCharacters = source.length) {  let linesCount = 0  let lastNewLinePos = -1  for (let i = 0; i < numberOfCharacters; i++) {    if (source.charCodeAt(i) === 10 /* newline char code */) {      linesCount++      lastNewLinePos = i    }  }  pos.offset += numberOfCharacters  pos.line += linesCount  pos.column =    lastNewLinePos === -1      ? pos.column + numberOfCharacters      : numberOfCharacters - lastNewLinePos  return pos}function advancePositionWithClone(  pos,  source,  numberOfCharacters = source.length) {  return advancePositionWithMutation(    extend({}, pos),    source,    numberOfCharacters  )}function advanceBy(context, numberOfCharacters) {  const { source } = context  advancePositionWithMutation(context, source, numberOfCharacters)  context.source = source.slice(numberOfCharacters)}function advanceSpaces(context) {  const match = /^[\t\r\n\f ]+/.exec(context.source)  if (match) {    advanceBy(context, match[0].length)  }}function getNewPosition(context, start, numberOfCharacters) {  return advancePositionWithClone(    start,    context.originalSource.slice(start.offset, numberOfCharacters),    numberOfCharacters  )}function emitError(context, code, offset, loc = getCursor(context)) {  if (offset) {    loc.offset += offset    loc.column += offset  }  // ignore...}function isEnd(context, mode, ancestors) {  const s = context.source  switch (mode) {    case TextModes.DATA:      if (startsWith(s, '</')) {        // TODO: probably bad performance        for (let i = ancestors.length - 1; i >= 0; --i) {          if (startsWithEndTagOpen(s, ancestors[i].tag)) {            return true          }        }      }      break    case TextModes.RCDATA:    case TextModes.RAWTEXT: {      const parent = last(ancestors)      if (parent && startsWithEndTagOpen(s, parent.tag)) {        return true      }      break    }    case TextModes.CDATA:      if (startsWith(s, ']]>')) {        return true      }      break  }  return !s}function startsWithEndTagOpen(source, tag) {  return (    startsWith(source, '</') &&    source.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase() &&    /[\t\r\n\f />]/.test(source[2 + tag.length] || '>')  )}const cacheStringFunction = (fn) => {  const cache = Object.create(null)  return (str) => {    const hit = cache[str]    return hit || (cache[str] = fn(str))  }}const camelizeRE = /-(\w)/gconst camelize = cacheStringFunction((str) => {  return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''))})const hyphenateRE = /\B([A-Z])/gconst hyphenate = cacheStringFunction((str) =>  str.replace(hyphenateRE, '-$1').toLowerCase())const capitalize = cacheStringFunction(  (str) => str.charAt(0).toUpperCase() + str.slice(1))const toHandlerKey = cacheStringFunction((str) =>  str ? `on${capitalize(str)}` : ``)const isBuiltInType = (tag, expected) =>  tag === expected || tag === hyphenate(expected)function isCoreComponent(tag) {  if (isBuiltInType(tag, 'Teleport')) {    return TELEPORT  } else if (isBuiltInType(tag, 'Suspense')) {    return SUSPENSE  } else if (isBuiltInType(tag, 'KeepAlive')) {    return KEEP_ALIVE  } else if (isBuiltInType(tag, 'BaseTransition')) {    return BASE_TRANSITION  }}const isSpecialTemplateDirective = /*#__PURE__*/ makeMap(  `if,else,else-if,for,slot`)function isComponent(tag, props, context) {  const options = context.options  if (options.isCustomElement(tag)) {    return false  }  if (    tag === 'component' ||    /^[A-Z]/.test(tag) ||    isCoreComponent(tag) ||    (options.isBuiltInComponent && options.isBuiltInComponent(tag)) ||    (options.isNativeTag && !options.isNativeTag(tag))  ) {    return true  }  // at this point the tag should be a native tag, but check for potential "is"  // casting  for (let i = 0; i < props.length; i++) {    const p = props[i]    if (p.type === NodeTypes.ATTRIBUTE) {      if (p.name === 'is' && p.value) {        if (p.value.content.startsWith('vue:')) {          return true        }      }    } else {      // directive      // v-is (TODO Deprecate)      if (p.name === 'is') {        return true      }    }  }}function pushNode(nodes, node) {  if (node.type === NodeTypes.TEXT) {    const prev = last(nodes)    // Merge if both this and the previous node are text and those are    // consecutive. This happens for cases like "a < b".    if (      prev &&      prev.type === NodeTypes.TEXT &&      prev.loc.end.offset === node.loc.start.offset    ) {      prev.content += node.content      prev.loc.end = node.loc.end      prev.loc.source += node.loc.source      return    }  }  nodes.push(node)}function getVNodeHelper(ssr, isComponent) {  return ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE}function getVNodeBlockHelper(ssr, isComponent) {  return ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK}function isSingleElementRoot(root, child) {  const { children } = root  return (    children.length === 1 &&    child.type === NodeTypes.ELEMENT &&    !isSlotOutlet(child)  )}function isSlotOutlet(node) {  return node.type === NodeTypes.ELEMENT && node.tagType === ElementTypes.SLOT}function findDir(node, name, allowEmpty = false) {  for (let i = 0; i < node.props.length; i++) {    const p = node.props[i]    if (      p.type === NodeTypes.DIRECTIVE &&      (allowEmpty || p.exp) &&      (isString(name) ? p.name === name : name.test(p.name))    ) {      return p    }  }}function findProp(node, name, dynamicOnly = false, allowEmpty = false) {  for (let i = 0; i < node.props.length; i++) {    const p = node.props[i]    if (p.type === NodeTypes.ATTRIBUTE) {      if (dynamicOnly) continue      if (p.name === name && (p.value || allowEmpty)) {        return p      }    } else if (      p.name === 'bind' &&      (p.exp || allowEmpty) &&      isStaticArgOf(p.arg, name)    ) {      return p    }  }}const isStaticExp = (p) => p.type === NodeTypes.SIMPLE_EXPRESSION && p.isStaticfunction isStaticArgOf(arg, name) {  return !!(arg && isStaticExp(arg) && arg.content === name)}function isVSlot(p) {  return p.type === NodeTypes.DIRECTIVE && p.name === 'slot'}function getMemoedVNodeCall(node) {  if (node.type === NodeTypes.JS_CALL_EXPRESSION && node.callee === WITH_MEMO) {    return node.arguments[1].returns  } else {    return node  }}function getInnerRange(loc, offset, length) {  const source = loc.source.slice(offset, offset + length)  const newLoc = {    source,    start: advancePositionWithClone(loc.start, loc.source, offset),    end: loc.end  }  if (length != null) {    newLoc.end = advancePositionWithClone(      loc.start,      loc.source,      offset + length    )  }  return newLoc}function toValidAssetId(name, type) {  // see issue#4422, we need adding identifier on validAssetId if variable `name` has specific character  return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {    return searchValue === '-' ? '_' : name.charCodeAt(replaceValue).toString()  })}`}function isTemplateNode(node) {  return (    node.type === NodeTypes.ELEMENT && node.tagType === ElementTypes.TEMPLATE  )}const FRAGMENT = Symbol(__DEV__ ? `Fragment` : ``)const TELEPORT = Symbol(__DEV__ ? `Teleport` : ``)const SUSPENSE = Symbol(__DEV__ ? `Suspense` : ``)const KEEP_ALIVE = Symbol(__DEV__ ? `KeepAlive` : ``)const BASE_TRANSITION = Symbol(__DEV__ ? `BaseTransition` : ``)const OPEN_BLOCK = Symbol(__DEV__ ? `openBlock` : ``)const CREATE_BLOCK = Symbol(__DEV__ ? `createBlock` : ``)const CREATE_ELEMENT_BLOCK = Symbol(__DEV__ ? `createElementBlock` : ``)const CREATE_VNODE = Symbol(__DEV__ ? `createVNode` : ``)const CREATE_ELEMENT_VNODE = Symbol(__DEV__ ? `createElementVNode` : ``)const CREATE_COMMENT = Symbol(__DEV__ ? `createCommentVNode` : ``)const CREATE_TEXT = Symbol(__DEV__ ? `createTextVNode` : ``)const CREATE_STATIC = Symbol(__DEV__ ? `createStaticVNode` : ``)const RESOLVE_COMPONENT = Symbol(__DEV__ ? `resolveComponent` : ``)const RESOLVE_DYNAMIC_COMPONENT = Symbol(  __DEV__ ? `resolveDynamicComponent` : ``)const RESOLVE_DIRECTIVE = Symbol(__DEV__ ? `resolveDirective` : ``)const RESOLVE_FILTER = Symbol(__DEV__ ? `resolveFilter` : ``)const WITH_DIRECTIVES = Symbol(__DEV__ ? `withDirectives` : ``)const RENDER_LIST = Symbol(__DEV__ ? `renderList` : ``)const RENDER_SLOT = Symbol(__DEV__ ? `renderSlot` : ``)const CREATE_SLOTS = Symbol(__DEV__ ? `createSlots` : ``)const TO_DISPLAY_STRING = Symbol(__DEV__ ? `toDisplayString` : ``)const MERGE_PROPS = Symbol(__DEV__ ? `mergeProps` : ``)const NORMALIZE_CLASS = Symbol(__DEV__ ? `normalizeClass` : ``)const NORMALIZE_STYLE = Symbol(__DEV__ ? `normalizeStyle` : ``)const NORMALIZE_PROPS = Symbol(__DEV__ ? `normalizeProps` : ``)const GUARD_REACTIVE_PROPS = Symbol(__DEV__ ? `guardReactiveProps` : ``)const TO_HANDLERS = Symbol(__DEV__ ? `toHandlers` : ``)const CAMELIZE = Symbol(__DEV__ ? `camelize` : ``)const CAPITALIZE = Symbol(__DEV__ ? `capitalize` : ``)const TO_HANDLER_KEY = Symbol(__DEV__ ? `toHandlerKey` : ``)const SET_BLOCK_TRACKING = Symbol(__DEV__ ? `setBlockTracking` : ``)const PUSH_SCOPE_ID = Symbol(__DEV__ ? `pushScopeId` : ``)const POP_SCOPE_ID = Symbol(__DEV__ ? `popScopeId` : ``)const WITH_CTX = Symbol(__DEV__ ? `withCtx` : ``)const UNREF = Symbol(__DEV__ ? `unref` : ``)const IS_REF = Symbol(__DEV__ ? `isRef` : ``)const WITH_MEMO = Symbol(__DEV__ ? `withMemo` : ``)const IS_MEMO_SAME = Symbol(__DEV__ ? `isMemoSame` : ``)// Name mapping for runtime helpers that need to be imported from 'vue' in// generated code. Make sure these are correctly exported in the runtime!// Using `any` here because TS doesn't allow symbols as index type.const helperNameMap = {  [FRAGMENT]: `Fragment`,  [TELEPORT]: `Teleport`,  [SUSPENSE]: `Suspense`,  [KEEP_ALIVE]: `KeepAlive`,  [BASE_TRANSITION]: `BaseTransition`,  [OPEN_BLOCK]: `openBlock`,  [CREATE_BLOCK]: `createBlock`,  [CREATE_ELEMENT_BLOCK]: `createElementBlock`,  [CREATE_VNODE]: `createVNode`,  [CREATE_ELEMENT_VNODE]: `createElementVNode`,  [CREATE_COMMENT]: `createCommentVNode`,  [CREATE_TEXT]: `createTextVNode`,  [CREATE_STATIC]: `createStaticVNode`,  [RESOLVE_COMPONENT]: `resolveComponent`,  [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,  [RESOLVE_DIRECTIVE]: `resolveDirective`,  [RESOLVE_FILTER]: `resolveFilter`,  [WITH_DIRECTIVES]: `withDirectives`,  [RENDER_LIST]: `renderList`,  [RENDER_SLOT]: `renderSlot`,  [CREATE_SLOTS]: `createSlots`,  [TO_DISPLAY_STRING]: `toDisplayString`,  [MERGE_PROPS]: `mergeProps`,  [NORMALIZE_CLASS]: `normalizeClass`,  [NORMALIZE_STYLE]: `normalizeStyle`,  [NORMALIZE_PROPS]: `normalizeProps`,  [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,  [TO_HANDLERS]: `toHandlers`,  [CAMELIZE]: `camelize`,  [CAPITALIZE]: `capitalize`,  [TO_HANDLER_KEY]: `toHandlerKey`,  [SET_BLOCK_TRACKING]: `setBlockTracking`,  [PUSH_SCOPE_ID]: `pushScopeId`,  [POP_SCOPE_ID]: `popScopeId`,  [WITH_CTX]: `withCtx`,  [UNREF]: `unref`,  [IS_REF]: `isRef`,  [WITH_MEMO]: `withMemo`,  [IS_MEMO_SAME]: `isMemoSame`}function registerRuntimeHelpers(helpers) {  Object.getOwnPropertySymbols(helpers).forEach((s) => {    helperNameMap[s] = helpers[s]  })}/** * Patch flags are optimization hints generated by the compiler. * when a block with dynamicChildren is encountered during diff, the algorithm * enters "optimized mode". In this mode, we know that the vdom is produced by * a render function generated by the compiler, so the algorithm only needs to * handle updates explicitly marked by these patch flags. * * Patch flags can be combined using the | bitwise operator and can be checked * using the & operator, e.g. * * ```js * const flag = TEXT | CLASS * if (flag & TEXT) { ... } * ``` * * Check the `patchElement` function in '../../runtime-core/src/renderer.ts' to see how the * flags are handled during diff. */const PatchFlags = {  /**   * Indicates an element with dynamic textContent (children fast path)   */  TEXT: 1,  /**   * Indicates an element with dynamic class binding.   */  CLASS: 1 << 1,  /**   * Indicates an element with dynamic style   * The compiler pre-compiles static string styles into static objects   * + detects and hoists inline static objects   * e.g. `style="color: red"` and `:style="{ color: 'red' }"` both get hoisted   * as:   * ```js   * const style = { color: 'red' }   * render() { return e('div', { style }) }   * ```   */  STYLE: 1 << 2,  /**   * Indicates an element that has non-class/style dynamic props.   * Can also be on a component that has any dynamic props (includes   * class/style). when this flag is present, the vnode also has a dynamicProps   * array that contains the keys of the props that may change so the runtime   * can diff them faster (without having to worry about removed props)   */  PROPS: 1 << 3,  /**   * Indicates an element with props with dynamic keys. When keys change, a full   * diff is always needed to remove the old key. This flag is mutually   * exclusive with CLASS, STYLE and PROPS.   */  FULL_PROPS: 1 << 4,  /**   * Indicates an element with event listeners (which need to be attached   * during hydration)   */  HYDRATE_EVENTS: 1 << 5,  /**   * Indicates a fragment whose children order doesn't change.   */  STABLE_FRAGMENT: 1 << 6,  /**   * Indicates a fragment with keyed or partially keyed children   */  KEYED_FRAGMENT: 1 << 7,  /**   * Indicates a fragment with unkeyed children.   */  UNKEYED_FRAGMENT: 1 << 8,  /**   * Indicates an element that only needs non-props patching, e.g. ref or   * directives (onVnodeXXX hooks). since every patched vnode checks for refs   * and onVnodeXXX hooks, it simply marks the vnode so that a parent block   * will track it.   */  NEED_PATCH: 1 << 9,  /**   * Indicates a component with dynamic slots (e.g. slot that references a v-for   * iterated value, or dynamic slot names).   * Components with this flag are always force updated.   */  DYNAMIC_SLOTS: 1 << 10,  /**   * Indicates a fragment that was created only because the user has placed   * comments at the root level of a template. This is a dev-only flag since   * comments are stripped in production.   */  DEV_ROOT_FRAGMENT: 1 << 11,  /**   * SPECIAL FLAGS -------------------------------------------------------------   * Special flags are negative integers. They are never matched against using   * bitwise operators (bitwise matching should only happen in branches where   * patchFlag > 0), and are mutually exclusive. When checking for a special   * flag, simply check patchFlag === FLAG.   */  /**   * Indicates a hoisted static vnode. This is a hint for hydration to skip   * the entire sub tree since static content never needs to be updated.   */  HOISTED: -1,  /**   * A special flag that indicates that the diffing algorithm should bail out   * of optimized mode. For example, on block fragments created by renderSlot()   * when encountering non-compiler generated slots (i.e. manually written   * render functions, which should always be fully diffed)   * OR manually cloneVNodes   */  BAIL: -2}/** * dev only flag -> name mapping */const PatchFlagNames = {  [PatchFlags.TEXT]: `TEXT`,  [PatchFlags.CLASS]: `CLASS`,  [PatchFlags.STYLE]: `STYLE`,  [PatchFlags.PROPS]: `PROPS`,  [PatchFlags.FULL_PROPS]: `FULL_PROPS`,  [PatchFlags.HYDRATE_EVENTS]: `HYDRATE_EVENTS`,  [PatchFlags.STABLE_FRAGMENT]: `STABLE_FRAGMENT`,  [PatchFlags.KEYED_FRAGMENT]: `KEYED_FRAGMENT`,  [PatchFlags.UNKEYED_FRAGMENT]: `UNKEYED_FRAGMENT`,  [PatchFlags.NEED_PATCH]: `NEED_PATCH`,  [PatchFlags.DYNAMIC_SLOTS]: `DYNAMIC_SLOTS`,  [PatchFlags.DEV_ROOT_FRAGMENT]: `DEV_ROOT_FRAGMENT`,  [PatchFlags.HOISTED]: `HOISTED`,  [PatchFlags.BAIL]: `BAIL`}function genFlagText(flag, names = PatchFlagNames) {  if (isArray(flag)) {    let f = 0    flag.forEach((ff) => {      f |= ff    })    return `${f} /* ${flag.map((f) => names[f]).join(', ')} */`  } else {    return `${flag} /* ${names[flag]} */`  }}const propsHelperSet = new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS])function getUnnormalizedProps(props, callPath = []) {  if (    props &&    !isString(props) &&    props.type === NodeTypes.JS_CALL_EXPRESSION  ) {    const callee = props.callee    if (!isString(callee) && propsHelperSet.has(callee)) {      return getUnnormalizedProps(props.arguments[0], callPath.concat(props))    }  }  return [props, callPath]}function injectProp(node, prop, context) {  let propsWithInjection  /**   * 1. mergeProps(...)   * 2. toHandlers(...)   * 3. normalizeProps(...)   * 4. normalizeProps(guardReactiveProps(...))   *   * we need to get the real props before normalization   */  let props =    node.type === NodeTypes.VNODE_CALL ? node.props : node.arguments[2]  let callPath = []  let parentCall  if (    props &&    !isString(props) &&    props.type === NodeTypes.JS_CALL_EXPRESSION  ) {    const ret = getUnnormalizedProps(props)    props = ret[0]    callPath = ret[1]    parentCall = callPath[callPath.length - 1]  }  if (props == null || isString(props)) {    propsWithInjection = createObjectExpression([prop])  } else if (props.type === NodeTypes.JS_CALL_EXPRESSION) {    // merged props... add ours    // only inject key to object literal if it's the first argument so that    // if doesn't override user provided keys    const first = props.arguments[0] | JSChildNode    if (!isString(first) && first.type === NodeTypes.JS_OBJECT_EXPRESSION) {      first.properties.unshift(prop)    } else {      if (props.callee === TO_HANDLERS) {        // #2366        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [          createObjectExpression([prop]),          props        ])      } else {        props.arguments.unshift(createObjectExpression([prop]))      }    }    !propsWithInjection && (propsWithInjection = props)  } else if (props.type === NodeTypes.JS_OBJECT_EXPRESSION) {    let alreadyExists = false    // check existing key to avoid overriding user provided keys    if (prop.key.type === NodeTypes.SIMPLE_EXPRESSION) {      const propKeyName = prop.key.content      alreadyExists = props.properties.some(        (p) =>          p.key.type === NodeTypes.SIMPLE_EXPRESSION &&          p.key.content === propKeyName      )    }    if (!alreadyExists) {      props.properties.unshift(prop)    }    propsWithInjection = props  } else {    // single v-bind with expression, return a merged replacement    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [      createObjectExpression([prop]),      props    ])    // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(props))`,    // it will be rewritten as `normalizeProps(mergeProps({ key: 0 }, props))`,    // the `guardReactiveProps` will no longer be needed    if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {      parentCall = callPath[callPath.length - 2]    }  }  if (node.type === NodeTypes.VNODE_CALL) {    if (parentCall) {      parentCall.arguments[0] = propsWithInjection    } else {      node.props = propsWithInjection    }  } else {    if (parentCall) {      parentCall.arguments[0] = propsWithInjection    } else {      node.arguments[2] = propsWithInjection    }  }}const BindingTypes = {  /**   * returned from data()   */  DATA: 'data',  /**   * declared as a prop   */  PROPS: 'props',  /**   * a local alias of a `<script setup>` destructured prop.   * the original is stored in __propsAliases of the bindingMetadata object.   */  PROPS_ALIASED: 'props-aliased',  /**   * a let binding (may or may not be a ref)   */  SETUP_LET: 'setup-let',  /**   * a const binding that can never be a ref.   * these bindings don't need `unref()` calls when processed in inlined   * template expressions.   */  SETUP_CONST: 'setup-const',  /**   * a const binding that may be a ref.   */  SETUP_MAYBE_REF: 'setup-maybe-ref',  /**   * bindings that are guaranteed to be refs   */  SETUP_REF: 'setup-ref',  /**   * declared by other options, e.g. computed, inject   */  OPTIONS: 'options'}class WalkerBase {  constructor() {    /** @type {boolean} */    this.should_skip = false    /** @type {boolean} */    this.should_remove = false    /** @type {BaseNode | null} */    this.replacement = null    /** @type {WalkerContext} */    this.context = {      skip: () => (this.should_skip = true),      remove: () => (this.should_remove = true),      replace: (node) => (this.replacement = node)    }  }  replace(parent, prop, index, node) {    if (parent) {      if (index !== null) {        parent[prop][index] = node      } else {        parent[prop] = node      }    }  }  remove(parent, prop, index) {    if (parent) {      if (index !== null) {        parent[prop].splice(index, 1)      } else {        delete parent[prop]      }    }  }}class SyncWalker extends WalkerBase {  constructor(enter, leave) {    super()    /** @type {SyncHandler} */    this.enter = enter    /** @type {SyncHandler} */    this.leave = leave  }  visit(node, parent, prop, index) {    if (node) {      if (this.enter) {        const _should_skip = this.should_skip        const _should_remove = this.should_remove        const _replacement = this.replacement        this.should_skip = false        this.should_remove = false        this.replacement = null        this.enter.call(this.context, node, parent, prop, index)        if (this.replacement) {          node = this.replacement          this.replace(parent, prop, index, node)        }        if (this.should_remove) {          this.remove(parent, prop, index)        }        const skipped = this.should_skip        const removed = this.should_remove        this.should_skip = _should_skip        this.should_remove = _should_remove        this.replacement = _replacement        if (skipped) return node        if (removed) return null      }      for (const key in node) {        const value = node[key]        if (typeof value !== 'object') {          continue        } else if (Array.isArray(value)) {          for (let i = 0; i < value.length; i += 1) {            if (value[i] !== null && typeof value[i].type === 'string') {              if (!this.visit(value[i], node, key, i)) {                // removed                i--              }            }          }        } else if (value !== null && typeof value.type === 'string') {          this.visit(value, node, key, null)        }      }      if (this.leave) {        const _replacement = this.replacement        const _should_remove = this.should_remove        this.replacement = null        this.should_remove = false        this.leave.call(this.context, node, parent, prop, index)        if (this.replacement) {          node = this.replacement          this.replace(parent, prop, index, node)        }        if (this.should_remove) {          this.remove(parent, prop, index)        }        const removed = this.should_remove        this.replacement = _replacement        this.should_remove = _should_remove        if (removed) return null      }    }    return node  }}class AsyncWalker extends WalkerBase {  constructor(enter, leave) {    super()    /** @type {AsyncHandler} */    this.enter = enter    /** @type {AsyncHandler} */    this.leave = leave  }  async visit(node, parent, prop, index) {    if (node) {      if (this.enter) {        const _should_skip = this.should_skip        const _should_remove = this.should_remove        const _replacement = this.replacement        this.should_skip = false        this.should_remove = false        this.replacement = null        await this.enter.call(this.context, node, parent, prop, index)        if (this.replacement) {          node = this.replacement          this.replace(parent, prop, index, node)        }        if (this.should_remove) {          this.remove(parent, prop, index)        }        const skipped = this.should_skip        const removed = this.should_remove        this.should_skip = _should_skip        this.should_remove = _should_remove        this.replacement = _replacement        if (skipped) return node        if (removed) return null      }      for (const key in node) {        const value = node[key]        if (typeof value !== 'object') {          continue        } else if (Array.isArray(value)) {          for (let i = 0; i < value.length; i += 1) {            if (value[i] !== null && typeof value[i].type === 'string') {              if (!(await this.visit(value[i], node, key, i))) {                // removed                i--              }            }          }        } else if (value !== null && typeof value.type === 'string') {          await this.visit(value, node, key, null)        }      }      if (this.leave) {        const _replacement = this.replacement        const _should_remove = this.should_remove        this.replacement = null        this.should_remove = false        await this.leave.call(this.context, node, parent, prop, index)        if (this.replacement) {          node = this.replacement          this.replace(parent, prop, index, node)        }        if (this.should_remove) {          this.remove(parent, prop, index)        }        const removed = this.should_remove        this.replacement = _replacement        this.should_remove = _should_remove        if (removed) return null      }    }    return node  }}function walk(ast, { enter, leave }) {  const instance = new SyncWalker(enter, leave)  return instance.visit(ast, null)}async function asyncWalk(ast, { enter, leave }) {  const instance = new AsyncWalker(enter, leave)  return await instance.visit(ast, null)}function isInDestructureAssignment(parent, parentStack) {  if (    parent &&    (parent.type === 'ObjectProperty' || parent.type === 'ArrayPattern')  ) {    let i = parentStack.length    while (i--) {      const p = parentStack[i]      if (p.type === 'AssignmentExpression') {        return true      } else if (p.type !== 'ObjectProperty' && !p.type.endsWith('Pattern')) {        break      }    }  }  return false}function walkIdentifiers(  root,  onIdentifier,  includeAll = false,  parentStack = [],  knownIds = Object.create(null)) {  if (__BROWSER__) {    return  }  const rootExp =    root.type === 'Program' &&    root.body[0].type === 'ExpressionStatement' &&    root.body[0].expression  walk(root, {    enter(node, parent) {      parent && parentStack.push(parent)      if (        parent &&        parent.type.startsWith('TS') &&        parent.type !== 'TSAsExpression' &&        parent.type !== 'TSNonNullExpression' &&        parent.type !== 'TSTypeAssertion'      ) {        return this.skip()      }      if (node.type === 'Identifier') {        const isLocal = !!knownIds[node.name]        const isRefed = isReferencedIdentifier(node, parent, parentStack)        if (includeAll || (isRefed && !isLocal)) {          onIdentifier(node, parent, parentStack, isRefed, isLocal)        }      } else if (        node.type === 'ObjectProperty' &&        parent.type === 'ObjectPattern'      ) {        // mark property in destructure pattern        node.inPattern = true      } else if (isFunctionType(node)) {        // walk function expressions and add its arguments to known identifiers        // so that we don't prefix them        walkFunctionParams(node, (id) =>          markScopeIdentifier(node, id, knownIds)        )      } else if (node.type === 'BlockStatement') {        // #3445 record block-level local variables        walkBlockDeclarations(node, (id) =>          markScopeIdentifier(node, id, knownIds)        )      }    },    leave(node, parent) {      parent && parentStack.pop()      if (node !== rootExp && node.scopeIds) {        for (const id of node.scopeIds) {          knownIds[id]--          if (knownIds[id] === 0) {            delete knownIds[id]          }        }      }    }  })}function isReferencedIdentifier(id, parent, parentStack) {  if (__BROWSER__) {    return false  }  if (!parent) {    return true  }  // is a special keyword but parsed as identifier  if (id.name === 'arguments') {    return false  }  if (isReferenced(id, parent)) {    return true  }  // babel's isReferenced check returns false for ids being assigned to, so we  // need to cover those cases here  switch (parent.type) {    case 'AssignmentExpression':    case 'AssignmentPattern':      return true    case 'ObjectPattern':    case 'ArrayPattern':      return isInDestructureAssignment(parent, parentStack)  }  return false}function isInDestructureAssignment(parent, parentStack) {  if (    parent &&    (parent.type === 'ObjectProperty' || parent.type === 'ArrayPattern')  ) {    let i = parentStack.length    while (i--) {      const p = parentStack[i]      if (p.type === 'AssignmentExpression') {        return true      } else if (p.type !== 'ObjectProperty' && !p.type.endsWith('Pattern')) {        break      }    }  }  return false}function walkFunctionParams(node, onIdent) {  for (const p of node.params) {    for (const id of extractIdentifiers(p)) {      onIdent(id)    }  }}function walkBlockDeclarations(block, onIdent) {  for (const stmt of block.body) {    if (stmt.type === 'VariableDeclaration') {      if (stmt.declare) continue      for (const decl of stmt.declarations) {        for (const id of extractIdentifiers(decl.id)) {          onIdent(id)        }      }    } else if (      stmt.type === 'FunctionDeclaration' ||      stmt.type === 'ClassDeclaration'    ) {      if (stmt.declare || !stmt.id) continue      onIdent(stmt.id)    }  }}function extractIdentifiers(param, nodes = []) {  switch (param.type) {    case 'Identifier':      nodes.push(param)      break    case 'MemberExpression':      let object = param      while (object.type === 'MemberExpression') {        object = object.object      }      nodes.push(object)      break    case 'ObjectPattern':      for (const prop of param.properties) {        if (prop.type === 'RestElement') {          extractIdentifiers(prop.argument, nodes)        } else {          extractIdentifiers(prop.value, nodes)        }      }      break    case 'ArrayPattern':      param.elements.forEach((element) => {        if (element) extractIdentifiers(element, nodes)      })      break    case 'RestElement':      extractIdentifiers(param.argument, nodes)      break    case 'AssignmentPattern':      extractIdentifiers(param.left, nodes)      break  }  return nodes}function markScopeIdentifier(node, child, knownIds) {  const { name } = child  if (node.scopeIds && node.scopeIds.has(name)) {    return  }  if (name in knownIds) {    knownIds[name]++  } else {    knownIds[name] = 1  }  ;(node.scopeIds || (node.scopeIds = new Set())).add(name)}const isFunctionType = (node) => {  return /Function(?:Expression|Declaration)$|Method$/.test(node.type)}const isStaticProperty = (node) =>  node &&  (node.type === 'ObjectProperty' || node.type === 'ObjectMethod') &&  !node.computedconst isStaticPropertyKey = (node, parent) =>  isStaticProperty(parent) && parent.key === node/** * Copied from https://github.com/babel/babel/blob/main/packages/babel-types/src/validators/isReferenced.ts * To avoid runtime dependency on @babel/types (which includes process references) * This file should not change very often in babel but we may need to keep it * up-to-date from time to time. * * https://github.com/babel/babel/blob/main/LICENSE * */function isReferenced(node, parent, grandparent) {  switch (parent.type) {    // yes: PARENT[NODE]    // yes: NODE.child    // no: parent.NODE    case 'MemberExpression':    case 'OptionalMemberExpression':      if (parent.property === node) {        return !!parent.computed      }      return parent.object === node    case 'JSXMemberExpression':      return parent.object === node    // no: let NODE = init;    // yes: let id = NODE;    case 'VariableDeclarator':      return parent.init === node    // yes: () => NODE    // no: (NODE) => {}    case 'ArrowFunctionExpression':      return parent.body === node    // no: class { #NODE; }    // no: class { get #NODE() {} }    // no: class { #NODE() {} }    // no: class { fn() { return this.#NODE; } }    case 'PrivateName':      return false    // no: class { NODE() {} }    // yes: class { [NODE]() {} }    // no: class { foo(NODE) {} }    case 'ClassMethod':    case 'ClassPrivateMethod':    case 'ObjectMethod':      if (parent.key === node) {        return !!parent.computed      }      return false    // yes: { [NODE]: "" }    // no: { NODE: "" }    // depends: { NODE }    // depends: { key: NODE }    case 'ObjectProperty':      if (parent.key === node) {        return !!parent.computed      }      // parent.value === node      return !grandparent || grandparent.type !== 'ObjectPattern'    // no: class { NODE = value; }    // yes: class { [NODE] = value; }    // yes: class { key = NODE; }    case 'ClassProperty':      if (parent.key === node) {        return !!parent.computed      }      return true    case 'ClassPrivateProperty':      return parent.key !== node    // no: class NODE {}    // yes: class Foo extends NODE {}    case 'ClassDeclaration':    case 'ClassExpression':      return parent.superClass === node    // yes: left = NODE;    // no: NODE = right;    case 'AssignmentExpression':      return parent.right === node    // no: [NODE = foo] = [];    // yes: [foo = NODE] = [];    case 'AssignmentPattern':      return parent.right === node    // no: NODE: for (;;) {}    case 'LabeledStatement':      return false    // no: try {} catch (NODE) {}    case 'CatchClause':      return false    // no: function foo(...NODE) {}    case 'RestElement':      return false    case 'BreakStatement':    case 'ContinueStatement':      return false    // no: function NODE() {}    // no: function foo(NODE) {}    case 'FunctionDeclaration':    case 'FunctionExpression':      return false    // no: export NODE from "foo";    // no: export * as NODE from "foo";    case 'ExportNamespaceSpecifier':    case 'ExportDefaultSpecifier':      return false    // no: export { foo as NODE };    // yes: export { NODE as foo };    // no: export { NODE as foo } from "foo";    case 'ExportSpecifier':      // @ts-expect-error      if (grandparent?.source) {        return false      }      return parent.local === node    // no: import NODE from "foo";    // no: import * as NODE from "foo";    // no: import { NODE as foo } from "foo";    // no: import { foo as NODE } from "foo";    // no: import NODE from "bar";    case 'ImportDefaultSpecifier':    case 'ImportNamespaceSpecifier':    case 'ImportSpecifier':      return false    // no: import "foo" assert { NODE: "json" }    case 'ImportAttribute':      return false    // no: <div NODE="foo" />    case 'JSXAttribute':      return false    // no: [NODE] = [];    // no: ({ NODE }) = [];    case 'ObjectPattern':    case 'ArrayPattern':      return false    // no: new.NODE    // no: NODE.target    case 'MetaProperty':      return false    // yes: type X = { someProperty: NODE }    // no: type X = { NODE: OtherType }    case 'ObjectTypeProperty':      return parent.key !== node    // yes: enum X { Foo = NODE }    // no: enum X { NODE }    case 'TSEnumMember':      return parent.id !== node    // yes: { [NODE]: value }    // no: { NODE: value }    case 'TSPropertySignature':      if (parent.key === node) {        return !!parent.computed      }      return true  }  return true}const validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/const validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/const whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/gconst MemberExpLexState = {  inMemberExp: 0,  inBrackets: 1,  inParens: 2,  inString: 3}const isMemberExpressionBrowser = (path) => {  // remove whitespaces around . or [ first  path = path.trim().replace(whitespaceRE, (s) => s.trim())  let state = MemberExpLexState.inMemberExp  let stateStack = []  let currentOpenBracketCount = 0  let currentOpenParensCount = 0  let currentStringType = null  for (let i = 0; i < path.length; i++) {    const char = path.charAt(i)    switch (state) {      case MemberExpLexState.inMemberExp:        if (char === '[') {          stateStack.push(state)          state = MemberExpLexState.inBrackets          currentOpenBracketCount++        } else if (char === '(') {          stateStack.push(state)          state = MemberExpLexState.inParens          currentOpenParensCount++        } else if (          !(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)        ) {          return false        }        break      case MemberExpLexState.inBrackets:        if (char === `'` || char === `"` || char === '`') {          stateStack.push(state)          state = MemberExpLexState.inString          currentStringType = char        } else if (char === `[`) {          currentOpenBracketCount++        } else if (char === `]`) {          if (!--currentOpenBracketCount) {            state = stateStack.pop()          }        }        break      case MemberExpLexState.inParens:        if (char === `'` || char === `"` || char === '`') {          stateStack.push(state)          state = MemberExpLexState.inString          currentStringType = char        } else if (char === `(`) {          currentOpenParensCount++        } else if (char === `)`) {          // if the exp ends as a call then it should not be considered valid          if (i === path.length - 1) {            return false          }          if (!--currentOpenParensCount) {            state = stateStack.pop()          }        }        break      case MemberExpLexState.inString:        if (char === currentStringType) {          state = stateStack.pop()          currentStringType = null        }        break    }  }  return !currentOpenBracketCount && !currentOpenParensCount}const isMemberExpressionNode = __BROWSER__  ? NOOP  : (path, context) => {      try {        let ret = babelParser.parseExpression(path, {          plugins: [...context.expressionPlugins, ...babelPlugins]        })        if (ret.type === 'TSAsExpression' || ret.type === 'TSTypeAssertion') {          ret = ret.expression        }        return (          ret.type === 'MemberExpression' ||          ret.type === 'OptionalMemberExpression' ||          ret.type === 'Identifier'        )      } catch (e) {        return false      }    }const isMemberExpression = __BROWSER__  ? isMemberExpressionBrowser  : isMemberExpressionNode// Check if a node contains expressions that reference current context scope idsfunction hasScopeRef(node, ids) {  if (!node || Object.keys(ids).length === 0) {    return false  }  switch (node.type) {    case NodeTypes.ELEMENT:      for (let i = 0; i < node.props.length; i++) {        const p = node.props[i]        if (          p.type === NodeTypes.DIRECTIVE &&          (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))        ) {          return true        }      }      return node.children.some((c) => hasScopeRef(c, ids))    case NodeTypes.FOR:      if (hasScopeRef(node.source, ids)) {        return true      }      return node.children.some((c) => hasScopeRef(c, ids))    case NodeTypes.IF:      return node.branches.some((b) => hasScopeRef(b, ids))    case NodeTypes.IF_BRANCH:      if (hasScopeRef(node.condition, ids)) {        return true      }      return node.children.some((c) => hasScopeRef(c, ids))    case NodeTypes.SIMPLE_EXPRESSION:      return (        !node.isStatic &&        isSimpleIdentifier(node.content) &&        !!ids[node.content]      )    case NodeTypes.COMPOUND_EXPRESSION:      return node.children.some((c) => isObject(c) && hasScopeRef(c, ids))    case NodeTypes.INTERPOLATION:    case NodeTypes.TEXT_CALL:      return hasScopeRef(node.content, ids)    case NodeTypes.TEXT:    case NodeTypes.COMMENT:      return false    default:      if (__DEV__) {        const exhaustiveCheck = node        exhaustiveCheck      }      return false  }}const SlotFlags = {  /**   * Stable slots that only reference slot props or context state. The slot   * can fully capture its own dependencies so when passed down the parent won't   * need to force the child to update.   */  STABLE: 1,  /**   * Slots that reference scope variables (v-for or an outer slot prop), or   * has conditional structure (v-if, v-for). The parent will need to force   * the child to update because the slot does not fully capture its dependencies.   */  DYNAMIC: 2,  /**   * `<slot/>` being forwarded into a child component. Whether the parent needs   * to update the child is dependent on what kind of slots the parent itself   * received. This has to be refined at runtime, when the child's vnode   * is being created (in `normalizeChildren`)   */  FORWARDED: 3}/** * Dev only */const slotFlagsText = {  [SlotFlags.STABLE]: 'STABLE',  [SlotFlags.DYNAMIC]: 'DYNAMIC',  [SlotFlags.FORWARDED]: 'FORWARDED'}function createElementWithCodegen(  tag,  props,  children,  patchFlag,  dynamicProps) {  return {    type: NodeTypes.ELEMENT,    loc: locStub,    ns: Namespaces.HTML,    tag: 'div',    tagType: ElementTypes.ELEMENT,    isSelfClosing: false,    props: [],    children: [],    codegenNode: {      type: NodeTypes.VNODE_CALL,      tag,      props,      children,      patchFlag,      dynamicProps,      directives: undefined,      isBlock: false,      disableTracking: false,      isComponent: false,      loc: locStub    }  }}function createParserContext(content, rawOptions) {  const options = extend({}, defaultParserOptions)  let key  for (key in rawOptions) {    // @ts-ignore    options[key] =      rawOptions[key] === undefined        ? defaultParserOptions[key]        : rawOptions[key]  }  return {    options,    column: 1,    line: 1,    offset: 0,    originalSource: content,    source: content,    inPre: false,    inVPre: false,    onWarn: options.onWarn  }}function createRoot(children, loc = locStub) {  return {    type: NodeTypes.ROOT,    children,    helpers: [],    components: [],    directives: [],    hoists: [],    imports: [],    cached: 0,    temps: 0,    codegenNode: undefined,    loc  }}function parseChildren(context, mode, ancestors) {  const parent = last(ancestors)  const ns = parent ? parent.ns : Namespaces.HTML  const nodes = [] // -> ancestors  // 1. while -> isEnd ? 游标不断往前走直接所以 source 都解析完成  while (!isEnd(context, mode, ancestors)) {    const s = context.source    let node = undefined    if (mode === TextModes.DATA || mode === TextModes.RCDATA) {      if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {        // '{{' 插值开始        node = parseInterpolation(context, mode)      } else if (mode === TextModes.DATA && s[0] === '<') {        if (s[1] === '/') {          // 结束标签          if (/[a-z]/i.test(s[2])) {            // 异常结束，如：`<div>some text<a`            emitError(context, 'X_INVALID_END_TAG')            parseTag(context, TagType.End, parent)            continue          }        } else if (/[a-z]/i.test(s[1])) {          // 正常的开始标签          node = parseElement(context, ancestors)          // 2.x <template> 无指令兼容，这里就不实现了，重点关注 3.x 的代码        }      }    }    // 以上都不是，说明应该是纯文本节点    if (!node) {      node = parseText(context, mode)    }    // 用 pushNode 在其中合并相邻的文本节点    if (isArray(node)) {      for (let i = 0; i < node.length; i++) {        pushNode(nodes, node[i])      }    } else {      pushNode(nodes, node)    }  }  // 2. 合并相邻文本节点，空格处理，会将多个空格合并成一个空格  let removedWhitespace = false  if (mode !== TextModes.RAWTEXT && mode !== TextModes.RCDATA) {    removedWhitespace = _removeWhitespace(nodes, context)  }  // 3. 最后返回解析后的节点树  return removedWhitespace ? nodes.filter(Boolean) : nodes}function _removeWhitespace(nodes, context) {  let removedWhitespace = false  // 可以通过选项来指定是不是保留空格，否则多余的会合并成一个  const shouldCondense = context.options.whitespace !== 'preserve'  for (let i = 0; i < nodes.length; i++) {    const node = nodes[i]    if (!context.inPre && node.type === NodeTypes.TEXT) {      if (!/[^\t\r\n\f]/.test(node.content)) {        const prev = nodes[i - 1]        const next = nodes[i + 1]        if (          !prev ||          !next ||          (shouldCondense &&            (prev.type === NodeTypes.COMMENT ||              next.type === NodeTypes.COMMENT ||              (prev.type === NodeTypes.ELEMENT &&                next.type === NodeTypes.ELEMENT &&                /[\r\n]/.test(node.content))))        ) {          removedWhitespace = true          nodes[i] = null        } else {          // 合并成一个          node.content = ' '        }      } else if (shouldCondense) {        // 保留空格        node.content = node.content.replace(/[\t\r\n\f]+/g, ' ')      }    } else if (node.type === NodeTypes.COMMENT && !context.options.comments) {      // 可以通过配置删除注释节点      removedWhitespace = true      nodes[i] = null    }  }  if (context.inPre && parent && context.options.isPreTag(parent.tag)) {    // 删除 <pre> 中的第一行的空行    const first = nodes[0]    if (first && first.type === NodeTypes.TEXT) {      first.content = first.content.replace(/^\r?\n/, '')    }  }  return removedWhitespace}function parseElement(context, ancestors) {  const parent = last(ancestors)  // 1. 解析出开始标签  const element = parseTag(context, TagType.Start, parent)  // 自闭合的标签： <div/>  if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {    return element  }  // children  ancestors.push(element)  const mode = context.options.getTextMode(element, parent)  // 递归解析子节点  const children = parseChildren(context, mode, ancestors)  // 解析完出栈 [root, parent1, parent2, ...] 代表层级  // <root><parent1><parent2></parent><parent1></root> -> 解析过程中通过  // ancestors 来维护这个层级关系  ancestors.pop()  element.children = children  // 2. 解析结束标签  if (startsWithEndTagOpen(context.source, element.tag)) {    parseTag(context, TagType.End, parent)  }  // 更新解析后节点在源码中的位置信息  element.loc = getSelection(context, element.loc.start)  return element}function parseTag(context, type, parent) {  // 1. 开始标签  const start = getCursor(context)  // 合法标签的正则匹配  const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source)  const tag = match[1]  const ns = context.options.getNamespace(tag, parent)  // 游标前进标签名长度的位置，如： <div id="foo"> -> ` id="foo">`  advanceBy(context, match[0].length)  // 空格处理  advanceSpaces(context)  // parse attributes  let props = parseAttributes(context, type)  // TODO v-pre 检测  // 2. 闭合标签  let isSelfClosing = false  if (context.source.length === 0) {    // 非法情况, ignore  } else {    isSelfClosing = startsWith(context.source, '/>')    advanceBy(context, isSelfClosing ? 2 : 1)  }  if (type === TagType.End) {    return  }  // 3. 分析出标签的类型  let tagType = ElementTypes.ELEMENT  if (!context.inVPre) {    if (tag === 'slot') {      tagType = ElementTypes.SLOT    } else if (tag === 'template') {      if (        props.some(          (p) =>            p.type === NodeTypes.DIRECTIVE && isSpecialTemplateDirective(p.name)        )      ) {        tagType = ElementTypes.TEMPLATE      }    } else if (isComponent(tag, props, context)) {      tagType = ElementTypes.COMPONENT    }  }  return {    type: NodeTypes.ELEMENT,    ns,    tag,    tagType,    props,    isSelfClosing,    children: [],    loc: getSelection(context, start),    codegenNode: undefined // 在 transform 阶段生成的产物  }}function parseText(context, mode) {  const endTokens =    mode === TextModes.CDATA ? [']]>'] : ['<', context.options.delimiters[0]]  let endIndex = context.source.length  for (let i = 0; i < endTokens.length; i++) {    const index = context.source.indexOf(endTokens[i], 1)    if (index !== -1 && endIndex > index) {      endIndex = index    }  }  const start = getCursor(context)  const content = parseTextData(context, endIndex, mode)  return {    type: NodeTypes.TEXT,    content,    loc: getSelection(context, start)  }}function parseTextData(context, length, mode) {  const rawText = context.source.slice(0, length)  advanceBy(context, length)  // 不含HTML entities  if (    mode === TextModes.RAWTEXT ||    mode === TextModes.CDATA ||    !rawText.includes('&')  ) {    return rawText  } else {    // 将 &gt; -> `>`, &lt; -> `<`, &amp; -> `&`, &apos; -> `'`, &quot; -> `"`    return context.options.decodeEntities(      rawText,      mode === TextModes.ATTRIBUTE_VALUE    )  }}function parseInterpolation(context, mode) {  const [open, close] = context.options.delimiters  // 如： source = "{{ a + b }}"  // closeIndex = indexOf("}}", "{{".length) = 9  const closeIndex = context.source.indexOf(close, open.length)  if (closeIndex === -1) {    emitError(context, 'X_MISSING_INTERPOLATION_END')    return undefined  }  const start = getCursor(context)  // >> 2 -> " a + b }}"  advanceBy(context, open.length)  // { line, column, offset }  const innerStart = getCursor(context)  const innerEnd = getCursor(context)  // 9 - '{{'.length = 7  const rawContentLength = closeIndex - open.length  // " a + b }}".slice(0, 7) => " a + b "  const rawContent = context.source.slice(0, rawContentLength)  const preTrimContent = parseTextData(context, rawContentLength, mode)  // " a + b " => "a + b"  const content = preTrimContent.trim()  const startOffset = preTrimContent.indexOf(content)  if (startOffset > 0) {    // 处理换行问题    advancePositionWithMutation(innerStart, rawContent, startOffset)  }  const endOffset =    rawContentLength - (preTrimContent.length - content.length - startOffset)  advancePositionWithMutation(innerEnd, rawContent, endOffset)  advanceBy(context, close.length)  return {    type: NodeTypes.INTERPOLATION,    content: {      type: NodeTypes.SIMPLE_EXPRESSION,      isStatic: false,      // Set `isConstant` to false by default and will decide in transformExpression      constType: ConstantTypes.NOT_CONSTANT,      content,      loc: getSelection(context, innerStart, innerEnd)    },    loc: getSelection(context, start)  }}function parseAttributes(context, type) {  const props = []  // 用 set 避免重复属性  const attributeNames = new Set()  while (    context.source.length > 0 &&    !startsWith(context.source, '>') &&    !startsWith(context.source, '/>')  ) {    // 一些非法检测, ignore    const attr = parseAttribute(context, attributeNames)    logg('ATTR', attr)    // 去掉 class 之间多余的空格，如： `foo   bar  ` -> `foo bar`    if (      attr.type === NodeTypes.ATTRIBUTE &&      attr.value &&      attr.name === 'class'    ) {      attr.value.content = attr.value.content.replace(/\s+/g, ' ').trim()    }    if (type === TagType.Start) {      props.push(attr)    }    advanceSpaces(context)  }  return props}function parseAttribute(context, nameSet) {  const start = getCursor(context)  const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source)  const name = match[0]  nameSet.add(name)  advanceBy(context, name.length)  let value = undefined  if (/^[\t\r\n\f ]*=/.test(context.source)) {    advanceSpaces(context)    advanceBy(context, 1)    advanceSpaces(context)    value = parseAttributeValue(context)  }  const loc = getSelection(context, start)  // v-on(@), v-bind(:), v-if, v-else, v-slot(#) 指令  if (!context.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(name)) {    const match =      /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(        name      )    log(`parseAttribute| match=${match}`)    let isPropShorthand = startsWith(name, '.')    let dirName =      match[1] ||      (isPropShorthand || startsWith(name, ':')        ? 'bind'        : startsWith(name, '@')        ? 'on'        : 'slot')    let arg    if (match[2]) {      const isSlot = dirName === 'slot'      const startOffset = name.lastIndexOf(match[2])      const loc = getSelection(        context,        getNewPosition(context, start, startOffset),        getNewPosition(          context,          start,          startOffset + match[2].length + ((isSlot && match[3]) || '').length        )      )      let content = match[2]      let isStatic = true      if (content.startsWith('[')) {        isStatic = false        content = content.slice(1, content.length - 1)      } else if (isSlot) {        content += match[3] || ''      }      arg = {        type: NodeTypes.SIMPLE_EXPRESSION,        content,        isStatic,        constType: isStatic          ? ConstantTypes.CAN_STRINGIFY          : ConstantTypes.NOT_CONSTANT,        loc      }    }    // quoted: `foo="bar"`, not quoted: `foo=bar`    if (value && value.isQuoted) {      const valueLoc = value.loc      valueLoc.start.offset++      valueLoc.start.column++      valueLoc.end = advancePositionWithClone(valueLoc.start, value.content)      valueLoc.source = valueLoc.source.slice(1, -1)    }    // 修饰符 v-bind.number="foo" => '.number' => ['number']    const modifiers = match[3] ? match[3].slice(1).split('.') : []    // `<div foo.prop="bar">` 如果不加 `.prop` 这个会被解析到 `$attrs` 中    // 如果加了 `.prop` 则会被解析到 `$props` 中去    if (isPropShorthand) {      modifiers.push('prop')    }    return {      type: NodeTypes.DIRECTIVE,      name: dirName,      exp: value && {        type: NodeTypes.SIMPLE_EXPRESSION,        content: value.content,        isStatic: false,        // Treat as non-constant by default. This can be potentially set to        // other values by `transformExpression` to make it eligible for hoisting.        constType: ConstantTypes.NOT_CONSTANT,        loc: value.loc      },      arg,      modifiers,      loc    }  }  return {    type: NodeTypes.ATTRIBUTE,    name,    value: value && {      type: NodeTypes.TEXT,      content: value.content,      loc: value.loc    },    loc  }}function parseAttributeValue(context) {  const start = getCursor(context)  let content  const quote = context.source[0]  // value 分两种情况，可以用引号包起来也可以不使用引号  // `<div foo="value">` 或 `<div foo=value>`  const isQuoted = quote === `"` || quote === `'`  if (isQuoted) {    // Quoted value.    advanceBy(context, 1)    const endIndex = context.source.indexOf(quote)    if (endIndex === -1) {      content = parseTextData(        context,        context.source.length,        TextModes.ATTRIBUTE_VALUE      )    } else {      content = parseTextData(context, endIndex, TextModes.ATTRIBUTE_VALUE)      advanceBy(context, 1)    }  } else {    // Unquoted    const match = /^[^\t\r\n\f >]+/.exec(context.source)    if (!match) {      return undefined    }    content = parseTextData(context, match[0].length, TextModes.ATTRIBUTE_VALUE)  }  return { content, isQuoted, loc: getSelection(context, start) }}function baseParse(content, options = {}) {  const context = createParserContext(content, options)  const start = getCursor(context)  return createRoot(    parseChildren(context, TextModes.DATA, []),    getSelection(context, start)  )}function createTransformContext(  root,  {    filename = '',    prefixIdentifiers = false,    hoistStatic = false,    cacheHandlers = false,    nodeTransforms = [],    directiveTransforms = {},    transformHoist = null,    isBuiltInComponent = NOOP,    isCustomElement = NOOP,    expressionPlugins = ['typescript'],    scopeId = null,    slotted = true,    ssr = false,    inSSR = false,    ssrCssVars = ``,    bindingMetadata = EMPTY_OBJ,    inline = false,    isTS = false,    onError = defaultOnError,    onWarn = defaultOnWarn,    compatConfig  }) {  const nameMatch = filename.replace(/\?.*$/, '').match(/([^/\\]+)\.\w+$/)  const context = {    // options    selfName: nameMatch && capitalize(camelize(nameMatch[1])),    prefixIdentifiers,    hoistStatic,    cacheHandlers,    nodeTransforms,    directiveTransforms,    transformHoist,    isBuiltInComponent,    isCustomElement,    expressionPlugins,    scopeId,    slotted,    ssr,    inSSR,    ssrCssVars,    bindingMetadata,    inline,    isTS,    onError,    onWarn,    compatConfig,    // state    root,    helpers: new Map(),    components: new Set(),    directives: new Set(),    hoists: [],    imports: [],    constantCache: new Map(),    temps: 0,    cached: 0,    identifiers: Object.create(null),    scopes: {      // 记录下面四个指令的嵌套层次      vFor: 0,      vSlot: 0,      vPre: 0,      vOnce: 0    },    parent: null,    currentNode: root,    childIndex: 0,    inVOnce: false,    // methods    helper(name) {      const count = context.helpers.get(name) || 0      context.helpers.set(name, count + 1)      return name    },    removeHelper(name) {      const count = context.helpers.get(name)      if (count) {        const currentCount = count - 1        if (!currentCount) {          context.helpers.delete(name)        } else {          context.helpers.set(name, currentCount)        }      }    },    helperString(name) {      return `_${helperNameMap[context.helper(name)]}`    },    replaceNode(node) {      context.parent.children[context.childIndex] = context.currentNode = node    },    removeNode(node) {      const list = context.parent.children      const removalIndex = node        ? list.indexOf(node)        : context.currentNode        ? context.childIndex        : -1      if (!node || node === context.currentNode) {        // current node removed        context.currentNode = null        context.onNodeRemoved()      } else {        // sibling node removed        if (context.childIndex > removalIndex) {          context.childIndex--          context.onNodeRemoved()        }      }      context.parent.children.splice(removalIndex, 1)    },    onNodeRemoved: () => {},    addIdentifiers(exp) {      // identifier tracking only happens in non-browser builds.      if (!__BROWSER__) {        if (isString(exp)) {          addId(exp)        } else if (exp.identifiers) {          exp.identifiers.forEach(addId)        } else if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {          addId(exp.content)        }      }    },    removeIdentifiers(exp) {      if (!__BROWSER__) {        if (isString(exp)) {          removeId(exp)        } else if (exp.identifiers) {          exp.identifiers.forEach(removeId)        } else if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {          removeId(exp.content)        }      }    },    hoist(exp) {      if (isString(exp)) exp = createSimpleExpression(exp)      context.hoists.push(exp)      const identifier = createSimpleExpression(        `_hoisted_${context.hoists.length}`,        false,        exp.loc,        ConstantTypes.CAN_HOIST      )      identifier.hoisted = exp      return identifier    },    cache(exp, isVNode = false) {      return createCacheExpression(context.cached++, exp, isVNode)    }  }  function addId(id) {    const { identifiers } = context    if (identifiers[id] === undefined) {      identifiers[id] = 0    }    identifiers[id]++  }  function removeId(id) {    context.identifiers[id]--  }  return context}function traverseNode(node, context) {  // 记录当前正在处理的节点  context.currentNode = node  // 对节点转换时使用到的插件(外部可通过这个来修改某个指令)  const { nodeTransforms } = context  // 递归遍历结束，回溯时调用的函数列表  // 也就是这个函数最后执行的函数，当一颗树遍历完成执行的函数  // 随后的 for 循环是用来收集这些函数的  const exitFns = []  logg('traverseNode', node)  for (let i = 0; i < nodeTransforms.length; i++) {    const onExit = nodeTransforms[i](node, context)    if (onExit) {      if (isArray(onExit)) {        exitFns.push(...onExit)      } else {        exitFns.push(onExit)      }    }    if (!context.currentNode) {      // node was removed      return    } else {      // node may have been replaced      node = context.currentNode    }  }  // 根据节点类型来分别处理，这里忽略注释  switch (node.type) {    case NodeTypes.INTERPOLATION:      // no need to traverse, but we need to inject toString helper      if (!context.ssr) {        context.helper(TO_DISPLAY_STRING)      }      break    // for container types, further traverse downwards    // 处理 if...else if...else 分支    case NodeTypes.IF:      for (let i = 0; i < node.branches.length; i++) {        traverseNode(node.branches[i], context)      }      break    case NodeTypes.IF_BRANCH: // else..if    case NodeTypes.FOR: // for    case NodeTypes.ELEMENT:    case NodeTypes.ROOT:      traverseChildren(node, context)      break  }  // 收集完成，执行这些收集到的函数，作用到当前节点上  context.currentNode = node  let i = exitFns.length  while (i--) {    exitFns[i]()  }}function traverseChildren(parent, context) {  let i = 0  const nodeRemoved = () => {    i--  }  for (; i < parent.children.length; i++) {    const child = parent.children[i]    if (isString(child)) continue    context.parent = parent    context.childIndex = i    context.onNodeRemoved = nodeRemoved    traverseNode(child, context)  }}function hoistStatic(root, context) {  _walk(    root,    context,    // Root node is unfortunately non-hoistable due to potential parent    // fallthrough attributes.    isSingleElementRoot(root, root.children[0])  )}function isSingleElementRoot(root, child) {  const { children } = root  return (    children.length === 1 &&    child.type === NodeTypes.ELEMENT &&    !isSlotOutlet(child)  )}function _walk(node, context, doNotHoistNode = false) {  const { children } = node  const originalCount = children.length  let hoistedCount = 0  for (let i = 0; i < children.length; i++) {    const child = children[i]    // only plain elements & text calls are eligible for hoisting.    if (      child.type === NodeTypes.ELEMENT &&      child.tagType === ElementTypes.ELEMENT    ) {      const constantType = doNotHoistNode        ? ConstantTypes.NOT_CONSTANT        : getConstantType(child, context)      if (constantType > ConstantTypes.NOT_CONSTANT) {        if (constantType >= ConstantTypes.CAN_HOIST) {          child.codegenNode.patchFlag =            PatchFlags.HOISTED + (__DEV__ ? ` /* HOISTED */` : ``)          child.codegenNode = context.hoist(child.codegenNode)          hoistedCount++          continue        }      } else {        // node may contain dynamic children, but its props may be eligible for        // hoisting.        const codegenNode = child.codegenNode        if (codegenNode.type === NodeTypes.VNODE_CALL) {          const flag = getPatchFlag(codegenNode)          if (            (!flag ||              flag === PatchFlags.NEED_PATCH ||              flag === PatchFlags.TEXT) &&            getGeneratedPropsConstantType(child, context) >=              ConstantTypes.CAN_HOIST          ) {            const props = getNodeProps(child)            if (props) {              codegenNode.props = context.hoist(props)            }          }          if (codegenNode.dynamicProps) {            codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps)          }        }      }    } else if (      child.type === NodeTypes.TEXT_CALL &&      getConstantType(child.content, context) >= ConstantTypes.CAN_HOIST    ) {      child.codegenNode = context.hoist(child.codegenNode)      hoistedCount++    }    // walk further    if (child.type === NodeTypes.ELEMENT) {      const isComponent = child.tagType === ElementTypes.COMPONENT      if (isComponent) {        context.scopes.vSlot++      }      _walk(child, context)      if (isComponent) {        context.scopes.vSlot--      }    } else if (child.type === NodeTypes.FOR) {      // Do not hoist v-for single child because it has to be a block      _walk(child, context, child.children.length === 1)    } else if (child.type === NodeTypes.IF) {      for (let i = 0; i < child.branches.length; i++) {        // Do not hoist v-if single child because it has to be a block        _walk(          child.branches[i],          context,          child.branches[i].children.length === 1        )      }    }  }  if (hoistedCount && context.transformHoist) {    logg(`hoist walk -> transformHoist, hoistedCount = ${hoistedCount}`)    context.transformHoist(children, context, node)  }  // all children were hoisted - the entire children array is hoistable.  if (    hoistedCount &&    hoistedCount === originalCount &&    node.type === NodeTypes.ELEMENT &&    node.tagType === ElementTypes.ELEMENT &&    node.codegenNode &&    node.codegenNode.type === NodeTypes.VNODE_CALL &&    isArray(node.codegenNode.children)  ) {    node.codegenNode.children = context.hoist(      createArrayExpression(node.codegenNode.children)    )  }}function getConstantType(node, context) {  const { constantCache } = context  switch (node.type) {    case NodeTypes.ELEMENT:      if (node.tagType !== ElementTypes.ELEMENT) {        return ConstantTypes.NOT_CONSTANT      }      const cached = constantCache.get(node)      if (cached !== undefined) {        return cached      }      const codegenNode = node.codegenNode      if (codegenNode.type !== NodeTypes.VNODE_CALL) {        return ConstantTypes.NOT_CONSTANT      }      if (        codegenNode.isBlock &&        node.tag !== 'svg' &&        node.tag !== 'foreignObject'      ) {        return ConstantTypes.NOT_CONSTANT      }      const flag = getPatchFlag(codegenNode)      if (!flag) {        let returnType = ConstantTypes.CAN_STRINGIFY        // Element itself has no patch flag. However we still need to check:        // 1. Even for a node with no patch flag, it is possible for it to contain        // non-hoistable expressions that refers to scope variables, e.g. compiler        // injected keys or cached event handlers. Therefore we need to always        // check the codegenNode's props to be sure.        const generatedPropsType = getGeneratedPropsConstantType(node, context)        if (generatedPropsType === ConstantTypes.NOT_CONSTANT) {          constantCache.set(node, ConstantTypes.NOT_CONSTANT)          return ConstantTypes.NOT_CONSTANT        }        if (generatedPropsType < returnType) {          returnType = generatedPropsType        }        // 2. its children.        for (let i = 0; i < node.children.length; i++) {          const childType = getConstantType(node.children[i], context)          if (childType === ConstantTypes.NOT_CONSTANT) {            constantCache.set(node, ConstantTypes.NOT_CONSTANT)            return ConstantTypes.NOT_CONSTANT          }          if (childType < returnType) {            returnType = childType          }        }        // 3. if the type is not already CAN_SKIP_PATCH which is the lowest non-0        // type, check if any of the props can cause the type to be lowered        // we can skip can_patch because it's guaranteed by the absence of a        // patchFlag.        if (returnType > ConstantTypes.CAN_SKIP_PATCH) {          for (let i = 0; i < node.props.length; i++) {            const p = node.props[i]            if (p.type === NodeTypes.DIRECTIVE && p.name === 'bind' && p.exp) {              const expType = getConstantType(p.exp, context)              if (expType === ConstantTypes.NOT_CONSTANT) {                constantCache.set(node, ConstantTypes.NOT_CONSTANT)                return ConstantTypes.NOT_CONSTANT              }              if (expType < returnType) {                returnType = expType              }            }          }        }        // only svg/foreignObject could be block here, however if they are        // static then they don't need to be blocks since there will be no        // nested updates.        if (codegenNode.isBlock) {          context.removeHelper(OPEN_BLOCK)          context.removeHelper(            getVNodeBlockHelper(context.inSSR, codegenNode.isComponent)          )          codegenNode.isBlock = false          context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent))        }        constantCache.set(node, returnType)        return returnType      } else {        constantCache.set(node, ConstantTypes.NOT_CONSTANT)        return ConstantTypes.NOT_CONSTANT      }    case NodeTypes.TEXT:    case NodeTypes.COMMENT:      return ConstantTypes.CAN_STRINGIFY    case NodeTypes.IF:    case NodeTypes.FOR:    case NodeTypes.IF_BRANCH:      return ConstantTypes.NOT_CONSTANT    case NodeTypes.INTERPOLATION:    case NodeTypes.TEXT_CALL:      return getConstantType(node.content, context)    case NodeTypes.SIMPLE_EXPRESSION:      return node.constType    case NodeTypes.COMPOUND_EXPRESSION:      let returnType = ConstantTypes.CAN_STRINGIFY      for (let i = 0; i < node.children.length; i++) {        const child = node.children[i]        if (isString(child) || isSymbol(child)) {          continue        }        const childType = getConstantType(child, context)        if (childType === ConstantTypes.NOT_CONSTANT) {          return ConstantTypes.NOT_CONSTANT        } else if (childType < returnType) {          returnType = childType        }      }      return returnType    default:      return ConstantTypes.NOT_CONSTANT  }}const allowHoistedHelperSet = new Set([  NORMALIZE_CLASS,  NORMALIZE_STYLE,  NORMALIZE_PROPS,  GUARD_REACTIVE_PROPS])function getConstantTypeOfHelperCall(value, context) {  if (    value.type === NodeTypes.JS_CALL_EXPRESSION &&    !isString(value.callee) &&    allowHoistedHelperSet.has(value.callee)  ) {    const arg = value.arguments[0]    if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {      return getConstantType(arg, context)    } else if (arg.type === NodeTypes.JS_CALL_EXPRESSION) {      // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(exp))`      return getConstantTypeOfHelperCall(arg, context)    }  }  return ConstantTypes.NOT_CONSTANT}function getGeneratedPropsConstantType(node, context) {  let returnType = ConstantTypes.CAN_STRINGIFY  const props = getNodeProps(node)  if (props && props.type === NodeTypes.JS_OBJECT_EXPRESSION) {    const { properties } = props    for (let i = 0; i < properties.length; i++) {      const { key, value } = properties[i]      const keyType = getConstantType(key, context)      if (keyType === ConstantTypes.NOT_CONSTANT) {        return keyType      }      if (keyType < returnType) {        returnType = keyType      }      let valueType      if (value.type === NodeTypes.SIMPLE_EXPRESSION) {        valueType = getConstantType(value, context)      } else if (value.type === NodeTypes.JS_CALL_EXPRESSION) {        // some helper calls can be hoisted,        // such as the `normalizeProps` generated by the compiler for pre-normalize class,        // in this case we need to respect the ConstantType of the helper's arguments        valueType = getConstantTypeOfHelperCall(value, context)      } else {        valueType = ConstantTypes.NOT_CONSTANT      }      if (valueType === ConstantTypes.NOT_CONSTANT) {        return valueType      }      if (valueType < returnType) {        returnType = valueType      }    }  }  return returnType}function getNodeProps(node) {  const codegenNode = node.codegenNode  if (codegenNode.type === NodeTypes.VNODE_CALL) {    return codegenNode.props  }}function getPatchFlag(node) {  const flag = node.patchFlag  return flag ? parseInt(flag, 10) : undefined}function createRootCodegen(root, context) {  const { helper } = context  const { children } = root  logg(    'createRootCodegen',    `children=${children.length}, 只有一个用 block, 多个用Fragment`  )  if (children.length === 1) {    const child = children[0]    // if the single child is an element, turn it into a block.    // 如果只有一个根元素，如： <template><div>...</div></template>    if (isSingleElementRoot(root, child) && child.codegenNode) {      // single element root is never hoisted so codegenNode will never be      // SimpleExpressionNode      const codegenNode = child.codegenNode      if (codegenNode.type === NodeTypes.VNODE_CALL) {        makeBlock(codegenNode, context)      }      root.codegenNode = codegenNode    } else {      // - single <slot/>, IfNode, ForNode: already blocks.      // - single text node: always patched.      // root codegen falls through via genNode()      root.codegenNode = child    }  } else if (children.length > 1) {    // root 下有多个节点时，使用 fragment block，3.x 特性，2.x中是不支持多个元素的    let patchFlag = PatchFlags.STABLE_FRAGMENT    let patchFlagText = PatchFlagNames[PatchFlags.STABLE_FRAGMENT]    root.codegenNode = createVNodeCall(      context,      helper(FRAGMENT),      undefined,      root.children,      patchFlag + (__DEV__ ? ` /* ${patchFlagText} */` : ``),      undefined,      undefined,      true,      undefined,      false /* isComponent */    )  } else {    // no children = noop. codegen will return null.  }}function createStructuralDirectiveTransform(name, fn) {  // 正则就用 test 方法，字符串直接比较  const matches = isString(name) ? (n) => n === name : (n) => name.test(n)  logg('createStructuralDirectiveTransform', `name=${name}, matches=${matches}`)  return (node, context) => {    if (node.type === NodeTypes.ELEMENT) {      const { props } = node      // v-slot 指令特殊处理，代码在 vSlot.ts 中，所以这里跳过它      if (node.tagType === ElementTypes.TEMPLATE && props.some(isVSlot)) {        return      }      const exitFns = []      for (let i = 0; i < props.length; i++) {        const prop = props[i]        if (prop.type === NodeTypes.DIRECTIVE && matches(prop.name)) {          // structural directives are removed to avoid infinite recursion          // also we remove them *before* applying so that it can further          // traverse itself in case it moves the node around          props.splice(i, 1)          i--          const onExit = fn(node, prop, context)          if (onExit) exitFns.push(onExit)        }      }      return exitFns    }  }}function getBaseTransformPreset(prefixIdentifiers) {  return [    [      transformOnce,      transformIf,      transformMemo,      transformFor,      ...(!__BROWSER__ && prefixIdentifiers        ? [            // order is important            trackVForSlotScopes,            transformExpression          ]        : __BROWSER__ && __DEV__        ? [transformExpression]        : []),      transformSlotOutlet,      transformElement,      trackSlotScopes,      transformText    ],    {      on: transformOn,      bind: transformBind,      model: transformModel    }  ]}function makeBlock(node, { helper, removeHelper, inSSR }) {  if (!node.isBlock) {    node.isBlock = true    removeHelper(getVNodeHelper(inSSR, node.isComponent))    helper(OPEN_BLOCK)    helper(getVNodeBlockHelper(inSSR, node.isComponent))  }}const defaultFallback = createSimpleExpression(`undefined`, false)// A NodeTransform that:// 1. Tracks scope identifiers for scoped slots so that they don't get prefixed//    by transformExpression. This is only applied in non-browser builds with//    { prefixIdentifiers: true }.// 2. Track v-slot depths so that we know a slot is inside another slot.//    Note the exit callback is executed before buildSlots() on the same node,//    so only nested slots see positive numbers.const trackSlotScopes = (node, context) => {  if (    node.type === NodeTypes.ELEMENT &&    (node.tagType === ElementTypes.COMPONENT ||      node.tagType === ElementTypes.TEMPLATE)  ) {    // We are only checking non-empty v-slot here    // since we only care about slots that introduce scope variables.    const vSlot = findDir(node, 'slot')    if (vSlot) {      const slotProps = vSlot.exp      if (!__BROWSER__ && context.prefixIdentifiers) {        slotProps && context.addIdentifiers(slotProps)      }      context.scopes.vSlot++      return () => {        if (!__BROWSER__ && context.prefixIdentifiers) {          slotProps && context.removeIdentifiers(slotProps)        }        context.scopes.vSlot--      }    }  }}// A NodeTransform that tracks scope identifiers for scoped slots with v-for.// This transform is only applied in non-browser builds with { prefixIdentifiers: true }const trackVForSlotScopes = (node, context) => {  let vFor  if (    isTemplateNode(node) &&    node.props.some(isVSlot) &&    (vFor = findDir(node, 'for'))  ) {    const result = (vFor.parseResult = parseForExpression(vFor.exp, context))    if (result) {      const { value, key, index } = result      const { addIdentifiers, removeIdentifiers } = context      value && addIdentifiers(value)      key && addIdentifiers(key)      index && addIdentifiers(index)      return () => {        value && removeIdentifiers(value)        key && removeIdentifiers(key)        index && removeIdentifiers(index)      }    }  }}const buildClientSlotFn = (props, children, loc) =>  createFunctionExpression(    props,    children,    false /* newline */,    true /* isSlot */,    children.length ? children[0].loc : loc  )// Instead of being a DirectiveTransform, v-slot processing is called during// transformElement to build the slots object for a component.function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {  context.helper(WITH_CTX)  const { children, loc } = node  const slotsProperties = []  const dynamicSlots = []  // If the slot is inside a v-for or another v-slot, force it to be dynamic  // since it likely uses a scope variable.  let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0  // with `prefixIdentifiers: true`, this can be further optimized to make  // it dynamic only when the slot actually uses the scope variables.  if (!__BROWSER__ && !context.ssr && context.prefixIdentifiers) {    hasDynamicSlots = hasScopeRef(node, context.identifiers)  }  // 1. Check for slot with slotProps on component itself.  //    <Comp v-slot="{ prop }"/>  const onComponentSlot = findDir(node, 'slot', true)  if (onComponentSlot) {    const { arg, exp } = onComponentSlot    if (arg && !isStaticExp(arg)) {      hasDynamicSlots = true    }    slotsProperties.push(      createObjectProperty(        arg || createSimpleExpression('default', true),        buildSlotFn(exp, children, loc)      )    )  }  // 2. Iterate through children and check for template slots  //    <template v-slot:foo="{ prop }">  let hasTemplateSlots = false  let hasNamedDefaultSlot = false  const implicitDefaultChildren = []  const seenSlotNames = new Set()  for (let i = 0; i < children.length; i++) {    const slotElement = children[i]    let slotDir    if (      !isTemplateNode(slotElement) ||      !(slotDir = findDir(slotElement, 'slot', true))    ) {      // 收集不在 template v-slot 中的元素/组件，这些都会合并到默认插槽中去      if (slotElement.type !== NodeTypes.COMMENT) {        implicitDefaultChildren.push(slotElement)      }      continue    }    if (onComponentSlot) {      logg(`buildSlots already has on-component slot - this is incorrect usage`)      break    }    hasTemplateSlots = true    const { children: slotChildren, loc: slotLoc } = slotElement    const {      arg: slotName = createSimpleExpression(`default`, true),      exp: slotProps,      loc: dirLoc    } = slotDir    // check if name is dynamic.    let staticSlotName    if (isStaticExp(slotName)) {      staticSlotName = slotName ? slotName.content : `default`    } else {      hasDynamicSlots = true    }    const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc)    // check if this slot is conditional (v-if/v-for)    let vIf    let vElse    let vFor    if ((vIf = findDir(slotElement, 'if'))) {      hasDynamicSlots = true      dynamicSlots.push(        createConditionalExpression(          vIf.exp,          buildDynamicSlot(slotName, slotFunction),          defaultFallback        )      )    } else if (      (vElse = findDir(slotElement, /^else(-if)?$/, true /* allowEmpty */))    ) {      // find adjacent v-if      let j = i      let prev      while (j--) {        prev = children[j]        if (prev.type !== NodeTypes.COMMENT) {          break        }      }      if (prev && isTemplateNode(prev) && findDir(prev, 'if')) {        // remove node        children.splice(i, 1)        i--        // attach this slot to previous conditional        let conditional = dynamicSlots[dynamicSlots.length - 1]        while (          conditional.alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION        ) {          conditional = conditional.alternate        }        conditional.alternate = vElse.exp          ? createConditionalExpression(              vElse.exp,              buildDynamicSlot(slotName, slotFunction),              defaultFallback            )          : buildDynamicSlot(slotName, slotFunction)      }    } else if ((vFor = findDir(slotElement, 'for'))) {      hasDynamicSlots = true      const parseResult =        vFor.parseResult || parseForExpression(vFor.exp, context)      if (parseResult) {        // Render the dynamic slots as an array and add it to the createSlot()        // args. The runtime knows how to handle it appropriately.        dynamicSlots.push(          createCallExpression(context.helper(RENDER_LIST), [            parseResult.source,            createFunctionExpression(              createForLoopParams(parseResult),              buildDynamicSlot(slotName, slotFunction),              true /* force newline */            )          ])        )      }    } else {      // check duplicate static names      if (staticSlotName) {        if (seenSlotNames.has(staticSlotName)) {          logg(`buildSlots seenSlotNames has slot name`)          continue        }        seenSlotNames.add(staticSlotName)        if (staticSlotName === 'default') {          hasNamedDefaultSlot = true        }      }      slotsProperties.push(createObjectProperty(slotName, slotFunction))    }  }  if (!onComponentSlot) {    const buildDefaultSlotProperty = (props, children) => {      const fn = buildSlotFn(props, children, loc)      return createObjectProperty(`default`, fn)    }    if (!hasTemplateSlots) {      // implicit default slot (on component)      slotsProperties.push(buildDefaultSlotProperty(undefined, children))    } else if (      implicitDefaultChildren.length &&      // #3766      // with whitespace: 'preserve', whitespaces between slots will end up in      // implicitDefaultChildren. Ignore if all implicit children are whitespaces.      implicitDefaultChildren.some((node) => isNonWhitespaceContent(node))    ) {      // implicit default slot (mixed with named slots)      if (hasNamedDefaultSlot) {        logg(`buildSlots hasNamedDefaultSlot`)      } else {        // 合并到默认插槽        slotsProperties.push(          buildDefaultSlotProperty(undefined, implicitDefaultChildren)        )      }    }  }  const slotFlag = hasDynamicSlots    ? SlotFlags.DYNAMIC    : hasForwardedSlots(node.children)    ? SlotFlags.FORWARDED    : SlotFlags.STABLE  let slots = createObjectExpression(    slotsProperties.concat(      createObjectProperty(        `_`,        // 2 = compiled but dynamic = can skip normalization, but must run diff        // 1 = compiled and static = can skip normalization AND diff as optimized        createSimpleExpression(          slotFlag + (__DEV__ ? ` /* ${slotFlagsText[slotFlag]} */` : ``),          false        )      )    ),    loc  )  if (dynamicSlots.length) {    slots = createCallExpression(context.helper(CREATE_SLOTS), [      slots,      createArrayExpression(dynamicSlots)    ])  }  return {    slots,    hasDynamicSlots  }}function buildDynamicSlot(name, fn) {  return createObjectExpression([    createObjectProperty(`name`, name),    createObjectProperty(`fn`, fn)  ])}function hasForwardedSlots(children) {  for (let i = 0; i < children.length; i++) {    const child = children[i]    switch (child.type) {      case NodeTypes.ELEMENT:        if (          child.tagType === ElementTypes.SLOT ||          hasForwardedSlots(child.children)        ) {          return true        }        break      case NodeTypes.IF:        if (hasForwardedSlots(child.branches)) return true        break      case NodeTypes.IF_BRANCH:      case NodeTypes.FOR:        if (hasForwardedSlots(child.children)) return true        break      default:        break    }  }  return false}function isNonWhitespaceContent(node) {  if (node.type !== NodeTypes.TEXT && node.type !== NodeTypes.TEXT_CALL)    return true  return node.type === NodeTypes.TEXT    ? !!node.content.trim()    : isNonWhitespaceContent(node.content)}// some directive transforms (e.g. v-model) may return a symbol for runtime// import, which should be used instead of a resolveDirective call.const directiveImportMap = new WeakMap()// generate a JavaScript AST for this element's codegenconst transformElement = (node, context) => {  // perform the work on exit, after all child expressions have been  // processed and merged.  return function postTransformElement() {    node = context.currentNode    if (      !(        node.type === NodeTypes.ELEMENT &&        (node.tagType === ElementTypes.ELEMENT ||          node.tagType === ElementTypes.COMPONENT)      )    ) {      return    }    const { tag, props } = node    const isComponent = node.tagType === ElementTypes.COMPONENT    // The goal of the transform is to create a codegenNode implementing the    // VNodeCall interface.    let vnodeTag = isComponent      ? resolveComponentType(node, context)      : `"${tag}"`    const isDynamicComponent =      isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT    let vnodeProps    let vnodeChildren    let vnodePatchFlag    let patchFlag = 0    let vnodeDynamicProps    let dynamicPropNames    let vnodeDirectives    let shouldUseBlock =      // dynamic component may resolve to plain elements      isDynamicComponent ||      vnodeTag === TELEPORT ||      vnodeTag === SUSPENSE ||      (!isComponent &&        // <svg> and <foreignObject> must be forced into blocks so that block        // updates inside get proper isSVG flag at runtime. (#639, #643)        // This is technically web-specific, but splitting the logic out of core        // leads to too much unnecessary complexity.        (tag === 'svg' || tag === 'foreignObject'))    // props    if (props.length > 0) {      const propsBuildResult = buildProps(node, context)      vnodeProps = propsBuildResult.props      patchFlag = propsBuildResult.patchFlag      dynamicPropNames = propsBuildResult.dynamicPropNames      const directives = propsBuildResult.directives      vnodeDirectives =        directives && directives.length          ? createArrayExpression(              directives.map((dir) => buildDirectiveArgs(dir, context))            )          : undefined      if (propsBuildResult.shouldUseBlock) {        shouldUseBlock = true      }    }    // children    if (node.children.length > 0) {      if (vnodeTag === KEEP_ALIVE) {        // Although a built-in component, we compile KeepAlive with raw children        // instead of slot functions so that it can be used inside Transition        // or other Transition-wrapping HOCs.        // To ensure correct updates with block optimizations, we need to:        // 1. Force keep-alive into a block. This avoids its children being        //    collected by a parent block.        shouldUseBlock = true        // 2. Force keep-alive to always be updated, since it uses raw children.        patchFlag |= PatchFlags.DYNAMIC_SLOTS      }      const shouldBuildAsSlots =        isComponent &&        // Teleport is not a real component and has dedicated runtime handling        vnodeTag !== TELEPORT &&        // explained above.        vnodeTag !== KEEP_ALIVE      if (shouldBuildAsSlots) {        const { slots, hasDynamicSlots } = buildSlots(node, context)        vnodeChildren = slots        if (hasDynamicSlots) {          patchFlag |= PatchFlags.DYNAMIC_SLOTS        }      } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {        const child = node.children[0]        const type = child.type        // check for dynamic text children        const hasDynamicTextChild =          type === NodeTypes.INTERPOLATION ||          type === NodeTypes.COMPOUND_EXPRESSION        if (          hasDynamicTextChild &&          getConstantType(child, context) === ConstantTypes.NOT_CONSTANT        ) {          patchFlag |= PatchFlags.TEXT        }        // pass directly if the only child is a text node        // (plain / interpolation / expression)        if (hasDynamicTextChild || type === NodeTypes.TEXT) {          vnodeChildren = child        } else {          vnodeChildren = node.children        }      } else {        vnodeChildren = node.children      }    }    // patchFlag & dynamicPropNames    if (patchFlag !== 0) {      vnodePatchFlag = String(patchFlag)      if (dynamicPropNames && dynamicPropNames.length) {        vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames)      }    }    node.codegenNode = createVNodeCall(      context,      vnodeTag,      vnodeProps,      vnodeChildren,      vnodePatchFlag,      vnodeDynamicProps,      vnodeDirectives,      !!shouldUseBlock,      false /* disableTracking */,      isComponent,      node.loc    )  }}function resolveComponentType(node, context, ssr = false) {  let { tag } = node  // 1. dynamic component  const isExplicitDynamic = isComponentTag(tag)  const isProp = findProp(node, 'is')  if (isProp) {    if (isExplicitDynamic) {      const exp =        isProp.type === NodeTypes.ATTRIBUTE          ? isProp.value && createSimpleExpression(isProp.value.content, true)          : isProp.exp      if (exp) {        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [          exp        ])      }    } else if (      isProp.type === NodeTypes.ATTRIBUTE &&      isProp.value.content.startsWith('vue:')    ) {      // <button is="vue:xxx">      // if not <component>, only is value that starts with "vue:" will be      // treated as component by the parse phase and reach here, unless it's      // compat mode where all is values are considered components      tag = isProp.value.content.slice(4)    }  }  // 1.5 v-is (TODO: Deprecate)  const isDir = !isExplicitDynamic && findDir(node, 'is')  if (isDir && isDir.exp) {    return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [      isDir.exp    ])  }  // 2. built-in components (Teleport, Transition, KeepAlive, Suspense...)  const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag)  if (builtIn) {    // built-ins are simply fallthroughs / have special handling during ssr    // so we don't need to import their runtime equivalents    if (!ssr) context.helper(builtIn)    return builtIn  }  // 3. user component (from setup bindings)  // this is skipped in browser build since browser builds do not perform  // binding analysis.  if (!__BROWSER__) {    const fromSetup = resolveSetupReference(tag, context)    if (fromSetup) {      return fromSetup    }    const dotIndex = tag.indexOf('.')    if (dotIndex > 0) {      const ns = resolveSetupReference(tag.slice(0, dotIndex), context)      if (ns) {        return ns + tag.slice(dotIndex)      }    }  }  // 4. Self referencing component (inferred from filename)  if (    !__BROWSER__ &&    context.selfName &&    capitalize(camelize(tag)) === context.selfName  ) {    context.helper(RESOLVE_COMPONENT)    // codegen.ts has special check for __self postfix when generating    // component imports, which will pass additional `maybeSelfReference` flag    // to `resolveComponent`.    context.components.add(tag + `__self`)    return toValidAssetId(tag, `component`)  }  // 5. user component (resolve)  context.helper(RESOLVE_COMPONENT)  context.components.add(tag)  return toValidAssetId(tag, `component`)}function resolveSetupReference(name, context) {  const bindings = context.bindingMetadata  if (!bindings || bindings.__isScriptSetup === false) {    return  }  const camelName = camelize(name)  const PascalName = capitalize(camelName)  const checkType = (type) => {    if (bindings[name] === type) {      return name    }    if (bindings[camelName] === type) {      return camelName    }    if (bindings[PascalName] === type) {      return PascalName    }  }  const fromConst = checkType(BindingTypes.SETUP_CONST)  if (fromConst) {    return context.inline      ? // in inline mode, const setup bindings (e.g. imports) can be used as-is        fromConst      : `$setup[${JSON.stringify(fromConst)}]`  }  const fromMaybeRef =    checkType(BindingTypes.SETUP_LET) ||    checkType(BindingTypes.SETUP_REF) ||    checkType(BindingTypes.SETUP_MAYBE_REF)  if (fromMaybeRef) {    return context.inline      ? // setup scope bindings that may be refs need to be unrefed        `${context.helperString(UNREF)}(${fromMaybeRef})`      : `$setup[${JSON.stringify(fromMaybeRef)}]`  }}function buildProps(node, context, props = node.props, ssr = false) {  const { tag, loc: elementLoc, children } = node  const isComponent = node.tagType === ElementTypes.COMPONENT  let properties = []  const mergeArgs = []  const runtimeDirectives = []  const hasChildren = children.length > 0  let shouldUseBlock = false  // patchFlag analysis  let patchFlag = 0  let hasRef = false  let hasClassBinding = false  let hasStyleBinding = false  let hasHydrationEventBinding = false  let hasDynamicKeys = false  let hasVnodeHook = false  const dynamicPropNames = []  const analyzePatchFlag = ({ key, value }) => {    if (isStaticExp(key)) {      const name = key.content      const isEventHandler = isOn(name)      if (        !isComponent &&        isEventHandler &&        // omit the flag for click handlers because hydration gives click        // dedicated fast path.        name.toLowerCase() !== 'onclick' &&        // omit v-model handlers        name !== 'onUpdate:modelValue' &&        // omit onVnodeXXX hooks        !isReservedProp(name)      ) {        hasHydrationEventBinding = true      }      if (isEventHandler && isReservedProp(name)) {        hasVnodeHook = true      }      if (        value.type === NodeTypes.JS_CACHE_EXPRESSION ||        ((value.type === NodeTypes.SIMPLE_EXPRESSION ||          value.type === NodeTypes.COMPOUND_EXPRESSION) &&          getConstantType(value, context) > 0)      ) {        // skip if the prop is a cached handler or has constant value        return      }      if (name === 'ref') {        hasRef = true      } else if (name === 'class') {        hasClassBinding = true      } else if (name === 'style') {        hasStyleBinding = true      } else if (name !== 'key' && !dynamicPropNames.includes(name)) {        dynamicPropNames.push(name)      }      // treat the dynamic class and style binding of the component as dynamic props      if (        isComponent &&        (name === 'class' || name === 'style') &&        !dynamicPropNames.includes(name)      ) {        dynamicPropNames.push(name)      }    } else {      hasDynamicKeys = true    }  }  for (let i = 0; i < props.length; i++) {    // static attribute    const prop = props[i]    if (prop.type === NodeTypes.ATTRIBUTE) {      const { loc, name, value } = prop      let isStatic = true      if (name === 'ref') {        hasRef = true        if (context.scopes.vFor > 0) {          properties.push(            createObjectProperty(              createSimpleExpression('ref_for', true),              createSimpleExpression('true')            )          )        }        // in inline mode there is no setupState object, so we can't use string        // keys to set the ref. Instead, we need to transform it to pass the        // actual ref instead.        if (          !__BROWSER__ &&          value &&          context.inline &&          context.bindingMetadata[value.content]        ) {          isStatic = false          properties.push(            createObjectProperty(              createSimpleExpression('ref_key', true),              createSimpleExpression(value.content, true, value.loc)            )          )        }      }      // skip is on <component>, or is="vue:xxx"      if (        name === 'is' &&        (isComponentTag(tag) || (value && value.content.startsWith('vue:')))      ) {        continue      }      properties.push(        createObjectProperty(          createSimpleExpression(            name,            true,            getInnerRange(loc, 0, name.length)          ),          createSimpleExpression(            value ? value.content : '',            isStatic,            value ? value.loc : loc          )        )      )    } else {      // directives      const { name, arg, exp, loc } = prop      const isVBind = name === 'bind'      const isVOn = name === 'on'      // skip v-slot - it is handled by its dedicated transform.      if (name === 'slot') {        continue      }      // skip v-once/v-memo - they are handled by dedicated transforms.      if (name === 'once' || name === 'memo') {        continue      }      // skip v-is and :is on <component>      if (        name === 'is' ||        (isVBind && isStaticArgOf(arg, 'is') && isComponentTag(tag))      ) {        continue      }      // skip v-on in SSR compilation      if (isVOn && ssr) {        continue      }      if (        // # elements with dynamic keys should be forced into blocks        (isVBind && isStaticArgOf(arg, 'key')) ||        // inline before-update hooks need to force block so that it is invoked        // before children        (isVOn && hasChildren && isStaticArgOf(arg, 'vue:before-update'))      ) {        shouldUseBlock = true      }      if (isVBind && isStaticArgOf(arg, 'ref') && context.scopes.vFor > 0) {        properties.push(          createObjectProperty(            createSimpleExpression('ref_for', true),            createSimpleExpression('true')          )        )      }      // special case for v-bind and v-on with no argument      if (!arg && (isVBind || isVOn)) {        hasDynamicKeys = true        if (exp) {          if (properties.length) {            mergeArgs.push(              createObjectExpression(dedupeProperties(properties), elementLoc)            )            properties = []          }          if (isVBind) {            mergeArgs.push(exp)          } else {            // v-on="obj" -> toHandlers(obj)            mergeArgs.push({              type: NodeTypes.JS_CALL_EXPRESSION,              loc,              callee: context.helper(TO_HANDLERS),              arguments: [exp]            })          }        }        continue      }      const directiveTransform = context.directiveTransforms[name]      if (directiveTransform) {        // has built-in directive transform.        const { props, needRuntime } = directiveTransform(prop, node, context)        !ssr && props.forEach(analyzePatchFlag)        properties.push(...props)        if (needRuntime) {          runtimeDirectives.push(prop)          if (isSymbol(needRuntime)) {            directiveImportMap.set(prop, needRuntime)          }        }      } else if (!isBuiltInDirective(name)) {        // no built-in transform, this is a user custom directive.        runtimeDirectives.push(prop)        // custom dirs may use beforeUpdate so they need to force blocks        // to ensure before-update gets called before children update        if (hasChildren) {          shouldUseBlock = true        }      }    }  }  let propsExpression = undefined  // has v-bind="object" or v-on="object", wrap with mergeProps  if (mergeArgs.length) {    if (properties.length) {      mergeArgs.push(        createObjectExpression(dedupeProperties(properties), elementLoc)      )    }    if (mergeArgs.length > 1) {      propsExpression = createCallExpression(        context.helper(MERGE_PROPS),        mergeArgs,        elementLoc      )    } else {      // single v-bind with nothing else - no need for a mergeProps call      propsExpression = mergeArgs[0]    }  } else if (properties.length) {    propsExpression = createObjectExpression(      dedupeProperties(properties),      elementLoc    )  }  // patchFlag analysis  if (hasDynamicKeys) {    patchFlag |= PatchFlags.FULL_PROPS  } else {    if (hasClassBinding && !isComponent) {      patchFlag |= PatchFlags.CLASS    }    if (hasStyleBinding && !isComponent) {      patchFlag |= PatchFlags.STYLE    }    if (dynamicPropNames.length) {      patchFlag |= PatchFlags.PROPS    }    if (hasHydrationEventBinding) {      patchFlag |= PatchFlags.HYDRATE_EVENTS    }  }  if (    !shouldUseBlock &&    (patchFlag === 0 || patchFlag === PatchFlags.HYDRATE_EVENTS) &&    (hasRef || hasVnodeHook || runtimeDirectives.length > 0)  ) {    patchFlag |= PatchFlags.NEED_PATCH  }  // pre-normalize props, SSR is skipped for now  if (!context.inSSR && propsExpression) {    switch (propsExpression.type) {      case NodeTypes.JS_OBJECT_EXPRESSION:        // means that there is no v-bind,        // but still need to deal with dynamic key binding        let classKeyIndex = -1        let styleKeyIndex = -1        let hasDynamicKey = false        for (let i = 0; i < propsExpression.properties.length; i++) {          const key = propsExpression.properties[i].key          if (isStaticExp(key)) {            if (key.content === 'class') {              classKeyIndex = i            } else if (key.content === 'style') {              styleKeyIndex = i            }          } else if (!key.isHandlerKey) {            hasDynamicKey = true          }        }        const classProp = propsExpression.properties[classKeyIndex]        const styleProp = propsExpression.properties[styleKeyIndex]        // no dynamic key        if (!hasDynamicKey) {          if (classProp && !isStaticExp(classProp.value)) {            classProp.value = createCallExpression(              context.helper(NORMALIZE_CLASS),              [classProp.value]            )          }          if (            styleProp &&            !isStaticExp(styleProp.value) &&            // the static style is compiled into an object,            // so use `hasStyleBinding` to ensure that it is a dynamic style binding            (hasStyleBinding ||              // v-bind:style and style both exist,              // v-bind:style with static literal object              styleProp.value.type === NodeTypes.JS_ARRAY_EXPRESSION)          ) {            styleProp.value = createCallExpression(              context.helper(NORMALIZE_STYLE),              [styleProp.value]            )          }        } else {          // dynamic key binding, wrap with `normalizeProps`          propsExpression = createCallExpression(            context.helper(NORMALIZE_PROPS),            [propsExpression]          )        }        break      case NodeTypes.JS_CALL_EXPRESSION:        // mergeProps call, do nothing        break      default:        // single v-bind        propsExpression = createCallExpression(          context.helper(NORMALIZE_PROPS),          [            createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [              propsExpression            ])          ]        )        break    }  }  return {    props: propsExpression,    directives: runtimeDirectives,    patchFlag,    dynamicPropNames,    shouldUseBlock  }}// Dedupe props in an object literal.// Literal duplicated attributes would have been warned during the parse phase,// however, it's possible to encounter duplicated `onXXX` handlers with different// modifiers. We also need to merge static and dynamic class / style attributes.// - onXXX handlers / style: merge into array// - class: merge into single expression with concatenationfunction dedupeProperties(properties) {  const knownProps = new Map()  const deduped = []  for (let i = 0; i < properties.length; i++) {    const prop = properties[i]    // dynamic keys are always allowed    if (prop.key.type === NodeTypes.COMPOUND_EXPRESSION || !prop.key.isStatic) {      deduped.push(prop)      continue    }    const name = prop.key.content    const existing = knownProps.get(name)    if (existing) {      if (name === 'style' || name === 'class' || isOn(name)) {        mergeAsArray(existing, prop)      }      // unexpected duplicate, should have emitted error during parse    } else {      knownProps.set(name, prop)      deduped.push(prop)    }  }  return deduped}function mergeAsArray(existing, incoming) {  if (existing.value.type === NodeTypes.JS_ARRAY_EXPRESSION) {    existing.value.elements.push(incoming.value)  } else {    existing.value = createArrayExpression(      [existing.value, incoming.value],      existing.loc    )  }}function buildDirectiveArgs(dir, context) {  const dirArgs = []  const runtime = directiveImportMap.get(dir)  if (runtime) {    // built-in directive with runtime    dirArgs.push(context.helperString(runtime))  } else {    // user directive.    // see if we have directives exposed via <script setup>    const fromSetup =      !__BROWSER__ && resolveSetupReference('v-' + dir.name, context)    if (fromSetup) {      dirArgs.push(fromSetup)    } else {      // inject statement for resolving directive      context.helper(RESOLVE_DIRECTIVE)      context.directives.add(dir.name)      dirArgs.push(toValidAssetId(dir.name, `directive`))    }  }  const { loc } = dir  if (dir.exp) dirArgs.push(dir.exp)  if (dir.arg) {    if (!dir.exp) {      dirArgs.push(`void 0`)    }    dirArgs.push(dir.arg)  }  if (Object.keys(dir.modifiers).length) {    if (!dir.arg) {      if (!dir.exp) {        dirArgs.push(`void 0`)      }      dirArgs.push(`void 0`)    }    const trueExpression = createSimpleExpression(`true`, false, loc)    dirArgs.push(      createObjectExpression(        dir.modifiers.map((modifier) =>          createObjectProperty(modifier, trueExpression)        ),        loc      )    )  }  return createArrayExpression(dirArgs, dir.loc)}function stringifyDynamicPropNames(props) {  let propsNamesString = `[`  for (let i = 0, l = props.length; i < l; i++) {    propsNamesString += JSON.stringify(props[i])    if (i < l - 1) propsNamesString += ', '  }  return propsNamesString + `]`}function isComponentTag(tag) {  return tag === 'component' || tag === 'Component'}const isLiteralWhitelisted = /*#__PURE__*/ makeMap('true,false,null,this')const transformExpression = (node, context) => {  logg(`transformExpression`, node)  // 插值处理  if (node.type === NodeTypes.INTERPOLATION) {    node.content = processExpression(node.content, context)  } else if (node.type === NodeTypes.ELEMENT) {    // 处理元素上的指令    for (let i = 0; i < node.props.length; i++) {      const dir = node.props[i]      logg(`transformExpression - prop[${i}] - directive`, node.props[i])      // do not process for v-on & v-for since they are special handled      if (dir.type === NodeTypes.DIRECTIVE && dir.name !== 'for') {        // v-for 在 vFor.ts 中处理        const exp = dir.exp        const arg = dir.arg        // do not process exp if this is v-on:arg - we need special handling        // for wrapping inline statements.        if (          exp &&          exp.type === NodeTypes.SIMPLE_EXPRESSION &&          !(dir.name === 'on' && arg)        ) {          dir.exp = processExpression(            exp,            context,            // slot args must be processed as function params            dir.name === 'slot'          )        }        if (arg && arg.type === NodeTypes.SIMPLE_EXPRESSION && !arg.isStatic) {          dir.arg = processExpression(arg, context)        }      }    }  }}// Important: since this function uses Node.js only dependencies, it should// always be used with a leading !__BROWSER__ check so that it can be// tree-shaken from the browser build.function processExpression(  node,  context,  // some expressions like v-slot props & v-for aliases should be parsed as  // function params  asParams = false,  // v-on handler values may contain multiple statements  asRawStatements = false,  localVars = Object.create(context.identifiers)) {  if (__BROWSER__) {    return node  }  if (!context.prefixIdentifiers || !node.content.trim()) {    return node  }  const { inline, bindingMetadata } = context  const rewriteIdentifier = (raw, parent, id) => {    const type = hasOwn(bindingMetadata, raw) && bindingMetadata[raw]    if (inline) {      // x = y      const isAssignmentLVal =        parent && parent.type === 'AssignmentExpression' && parent.left === id      // x++      const isUpdateArg =        parent && parent.type === 'UpdateExpression' && parent.argument === id      // ({ x } = y)      const isDestructureAssignment =        parent && isInDestructureAssignment(parent, parentStack)      if (type === BindingTypes.SETUP_CONST || localVars[raw]) {        return raw      } else if (type === BindingTypes.SETUP_REF) {        return `${raw}.value`      } else if (type === BindingTypes.SETUP_MAYBE_REF) {        // const binding that may or may not be ref        // if it's not a ref, then assignments don't make sense -        // so we ignore the non-ref assignment case and generate code        // that assumes the value to be a ref for more efficiency        return isAssignmentLVal || isUpdateArg || isDestructureAssignment          ? `${raw}.value`          : `${context.helperString(UNREF)}(${raw})`      } else if (type === BindingTypes.SETUP_LET) {        if (isAssignmentLVal) {          // let binding.          // this is a bit more tricky as we need to cover the case where          // let is a local non-ref value, and we need to replicate the          // right hand side value.          // x = y --> isRef(x) ? x.value = y : x = y          const { right: rVal, operator } = parent          const rExp = rawExp.slice(rVal.start - 1, rVal.end - 1)          const rExpString = stringifyExpression(            processExpression(              createSimpleExpression(rExp, false),              context,              false,              false,              knownIds            )          )          return `${context.helperString(            IS_REF          )}(${raw})${``} ? ${raw}.value ${operator} ${rExpString} : ${raw}`        } else if (isUpdateArg) {          // make id replace parent in the code range so the raw update operator          // is removed          id.start = parent.start          id.end = parent.end          const { prefix: isPrefix, operator } = parent          const prefix = isPrefix ? operator : ``          const postfix = isPrefix ? `` : operator          // let binding.          // x++ --> isRef(a) ? a.value++ : a++          return `${context.helperString(            IS_REF          )}(${raw})${``} ? ${prefix}${raw}.value${postfix} : ${prefix}${raw}${postfix}`        } else if (isDestructureAssignment) {          // TODO          // let binding in a destructure assignment - it's very tricky to          // handle both possible cases here without altering the original          // structure of the code, so we just assume it's not a ref here          // for now          return raw        } else {          return `${context.helperString(UNREF)}(${raw})`        }      } else if (type === BindingTypes.PROPS) {        // use __props which is generated by compileScript so in ts mode        // it gets correct type        return `__props.${raw}`      } else if (type === BindingTypes.PROPS_ALIASED) {        // prop with a different local alias (from defineProps() destructure)        return `__props.${bindingMetadata.__propsAliases[raw]}`      }    } else {      if (type && type.startsWith('setup')) {        // setup bindings in non-inline mode        return `$setup.${raw}`      } else if (type === BindingTypes.PROPS_ALIASED) {        return `$props.${bindingMetadata.__propsAliases[raw]}`      } else if (type) {        return `$${type}.${raw}`      }    }    // fallback to ctx    return `_ctx.${raw}`  }  // fast path if expression is a simple identifier.  const rawExp = node.content  // bail constant on parens (function invocation) and dot (member access)  const bailConstant = rawExp.indexOf(`(`) > -1 || rawExp.indexOf('.') > 0 logg(`processExpression - nde.content: ${rawExp}`)  if (isSimpleIdentifier(rawExp)) {    const isScopeVarReference = context.identifiers[rawExp]    const isAllowedGlobal = isGloballyWhitelisted(rawExp)    const isLiteral = isLiteralWhitelisted(rawExp)    if (!asParams && !isScopeVarReference && !isAllowedGlobal && !isLiteral) {      // const bindings exposed from setup can be skipped for patching but      // cannot be hoisted to module scope      if (bindingMetadata[node.content] === BindingTypes.SETUP_CONST) {        node.constType = ConstantTypes.CAN_SKIP_PATCH      }      node.content = rewriteIdentifier(rawExp)    } else if (!isScopeVarReference) {      if (isLiteral) {        node.constType = ConstantTypes.CAN_STRINGIFY      } else {        node.constType = ConstantTypes.CAN_HOIST      }    }    return node  }  let ast  // exp needs to be parsed differently:  // 1. Multiple inline statements (v-on, with presence of `;`): parse as raw  //    exp, but make sure to pad with spaces for consistent ranges  // 2. Expressions: wrap with parens (for e.g. object expressions)  // 3. Function arguments (v-for, v-slot): place in a function argument position  const source = asRawStatements    ? ` ${rawExp} `    : `(${rawExp})${asParams ? `=>{}` : ``}`  try {    ast = babelParser.parse(source, {      plugins: [ ...context.expressionPlugins , ...babelPlugins]    }).program  } catch (e) {    return node  }  logg(`processExpression - babel parse`, ast)  const ids = []  const parentStack = []  const knownIds = Object.create(context.identifiers)  walkIdentifiers(    ast,    (node, parent, _, isReferenced, isLocal) => {      if (isStaticPropertyKey(node, parent)) {        return      }      const needPrefix = isReferenced && canPrefix(node)      if (needPrefix && !isLocal) {        if (isStaticProperty(parent) && parent.shorthand) {          // property shorthand like { foo }, we need to add the key since          // we rewrite the value          node.prefix = `${node.name}: `        }        node.name = rewriteIdentifier(node.name, parent, node)        ids.push(node)      } else {        // The identifier is considered constant unless it's pointing to a        // local scope variable (a v-for alias, or a v-slot prop)        if (!(needPrefix && isLocal) && !bailConstant) {          node.isConstant = true        }        // also generate sub-expressions for other identifiers for better        // source map support. (except for property keys which are static)        ids.push(node)      }    },    true, // invoke on ALL identifiers    parentStack,    knownIds  )  // We break up the compound expression into an array of strings and sub  // expressions (for identifiers that have been prefixed). In codegen, if  // an ExpressionNode has the `.children` property, it will be used instead of  // `.content`.  const children = []  ids.sort((a, b) => a.start - b.start)  ids.forEach((id, i) => {    // range is offset by -1 due to the wrapping parens when parsed    const start = id.start - 1    const end = id.end - 1    const last = ids[i - 1]    const leadingText = rawExp.slice(last ? last.end - 1 : 0, start)    if (leadingText.length || id.prefix) {      children.push(leadingText + (id.prefix || ``))    }    const source = rawExp.slice(start, end)    children.push(      createSimpleExpression(        id.name,        false,        {          source,          start: advancePositionWithClone(node.loc.start, source, start),          end: advancePositionWithClone(node.loc.start, source, end)        },        id.isConstant ? ConstantTypes.CAN_STRINGIFY : ConstantTypes.NOT_CONSTANT      )    )    if (i === ids.length - 1 && end < rawExp.length) {      children.push(rawExp.slice(end))    }  })  let ret  if (children.length) {    ret = createCompoundExpression(children, node.loc)  } else {    ret = node    ret.constType = bailConstant      ? ConstantTypes.NOT_CONSTANT      : ConstantTypes.CAN_STRINGIFY  }  ret.identifiers = Object.keys(knownIds)  return ret}function canPrefix(id) {  // skip whitelisted globals  if (isGloballyWhitelisted(id.name)) {    return false  }  // special case for webpack compilation  if (id.name === 'require') {    return false  }  return true}function stringifyExpression(exp) {  if (isString(exp)) {    return exp  } else if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {    return exp.content  } else {    return exp.children.map(stringifyExpression).join('')  }}const transformSlotOutlet = (node, context) => {  if (isSlotOutlet(node)) {    // <slot/>    const { children, loc } = node    const { slotName, slotProps } = processSlotOutlet(node, context)    const slotArgs = [      context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,      slotName,      '{}', //  props      'undefined', // children      'true'    ]    let expectedLen = 2    if (slotProps) {      slotArgs[2] = slotProps      expectedLen = 3    }    if (children.length) {      slotArgs[3] = createFunctionExpression([], children, false, false, loc)      expectedLen = 4    }    if (context.scopeId && !context.slotted) {      expectedLen = 5    }    slotArgs.splice(expectedLen) // remove unused arguments    // -> renderSlot($slots, slotName, props, children, true)    node.codegenNode = createCallExpression(      context.helper(RENDER_SLOT), // renderSlot      slotArgs,      loc    )  }}function processSlotOutlet(node, context) {  let slotName = `"default"`  let slotProps = undefined  const nonNameProps = [] // 无名插槽  logg(`processSlotOutlet| props.length = ${node.props.length}`)  for (let i = 0; i < node.props.length; i++) {    const p = node.props[i]    logg(`processSlotOutlet| props[${i}]`, p)    if (p.type === NodeTypes.ATTRIBUTE) {      // 静态 <slot name="xxx"/>      if (p.value) {        if (p.name === 'name') {          slotName = JSON.stringify(p.value.content)        } else {          p.name = camelize(p.name)          nonNameProps.push(p)        }      }    } else {      // 动态 <slot :name="xxx"/>      // 动态插槽 <slot v-bind:name="slotName"/>      if (p.name === 'bind' && isStaticArgOf(p.arg, 'name')) {        if (p.exp) slotName = p.exp      } else {        if (p.name === 'bind' && p.arg && isStaticExp(p.arg)) {          p.arg.content = camelize(p.arg.content)        }        nonNameProps.push(p)      }    }  }  logg(`processSlotOutlet| nonNameProps.length=${nonNameProps.length}`)  if (nonNameProps.length > 0) {    const { props, directives } = buildProps(node, context, nonNameProps)    slotProps = props    if (directives.length) {      logg('[ERROR] X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET')    }  }  return {    slotName,    slotProps  }}// Merge adjacent text nodes and expressions into a single expression// e.g. <div>abc {{ d }} {{ e }}</div> should have a single expression node as child.const transformText = (node, context) => {  if (    node.type === NodeTypes.ROOT ||    node.type === NodeTypes.ELEMENT ||    node.type === NodeTypes.FOR ||    node.type === NodeTypes.IF_BRANCH  ) {    // perform the transform on node exit so that all expressions have already    // been processed.    return () => {      const children = node.children      let currentContainer = undefined      let hasText = false      for (let i = 0; i < children.length; i++) {        const child = children[i]        if (isText(child)) {          hasText = true          for (let j = i + 1; j < children.length; j++) {            const next = children[j]            if (isText(next)) {              if (!currentContainer) {                currentContainer = children[i] = {                  type: NodeTypes.COMPOUND_EXPRESSION,                  loc: child.loc,                  children: [child]                }              }              // merge adjacent text node into current              currentContainer.children.push(` + `, next)              children.splice(j, 1)              j--            } else {              currentContainer = undefined              break            }          }        }      }      if (        !hasText ||        // if this is a plain element with a single text child, leave it        // as-is since the runtime has dedicated fast path for this by directly        // setting textContent of the element.        // for component root it's always normalized anyway.        (children.length === 1 &&          (node.type === NodeTypes.ROOT ||            (node.type === NodeTypes.ELEMENT &&              node.tagType === ElementTypes.ELEMENT &&              // #3756              // custom directives can potentially add DOM elements arbitrarily,              // we need to avoid setting textContent of the element at runtime              // to avoid accidentally overwriting the DOM elements added              // by the user through custom directives.              !node.props.find(                (p) =>                  p.type === NodeTypes.DIRECTIVE &&                  !context.directiveTransforms[p.name]              ))))      ) {        return      }      // pre-convert text nodes into createTextVNode(text) calls to avoid      // runtime normalization.      for (let i = 0; i < children.length; i++) {        const child = children[i]        if (isText(child) || child.type === NodeTypes.COMPOUND_EXPRESSION) {          const callArgs = []          // createTextVNode defaults to single whitespace, so if it is a          // single space the code could be an empty call to save bytes.          if (child.type !== NodeTypes.TEXT || child.content !== ' ') {            callArgs.push(child)          }          // mark dynamic text with flag so it gets patched inside a block          if (            !context.ssr &&            getConstantType(child, context) === ConstantTypes.NOT_CONSTANT          ) {            callArgs.push(              PatchFlags.TEXT +                (__DEV__ ? ` /* ${PatchFlagNames[PatchFlags.TEXT]} */` : ``)            )          }          children[i] = {            type: NodeTypes.TEXT_CALL,            content: child,            loc: child.loc,            codegenNode: createCallExpression(              context.helper(CREATE_TEXT),              callArgs            )          }        }      }    }  }}// v-bind without arg is handled directly in ./transformElements.ts due to it affecting// codegen for the entire props object. This transform here is only for v-bind// *with* args.const transformBind = (dir, _node, context) => {  const { exp, modifiers, loc } = dir  const arg = dir.arg  if (arg.type !== NodeTypes.SIMPLE_EXPRESSION) {    arg.children.unshift(`(`)    arg.children.push(`) || ""`)  } else if (!arg.isStatic) {    arg.content = `${arg.content} || ""`  }  // .sync is replaced by v-model:arg  if (modifiers.includes('camel')) {    if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {      if (arg.isStatic) {        arg.content = camelize(arg.content)      } else {        arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`      }    } else {      arg.children.unshift(`${context.helperString(CAMELIZE)}(`)      arg.children.push(`)`)    }  }  if (!context.inSSR) {    if (modifiers.includes('prop')) {      injectPrefix(arg, '.')    }    if (modifiers.includes('attr')) {      injectPrefix(arg, '^')    }  }  if (    !exp ||    (exp.type === NodeTypes.SIMPLE_EXPRESSION && !exp.content.trim())  ) {    logg(`transformBind v-bind no expression`)    return {      props: [createObjectProperty(arg, createSimpleExpression('', true, loc))]    }  }  return {    props: [createObjectProperty(arg, exp)]  }}const injectPrefix = (arg, prefix) => {  if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {    if (arg.isStatic) {      arg.content = prefix + arg.content    } else {      arg.content = `\`${prefix}\${${arg.content}}\``    }  } else {    arg.children.unshift(`'${prefix}' + (`)    arg.children.push(`)`)  }}const transformFor = createStructuralDirectiveTransform(  'for',  (node, dir, context) => {    const { helper, removeHelper } = context    return processFor(node, dir, context, (forNode) => {      // create the loop render function expression now, and add the      // iterator on exit after all children have been traversed      const renderExp = createCallExpression(helper(RENDER_LIST), [        forNode.source      ])      const isTemplate = isTemplateNode(node)      const memo = findDir(node, 'memo')      const keyProp = findProp(node, `key`)      const keyExp =        keyProp &&        (keyProp.type === NodeTypes.ATTRIBUTE          ? createSimpleExpression(keyProp.value.content, true)          : keyProp.exp)      const keyProperty = keyProp ? createObjectProperty(`key`, keyExp) : null      if (!__BROWSER__ && isTemplate) {        // #2085 / #5288 process :key and v-memo expressions need to be        // processed on `<template v-for>`. In this case the node is discarded        // and never traversed so its binding expressions won't be processed        // by the normal transforms.        if (memo) {          memo.exp = processExpression(memo.exp, context)        }        if (keyProperty && keyProp.type !== NodeTypes.ATTRIBUTE) {          keyProperty.value = processExpression(keyProperty.value, context)        }      }      const isStableFragment =        forNode.source.type === NodeTypes.SIMPLE_EXPRESSION &&        forNode.source.constType > ConstantTypes.NOT_CONSTANT      const fragmentFlag = isStableFragment        ? PatchFlags.STABLE_FRAGMENT        : keyProp        ? PatchFlags.KEYED_FRAGMENT        : PatchFlags.UNKEYED_FRAGMENT      forNode.codegenNode = createVNodeCall(        context,        helper(FRAGMENT),        undefined,        renderExp,        fragmentFlag +          (__DEV__ ? ` /* ${PatchFlagNames[fragmentFlag]} */` : ``),        undefined,        undefined,        true /* isBlock */,        !isStableFragment /* disableTracking */,        false /* isComponent */,        node.loc      )      return () => {        // finish the codegen now that all children have been traversed        let childBlock        const { children } = forNode        // check <template v-for> key placement        if ((__DEV__ || !__BROWSER__) && isTemplate) {          node.children.some((c) => {            if (c.type === NodeTypes.ELEMENT) {              const key = findProp(c, 'key')              if (key) {                logg(`transformFor - key on template`)                return true              }            }          })        }        const needFragmentWrapper =          children.length !== 1 || children[0].type !== NodeTypes.ELEMENT        const slotOutlet = isSlotOutlet(node)          ? node          : isTemplate &&            node.children.length === 1 &&            isSlotOutlet(node.children[0])          ? node.children[0] // api-extractor somehow fails to infer this          : null        if (slotOutlet) {          // <slot v-for="..."> or <template v-for="..."><slot/></template>          childBlock = slotOutlet.codegenNode          if (isTemplate && keyProperty) {            // <template v-for="..." :key="..."><slot/></template>            // we need to inject the key to the renderSlot() call.            // the props for renderSlot is passed as the 3rd argument.            injectProp(childBlock, keyProperty, context)          }        } else if (needFragmentWrapper) {          // <template v-for="..."> with text or multi-elements          // should generate a fragment block for each loop          childBlock = createVNodeCall(            context,            helper(FRAGMENT),            keyProperty ? createObjectExpression([keyProperty]) : undefined,            node.children,            PatchFlags.STABLE_FRAGMENT +              (__DEV__                ? ` /* ${PatchFlagNames[PatchFlags.STABLE_FRAGMENT]} */`                : ``),            undefined,            undefined,            true,            undefined,            false /* isComponent */          )        } else {          // Normal element v-for. Directly use the child's codegenNode          // but mark it as a block.          childBlock = children[0].codegenNode          if (isTemplate && keyProperty) {            injectProp(childBlock, keyProperty, context)          }          if (childBlock.isBlock !== !isStableFragment) {            if (childBlock.isBlock) {              // switch from block to vnode              removeHelper(OPEN_BLOCK)              removeHelper(                getVNodeBlockHelper(context.inSSR, childBlock.isComponent)              )            } else {              // switch from vnode to block              removeHelper(                getVNodeHelper(context.inSSR, childBlock.isComponent)              )            }          }          childBlock.isBlock = !isStableFragment          if (childBlock.isBlock) {            helper(OPEN_BLOCK)            helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent))          } else {            helper(getVNodeHelper(context.inSSR, childBlock.isComponent))          }        }        if (memo) {          const loop = createFunctionExpression(            createForLoopParams(forNode.parseResult, [              createSimpleExpression(`_cached`)            ])          )          loop.body = createBlockStatement([            createCompoundExpression([`const _memo = (`, memo.exp, `)`]),            createCompoundExpression([              `if (_cached`,              ...(keyExp ? [` && _cached.key === `, keyExp] : []),              ` && ${context.helperString(                IS_MEMO_SAME              )}(_cached, _memo)) return _cached`            ]),            createCompoundExpression([`const _item = `, childBlock]),            createSimpleExpression(`_item.memo = _memo`),            createSimpleExpression(`return _item`)          ])          renderExp.arguments.push(            loop,            createSimpleExpression(`_cache`),            createSimpleExpression(String(context.cached++))          )        } else {          renderExp.arguments.push(            createFunctionExpression(              createForLoopParams(forNode.parseResult),              childBlock,              true /* force newline */            )          )        }      }    })  })// target-agnostic transform used for both Client and SSRfunction processFor(node, dir, context, processCodegen) {  if (!dir.exp) {    logg(`processFor - dir.exp is null`)    return  }  const parseResult = parseForExpression(    // can only be simple expression because vFor transform is applied    // before expression transform.    dir.exp,    context  )  if (!parseResult) {    logg(`processFor - parseResult is null`)    return  }  const { addIdentifiers, removeIdentifiers, scopes } = context  const { source, value, key, index } = parseResult  const forNode = {    type: NodeTypes.FOR,    loc: dir.loc,    source,    valueAlias: value,    keyAlias: key,    objectIndexAlias: index,    parseResult,    children: isTemplateNode(node) ? node.children : [node]  }  context.replaceNode(forNode)  // bookkeeping  scopes.vFor++  if (!__BROWSER__ && context.prefixIdentifiers) {    // scope management    // inject identifiers to context    value && addIdentifiers(value)    key && addIdentifiers(key)    index && addIdentifiers(index)  }  const onExit = processCodegen && processCodegen(forNode)  return () => {    scopes.vFor--    if (!__BROWSER__ && context.prefixIdentifiers) {      value && removeIdentifiers(value)      key && removeIdentifiers(key)      index && removeIdentifiers(index)    }    if (onExit) onExit()  }}const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/// This regex doesn't cover the case if key or index aliases have destructuring,// but those do not make sense in the first place, so this works in practice.const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/const stripParensRE = /^\(|\)$/gfunction parseForExpression(input, context) {  const loc = input.loc  const exp = input.content  const inMatch = exp.match(forAliasRE)  if (!inMatch) return  const [, LHS, RHS] = inMatch  const result = {    source: createAliasExpression(      loc,      RHS.trim(),      exp.indexOf(RHS, LHS.length)    ),    value: undefined,    key: undefined,    index: undefined  }  if (!__BROWSER__ && context.prefixIdentifiers) {    result.source = processExpression(result.source, context)  }  let valueContent = LHS.trim().replace(stripParensRE, '').trim()  const trimmedOffset = LHS.indexOf(valueContent)  const iteratorMatch = valueContent.match(forIteratorRE)  if (iteratorMatch) {    valueContent = valueContent.replace(forIteratorRE, '').trim()    const keyContent = iteratorMatch[1].trim()    let keyOffset    if (keyContent) {      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length)      result.key = createAliasExpression(loc, keyContent, keyOffset)      if (!__BROWSER__ && context.prefixIdentifiers) {        result.key = processExpression(result.key, context, true)      }    }    if (iteratorMatch[2]) {      const indexContent = iteratorMatch[2].trim()      if (indexContent) {        result.index = createAliasExpression(          loc,          indexContent,          exp.indexOf(            indexContent,            result.key              ? keyOffset + keyContent.length              : trimmedOffset + valueContent.length          )        )        if (!__BROWSER__ && context.prefixIdentifiers) {          result.index = processExpression(result.index, context, true)        }      }    }  }  if (valueContent) {    result.value = createAliasExpression(loc, valueContent, trimmedOffset)    if (!__BROWSER__ && context.prefixIdentifiers) {      result.value = processExpression(result.value, context, true)    }  }  return result}function createAliasExpression(range, content, offset) {  return createSimpleExpression(    content,    false,    getInnerRange(range, offset, content.length)  )}function createForLoopParams({ value, key, index }, memoArgs = []) {  return createParamsList([value, key, index, ...memoArgs])}function createParamsList(args) {  let i = args.length  while (i--) {    if (args[i]) break  }  return args    .slice(0, i + 1)    .map((arg, i) => arg || createSimpleExpression(`_`.repeat(i + 1), false))}function processIf(node, dir, context, processCodegen) {  logg('processIf - node - dir', node, dir)  if (dir.name !== 'else' && (!dir.exp || !dir.exp.content.trim())) {    const loc = dir.exp ? dir.exp.loc : node.loc    // <div v-if></div> 没有指令值的情况，默认值为 true    dir.exp = createSimpleExpression(`true`, false, loc)  }  if (!__BROWSER__ && context.prefixIdentifiers && dir.exp) {    // dir.exp can only be simple expression because vIf transform is applied    // before expression transform.    dir.exp = processExpression(dir.exp, context)  }  if (dir.name === 'if') {    // v-if    const branch = createIfBranch(node, dir)    const ifNode = {      type: NodeTypes.IF,      loc: node.loc,      branches: [branch]    }    context.replaceNode(ifNode)    if (processCodegen) {      return processCodegen(ifNode, branch, true)    }  } else {    // locate the adjacent v-if    const siblings = context.parent.children    const comments = []    let i = siblings.indexOf(node)    while (i-- >= -1) {      const sibling = siblings[i]      // 空行，空文本      if (        sibling &&        sibling.type === NodeTypes.TEXT &&        !sibling.content.trim().length      ) {        context.removeNode(sibling)        continue      }      if (sibling && sibling.type === NodeTypes.IF) {        // 这里会将原本的结点删除，而是用新组装的 if 结构(包含else-if, else 分支的结构，node.branches[...])        context.removeNode()        const branch = createIfBranch(node, dir)        sibling.branches.push(branch)        const onExit = processCodegen && processCodegen(sibling, branch, false)        // 这里需要手动触发一次遍历，因为上面将原本的分支节点从原来的节点树中删除了        traverseNode(branch, context)        // 回溯结束后执行收集到的 transformXxx 函数        if (onExit) onExit()        // make sure to reset currentNode after traversal to indicate this        // node has been removed.        context.currentNode = null      }      break    }  }}function createIfBranch(node, dir) {  return {    type: NodeTypes.IF_BRANCH,    loc: node.loc,    condition: dir.name === 'else' ? undefined : dir.exp,    children:      node.tagType === ElementTypes.TEMPLATE && !findDir(node, 'for')        ? node.children        : [node],    userKey: findProp(node, `key`)  }}function createCodegenNodeForBranch(branch, keyIndex, context) {  if (branch.condition) {    return createConditionalExpression(      branch.condition,      createChildrenCodegenNode(branch, keyIndex, context),      // 这里是考虑到只有 v-if 的情况，因为 v-if 指令最后都会被解析成三目运算符形式      // 如： <div v-if="foo"/><div v-else/> => foo ? ... : ...      // 如： <div v-if="foo"/><div v-else-if="bar"/><div v-else/> => foo ? ... : bar ? ... : ...      // 所以必需得要有一个 v-else，如果没有的话就相当于是 `foo ? ...` 这样的语句是不合法的      // 因此这里在判断没有 v-else 分支的情况时默认给它创建了个注释节点      createCallExpression(context.helper(CREATE_COMMENT), [        __DEV__ ? '"v-if"' : '""',        'true'      ])    )  } else {    return createChildrenCodegenNode(branch, keyIndex, context)  }}function createChildrenCodegenNode(branch, keyIndex, context) {  const { helper } = context  const keyProperty = createObjectProperty(    `key`,    createSimpleExpression(      `${keyIndex}`,      false,      locStub,      ConstantTypes.CAN_HOIST    )  )  const { children } = branch  const firstChild = children[0]  const needFragmentWrapper =    children.length !== 1 || firstChild.type !== NodeTypes.ELEMENT  if (needFragmentWrapper) {    if (children.length === 1 && firstChild.type === NodeTypes.FOR) {      // optimize away nested fragments when child is a ForNode      const vnodeCall = firstChild.codegenNode      injectProp(vnodeCall, keyProperty, context)      return vnodeCall    } else {      let patchFlag = PatchFlags.STABLE_FRAGMENT      let patchFlagText = PatchFlagNames[PatchFlags.STABLE_FRAGMENT]      return createVNodeCall(        context,        helper(FRAGMENT),        createObjectExpression([keyProperty]),        children,        patchFlag + (__DEV__ ? ` /* ${patchFlagText} */` : ``),        undefined,        undefined,        true,        false,        false /* isComponent */,        branch.loc      )    }  } else {    const ret = firstChild.codegenNode    const vnodeCall = getMemoedVNodeCall(ret)    // Change createVNode to createBlock.    if (vnodeCall.type === NodeTypes.VNODE_CALL) {      makeBlock(vnodeCall, context)    }    // inject branch key    injectProp(vnodeCall, keyProperty, context)    return ret  }}function isSameKey(a, b) {  if (!a || a.type !== b.type) {    return false  }  if (a.type === NodeTypes.ATTRIBUTE) {    if (a.value.content !== b.value.content) {      return false    }  } else {    // directive    const exp = a.exp    const branchExp = b.exp    if (exp.type !== branchExp.type) {      return false    }    if (      exp.type !== NodeTypes.SIMPLE_EXPRESSION ||      exp.isStatic !== branchExp.isStatic ||      exp.content !== branchExp.content    ) {      return false    }  }  return true}function getParentCondition(node) {  while (true) {    if (node.type === NodeTypes.JS_CONDITIONAL_EXPRESSION) {      if (node.alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION) {        node = node.alternate      } else {        return node      }    } else if (node.type === NodeTypes.JS_CACHE_EXPRESSION) {      node = node.value    }  }}const transformIf = createStructuralDirectiveTransform(  /^(if|else|else-if)$/,  (node, dir, context) => {    return processIf(node, dir, context, (ifNode, branch, isRoot) => {      const siblings = context.parent.children      // if...else if...else 都处于同级渲染      let i = siblings.indexOf(ifNode)      let key = 0      while (i-- >= 0) {        const sibling = siblings[i]        if (sibling && sibling.type === NodeTypes.IF) {          key += sibling.branches.length        }      }      logg('transformIf', ifNode, { isRoot, branch })      // 退出时的回调，当所有 children 被遍历转换完成时被调用生成 codegenNode      return () => {        if (isRoot) {          // v-if          ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context)          logg('transformIf - isRoot - v-if', ifNode)        } else {          // v-else, v-else-if          // 将 v-else-* 分枝挂到 v-if 节点下面          const parentCondition = getParentCondition(ifNode.codegenNode)          parentCondition.alternate = createCodegenNodeForBranch(            branch,            key + ifNode.branches.length - 1,            context          )          logg('transformIf - v-else-*', ifNode)        }      }    })  })const memoSeen = new WeakSet()const transformMemo = (node, context) => {  if (node.type === NodeTypes.ELEMENT) {    const dir = findDir(node, 'memo')    if (!dir || memoSeen.has(node)) {      return    }    memoSeen.add(node)    return () => {      const codegenNode = node.codegenNode || context.currentNode.codegenNode      if (codegenNode && codegenNode.type === NodeTypes.VNODE_CALL) {        // non-component sub tree should be turned into a block        if (node.tagType !== ElementTypes.COMPONENT) {          makeBlock(codegenNode, context)        }        node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [          dir.exp,          createFunctionExpression(undefined, codegenNode),          `_cache`,          String(context.cached++)        ])      }    }  }}const transformModel = (dir, node, context) => {  const { exp, arg } = dir  if (!exp) {    logg(`transformModel no exp`)    return createTransformProps()  }  const rawExp = exp.loc.source  const expString =    exp.type === NodeTypes.SIMPLE_EXPRESSION ? exp.content : rawExp  // im SFC <script setup> inline mode, the exp may have been transformed into  // _unref(exp)  const bindingType = context.bindingMetadata[rawExp]  const maybeRef =    !__BROWSER__ &&    context.inline &&    bindingType &&    bindingType !== BindingTypes.SETUP_CONST  if (    !expString.trim() ||    (!isMemberExpression(expString, context) && !maybeRef)  ) {    return createTransformProps()  }  if (    !__BROWSER__ &&    context.prefixIdentifiers &&    isSimpleIdentifier(expString) &&    context.identifiers[expString]  ) {    return createTransformProps()  }  const propName = arg ? arg : createSimpleExpression('modelValue', true)  const eventName = arg    ? isStaticExp(arg)      ? `onUpdate:${arg.content}`      : createCompoundExpression(['"onUpdate:" + ', arg])    : `onUpdate:modelValue`  let assignmentExp  const eventArg = context.isTS ? `($event: any)` : `$event`  if (maybeRef) {    if (bindingType === BindingTypes.SETUP_REF) {      // v-model used on known ref.      assignmentExp = createCompoundExpression([        `${eventArg} => ((`,        createSimpleExpression(rawExp, false, exp.loc),        `).value = $event)`      ])    } else {      // v-model used on a potentially ref binding in <script setup> inline mode.      // the assignment needs to check whether the binding is actually a ref.      const altAssignment =        bindingType === BindingTypes.SETUP_LET ? `${rawExp} = $event` : `null`      assignmentExp = createCompoundExpression([        `${eventArg} => (${context.helperString(IS_REF)}(${rawExp}) ? (`,        createSimpleExpression(rawExp, false, exp.loc),        `).value = $event : ${altAssignment})`      ])    }  } else {    assignmentExp = createCompoundExpression([      `${eventArg} => ((`,      exp,      `) = $event)`    ])  }  const props = [    // modelValue: foo    createObjectProperty(propName, dir.exp),    // "onUpdate:modelValue": $event => (foo = $event)    createObjectProperty(eventName, assignmentExp)  ]  // cache v-model handler if applicable (when it doesn't refer any scope vars)  if (    !__BROWSER__ &&    context.prefixIdentifiers &&    !context.inVOnce &&    context.cacheHandlers &&    !hasScopeRef(exp, context.identifiers)  ) {    props[1].value = context.cache(props[1].value)  }  // modelModifiers: { foo: true, "bar-baz": true }  if (dir.modifiers.length && node.tagType === ElementTypes.COMPONENT) {    const modifiers = dir.modifiers      .map((m) => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`)      .join(`, `)    const modifiersKey = arg      ? isStaticExp(arg)        ? `${arg.content}Modifiers`        : createCompoundExpression([arg, ' + "Modifiers"'])      : `modelModifiers`    props.push(      createObjectProperty(        modifiersKey,        createSimpleExpression(          `{ ${modifiers} }`,          false,          dir.loc,          ConstantTypes.CAN_HOIST        )      )    )  }  return createTransformProps(props)}function createTransformProps(props = []) {  return { props }}// 函数表达式正则, @click="fnExp"const fnExpRE =  /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/const transformOn = (dir, node, context, augmentor) => {  const { loc, modifiers, arg } = dir  let eventName  if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {    if (arg.isStatic) {      let rawName = arg.content      // 将事件名转成驼峰式      eventName = createSimpleExpression(        toHandlerKey(camelize(rawName)),        true,        arg.loc      )    } else {      // #2388 toHandlerKey 将事件名转成 onXxx, 如：eventName -> onEventName      eventName = createCompoundExpression([        `${context.helperString(TO_HANDLER_KEY)}(`,        arg,        `)`      ])    }  } else {    // already a compound expression.    eventName = arg    eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`)    eventName.children.push(`)`)  }  // handler processing, 事件表达式内容  let exp = dir.exp  if (exp && !exp.content.trim()) {    exp = undefined  }  // 事件处理函数缓存  let shouldCache = context.cacheHandlers && !exp && !context.inVOnce  if (exp) {    const isMemberExp = isMemberExpression(exp.content, context)    const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content))    const hasMultipleStatements = exp.content.includes(`;`)    // process the expression since it's been skipped    if (!__BROWSER__ && context.prefixIdentifiers) {      isInlineStatement && context.addIdentifiers(`$event`)      exp = dir.exp = processExpression(        exp,        context,        false,        hasMultipleStatements      )      isInlineStatement && context.removeIdentifiers(`$event`)      // with scope analysis, the function is hoistable if it has no reference      // to scope variables.      shouldCache =        context.cacheHandlers &&        // unnecessary to cache inside v-once        !context.inVOnce &&        // runtime constants don't need to be cached        // (this is analyzed by compileScript in SFC <script setup>)        !(exp.type === NodeTypes.SIMPLE_EXPRESSION && exp.constType > 0) &&        // #1541 bail if this is a member exp handler passed to a component -        // we need to use the original function to preserve arity,        // e.g. <transition> relies on checking cb.length to determine        // transition end handling. Inline function is ok since its arity        // is preserved even when cached.        !(isMemberExp && node.tagType === ElementTypes.COMPONENT) &&        // bail if the function references closure variables (v-for, v-slot)        // it must be passed fresh to avoid stale values.        !hasScopeRef(exp, context.identifiers)      // If the expression is optimizable and is a member expression pointing      // to a function, turn it into invocation (and wrap in an arrow function      // below) so that it always accesses the latest value when called - thus      // avoiding the need to be patched.      if (shouldCache && isMemberExp) {        if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {          exp.content = `${exp.content} && ${exp.content}(...args)`        } else {          exp.children = [...exp.children, ` && `, ...exp.children, `(...args)`]        }      }    }    if (isInlineStatement || (shouldCache && isMemberExp)) {      // wrap inline statement in a function expression      // ($event) => statement      // (...args) => { statement1;statement2 }      exp = createCompoundExpression([        `${isInlineStatement ? `$event` : `(...args)`} => ${          hasMultipleStatements ? `{` : `(`        }`,        exp,        hasMultipleStatements ? `}` : `)`      ])    }  }  let ret = {    props: [      createObjectProperty(        eventName,        exp || createSimpleExpression(`() => {}`, false, loc)      )    ]  }  // apply extended compiler augmentor  if (augmentor) {    ret = augmentor(ret)  }  if (shouldCache) {    // cache handlers so that it's always the same handler being passed down.    // this avoids unnecessary re-renders when users use inline handlers on    // components.    ret.props[0].value = context.cache(ret.props[0].value)  }  // mark the key as handler for props normalization check  ret.props.forEach((p) => (p.key.isHandlerKey = true))  return ret}const seen = new WeakSet()const transformOnce = (node, context) => {  if (node.type === NodeTypes.ELEMENT && findDir(node, 'once', true)) {    if (seen.has(node) || context.inVOnce) {      logg(`transformOnce node has seen`)      return    }    seen.add(node)    context.inVOnce = true    context.helper(SET_BLOCK_TRACKING)    return () => {      context.inVOnce = false      const cur = context.currentNode      if (cur.codegenNode) {        cur.codegenNode = context.cache(cur.codegenNode, true /* isVNode */)      }    }  }}// Important: since this function uses Node.js only dependencies, it should// always be used with a leading !__BROWSER__ check so that it can be// tree-shaken from the browser build.function processExpression(  node,  context,  // some expressions like v-slot props & v-for aliases should be parsed as  // function params  asParams = false,  // v-on handler values may contain multiple statements  asRawStatements = false,  localVars = Object.create(context.identifiers)) {  if (__BROWSER__) {    return node  }  if (!context.prefixIdentifiers || !node.content.trim()) {    return node  }  const { inline, bindingMetadata } = context  const rewriteIdentifier = (raw, parent, id) => {    const type = hasOwn(bindingMetadata, raw) && bindingMetadata[raw]    if (inline) {      // x = y      const isAssignmentLVal =        parent && parent.type === 'AssignmentExpression' && parent.left === id      // x++      const isUpdateArg =        parent && parent.type === 'UpdateExpression' && parent.argument === id      // ({ x } = y)      const isDestructureAssignment =        parent && isInDestructureAssignment(parent, parentStack)      if (type === BindingTypes.SETUP_CONST || localVars[raw]) {        return raw      } else if (type === BindingTypes.SETUP_REF) {        return `${raw}.value`      } else if (type === BindingTypes.SETUP_MAYBE_REF) {        // const binding that may or may not be ref        // if it's not a ref, then assignments don't make sense -        // so we ignore the non-ref assignment case and generate code        // that assumes the value to be a ref for more efficiency        return isAssignmentLVal || isUpdateArg || isDestructureAssignment          ? `${raw}.value`          : `${context.helperString(UNREF)}(${raw})`      } else if (type === BindingTypes.SETUP_LET) {        if (isAssignmentLVal) {          // let binding.          // this is a bit more tricky as we need to cover the case where          // let is a local non-ref value, and we need to replicate the          // right hand side value.          // x = y --> isRef(x) ? x.value = y : x = y          const { right: rVal, operator } = parent          const rExp = rawExp.slice(rVal.start - 1, rVal.end - 1)          const rExpString = stringifyExpression(            processExpression(              createSimpleExpression(rExp, false),              context,              false,              false,              knownIds            )          )          return `${context.helperString(            IS_REF          )}(${raw})${``} ? ${raw}.value ${operator} ${rExpString} : ${raw}`        } else if (isUpdateArg) {          // make id replace parent in the code range so the raw update operator          // is removed          id.start = parent.start          id.end = parent.end          const { prefix: isPrefix, operator } = parent          const prefix = isPrefix ? operator : ``          const postfix = isPrefix ? `` : operator          // let binding.          // x++ --> isRef(a) ? a.value++ : a++          return `${context.helperString(            IS_REF          )}(${raw})${``} ? ${prefix}${raw}.value${postfix} : ${prefix}${raw}${postfix}`        } else if (isDestructureAssignment) {          // TODO          // let binding in a destructure assignment - it's very tricky to          // handle both possible cases here without altering the original          // structure of the code, so we just assume it's not a ref here          // for now          return raw        } else {          return `${context.helperString(UNREF)}(${raw})`        }      } else if (type === BindingTypes.PROPS) {        // use __props which is generated by compileScript so in ts mode        // it gets correct type        return `__props.${raw}`      } else if (type === BindingTypes.PROPS_ALIASED) {        // prop with a different local alias (from defineProps() destructure)        return `__props.${bindingMetadata.__propsAliases[raw]}`      }   } else {      if (type & type.startsWith('setup')) {        // setup bindings in non-inline mode        return `$setup.${raw}`      } else if (type === BindingTypes.PROPS_ALIASED) {        return `$props.${bindingMetadata.__propsAliases[raw]}`      } else if (type) {        return `$${type}.${raw}`      }    }    // fallback to ctx    return `_ctx.${raw}`  }  // fast path if expression is a simple identifier.  const rawExp = node.content  // bail constant on parens (function invocation) and dot (member access)  const bailConstant = rawExp.indexOf(`(`) > -1 || rawExp.indexOf('.') > 0  if (isSimpleIdentifier(rawExp)) {    const isScopeVarReference = context.identifiers[rawExp]    const isAllowedGlobal = isGloballyWhitelisted(rawExp)    const isLiteral = isLiteralWhitelisted(rawExp)    if (!asParams && !isScopeVarReference && !isAllowedGlobal && !isLiteral) {      // const bindings exposed from setup can be skipped for patching but      // cannot be hoisted to module scope      if (bindingMetadata[node.content] === BindingTypes.SETUP_CONST) {        node.constType = ConstantTypes.CAN_SKIP_PATCH      }      node.content = rewriteIdentifier(rawExp)    } else if (!isScopeVarReference) {      if (isLiteral) {        node.constType = ConstantTypes.CAN_STRINGIFY      } else {        node.constType = ConstantTypes.CAN_HOIST      }    }    return node  }  let ast  // exp needs to be parsed differently:  // 1. Multiple inline statements (v-on, with presence of `;`): parse as raw  //    exp, but make sure to pad with spaces for consistent ranges  // 2. Expressions: wrap with parens (for e.g. object expressions)  // 3. Function arguments (v-for, v-slot): place in a function argument position  const source = asRawStatements    ? ` ${rawExp} `    : `(${rawExp})${asParams ? `=>{}` : ``}`  try {    ast = babelParser.parse(source, {      plugins: [ ...context.expressionPlugins , ...babelPlugins]    }).program  } catch (e) {    return node  }  const ids = []  const parentStack = []  const knownIds = Object.create(context.identifiers)  walkIdentifiers(    ast,    (node, parent, _, isReferenced, isLocal) => {      if (isStaticPropertyKey(node, parent)) {        return      }      const needPrefix = isReferenced && canPrefix(node)      if (needPrefix && !isLocal) {        if (isStaticProperty(parent) && parent.shorthand) {          // property shorthand like { foo }, we need to add the key since          // we rewrite the value          node.prefix = `${node.name}: `        }        node.name = rewriteIdentifier(node.name, parent, node)        ids.push(node)      } else {        // The identifier is considered constant unless it's pointing to a        // local scope variable (a v-for alias, or a v-slot prop)        if (!(needPrefix && isLocal) && !bailConstant) {          node.isConstant = true        }        // also generate sub-expressions for other identifiers for better        // source map support. (except for property keys which are static)        ids.push(node)      }    },    true, // invoke on ALL identifiers    parentStack,    knownIds  )  // We break up the compound expression into an array of strings and sub  // expressions (for identifiers that have been prefixed). In codegen, if  // an ExpressionNode has the `.children` property, it will be used instead of  // `.content`.  const children = []  ids.sort((a, b) => a.start - b.start)  ids.forEach((id, i) => {    // range is offset by -1 due to the wrapping parens when parsed    const start = id.start - 1    const end = id.end - 1    const last = ids[i - 1]    const leadingText = rawExp.slice(last ? last.end - 1 : 0, start)    if (leadingText.length || id.prefix) {      children.push(leadingText + (id.prefix || ``))    }    const source = rawExp.slice(start, end)    children.push(      createSimpleExpression(        id.name,        false,        {          source,          start: advancePositionWithClone(node.loc.start, source, start),          end: advancePositionWithClone(node.loc.start, source, end)        },        id.isConstant ? ConstantTypes.CAN_STRINGIFY : ConstantTypes.NOT_CONSTANT      )    )    if (i === ids.length - 1 && end < rawExp.length) {      children.push(rawExp.slice(end))    }  })  let ret  if (children.length) {    ret = createCompoundExpression(children, node.loc)  } else {    ret = node    ret.constType = bailConstant      ? ConstantTypes.NOT_CONSTANT      : ConstantTypes.CAN_STRINGIFY  }  ret.identifiers = Object.keys(knownIds)  return ret}function canPrefix(id) {  // skip whitelisted globals  if (isGloballyWhitelisted(id.name)) {    return false  }  // special case for webpack compilation  if (id.name === 'require') {    return false  }  return true}function stringifyExpression(exp) {  if (isString(exp)) {    return exp  } else if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {    return exp.content  } else {    return exp.children.map(stringifyExpression).join('')  }}function createRoot(children, loc = locStub) {  return {    type: NodeTypes.ROOT,    children,    helpers: [],    components: [],    directives: [],    hoists: [],    imports: [],    cached: 0,    temps: 0,    codegenNode: undefined,    loc  }}function createVNodeCall(  context,  tag,  props,  children,  patchFlag,  dynamicProps,  directives,  isBlock = false,  disableTracking = false,  isComponent = false,  loc = locStub) {  if (context) {    // 单个子节点用 block    if (isBlock) {      context.helper(OPEN_BLOCK)      context.helper(getVNodeBlockHelper(context.inSSR, isComponent))    } else {      // 多个节节点用 fragment      context.helper(getVNodeHelper(context.inSSR, isComponent))    }    if (directives) {      context.helper(WITH_DIRECTIVES)    }  }  return {    type: NodeTypes.VNODE_CALL,    tag,    props,    children,    patchFlag,    dynamicProps,    directives,    isBlock,    disableTracking,    isComponent,    loc  }}function createArrayExpression(elements, loc = locStub) {  return {    type: NodeTypes.JS_ARRAY_EXPRESSION,    loc,    elements  }}function createObjectExpression(properties, loc = locStub) {  return {    type: NodeTypes.JS_OBJECT_EXPRESSION,    loc,    properties  }}function createObjectProperty(key, value) {  return {    type: NodeTypes.JS_PROPERTY,    loc: locStub,    key: isString(key) ? createSimpleExpression(key, true) : key,    value  }}function createSimpleExpression(  content,  isStatic = false,  loc = locStub,  constType = ConstantTypes.NOT_CONSTANT) {  return {    type: NodeTypes.SIMPLE_EXPRESSION,    loc,    content,    isStatic,    constType: isStatic ? ConstantTypes.CAN_STRINGIFY : constType  }}function createInterpolation(content, loc) {  return {    type: NodeTypes.INTERPOLATION,    loc,    content: isString(content)      ? createSimpleExpression(content, false, loc)      : content  }}function createCompoundExpression(children, loc = locStub) {  return {    type: NodeTypes.COMPOUND_EXPRESSION,    loc,    children  }}function createCallExpression(callee, args = [], loc = locStub) {  return {    type: NodeTypes.JS_CALL_EXPRESSION,    loc,    callee,    arguments: args  }}function createFunctionExpression(  params,  returns = undefined,  newline = false,  isSlot = false,  loc = locStub) {  return {    type: NodeTypes.JS_FUNCTION_EXPRESSION,    params,    returns,    newline,    isSlot,    loc  }}function createConditionalExpression(  test,  consequent,  alternate,  newline = true) {  return {    type: NodeTypes.JS_CONDITIONAL_EXPRESSION,    test,    consequent,    alternate,    newline,    loc: locStub  }}function createCacheExpression(index, value, isVNode = false) {  return {    type: NodeTypes.JS_CACHE_EXPRESSION,    index,    value,    isVNode,    loc: locStub  }}function createBlockStatement(body) {  return {    type: NodeTypes.JS_BLOCK_STATEMENT,    body,    loc: locStub  }}function createTemplateLiteral(elements) {  return {    type: NodeTypes.JS_TEMPLATE_LITERAL,    elements,    loc: locStub  }}function createIfStatement(test, consequent, alternate) {  return {    type: NodeTypes.JS_IF_STATEMENT,    test,    consequent,    alternate,    loc: locStub  }}function createAssignmentExpression(left, right) {  return {    type: NodeTypes.JS_ASSIGNMENT_EXPRESSION,    left,    right,    loc: locStub  }}function createSequenceExpression(expressions) {  return {    type: NodeTypes.JS_SEQUENCE_EXPRESSION,    expressions,    loc: locStub  }}function createReturnStatement(returns) {  return {    type: NodeTypes.JS_RETURN_STATEMENT,    returns,    loc: locStub  }}function transform(root, options) {  // transform 上下文  const context = createTransformContext(root, options)  // 递归遍历整个 ast root 树，最终为每颗子树生成 codegenNode  traverseNode(root, context)  // 静态提升处理  if (options.hoistStatic) {    hoistStatic(root, context)  }  // 创建 root codegenNode 代码  if (!options.ssr) {    createRootCodegen(root, context)  }  // finalize meta information  root.helpers = [...context.helpers.keys()]  root.components = [...context.components]  root.directives = [...context.directives]  root.imports = context.imports  root.hoists = context.hoists  root.temps = context.temps  root.cached = context.cached}function getBaseTransformPreset(prefixIdentifiers) {  return [    [      transformOnce,      transformIf,      transformMemo,      transformFor,      ...(!__BROWSER__ && prefixIdentifiers        ? [            // order is important            trackVForSlotScopes,            transformExpression          ]        : __BROWSER__ && __DEV__        ? [transformExpression]        : []),      transformSlotOutlet,      transformElement,      trackSlotScopes,      transformText    ],    {      on: transformOn,      bind: transformBind,      model: transformModel    }  ]}const PURE_ANNOTATION = `/*#__PURE__*/`function isText$1(n) {  return (    isString(n) ||    n.type === NodeTypes.SIMPLE_EXPRESSION ||    n.type === NodeTypes.TEXT ||    n.type === NodeTypes.INTERPOLATION ||    n.type === NodeTypes.COMPOUND_EXPRESSION  )}// 过滤掉后面空值参数fn(a, b, c, null, undefined, '') => fn(a,b,c)function genNullableArgs(args) {  let i = args.length  while (i--) {    if (args[i] != null) break  }  return args.slice(0, i + 1).map((arg) => arg || `null`)}// 生成对象的 key 值，可能是个表达式，如： { [a + b + c]: value }function genExpressionAsPropertyKey(node, context) {  const { push } = context  if (node.type === NodeTypes.COMPOUND_EXPRESSION) {    push(`[`)    genCompoundExpression(node, context)    push(`]`)  } else if (node.isStatic) {    // only quote keys if necessary    const text = isSimpleIdentifier(node.content)      ? node.content      : JSON.stringify(node.content)    push(text, node)  } else {    push(`[${node.content}]`, node)  }}function createCodegenContext(  ast,  {    mode = 'function',    prefixIdentifiers = mode === 'module',    sourceMap = false,    filename = `template.vue.html`,    scopeId = null,    optimizeImports = false,    runtimeGlobalName = `Vue`,    runtimeModuleName = `vue`,    ssrRuntimeModuleName = 'vue/server-renderer',    ssr = false,    isTS = false,    inSSR = false  }) {  const context = {    mode,    prefixIdentifiers,    sourceMap,    filename,    scopeId,    optimizeImports,    runtimeGlobalName,    runtimeModuleName,    ssrRuntimeModuleName,    ssr,    isTS,    inSSR,    source: ast.loc.source,    code: ``,    column: 1,    line: 1,    offset: 0,    indentLevel: 0,    pure: false,    map: undefined,    helper(key) {      return `_${helperNameMap[key]}`    },    push(code, node) {      context.code += code      if (!__BROWSER__ && context.map) {        if (node) {          let name          if (node.type === NodeTypes.SIMPLE_EXPRESSION && !node.isStatic) {            const content = node.content.replace(/^_ctx\./, '')            if (content !== node.content && isSimpleIdentifier(content)) {              name = content            }          }          addMapping(node.loc.start, name)        }        advancePositionWithMutation(context, code)        if (node && node.loc !== locStub) {          addMapping(node.loc.end)        }      }    },    indent() {      newline(++context.indentLevel)    },    deindent(withoutNewLine = false) {      if (withoutNewLine) {        --context.indentLevel      } else {        newline(--context.indentLevel)      }    },    newline() {      newline(context.indentLevel)    }  }  function newline(n) {    context.push('\n' + `  `.repeat(n))  }  function addMapping(loc, name) {    context.map.addMapping({      name,      source: context.filename,      original: {        line: loc.line,        column: loc.column - 1 // source-map column is 0 based      },      generated: {        line: context.line,        column: context.column - 1      }    })  }  return context}function genModulePreamble(ast, context, genScopeId, inline) {  const {    push,    newline,    optimizeImports,    runtimeModuleName,    ssrRuntimeModuleName  } = context  if (genScopeId && ast.hoists.length) {    ast.helpers.push(PUSH_SCOPE_ID, POP_SCOPE_ID)  }  // generate import statements for helpers  if (ast.helpers.length) {    if (optimizeImports) {      // when bundled with webpack with code-split, calling an import binding      // as a function leads to it being wrapped with `Object(a.b)` or `(0,a.b)`,      // incurring both payload size increase and potential perf overhead.      // therefore we assign the imports to variables (which is a constant ~50b      // cost per-component instead of scaling with template size)      push(        `import { ${ast.helpers          .map((s) => helperNameMap[s])          .join(', ')} } from ${JSON.stringify(runtimeModuleName)}\n`      )      push(        `\n// Binding optimization for webpack code-split\nconst ${ast.helpers          .map((s) => `_${helperNameMap[s]} = ${helperNameMap[s]}`)          .join(', ')}\n`      )    } else {      push(        `import { ${ast.helpers          .map((s) => `${helperNameMap[s]} as _${helperNameMap[s]}`)          .join(', ')} } from ${JSON.stringify(runtimeModuleName)}\n`      )    }  }  if (ast.ssrHelpers && ast.ssrHelpers.length) {    push(      `import { ${ast.ssrHelpers        .map((s) => `${helperNameMap[s]} as _${helperNameMap[s]}`)        .join(', ')} } from "${ssrRuntimeModuleName}"\n`    )  }  if (ast.imports.length) {    genImports(ast.imports, context)    newline()  }  genHoists(ast.hoists, context)  newline()  if (!inline) {    push(`export `)  }}function genImports(importsOptions, context) {  if (!importsOptions.length) {    return  }  importsOptions.forEach((imports) => {    context.push(`import `)    genNode(imports.exp, context)    context.push(` from '${imports.path}'`)    context.newline()  })}function genFunctionPreamble(ast, context) {  const {    ssr,    prefixIdentifiers,    push,    newline,    runtimeModuleName,    runtimeGlobalName,    ssrRuntimeModuleName  } = context  const VueBinding =    !__BROWSER__ && ssr      ? `require(${JSON.stringify(runtimeModuleName)})`      : runtimeGlobalName  const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`  // Generate const declaration for helpers  // In prefix mode, we place the const declaration at top so it's done  // only once; But if we not prefixing, we place the declaration inside the  // with block so it doesn't incur the `in` check cost for every helper access.  if (ast.helpers.length > 0) {    if (!__BROWSER__ && prefixIdentifiers) {      push(        `const { ${ast.helpers.map(aliasHelper).join(', ')} } = ${VueBinding}\n`      )    } else {      // "with" mode.      // save Vue in a separate variable to avoid collision      push(`const _Vue = ${VueBinding}\n`)      // in "with" mode, helpers are declared inside the with block to avoid      // has check cost, but hoists are lifted out of the function - we need      // to provide the helper here.      if (ast.hoists.length) {        const staticHelpers = [          CREATE_VNODE,          CREATE_ELEMENT_VNODE,          CREATE_COMMENT,          CREATE_TEXT,          CREATE_STATIC        ]          .filter((helper) => ast.helpers.includes(helper))          .map(aliasHelper)          .join(', ')        push(`const { ${staticHelpers} } = _Vue\n`)      }    }  }  // generate variables for ssr helpers  if (!__BROWSER__ && ast.ssrHelpers && ast.ssrHelpers.length) {    // ssr guarantees prefixIdentifier: true    push(      `const { ${ast.ssrHelpers        .map(aliasHelper)        .join(', ')} } = require("${ssrRuntimeModuleName}")\n`    )  }  genHoists(ast.hoists, context)  newline()  push(`return `)}function genHoists(hoists, context) {  if (!hoists.length) {    return  }  context.pure = true  const { push, newline, helper, scopeId, mode } = context  const genScopeId = !__BROWSER__ && scopeId != null && mode !== 'function'  newline()  // generate inlined withScopeId helper  if (genScopeId) {    push(      `const _withScopeId = n => (${helper(        PUSH_SCOPE_ID      )}("${scopeId}"),n=n(),${helper(POP_SCOPE_ID)}(),n)`    )    newline()  }  for (let i = 0; i < hoists.length; i++) {    const exp = hoists[i]    if (exp) {      const needScopeIdWrapper = genScopeId && exp.type === NodeTypes.VNODE_CALL      push(        `const _hoisted_${i + 1} = ${          needScopeIdWrapper ? `${PURE_ANNOTATION} _withScopeId(() => ` : ``        }`      )      genNode(exp, context)      if (needScopeIdWrapper) {        push(`)`)      }      newline()    }  }  context.pure = false}// type = 'component' | 'directive' | 'filter'function genAssets(assets, type, { helper, push, newline, isTS }) {  const resolver = helper(    type === 'component' ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE  )  for (let i = 0; i < assets.length; i++) {    let id = assets[i]    // potential component implicit self-reference inferred from SFC filename    const maybeSelfReference = id.endsWith('__self')    if (maybeSelfReference) {      id = id.slice(0, -6)    }    push(      `const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${        maybeSelfReference ? `, true` : ``      })${isTS ? `!` : ``}`    )    if (i < assets.length - 1) {      newline()    }  }}function genText(node, context) {  context.push(JSON.stringify(node.content), node)}function genExpression(node, context) {  const { content, isStatic } = node  context.push(isStatic ? JSON.stringify(content) : content, node)}function genInterpolation(node, context) {  const { push, helper, pure } = context  if (pure) push(PURE_ANNOTATION)  push(`${helper(TO_DISPLAY_STRING)}(`)  genNode(node.content, context)  push(`)`)}function genCompoundExpression(node, context) {  for (let i = 0; i < node.children.length; i++) {    const child = node.children[i]    if (isString(child)) {      context.push(child)    } else {      genNode(child, context)    }  }}function genComment(node, context) {  const { push, helper, pure } = context  if (pure) {    push(PURE_ANNOTATION)  }  push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node)}function genVNodeCall(node, context) {  const { push, helper, pure } = context  const {    tag,    props,    children,    patchFlag,    dynamicProps,    directives,    isBlock,    disableTracking,    isComponent  } = node  if (directives) {    push(helper(WITH_DIRECTIVES) + `(`)  }  if (isBlock) {    push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `)  }  if (pure) {    push(PURE_ANNOTATION)  }  const callHelper = isBlock    ? getVNodeBlockHelper(context.inSSR, isComponent)    : getVNodeHelper(context.inSSR, isComponent)  push(helper(callHelper) + `(`, node)  genNodeList(    genNullableArgs([tag, props, children, patchFlag, dynamicProps]),    context  )  push(`)`)  if (isBlock) {    push(`)`)  }  if (directives) {    push(`, `)    genNode(directives, context)    push(`)`)  }}// JavaScriptfunction genCallExpression(node, context) {  const { push, helper, pure } = context  const callee = isString(node.callee) ? node.callee : helper(node.callee)  if (pure) {    push(PURE_ANNOTATION)  }  push(callee + `(`, node)  genNodeList(node.arguments, context)  push(`)`)}function genObjectExpression(node, context) {  const { push, indent, deindent, newline } = context  const { properties } = node  if (!properties.length) {    push(`{}`, node)    return  }  const multilines =    properties.length > 1 ||    ((!__BROWSER__ || __DEV__) &&      properties.some((p) => p.value.type !== NodeTypes.SIMPLE_EXPRESSION))  push(multilines ? `{` : `{ `)  multilines && indent()  for (let i = 0; i < properties.length; i++) {    const { key, value } = properties[i]    // key    genExpressionAsPropertyKey(key, context)    push(`: `)    // value    genNode(value, context)    if (i < properties.length - 1) {      // will only reach this if it's multilines      push(`,`)      newline()    }  }  multilines && deindent()  push(multilines ? `}` : ` }`)}function genArrayExpression(node, context) {  genNodeListAsArray(node.elements, context)}function genFunctionExpression(node, context) {  const { push, indent, deindent } = context  const { params, returns, body, newline, isSlot } = node  if (isSlot) {    // wrap slot functions with owner context    push(`_${helperNameMap[WITH_CTX]}(`)  }  push(`(`, node)  if (isArray(params)) {    genNodeList(params, context)  } else if (params) {    genNode(params, context)  }  push(`) => `)  if (newline || body) {    push(`{`)    indent()  }  if (returns) {    if (newline) {      push(`return `)    }    if (isArray(returns)) {      genNodeListAsArray(returns, context)    } else {      genNode(returns, context)    }  } else if (body) {    genNode(body, context)  }  if (newline || body) {    deindent()    push(`}`)  }  if (isSlot) {    push(`)`)  }}function genConditionalExpression(node, context) {  const { test, consequent, alternate, newline: needNewline } = node  const { push, indent, deindent, newline } = context  if (test.type === NodeTypes.SIMPLE_EXPRESSION) {    const needsParens = !isSimpleIdentifier(test.content)    needsParens && push(`(`)    genExpression(test, context)    needsParens && push(`)`)  } else {    push(`(`)    genNode(test, context)    push(`)`)  }  needNewline && indent()  context.indentLevel++  needNewline || push(` `)  push(`? `)  genNode(consequent, context)  context.indentLevel--  needNewline && newline()  needNewline || push(` `)  push(`: `)  const isNested = alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION  if (!isNested) {    context.indentLevel++  }  genNode(alternate, context)  if (!isNested) {    context.indentLevel--  }  needNewline && deindent(true /* without newline */)}function genCacheExpression(node, context) {  const { push, helper, indent, deindent, newline } = context  push(`_cache[${node.index}] || (`)  if (node.isVNode) {    indent()    push(`${helper(SET_BLOCK_TRACKING)}(-1),`)    newline()  }  push(`_cache[${node.index}] = `)  genNode(node.value, context)  if (node.isVNode) {    push(`,`)    newline()    push(`${helper(SET_BLOCK_TRACKING)}(1),`)    newline()    push(`_cache[${node.index}]`)    deindent()  }  push(`)`)}function genNodeList(nodes, context, multilines = false, comma = true) {  const { push, newline } = context  for (let i = 0; i < nodes.length; i++) {    const node = nodes[i]    if (isString(node)) {      push(node)    } else if (isArray(node)) {      genNodeListAsArray(node, context)    } else {      genNode(node, context)    }    if (i < nodes.length - 1) {      if (multilines) {        comma && push(',')        newline()      } else {        comma && push(', ')      }    }  }}function genTemplateLiteral(node, context) {  const { push, indent, deindent } = context  push('`')  const l = node.elements.length  const multilines = l > 3  for (let i = 0; i < l; i++) {    const e = node.elements[i]    if (isString(e)) {      push(e.replace(/(`|\$|\\)/g, '\\$1'))    } else {      push('${')      if (multilines) indent()      genNode(e, context)      if (multilines) deindent()      push('}')    }  }  push('`')}function genIfStatement(node, context) {  const { push, indent, deindent } = context  const { test, consequent, alternate } = node  push(`if (`)  genNode(test, context)  push(`) {`)  indent()  genNode(consequent, context)  deindent()  push(`}`)  if (alternate) {    push(` else `)    if (alternate.type === NodeTypes.JS_IF_STATEMENT) {      genIfStatement(alternate, context)    } else {      push(`{`)      indent()      genNode(alternate, context)      deindent()      push(`}`)    }  }}function genAssignmentExpression(node, context) {  genNode(node.left, context)  context.push(` = `)  genNode(node.right, context)}function genSequenceExpression(node, context) {  context.push(`(`)  genNodeList(node.expressions, context)  context.push(`)`)}function genReturnStatement({ returns }, context) {  context.push(`return `)  if (isArray(returns)) {    genNodeListAsArray(returns, context)  } else {    genNode(returns, context)  }}function genNode(node, context) {  if (isString(node)) {    context.push(node)    return  }  if (isSymbol(node)) {    context.push(context.helper(node))    return  }  switch (node.type) {    case NodeTypes.ELEMENT:    case NodeTypes.IF:    case NodeTypes.FOR:      genNode(node.codegenNode, context)      break    case NodeTypes.TEXT:      genText(node, context)      break    case NodeTypes.SIMPLE_EXPRESSION:      genExpression(node, context)      break    case NodeTypes.INTERPOLATION:      genInterpolation(node, context)      break    case NodeTypes.TEXT_CALL:      genNode(node.codegenNode, context)      break    case NodeTypes.COMPOUND_EXPRESSION:      genCompoundExpression(node, context)      break    case NodeTypes.COMMENT:      genComment(node, context)      break    case NodeTypes.VNODE_CALL:      genVNodeCall(node, context)      break    case NodeTypes.JS_CALL_EXPRESSION:      genCallExpression(node, context)      break    case NodeTypes.JS_OBJECT_EXPRESSION:      genObjectExpression(node, context)      break    case NodeTypes.JS_ARRAY_EXPRESSION:      genArrayExpression(node, context)      break    case NodeTypes.JS_FUNCTION_EXPRESSION:      genFunctionExpression(node, context)      break    case NodeTypes.JS_CONDITIONAL_EXPRESSION:      genConditionalExpression(node, context)      break    case NodeTypes.JS_CACHE_EXPRESSION:      genCacheExpression(node, context)      break    case NodeTypes.JS_BLOCK_STATEMENT:      genNodeList(node.body, context, true, false)      break    // SSR only types    case NodeTypes.JS_TEMPLATE_LITERAL:      !__BROWSER__ && genTemplateLiteral(node, context)      break    case NodeTypes.JS_IF_STATEMENT:      !__BROWSER__ && genIfStatement(node, context)      break    case NodeTypes.JS_ASSIGNMENT_EXPRESSION:      !__BROWSER__ && genAssignmentExpression(node, context)      break    case NodeTypes.JS_SEQUENCE_EXPRESSION:      !__BROWSER__ && genSequenceExpression(node, context)      break    case NodeTypes.JS_RETURN_STATEMENT:      !__BROWSER__ && genReturnStatement(node, context)      break    /* istanbul ignore next */    case NodeTypes.IF_BRANCH:      // noop      break    default:      logg(`unhandled codegen node type: ${node.type}`)  }}function genNodeListAsArray(nodes, context) {  const multilines =    nodes.length > 3 ||    ((!__BROWSER__ || __DEV__) && nodes.some((n) => isArray(n) || !isText(n)))  context.push(`[`)  multilines && context.indent()  genNodeList(nodes, context, multilines)  multilines && context.deindent()  context.push(`]`)}function generate(ast, options = {}) {  const context = createCodegenContext(ast, options)  if (options.onContextCreated) options.onContextCreated(context)  const {    mode,    push,    prefixIdentifiers,    indent,    deindent,    newline,    scopeId,    ssr  } = context  const hasHelpers = ast.helpers.length > 0  const useWithBlock = !prefixIdentifiers && mode !== 'module'  const genScopeId = !__BROWSER__ && scopeId != null && mode === 'module'  const isSetupInlined = !__BROWSER__ && !!options.inline  // preambles  // in setup() inline mode, the preamble is generated in a sub context  // and returned separately.  const preambleContext = isSetupInlined    ? createCodegenContext(ast, options)    : context  if (!__BROWSER__ && mode === 'module') {    genModulePreamble(ast, preambleContext, genScopeId, isSetupInlined)  } else {    genFunctionPreamble(ast, preambleContext)  }  // enter render function  const functionName = ssr ? `ssrRender` : `render`  const args = ssr ? ['_ctx', '_push', '_parent', '_attrs'] : ['_ctx', '_cache']  if (!__BROWSER__ && options.bindingMetadata && !options.inline) {    // binding optimization args    args.push('$props', '$setup', '$data', '$options')  }  const signature =    !__BROWSER__ && options.isTS      ? args.map((arg) => `${arg}: any`).join(',')      : args.join(', ')  if (isSetupInlined) {    push(`(${signature}) => {`)  } else {    push(`function ${functionName}(${signature}) {`)  }  indent()  if (useWithBlock) {    push(`with (_ctx) {`)    indent()    // function mode const declarations should be inside with block    // also they should be renamed to avoid collision with user properties    if (hasHelpers) {      push(        `const { ${ast.helpers          .map((s) => `${helperNameMap[s]}: _${helperNameMap[s]}`)          .join(', ')} } = _Vue`      )      push(`\n`)      newline()    }  }  // generate asset resolution statements  if (ast.components.length) {    genAssets(ast.components, 'component', context)    if (ast.directives.length || ast.temps > 0) {      newline()    }  }  if (ast.directives.length) {    genAssets(ast.directives, 'directive', context)    if (ast.temps > 0) {      newline()    }  }  // 临时变量  if (ast.temps > 0) {    push(`let `)    for (let i = 0; i < ast.temps; i++) {      push(`${i > 0 ? `, ` : ``}_temp${i}`)    }  }  if (ast.components.length || ast.directives.length || ast.temps) {    push(`\n`)    newline()  }  // generate the VNode tree expression  if (!ssr) {    push(`return `)  }  if (ast.codegenNode) {    genNode(ast.codegenNode, context)  } else {    push(`null`)  }  if (useWithBlock) {    deindent()    push(`}`)  }  deindent()  push(`}`)  return {    ast,    code: context.code,    preamble: isSetupInlined ? preambleContext.code : ``,    // SourceMapGenerator does have toJSON() method but it's not in the types    map: context.map ? context.map.toJSON() : undefined  }}function baseCompile(template, options = {}) {  const isModuleMode = options.mode === 'module'  const prefixIdentifiers =    !__BROWSER__ && (options.prefixIdentifiers === true || isModuleMode)  const ast = isString(template) ? baseParse(template, options) : template  const [nodeTransforms, directiveTransforms] =    getBaseTransformPreset(prefixIdentifiers)  // 转换出每个节点的 codegenNode  transform(    ast,    extend({}, options, {      prefixIdentifiers,      nodeTransforms: [        ...nodeTransforms,        ...(options.nodeTransforms || []) // user transforms      ],      directiveTransforms: extend(        {},        directiveTransforms,        options.directiveTransforms || {} // user transforms      )    })  )  // 生成 codegen  return generate(ast, extend({}, options, { prefixIdentifiers }))}const namedCharacterReferences = {  GT: '>',  gt: '>',  LT: '<',  lt: '<',  'ac;': '∾',  'af;': '⁡',  AMP: '&',  amp: '&',  'ap;': '≈',  'DD;': 'ⅅ',  'dd;': 'ⅆ',  deg: '°',  'ee;': 'ⅇ',  'eg;': '⪚',  'el;': '⪙',  ETH: 'Ð',  eth: 'ð',  'gE;': '≧',  'ge;': '≥',  'Gg;': '⋙',  'gg;': '≫',  'gl;': '≷',  'GT;': '>',  'Gt;': '≫',  'gt;': '>',  'ic;': '⁣',  'ii;': 'ⅈ',  'Im;': 'ℑ',  'in;': '∈',  'it;': '⁢',  'lE;': '≦',  'le;': '≤',  'lg;': '≶',  'Ll;': '⋘',  'll;': '≪',  'LT;': '<',  'Lt;': '≪',  'lt;': '<',  'mp;': '∓',  'Mu;': 'Μ',  'mu;': 'μ',  'ne;': '≠',  'ni;': '∋',  not: '¬',  'Nu;': 'Ν',  'nu;': 'ν',  'Or;': '⩔',  'or;': '∨',  'oS;': 'Ⓢ',  'Pi;': 'Π',  'pi;': 'π',  'pm;': '±',  'Pr;': '⪻',  'pr;': '≺',  'Re;': 'ℜ',  REG: '®',  reg: '®',  'rx;': '℞',  'Sc;': '⪼',  'sc;': '≻',  shy: '­',  uml: '¨',  'wp;': '℘',  'wr;': '≀',  'Xi;': 'Ξ',  'xi;': 'ξ',  yen: '¥',  'acd;': '∿',  'acE;': '∾̳',  'Acy;': 'А',  'acy;': 'а',  'Afr;': '𝔄',  'afr;': '𝔞',  'AMP;': '&',  'amp;': '&',  'And;': '⩓',  'and;': '∧',  'ang;': '∠',  'apE;': '⩰',  'ape;': '≊',  'ast;': '*',  Auml: 'Ä',  auml: 'ä',  'Bcy;': 'Б',  'bcy;': 'б',  'Bfr;': '𝔅',  'bfr;': '𝔟',  'bne;': '=⃥',  'bot;': '⊥',  'Cap;': '⋒',  'cap;': '∩',  cent: '¢',  'Cfr;': 'ℭ',  'cfr;': '𝔠',  'Chi;': 'Χ',  'chi;': 'χ',  'cir;': '○',  COPY: '©',  copy: '©',  'Cup;': '⋓',  'cup;': '∪',  'Dcy;': 'Д',  'dcy;': 'д',  'deg;': '°',  'Del;': '∇',  'Dfr;': '𝔇',  'dfr;': '𝔡',  'die;': '¨',  'div;': '÷',  'Dot;': '¨',  'dot;': '˙',  'Ecy;': 'Э',  'ecy;': 'э',  'Efr;': '𝔈',  'efr;': '𝔢',  'egs;': '⪖',  'ell;': 'ℓ',  'els;': '⪕',  'ENG;': 'Ŋ',  'eng;': 'ŋ',  'Eta;': 'Η',  'eta;': 'η',  'ETH;': 'Ð',  'eth;': 'ð',  Euml: 'Ë',  euml: 'ë',  'Fcy;': 'Ф',  'fcy;': 'ф',  'Ffr;': '𝔉',  'ffr;': '𝔣',  'gap;': '⪆',  'Gcy;': 'Г',  'gcy;': 'г',  'gEl;': '⪌',  'gel;': '⋛',  'geq;': '≥',  'ges;': '⩾',  'Gfr;': '𝔊',  'gfr;': '𝔤',  'ggg;': '⋙',  'gla;': '⪥',  'glE;': '⪒',  'glj;': '⪤',  'gnE;': '≩',  'gne;': '⪈',  'Hat;': '^',  'Hfr;': 'ℌ',  'hfr;': '𝔥',  'Icy;': 'И',  'icy;': 'и',  'iff;': '⇔',  'Ifr;': 'ℑ',  'ifr;': '𝔦',  'Int;': '∬',  'int;': '∫',  Iuml: 'Ï',  iuml: 'ï',  'Jcy;': 'Й',  'jcy;': 'й',  'Jfr;': '𝔍',  'jfr;': '𝔧',  'Kcy;': 'К',  'kcy;': 'к',  'Kfr;': '𝔎',  'kfr;': '𝔨',  'lap;': '⪅',  'lat;': '⪫',  'Lcy;': 'Л',  'lcy;': 'л',  'lEg;': '⪋',  'leg;': '⋚',  'leq;': '≤',  'les;': '⩽',  'Lfr;': '𝔏',  'lfr;': '𝔩',  'lgE;': '⪑',  'lnE;': '≨',  'lne;': '⪇',  'loz;': '◊',  'lrm;': '‎',  'Lsh;': '↰',  'lsh;': '↰',  macr: '¯',  'Map;': '⤅',  'map;': '↦',  'Mcy;': 'М',  'mcy;': 'м',  'Mfr;': '𝔐',  'mfr;': '𝔪',  'mho;': '℧',  'mid;': '∣',  'nap;': '≉',  nbsp: ' ',  'Ncy;': 'Н',  'ncy;': 'н',  'Nfr;': '𝔑',  'nfr;': '𝔫',  'ngE;': '≧̸',  'nge;': '≱',  'nGg;': '⋙̸',  'nGt;': '≫⃒',  'ngt;': '≯',  'nis;': '⋼',  'niv;': '∋',  'nlE;': '≦̸',  'nle;': '≰',  'nLl;': '⋘̸',  'nLt;': '≪⃒',  'nlt;': '≮',  'Not;': '⫬',  'not;': '¬',  'npr;': '⊀',  'nsc;': '⊁',  'num;': '#',  'Ocy;': 'О',  'ocy;': 'о',  'Ofr;': '𝔒',  'ofr;': '𝔬',  'ogt;': '⧁',  'ohm;': 'Ω',  'olt;': '⧀',  'ord;': '⩝',  ordf: 'ª',  ordm: 'º',  'orv;': '⩛',  Ouml: 'Ö',  ouml: 'ö',  'par;': '∥',  para: '¶',  'Pcy;': 'П',  'pcy;': 'п',  'Pfr;': '𝔓',  'pfr;': '𝔭',  'Phi;': 'Φ',  'phi;': 'φ',  'piv;': 'ϖ',  'prE;': '⪳',  'pre;': '⪯',  'Psi;': 'Ψ',  'psi;': 'ψ',  'Qfr;': '𝔔',  'qfr;': '𝔮',  QUOT: '"',  quot: '"',  'Rcy;': 'Р',  'rcy;': 'р',  'REG;': '®',  'reg;': '®',  'Rfr;': 'ℜ',  'rfr;': '𝔯',  'Rho;': 'Ρ',  'rho;': 'ρ',  'rlm;': '‏',  'Rsh;': '↱',  'rsh;': '↱',  'scE;': '⪴',  'sce;': '⪰',  'Scy;': 'С',  'scy;': 'с',  sect: '§',  'Sfr;': '𝔖',  'sfr;': '𝔰',  'shy;': '­',  'sim;': '∼',  'smt;': '⪪',  'sol;': '/',  'squ;': '□',  'Sub;': '⋐',  'sub;': '⊂',  'Sum;': '∑',  'sum;': '∑',  'Sup;': '⋑',  'sup;': '⊃',  sup1: '¹',  sup2: '²',  sup3: '³',  'Tab;': '\t',  'Tau;': 'Τ',  'tau;': 'τ',  'Tcy;': 'Т',  'tcy;': 'т',  'Tfr;': '𝔗',  'tfr;': '𝔱',  'top;': '⊤',  'Ucy;': 'У',  'ucy;': 'у',  'Ufr;': '𝔘',  'ufr;': '𝔲',  'uml;': '¨',  Uuml: 'Ü',  uuml: 'ü',  'Vcy;': 'В',  'vcy;': 'в',  'Vee;': '⋁',  'vee;': '∨',  'Vfr;': '𝔙',  'vfr;': '𝔳',  'Wfr;': '𝔚',  'wfr;': '𝔴',  'Xfr;': '𝔛',  'xfr;': '𝔵',  'Ycy;': 'Ы',  'ycy;': 'ы',  'yen;': '¥',  'Yfr;': '𝔜',  'yfr;': '𝔶',  yuml: 'ÿ',  'Zcy;': 'З',  'zcy;': 'з',  'Zfr;': 'ℨ',  'zfr;': '𝔷',  'zwj;': '‍',  Acirc: 'Â',  acirc: 'â',  acute: '´',  AElig: 'Æ',  aelig: 'æ',  'andd;': '⩜',  'andv;': '⩚',  'ange;': '⦤',  'Aopf;': '𝔸',  'aopf;': '𝕒',  'apid;': '≋',  'apos;': "'",  Aring: 'Å',  aring: 'å',  'Ascr;': '𝒜',  'ascr;': '𝒶',  'Auml;': 'Ä',  'auml;': 'ä',  'Barv;': '⫧',  'bbrk;': '⎵',  'Beta;': 'Β',  'beta;': 'β',  'beth;': 'ℶ',  'bNot;': '⫭',  'bnot;': '⌐',  'Bopf;': '𝔹',  'bopf;': '𝕓',  'boxH;': '═',  'boxh;': '─',  'boxV;': '║',  'boxv;': '│',  'Bscr;': 'ℬ',  'bscr;': '𝒷',  'bsim;': '∽',  'bsol;': '\\',  'bull;': '•',  'bump;': '≎',  'caps;': '∩︀',  'Cdot;': 'Ċ',  'cdot;': 'ċ',  cedil: '¸',  'cent;': '¢',  'CHcy;': 'Ч',  'chcy;': 'ч',  'circ;': 'ˆ',  'cirE;': '⧃',  'cire;': '≗',  'comp;': '∁',  'cong;': '≅',  'Copf;': 'ℂ',  'copf;': '𝕔',  'COPY;': '©',  'copy;': '©',  'Cscr;': '𝒞',  'cscr;': '𝒸',  'csub;': '⫏',  'csup;': '⫐',  'cups;': '∪︀',  'Darr;': '↡',  'dArr;': '⇓',  'darr;': '↓',  'dash;': '‐',  'dHar;': '⥥',  'diam;': '⋄',  'DJcy;': 'Ђ',  'djcy;': 'ђ',  'Dopf;': '𝔻',  'dopf;': '𝕕',  'Dscr;': '𝒟',  'dscr;': '𝒹',  'DScy;': 'Ѕ',  'dscy;': 'ѕ',  'dsol;': '⧶',  'dtri;': '▿',  'DZcy;': 'Џ',  'dzcy;': 'џ',  'ecir;': '≖',  Ecirc: 'Ê',  ecirc: 'ê',  'Edot;': 'Ė',  'eDot;': '≑',  'edot;': 'ė',  'emsp;': ' ',  'ensp;': ' ',  'Eopf;': '𝔼',  'eopf;': '𝕖',  'epar;': '⋕',  'epsi;': 'ε',  'Escr;': 'ℰ',  'escr;': 'ℯ',  'Esim;': '⩳',  'esim;': '≂',  'Euml;': 'Ë',  'euml;': 'ë',  'euro;': '€',  'excl;': '!',  'flat;': '♭',  'fnof;': 'ƒ',  'Fopf;': '𝔽',  'fopf;': '𝕗',  'fork;': '⋔',  'Fscr;': 'ℱ',  'fscr;': '𝒻',  'Gdot;': 'Ġ',  'gdot;': 'ġ',  'geqq;': '≧',  'gesl;': '⋛︀',  'GJcy;': 'Ѓ',  'gjcy;': 'ѓ',  'gnap;': '⪊',  'gneq;': '⪈',  'Gopf;': '𝔾',  'gopf;': '𝕘',  'Gscr;': '𝒢',  'gscr;': 'ℊ',  'gsim;': '≳',  'gtcc;': '⪧',  'gvnE;': '≩︀',  'half;': '½',  'hArr;': '⇔',  'harr;': '↔',  'hbar;': 'ℏ',  'Hopf;': 'ℍ',  'hopf;': '𝕙',  'Hscr;': 'ℋ',  'hscr;': '𝒽',  Icirc: 'Î',  icirc: 'î',  'Idot;': 'İ',  'IEcy;': 'Е',  'iecy;': 'е',  iexcl: '¡',  'imof;': '⊷',  'IOcy;': 'Ё',  'iocy;': 'ё',  'Iopf;': '𝕀',  'iopf;': '𝕚',  'Iota;': 'Ι',  'iota;': 'ι',  'Iscr;': 'ℐ',  'iscr;': '𝒾',  'isin;': '∈',  'Iuml;': 'Ï',  'iuml;': 'ï',  'Jopf;': '𝕁',  'jopf;': '𝕛',  'Jscr;': '𝒥',  'jscr;': '𝒿',  'KHcy;': 'Х',  'khcy;': 'х',  'KJcy;': 'Ќ',  'kjcy;': 'ќ',  'Kopf;': '𝕂',  'kopf;': '𝕜',  'Kscr;': '𝒦',  'kscr;': '𝓀',  'Lang;': '⟪',  'lang;': '⟨',  laquo: '«',  'Larr;': '↞',  'lArr;': '⇐',  'larr;': '←',  'late;': '⪭',  'lcub;': '{',  'ldca;': '⤶',  'ldsh;': '↲',  'leqq;': '≦',  'lesg;': '⋚︀',  'lHar;': '⥢',  'LJcy;': 'Љ',  'ljcy;': 'љ',  'lnap;': '⪉',  'lneq;': '⪇',  'Lopf;': '𝕃',  'lopf;': '𝕝',  'lozf;': '⧫',  'lpar;': '(',  'Lscr;': 'ℒ',  'lscr;': '𝓁',  'lsim;': '≲',  'lsqb;': '[',  'ltcc;': '⪦',  'ltri;': '◃',  'lvnE;': '≨︀',  'macr;': '¯',  'male;': '♂',  'malt;': '✠',  micro: 'µ',  'mlcp;': '⫛',  'mldr;': '…',  'Mopf;': '𝕄',  'mopf;': '𝕞',  'Mscr;': 'ℳ',  'mscr;': '𝓂',  'nang;': '∠⃒',  'napE;': '⩰̸',  'nbsp;': ' ',  'ncap;': '⩃',  'ncup;': '⩂',  'ngeq;': '≱',  'nges;': '⩾̸',  'ngtr;': '≯',  'nGtv;': '≫̸',  'nisd;': '⋺',  'NJcy;': 'Њ',  'njcy;': 'њ',  'nldr;': '‥',  'nleq;': '≰',  'nles;': '⩽̸',  'nLtv;': '≪̸',  'nmid;': '∤',  'Nopf;': 'ℕ',  'nopf;': '𝕟',  'npar;': '∦',  'npre;': '⪯̸',  'nsce;': '⪰̸',  'Nscr;': '𝒩',  'nscr;': '𝓃',  'nsim;': '≁',  'nsub;': '⊄',  'nsup;': '⊅',  'ntgl;': '≹',  'ntlg;': '≸',  'nvap;': '≍⃒',  'nvge;': '≥⃒',  'nvgt;': '>⃒',  'nvle;': '≤⃒',  'nvlt;': '<⃒',  'oast;': '⊛',  'ocir;': '⊚',  Ocirc: 'Ô',  ocirc: 'ô',  'odiv;': '⨸',  'odot;': '⊙',  'ogon;': '˛',  'oint;': '∮',  'omid;': '⦶',  'Oopf;': '𝕆',  'oopf;': '𝕠',  'opar;': '⦷',  'ordf;': 'ª',  'ordm;': 'º',  'oror;': '⩖',  'Oscr;': '𝒪',  'oscr;': 'ℴ',  'osol;': '⊘',  'Ouml;': 'Ö',  'ouml;': 'ö',  'para;': '¶',  'part;': '∂',  'perp;': '⊥',  'phiv;': 'ϕ',  'plus;': '+',  'Popf;': 'ℙ',  'popf;': '𝕡',  pound: '£',  'prap;': '⪷',  'prec;': '≺',  'prnE;': '⪵',  'prod;': '∏',  'prop;': '∝',  'Pscr;': '𝒫',  'pscr;': '𝓅',  'qint;': '⨌',  'Qopf;': 'ℚ',  'qopf;': '𝕢',  'Qscr;': '𝒬',  'qscr;': '𝓆',  'QUOT;': '"',  'quot;': '"',  'race;': '∽̱',  'Rang;': '⟫',  'rang;': '⟩',  raquo: '»',  'Rarr;': '↠',  'rArr;': '⇒',  'rarr;': '→',  'rcub;': '}',  'rdca;': '⤷',  'rdsh;': '↳',  'real;': 'ℜ',  'rect;': '▭',  'rHar;': '⥤',  'rhov;': 'ϱ',  'ring;': '˚',  'Ropf;': 'ℝ',  'ropf;': '𝕣',  'rpar;': ')',  'Rscr;': 'ℛ',  'rscr;': '𝓇',  'rsqb;': ']',  'rtri;': '▹',  'scap;': '⪸',  'scnE;': '⪶',  'sdot;': '⋅',  'sect;': '§',  'semi;': ';',  'sext;': '✶',  'SHcy;': 'Ш',  'shcy;': 'ш',  'sime;': '≃',  'simg;': '⪞',  'siml;': '⪝',  'smid;': '∣',  'smte;': '⪬',  'solb;': '⧄',  'Sopf;': '𝕊',  'sopf;': '𝕤',  'spar;': '∥',  'Sqrt;': '√',  'squf;': '▪',  'Sscr;': '𝒮',  'sscr;': '𝓈',  'Star;': '⋆',  'star;': '☆',  'subE;': '⫅',  'sube;': '⊆',  'succ;': '≻',  'sung;': '♪',  'sup1;': '¹',  'sup2;': '²',  'sup3;': '³',  'supE;': '⫆',  'supe;': '⊇',  szlig: 'ß',  'tbrk;': '⎴',  'tdot;': '⃛',  THORN: 'Þ',  thorn: 'þ',  times: '×',  'tint;': '∭',  'toea;': '⤨',  'Topf;': '𝕋',  'topf;': '𝕥',  'tosa;': '⤩',  'trie;': '≜',  'Tscr;': '𝒯',  'tscr;': '𝓉',  'TScy;': 'Ц',  'tscy;': 'ц',  'Uarr;': '↟',  'uArr;': '⇑',  'uarr;': '↑',  Ucirc: 'Û',  ucirc: 'û',  'uHar;': '⥣',  'Uopf;': '𝕌',  'uopf;': '𝕦',  'Upsi;': 'ϒ',  'upsi;': 'υ',  'Uscr;': '𝒰',  'uscr;': '𝓊',  'utri;': '▵',  'Uuml;': 'Ü',  'uuml;': 'ü',  'vArr;': '⇕',  'varr;': '↕',  'Vbar;': '⫫',  'vBar;': '⫨',  'Vert;': '‖',  'vert;': '|',  'Vopf;': '𝕍',  'vopf;': '𝕧',  'Vscr;': '𝒱',  'vscr;': '𝓋',  'Wopf;': '𝕎',  'wopf;': '𝕨',  'Wscr;': '𝒲',  'wscr;': '𝓌',  'xcap;': '⋂',  'xcup;': '⋃',  'xmap;': '⟼',  'xnis;': '⋻',  'Xopf;': '𝕏',  'xopf;': '𝕩',  'Xscr;': '𝒳',  'xscr;': '𝓍',  'xvee;': '⋁',  'YAcy;': 'Я',  'yacy;': 'я',  'YIcy;': 'Ї',  'yicy;': 'ї',  'Yopf;': '𝕐',  'yopf;': '𝕪',  'Yscr;': '𝒴',  'yscr;': '𝓎',  'YUcy;': 'Ю',  'yucy;': 'ю',  'Yuml;': 'Ÿ',  'yuml;': 'ÿ',  'Zdot;': 'Ż',  'zdot;': 'ż',  'Zeta;': 'Ζ',  'zeta;': 'ζ',  'ZHcy;': 'Ж',  'zhcy;': 'ж',  'Zopf;': 'ℤ',  'zopf;': '𝕫',  'Zscr;': '𝒵',  'zscr;': '𝓏',  'zwnj;': '‌',  Aacute: 'Á',  aacute: 'á',  'Acirc;': 'Â',  'acirc;': 'â',  'acute;': '´',  'AElig;': 'Æ',  'aelig;': 'æ',  Agrave: 'À',  agrave: 'à',  'aleph;': 'ℵ',  'Alpha;': 'Α',  'alpha;': 'α',  'Amacr;': 'Ā',  'amacr;': 'ā',  'amalg;': '⨿',  'angle;': '∠',  'angrt;': '∟',  'angst;': 'Å',  'Aogon;': 'Ą',  'aogon;': 'ą',  'Aring;': 'Å',  'aring;': 'å',  'asymp;': '≈',  Atilde: 'Ã',  atilde: 'ã',  'awint;': '⨑',  'bcong;': '≌',  'bdquo;': '„',  'bepsi;': '϶',  'blank;': '␣',  'blk12;': '▒',  'blk14;': '░',  'blk34;': '▓',  'block;': '█',  'boxDL;': '╗',  'boxDl;': '╖',  'boxdL;': '╕',  'boxdl;': '┐',  'boxDR;': '╔',  'boxDr;': '╓',  'boxdR;': '╒',  'boxdr;': '┌',  'boxHD;': '╦',  'boxHd;': '╤',  'boxhD;': '╥',  'boxhd;': '┬',  'boxHU;': '╩',  'boxHu;': '╧',  'boxhU;': '╨',  'boxhu;': '┴',  'boxUL;': '╝',  'boxUl;': '╜',  'boxuL;': '╛',  'boxul;': '┘',  'boxUR;': '╚',  'boxUr;': '╙',  'boxuR;': '╘',  'boxur;': '└',  'boxVH;': '╬',  'boxVh;': '╫',  'boxvH;': '╪',  'boxvh;': '┼',  'boxVL;': '╣',  'boxVl;': '╢',  'boxvL;': '╡',  'boxvl;': '┤',  'boxVR;': '╠',  'boxVr;': '╟',  'boxvR;': '╞',  'boxvr;': '├',  'Breve;': '˘',  'breve;': '˘',  brvbar: '¦',  'bsemi;': '⁏',  'bsime;': '⋍',  'bsolb;': '⧅',  'bumpE;': '⪮',  'bumpe;': '≏',  'caret;': '⁁',  'caron;': 'ˇ',  'ccaps;': '⩍',  Ccedil: 'Ç',  ccedil: 'ç',  'Ccirc;': 'Ĉ',  'ccirc;': 'ĉ',  'ccups;': '⩌',  'cedil;': '¸',  'check;': '✓',  'clubs;': '♣',  'Colon;': '∷',  'colon;': ':',  'comma;': ',',  'crarr;': '↵',  'Cross;': '⨯',  'cross;': '✗',  'csube;': '⫑',  'csupe;': '⫒',  'ctdot;': '⋯',  'cuepr;': '⋞',  'cuesc;': '⋟',  'cupor;': '⩅',  curren: '¤',  'cuvee;': '⋎',  'cuwed;': '⋏',  'cwint;': '∱',  'Dashv;': '⫤',  'dashv;': '⊣',  'dblac;': '˝',  'ddarr;': '⇊',  'Delta;': 'Δ',  'delta;': 'δ',  'dharl;': '⇃',  'dharr;': '⇂',  'diams;': '♦',  'disin;': '⋲',  divide: '÷',  'doteq;': '≐',  'dtdot;': '⋱',  'dtrif;': '▾',  'duarr;': '⇵',  'duhar;': '⥯',  Eacute: 'É',  eacute: 'é',  'Ecirc;': 'Ê',  'ecirc;': 'ê',  'eDDot;': '⩷',  'efDot;': '≒',  Egrave: 'È',  egrave: 'è',  'Emacr;': 'Ē',  'emacr;': 'ē',  'empty;': '∅',  'Eogon;': 'Ę',  'eogon;': 'ę',  'eplus;': '⩱',  'epsiv;': 'ϵ',  'eqsim;': '≂',  'Equal;': '⩵',  'equiv;': '≡',  'erarr;': '⥱',  'erDot;': '≓',  'esdot;': '≐',  'exist;': '∃',  'fflig;': 'ﬀ',  'filig;': 'ﬁ',  'fjlig;': 'fj',  'fllig;': 'ﬂ',  'fltns;': '▱',  'forkv;': '⫙',  frac12: '½',  frac14: '¼',  frac34: '¾',  'frasl;': '⁄',  'frown;': '⌢',  'Gamma;': 'Γ',  'gamma;': 'γ',  'Gcirc;': 'Ĝ',  'gcirc;': 'ĝ',  'gescc;': '⪩',  'gimel;': 'ℷ',  'gneqq;': '≩',  'gnsim;': '⋧',  'grave;': '`',  'gsime;': '⪎',  'gsiml;': '⪐',  'gtcir;': '⩺',  'gtdot;': '⋗',  'Hacek;': 'ˇ',  'harrw;': '↭',  'Hcirc;': 'Ĥ',  'hcirc;': 'ĥ',  'hoarr;': '⇿',  Iacute: 'Í',  iacute: 'í',  'Icirc;': 'Î',  'icirc;': 'î',  'iexcl;': '¡',  Igrave: 'Ì',  igrave: 'ì',  'iiint;': '∭',  'iiota;': '℩',  'IJlig;': 'Ĳ',  'ijlig;': 'ĳ',  'Imacr;': 'Ī',  'imacr;': 'ī',  'image;': 'ℑ',  'imath;': 'ı',  'imped;': 'Ƶ',  'infin;': '∞',  'Iogon;': 'Į',  'iogon;': 'į',  'iprod;': '⨼',  iquest: '¿',  'isinE;': '⋹',  'isins;': '⋴',  'isinv;': '∈',  'Iukcy;': 'І',  'iukcy;': 'і',  'Jcirc;': 'Ĵ',  'jcirc;': 'ĵ',  'jmath;': 'ȷ',  'Jukcy;': 'Є',  'jukcy;': 'є',  'Kappa;': 'Κ',  'kappa;': 'κ',  'lAarr;': '⇚',  'langd;': '⦑',  'laquo;': '«',  'larrb;': '⇤',  'lates;': '⪭︀',  'lBarr;': '⤎',  'lbarr;': '⤌',  'lbbrk;': '❲',  'lbrke;': '⦋',  'lceil;': '⌈',  'ldquo;': '“',  'lescc;': '⪨',  'lhard;': '↽',  'lharu;': '↼',  'lhblk;': '▄',  'llarr;': '⇇',  'lltri;': '◺',  'lneqq;': '≨',  'lnsim;': '⋦',  'loang;': '⟬',  'loarr;': '⇽',  'lobrk;': '⟦',  'lopar;': '⦅',  'lrarr;': '⇆',  'lrhar;': '⇋',  'lrtri;': '⊿',  'lsime;': '⪍',  'lsimg;': '⪏',  'lsquo;': '‘',  'ltcir;': '⩹',  'ltdot;': '⋖',  'ltrie;': '⊴',  'ltrif;': '◂',  'mdash;': '—',  'mDDot;': '∺',  'micro;': 'µ',  middot: '·',  'minus;': '−',  'mumap;': '⊸',  'nabla;': '∇',  'napid;': '≋̸',  'napos;': 'ŉ',  'natur;': '♮',  'nbump;': '≎̸',  'ncong;': '≇',  'ndash;': '–',  'neArr;': '⇗',  'nearr;': '↗',  'nedot;': '≐̸',  'nesim;': '≂̸',  'ngeqq;': '≧̸',  'ngsim;': '≵',  'nhArr;': '⇎',  'nharr;': '↮',  'nhpar;': '⫲',  'nlArr;': '⇍',  'nlarr;': '↚',  'nleqq;': '≦̸',  'nless;': '≮',  'nlsim;': '≴',  'nltri;': '⋪',  'notin;': '∉',  'notni;': '∌',  'npart;': '∂̸',  'nprec;': '⊀',  'nrArr;': '⇏',  'nrarr;': '↛',  'nrtri;': '⋫',  'nsime;': '≄',  'nsmid;': '∤',  'nspar;': '∦',  'nsubE;': '⫅̸',  'nsube;': '⊈',  'nsucc;': '⊁',  'nsupE;': '⫆̸',  'nsupe;': '⊉',  Ntilde: 'Ñ',  ntilde: 'ñ',  'numsp;': ' ',  'nvsim;': '∼⃒',  'nwArr;': '⇖',  'nwarr;': '↖',  Oacute: 'Ó',  oacute: 'ó',  'Ocirc;': 'Ô',  'ocirc;': 'ô',  'odash;': '⊝',  'OElig;': 'Œ',  'oelig;': 'œ',  'ofcir;': '⦿',  Ograve: 'Ò',  ograve: 'ò',  'ohbar;': '⦵',  'olarr;': '↺',  'olcir;': '⦾',  'oline;': '‾',  'Omacr;': 'Ō',  'omacr;': 'ō',  'Omega;': 'Ω',  'omega;': 'ω',  'operp;': '⦹',  'oplus;': '⊕',  'orarr;': '↻',  'order;': 'ℴ',  Oslash: 'Ø',  oslash: 'ø',  Otilde: 'Õ',  otilde: 'õ',  'ovbar;': '⌽',  'parsl;': '⫽',  'phone;': '☎',  'plusb;': '⊞',  'pluse;': '⩲',  plusmn: '±',  'pound;': '£',  'prcue;': '≼',  'Prime;': '″',  'prime;': '′',  'prnap;': '⪹',  'prsim;': '≾',  'quest;': '?',  'rAarr;': '⇛',  'radic;': '√',  'rangd;': '⦒',  'range;': '⦥',  'raquo;': '»',  'rarrb;': '⇥',  'rarrc;': '⤳',  'rarrw;': '↝',  'ratio;': '∶',  'RBarr;': '⤐',  'rBarr;': '⤏',  'rbarr;': '⤍',  'rbbrk;': '❳',  'rbrke;': '⦌',  'rceil;': '⌉',  'rdquo;': '”',  'reals;': 'ℝ',  'rhard;': '⇁',  'rharu;': '⇀',  'rlarr;': '⇄',  'rlhar;': '⇌',  'rnmid;': '⫮',  'roang;': '⟭',  'roarr;': '⇾',  'robrk;': '⟧',  'ropar;': '⦆',  'rrarr;': '⇉',  'rsquo;': '’',  'rtrie;': '⊵',  'rtrif;': '▸',  'sbquo;': '‚',  'sccue;': '≽',  'Scirc;': 'Ŝ',  'scirc;': 'ŝ',  'scnap;': '⪺',  'scsim;': '≿',  'sdotb;': '⊡',  'sdote;': '⩦',  'seArr;': '⇘',  'searr;': '↘',  'setmn;': '∖',  'sharp;': '♯',  'Sigma;': 'Σ',  'sigma;': 'σ',  'simeq;': '≃',  'simgE;': '⪠',  'simlE;': '⪟',  'simne;': '≆',  'slarr;': '←',  'smile;': '⌣',  'smtes;': '⪬︀',  'sqcap;': '⊓',  'sqcup;': '⊔',  'sqsub;': '⊏',  'sqsup;': '⊐',  'srarr;': '→',  'starf;': '★',  'strns;': '¯',  'subnE;': '⫋',  'subne;': '⊊',  'supnE;': '⫌',  'supne;': '⊋',  'swArr;': '⇙',  'swarr;': '↙',  'szlig;': 'ß',  'Theta;': 'Θ',  'theta;': 'θ',  'thkap;': '≈',  'THORN;': 'Þ',  'thorn;': 'þ',  'Tilde;': '∼',  'tilde;': '˜',  'times;': '×',  'TRADE;': '™',  'trade;': '™',  'trisb;': '⧍',  'TSHcy;': 'Ћ',  'tshcy;': 'ћ',  'twixt;': '≬',  Uacute: 'Ú',  uacute: 'ú',  'Ubrcy;': 'Ў',  'ubrcy;': 'ў',  'Ucirc;': 'Û',  'ucirc;': 'û',  'udarr;': '⇅',  'udhar;': '⥮',  Ugrave: 'Ù',  ugrave: 'ù',  'uharl;': '↿',  'uharr;': '↾',  'uhblk;': '▀',  'ultri;': '◸',  'Umacr;': 'Ū',  'umacr;': 'ū',  'Union;': '⋃',  'Uogon;': 'Ų',  'uogon;': 'ų',  'uplus;': '⊎',  'upsih;': 'ϒ',  'UpTee;': '⊥',  'Uring;': 'Ů',  'uring;': 'ů',  'urtri;': '◹',  'utdot;': '⋰',  'utrif;': '▴',  'uuarr;': '⇈',  'varpi;': 'ϖ',  'vBarv;': '⫩',  'VDash;': '⊫',  'Vdash;': '⊩',  'vDash;': '⊨',  'vdash;': '⊢',  'veeeq;': '≚',  'vltri;': '⊲',  'vnsub;': '⊂⃒',  'vnsup;': '⊃⃒',  'vprop;': '∝',  'vrtri;': '⊳',  'Wcirc;': 'Ŵ',  'wcirc;': 'ŵ',  'Wedge;': '⋀',  'wedge;': '∧',  'xcirc;': '◯',  'xdtri;': '▽',  'xhArr;': '⟺',  'xharr;': '⟷',  'xlArr;': '⟸',  'xlarr;': '⟵',  'xodot;': '⨀',  'xrArr;': '⟹',  'xrarr;': '⟶',  'xutri;': '△',  Yacute: 'Ý',  yacute: 'ý',  'Ycirc;': 'Ŷ',  'ycirc;': 'ŷ',  'Aacute;': 'Á',  'aacute;': 'á',  'Abreve;': 'Ă',  'abreve;': 'ă',  'Agrave;': 'À',  'agrave;': 'à',  'andand;': '⩕',  'angmsd;': '∡',  'angsph;': '∢',  'apacir;': '⩯',  'approx;': '≈',  'Assign;': '≔',  'Atilde;': 'Ã',  'atilde;': 'ã',  'barvee;': '⊽',  'Barwed;': '⌆',  'barwed;': '⌅',  'becaus;': '∵',  'bernou;': 'ℬ',  'bigcap;': '⋂',  'bigcup;': '⋃',  'bigvee;': '⋁',  'bkarow;': '⤍',  'bottom;': '⊥',  'bowtie;': '⋈',  'boxbox;': '⧉',  'bprime;': '‵',  'brvbar;': '¦',  'bullet;': '•',  'Bumpeq;': '≎',  'bumpeq;': '≏',  'Cacute;': 'Ć',  'cacute;': 'ć',  'capand;': '⩄',  'capcap;': '⩋',  'capcup;': '⩇',  'capdot;': '⩀',  'Ccaron;': 'Č',  'ccaron;': 'č',  'Ccedil;': 'Ç',  'ccedil;': 'ç',  'circeq;': '≗',  'cirmid;': '⫯',  'Colone;': '⩴',  'colone;': '≔',  'commat;': '@',  'compfn;': '∘',  'Conint;': '∯',  'conint;': '∮',  'coprod;': '∐',  'copysr;': '℗',  'cularr;': '↶',  'CupCap;': '≍',  'cupcap;': '⩆',  'cupcup;': '⩊',  'cupdot;': '⊍',  'curarr;': '↷',  'curren;': '¤',  'cylcty;': '⌭',  'Dagger;': '‡',  'dagger;': '†',  'daleth;': 'ℸ',  'Dcaron;': 'Ď',  'dcaron;': 'ď',  'dfisht;': '⥿',  'divide;': '÷',  'divonx;': '⋇',  'dlcorn;': '⌞',  'dlcrop;': '⌍',  'dollar;': '$',  'DotDot;': '⃜',  'drcorn;': '⌟',  'drcrop;': '⌌',  'Dstrok;': 'Đ',  'dstrok;': 'đ',  'Eacute;': 'É',  'eacute;': 'é',  'easter;': '⩮',  'Ecaron;': 'Ě',  'ecaron;': 'ě',  'ecolon;': '≕',  'Egrave;': 'È',  'egrave;': 'è',  'egsdot;': '⪘',  'elsdot;': '⪗',  'emptyv;': '∅',  'emsp13;': ' ',  'emsp14;': ' ',  'eparsl;': '⧣',  'eqcirc;': '≖',  'equals;': '=',  'equest;': '≟',  'Exists;': '∃',  'female;': '♀',  'ffilig;': 'ﬃ',  'ffllig;': 'ﬄ',  'ForAll;': '∀',  'forall;': '∀',  'frac12;': '½',  'frac13;': '⅓',  'frac14;': '¼',  'frac15;': '⅕',  'frac16;': '⅙',  'frac18;': '⅛',  'frac23;': '⅔',  'frac25;': '⅖',  'frac34;': '¾',  'frac35;': '⅗',  'frac38;': '⅜',  'frac45;': '⅘',  'frac56;': '⅚',  'frac58;': '⅝',  'frac78;': '⅞',  'gacute;': 'ǵ',  'Gammad;': 'Ϝ',  'gammad;': 'ϝ',  'Gbreve;': 'Ğ',  'gbreve;': 'ğ',  'Gcedil;': 'Ģ',  'gesdot;': '⪀',  'gesles;': '⪔',  'gtlPar;': '⦕',  'gtrarr;': '⥸',  'gtrdot;': '⋗',  'gtrsim;': '≳',  'hairsp;': ' ',  'hamilt;': 'ℋ',  'HARDcy;': 'Ъ',  'hardcy;': 'ъ',  'hearts;': '♥',  'hellip;': '…',  'hercon;': '⊹',  'homtht;': '∻',  'horbar;': '―',  'hslash;': 'ℏ',  'Hstrok;': 'Ħ',  'hstrok;': 'ħ',  'hybull;': '⁃',  'hyphen;': '‐',  'Iacute;': 'Í',  'iacute;': 'í',  'Igrave;': 'Ì',  'igrave;': 'ì',  'iiiint;': '⨌',  'iinfin;': '⧜',  'incare;': '℅',  'inodot;': 'ı',  'intcal;': '⊺',  'iquest;': '¿',  'isinsv;': '⋳',  'Itilde;': 'Ĩ',  'itilde;': 'ĩ',  'Jsercy;': 'Ј',  'jsercy;': 'ј',  'kappav;': 'ϰ',  'Kcedil;': 'Ķ',  'kcedil;': 'ķ',  'kgreen;': 'ĸ',  'Lacute;': 'Ĺ',  'lacute;': 'ĺ',  'lagran;': 'ℒ',  'Lambda;': 'Λ',  'lambda;': 'λ',  'langle;': '⟨',  'larrfs;': '⤝',  'larrhk;': '↩',  'larrlp;': '↫',  'larrpl;': '⤹',  'larrtl;': '↢',  'lAtail;': '⤛',  'latail;': '⤙',  'lbrace;': '{',  'lbrack;': '[',  'Lcaron;': 'Ľ',  'lcaron;': 'ľ',  'Lcedil;': 'Ļ',  'lcedil;': 'ļ',  'ldquor;': '„',  'lesdot;': '⩿',  'lesges;': '⪓',  'lfisht;': '⥼',  'lfloor;': '⌊',  'lharul;': '⥪',  'llhard;': '⥫',  'Lmidot;': 'Ŀ',  'lmidot;': 'ŀ',  'lmoust;': '⎰',  'loplus;': '⨭',  'lowast;': '∗',  'lowbar;': '_',  'lparlt;': '⦓',  'lrhard;': '⥭',  'lsaquo;': '‹',  'lsquor;': '‚',  'Lstrok;': 'Ł',  'lstrok;': 'ł',  'lthree;': '⋋',  'ltimes;': '⋉',  'ltlarr;': '⥶',  'ltrPar;': '⦖',  'mapsto;': '↦',  'marker;': '▮',  'mcomma;': '⨩',  'midast;': '*',  'midcir;': '⫰',  'middot;': '·',  'minusb;': '⊟',  'minusd;': '∸',  'mnplus;': '∓',  'models;': '⊧',  'mstpos;': '∾',  'Nacute;': 'Ń',  'nacute;': 'ń',  'nbumpe;': '≏̸',  'Ncaron;': 'Ň',  'ncaron;': 'ň',  'Ncedil;': 'Ņ',  'ncedil;': 'ņ',  'nearhk;': '⤤',  'nequiv;': '≢',  'nesear;': '⤨',  'nexist;': '∄',  'nltrie;': '⋬',  'notinE;': '⋹̸',  'nparsl;': '⫽⃥',  'nprcue;': '⋠',  'nrarrc;': '⤳̸',  'nrarrw;': '↝̸',  'nrtrie;': '⋭',  'nsccue;': '⋡',  'nsimeq;': '≄',  'Ntilde;': 'Ñ',  'ntilde;': 'ñ',  'numero;': '№',  'nVDash;': '⊯',  'nVdash;': '⊮',  'nvDash;': '⊭',  'nvdash;': '⊬',  'nvHarr;': '⤄',  'nvlArr;': '⤂',  'nvrArr;': '⤃',  'nwarhk;': '⤣',  'nwnear;': '⤧',  'Oacute;': 'Ó',  'oacute;': 'ó',  'Odblac;': 'Ő',  'odblac;': 'ő',  'odsold;': '⦼',  'Ograve;': 'Ò',  'ograve;': 'ò',  'ominus;': '⊖',  'origof;': '⊶',  'Oslash;': 'Ø',  'oslash;': 'ø',  'Otilde;': 'Õ',  'otilde;': 'õ',  'Otimes;': '⨷',  'otimes;': '⊗',  'parsim;': '⫳',  'percnt;': '%',  'period;': '.',  'permil;': '‰',  'phmmat;': 'ℳ',  'planck;': 'ℏ',  'plankv;': 'ℏ',  'plusdo;': '∔',  'plusdu;': '⨥',  'plusmn;': '±',  'preceq;': '⪯',  'primes;': 'ℙ',  'prnsim;': '⋨',  'propto;': '∝',  'prurel;': '⊰',  'puncsp;': ' ',  'qprime;': '⁗',  'Racute;': 'Ŕ',  'racute;': 'ŕ',  'rangle;': '⟩',  'rarrap;': '⥵',  'rarrfs;': '⤞',  'rarrhk;': '↪',  'rarrlp;': '↬',  'rarrpl;': '⥅',  'Rarrtl;': '⤖',  'rarrtl;': '↣',  'rAtail;': '⤜',  'ratail;': '⤚',  'rbrace;': '}',  'rbrack;': ']',  'Rcaron;': 'Ř',  'rcaron;': 'ř',  'Rcedil;': 'Ŗ',  'rcedil;': 'ŗ',  'rdquor;': '”',  'rfisht;': '⥽',  'rfloor;': '⌋',  'rharul;': '⥬',  'rmoust;': '⎱',  'roplus;': '⨮',  'rpargt;': '⦔',  'rsaquo;': '›',  'rsquor;': '’',  'rthree;': '⋌',  'rtimes;': '⋊',  'Sacute;': 'Ś',  'sacute;': 'ś',  'Scaron;': 'Š',  'scaron;': 'š',  'Scedil;': 'Ş',  'scedil;': 'ş',  'scnsim;': '⋩',  'searhk;': '⤥',  'seswar;': '⤩',  'sfrown;': '⌢',  'SHCHcy;': 'Щ',  'shchcy;': 'щ',  'sigmaf;': 'ς',  'sigmav;': 'ς',  'simdot;': '⩪',  'smashp;': '⨳',  'SOFTcy;': 'Ь',  'softcy;': 'ь',  'solbar;': '⌿',  'spades;': '♠',  'sqcaps;': '⊓︀',  'sqcups;': '⊔︀',  'sqsube;': '⊑',  'sqsupe;': '⊒',  'Square;': '□',  'square;': '□',  'squarf;': '▪',  'ssetmn;': '∖',  'ssmile;': '⌣',  'sstarf;': '⋆',  'subdot;': '⪽',  'Subset;': '⋐',  'subset;': '⊂',  'subsim;': '⫇',  'subsub;': '⫕',  'subsup;': '⫓',  'succeq;': '⪰',  'supdot;': '⪾',  'Supset;': '⋑',  'supset;': '⊃',  'supsim;': '⫈',  'supsub;': '⫔',  'supsup;': '⫖',  'swarhk;': '⤦',  'swnwar;': '⤪',  'target;': '⌖',  'Tcaron;': 'Ť',  'tcaron;': 'ť',  'Tcedil;': 'Ţ',  'tcedil;': 'ţ',  'telrec;': '⌕',  'there4;': '∴',  'thetav;': 'ϑ',  'thinsp;': ' ',  'thksim;': '∼',  'timesb;': '⊠',  'timesd;': '⨰',  'topbot;': '⌶',  'topcir;': '⫱',  'tprime;': '‴',  'tridot;': '◬',  'Tstrok;': 'Ŧ',  'tstrok;': 'ŧ',  'Uacute;': 'Ú',  'uacute;': 'ú',  'Ubreve;': 'Ŭ',  'ubreve;': 'ŭ',  'Udblac;': 'Ű',  'udblac;': 'ű',  'ufisht;': '⥾',  'Ugrave;': 'Ù',  'ugrave;': 'ù',  'ulcorn;': '⌜',  'ulcrop;': '⌏',  'urcorn;': '⌝',  'urcrop;': '⌎',  'Utilde;': 'Ũ',  'utilde;': 'ũ',  'vangrt;': '⦜',  'varphi;': 'ϕ',  'varrho;': 'ϱ',  'Vdashl;': '⫦',  'veebar;': '⊻',  'vellip;': '⋮',  'Verbar;': '‖',  'verbar;': '|',  'vsubnE;': '⫋︀',  'vsubne;': '⊊︀',  'vsupnE;': '⫌︀',  'vsupne;': '⊋︀',  'Vvdash;': '⊪',  'wedbar;': '⩟',  'wedgeq;': '≙',  'weierp;': '℘',  'wreath;': '≀',  'xoplus;': '⨁',  'xotime;': '⨂',  'xsqcup;': '⨆',  'xuplus;': '⨄',  'xwedge;': '⋀',  'Yacute;': 'Ý',  'yacute;': 'ý',  'Zacute;': 'Ź',  'zacute;': 'ź',  'Zcaron;': 'Ž',  'zcaron;': 'ž',  'zeetrf;': 'ℨ',  'alefsym;': 'ℵ',  'angrtvb;': '⊾',  'angzarr;': '⍼',  'asympeq;': '≍',  'backsim;': '∽',  'Because;': '∵',  'because;': '∵',  'bemptyv;': '⦰',  'between;': '≬',  'bigcirc;': '◯',  'bigodot;': '⨀',  'bigstar;': '★',  'bnequiv;': '≡⃥',  'boxplus;': '⊞',  'Cayleys;': 'ℭ',  'Cconint;': '∰',  'ccupssm;': '⩐',  'Cedilla;': '¸',  'cemptyv;': '⦲',  'cirscir;': '⧂',  'coloneq;': '≔',  'congdot;': '⩭',  'cudarrl;': '⤸',  'cudarrr;': '⤵',  'cularrp;': '⤽',  'curarrm;': '⤼',  'dbkarow;': '⤏',  'ddagger;': '‡',  'ddotseq;': '⩷',  'demptyv;': '⦱',  'Diamond;': '⋄',  'diamond;': '⋄',  'digamma;': 'ϝ',  'dotplus;': '∔',  'DownTee;': '⊤',  'dwangle;': '⦦',  'Element;': '∈',  'Epsilon;': 'Ε',  'epsilon;': 'ε',  'eqcolon;': '≕',  'equivDD;': '⩸',  'gesdoto;': '⪂',  'gtquest;': '⩼',  'gtrless;': '≷',  'harrcir;': '⥈',  'Implies;': '⇒',  'intprod;': '⨼',  'isindot;': '⋵',  'larrbfs;': '⤟',  'larrsim;': '⥳',  'lbrksld;': '⦏',  'lbrkslu;': '⦍',  'ldrdhar;': '⥧',  'LeftTee;': '⊣',  'lesdoto;': '⪁',  'lessdot;': '⋖',  'lessgtr;': '≶',  'lesssim;': '≲',  'lotimes;': '⨴',  'lozenge;': '◊',  'ltquest;': '⩻',  'luruhar;': '⥦',  'maltese;': '✠',  'minusdu;': '⨪',  'napprox;': '≉',  'natural;': '♮',  'nearrow;': '↗',  'NewLine;': '\n',  'nexists;': '∄',  'NoBreak;': '⁠',  'notinva;': '∉',  'notinvb;': '⋷',  'notinvc;': '⋶',  'NotLess;': '≮',  'notniva;': '∌',  'notnivb;': '⋾',  'notnivc;': '⋽',  'npolint;': '⨔',  'npreceq;': '⪯̸',  'nsqsube;': '⋢',  'nsqsupe;': '⋣',  'nsubset;': '⊂⃒',  'nsucceq;': '⪰̸',  'nsupset;': '⊃⃒',  'nvinfin;': '⧞',  'nvltrie;': '⊴⃒',  'nvrtrie;': '⊵⃒',  'nwarrow;': '↖',  'olcross;': '⦻',  'Omicron;': 'Ο',  'omicron;': 'ο',  'orderof;': 'ℴ',  'orslope;': '⩗',  'OverBar;': '‾',  'pertenk;': '‱',  'planckh;': 'ℎ',  'pluscir;': '⨢',  'plussim;': '⨦',  'plustwo;': '⨧',  'precsim;': '≾',  'Product;': '∏',  'quatint;': '⨖',  'questeq;': '≟',  'rarrbfs;': '⤠',  'rarrsim;': '⥴',  'rbrksld;': '⦎',  'rbrkslu;': '⦐',  'rdldhar;': '⥩',  'realine;': 'ℛ',  'rotimes;': '⨵',  'ruluhar;': '⥨',  'searrow;': '↘',  'simplus;': '⨤',  'simrarr;': '⥲',  'subedot;': '⫃',  'submult;': '⫁',  'subplus;': '⪿',  'subrarr;': '⥹',  'succsim;': '≿',  'supdsub;': '⫘',  'supedot;': '⫄',  'suphsol;': '⟉',  'suphsub;': '⫗',  'suplarr;': '⥻',  'supmult;': '⫂',  'supplus;': '⫀',  'swarrow;': '↙',  'topfork;': '⫚',  'triplus;': '⨹',  'tritime;': '⨻',  'UpArrow;': '↑',  'Uparrow;': '⇑',  'uparrow;': '↑',  'Upsilon;': 'Υ',  'upsilon;': 'υ',  'uwangle;': '⦧',  'vzigzag;': '⦚',  'zigrarr;': '⇝',  'andslope;': '⩘',  'angmsdaa;': '⦨',  'angmsdab;': '⦩',  'angmsdac;': '⦪',  'angmsdad;': '⦫',  'angmsdae;': '⦬',  'angmsdaf;': '⦭',  'angmsdag;': '⦮',  'angmsdah;': '⦯',  'angrtvbd;': '⦝',  'approxeq;': '≊',  'awconint;': '∳',  'backcong;': '≌',  'barwedge;': '⌅',  'bbrktbrk;': '⎶',  'bigoplus;': '⨁',  'bigsqcup;': '⨆',  'biguplus;': '⨄',  'bigwedge;': '⋀',  'boxminus;': '⊟',  'boxtimes;': '⊠',  'bsolhsub;': '⟈',  'capbrcup;': '⩉',  'circledR;': '®',  'circledS;': 'Ⓢ',  'cirfnint;': '⨐',  'clubsuit;': '♣',  'cupbrcap;': '⩈',  'curlyvee;': '⋎',  'cwconint;': '∲',  'DDotrahd;': '⤑',  'doteqdot;': '≑',  'DotEqual;': '≐',  'dotminus;': '∸',  'drbkarow;': '⤐',  'dzigrarr;': '⟿',  'elinters;': '⏧',  'emptyset;': '∅',  'eqvparsl;': '⧥',  'fpartint;': '⨍',  'geqslant;': '⩾',  'gesdotol;': '⪄',  'gnapprox;': '⪊',  'hksearow;': '⤥',  'hkswarow;': '⤦',  'imagline;': 'ℐ',  'imagpart;': 'ℑ',  'infintie;': '⧝',  'integers;': 'ℤ',  'Integral;': '∫',  'intercal;': '⊺',  'intlarhk;': '⨗',  'laemptyv;': '⦴',  'ldrushar;': '⥋',  'leqslant;': '⩽',  'lesdotor;': '⪃',  'LessLess;': '⪡',  'llcorner;': '⌞',  'lnapprox;': '⪉',  'lrcorner;': '⌟',  'lurdshar;': '⥊',  'mapstoup;': '↥',  'multimap;': '⊸',  'naturals;': 'ℕ',  'ncongdot;': '⩭̸',  'NotEqual;': '≠',  'notindot;': '⋵̸',  'NotTilde;': '≁',  'otimesas;': '⨶',  'parallel;': '∥',  'PartialD;': '∂',  'plusacir;': '⨣',  'pointint;': '⨕',  'Precedes;': '≺',  'precneqq;': '⪵',  'precnsim;': '⋨',  'profalar;': '⌮',  'profline;': '⌒',  'profsurf;': '⌓',  'raemptyv;': '⦳',  'realpart;': 'ℜ',  'RightTee;': '⊢',  'rppolint;': '⨒',  'rtriltri;': '⧎',  'scpolint;': '⨓',  'setminus;': '∖',  'shortmid;': '∣',  'smeparsl;': '⧤',  'sqsubset;': '⊏',  'sqsupset;': '⊐',  'subseteq;': '⊆',  'Succeeds;': '≻',  'succneqq;': '⪶',  'succnsim;': '⋩',  'SuchThat;': '∋',  'Superset;': '⊃',  'supseteq;': '⊇',  'thetasym;': 'ϑ',  'thicksim;': '∼',  'timesbar;': '⨱',  'triangle;': '▵',  'triminus;': '⨺',  'trpezium;': '⏢',  'Uarrocir;': '⥉',  'ulcorner;': '⌜',  'UnderBar;': '_',  'urcorner;': '⌝',  'varkappa;': 'ϰ',  'varsigma;': 'ς',  'vartheta;': 'ϑ',  'backprime;': '‵',  'backsimeq;': '⋍',  'Backslash;': '∖',  'bigotimes;': '⨂',  'CenterDot;': '·',  'centerdot;': '·',  'checkmark;': '✓',  'CircleDot;': '⊙',  'complexes;': 'ℂ',  'Congruent;': '≡',  'Coproduct;': '∐',  'dotsquare;': '⊡',  'DoubleDot;': '¨',  'DownArrow;': '↓',  'Downarrow;': '⇓',  'downarrow;': '↓',  'DownBreve;': '̑',  'gtrapprox;': '⪆',  'gtreqless;': '⋛',  'gvertneqq;': '≩︀',  'heartsuit;': '♥',  'HumpEqual;': '≏',  'LeftArrow;': '←',  'Leftarrow;': '⇐',  'leftarrow;': '←',  'LeftFloor;': '⌊',  'lesseqgtr;': '⋚',  'LessTilde;': '≲',  'lvertneqq;': '≨︀',  'Mellintrf;': 'ℳ',  'MinusPlus;': '∓',  'ngeqslant;': '⩾̸',  'nleqslant;': '⩽̸',  'NotCupCap;': '≭',  'NotExists;': '∄',  'NotSubset;': '⊂⃒',  'nparallel;': '∦',  'nshortmid;': '∤',  'nsubseteq;': '⊈',  'nsupseteq;': '⊉',  'OverBrace;': '⏞',  'pitchfork;': '⋔',  'PlusMinus;': '±',  'rationals;': 'ℚ',  'spadesuit;': '♠',  'subseteqq;': '⫅',  'subsetneq;': '⊊',  'supseteqq;': '⫆',  'supsetneq;': '⊋',  'Therefore;': '∴',  'therefore;': '∴',  'ThinSpace;': ' ',  'triangleq;': '≜',  'TripleDot;': '⃛',  'UnionPlus;': '⊎',  'varpropto;': '∝',  'Bernoullis;': 'ℬ',  'circledast;': '⊛',  'CirclePlus;': '⊕',  'complement;': '∁',  'curlywedge;': '⋏',  'eqslantgtr;': '⪖',  'EqualTilde;': '≂',  'Fouriertrf;': 'ℱ',  'gtreqqless;': '⪌',  'ImaginaryI;': 'ⅈ',  'Laplacetrf;': 'ℒ',  'LeftVector;': '↼',  'lessapprox;': '⪅',  'lesseqqgtr;': '⪋',  'Lleftarrow;': '⇚',  'lmoustache;': '⎰',  'longmapsto;': '⟼',  'mapstodown;': '↧',  'mapstoleft;': '↤',  'nLeftarrow;': '⇍',  'nleftarrow;': '↚',  'NotElement;': '∉',  'NotGreater;': '≯',  'nsubseteqq;': '⫅̸',  'nsupseteqq;': '⫆̸',  'precapprox;': '⪷',  'Proportion;': '∷',  'RightArrow;': '→',  'Rightarrow;': '⇒',  'rightarrow;': '→',  'RightFloor;': '⌋',  'rmoustache;': '⎱',  'sqsubseteq;': '⊑',  'sqsupseteq;': '⊒',  'subsetneqq;': '⫋',  'succapprox;': '⪸',  'supsetneqq;': '⫌',  'ThickSpace;': '  ',  'TildeEqual;': '≃',  'TildeTilde;': '≈',  'UnderBrace;': '⏟',  'UpArrowBar;': '⤒',  'UpTeeArrow;': '↥',  'upuparrows;': '⇈',  'varepsilon;': 'ϵ',  'varnothing;': '∅',  'backepsilon;': '϶',  'blacksquare;': '▪',  'circledcirc;': '⊚',  'circleddash;': '⊝',  'CircleMinus;': '⊖',  'CircleTimes;': '⊗',  'curlyeqprec;': '⋞',  'curlyeqsucc;': '⋟',  'diamondsuit;': '♦',  'eqslantless;': '⪕',  'Equilibrium;': '⇌',  'expectation;': 'ℰ',  'GreaterLess;': '≷',  'LeftCeiling;': '⌈',  'LessGreater;': '≶',  'MediumSpace;': ' ',  'NotLessLess;': '≪̸',  'NotPrecedes;': '⊀',  'NotSucceeds;': '⊁',  'NotSuperset;': '⊃⃒',  'nRightarrow;': '⇏',  'nrightarrow;': '↛',  'OverBracket;': '⎴',  'preccurlyeq;': '≼',  'precnapprox;': '⪹',  'quaternions;': 'ℍ',  'RightVector;': '⇀',  'Rrightarrow;': '⇛',  'RuleDelayed;': '⧴',  'SmallCircle;': '∘',  'SquareUnion;': '⊔',  'straightphi;': 'ϕ',  'SubsetEqual;': '⊆',  'succcurlyeq;': '≽',  'succnapprox;': '⪺',  'thickapprox;': '≈',  'UpDownArrow;': '↕',  'Updownarrow;': '⇕',  'updownarrow;': '↕',  'VerticalBar;': '∣',  'blacklozenge;': '⧫',  'DownArrowBar;': '⤓',  'DownTeeArrow;': '↧',  'ExponentialE;': 'ⅇ',  'exponentiale;': 'ⅇ',  'GreaterEqual;': '≥',  'GreaterTilde;': '≳',  'HilbertSpace;': 'ℋ',  'HumpDownHump;': '≎',  'Intersection;': '⋂',  'LeftArrowBar;': '⇤',  'LeftTeeArrow;': '↤',  'LeftTriangle;': '⊲',  'LeftUpVector;': '↿',  'NotCongruent;': '≢',  'NotHumpEqual;': '≏̸',  'NotLessEqual;': '≰',  'NotLessTilde;': '≴',  'Proportional;': '∝',  'RightCeiling;': '⌉',  'risingdotseq;': '≓',  'RoundImplies;': '⥰',  'ShortUpArrow;': '↑',  'SquareSubset;': '⊏',  'triangledown;': '▿',  'triangleleft;': '◃',  'UnderBracket;': '⎵',  'varsubsetneq;': '⊊︀',  'varsupsetneq;': '⊋︀',  'VerticalLine;': '|',  'ApplyFunction;': '⁡',  'bigtriangleup;': '△',  'blacktriangle;': '▴',  'DifferentialD;': 'ⅆ',  'divideontimes;': '⋇',  'DoubleLeftTee;': '⫤',  'DoubleUpArrow;': '⇑',  'fallingdotseq;': '≒',  'hookleftarrow;': '↩',  'leftarrowtail;': '↢',  'leftharpoonup;': '↼',  'LeftTeeVector;': '⥚',  'LeftVectorBar;': '⥒',  'LessFullEqual;': '≦',  'LongLeftArrow;': '⟵',  'Longleftarrow;': '⟸',  'longleftarrow;': '⟵',  'looparrowleft;': '↫',  'measuredangle;': '∡',  'NotEqualTilde;': '≂̸',  'NotTildeEqual;': '≄',  'NotTildeTilde;': '≉',  'ntriangleleft;': '⋪',  'Poincareplane;': 'ℌ',  'PrecedesEqual;': '⪯',  'PrecedesTilde;': '≾',  'RightArrowBar;': '⇥',  'RightTeeArrow;': '↦',  'RightTriangle;': '⊳',  'RightUpVector;': '↾',  'shortparallel;': '∥',  'smallsetminus;': '∖',  'SucceedsEqual;': '⪰',  'SucceedsTilde;': '≿',  'SupersetEqual;': '⊇',  'triangleright;': '▹',  'UpEquilibrium;': '⥮',  'upharpoonleft;': '↿',  'varsubsetneqq;': '⫋︀',  'varsupsetneqq;': '⫌︀',  'VerticalTilde;': '≀',  'VeryThinSpace;': ' ',  'curvearrowleft;': '↶',  'DiacriticalDot;': '˙',  'doublebarwedge;': '⌆',  'DoubleRightTee;': '⊨',  'downdownarrows;': '⇊',  'DownLeftVector;': '↽',  'GreaterGreater;': '⪢',  'hookrightarrow;': '↪',  'HorizontalLine;': '─',  'InvisibleComma;': '⁣',  'InvisibleTimes;': '⁢',  'LeftDownVector;': '⇃',  'leftleftarrows;': '⇇',  'LeftRightArrow;': '↔',  'Leftrightarrow;': '⇔',  'leftrightarrow;': '↔',  'leftthreetimes;': '⋋',  'LessSlantEqual;': '⩽',  'LongRightArrow;': '⟶',  'Longrightarrow;': '⟹',  'longrightarrow;': '⟶',  'looparrowright;': '↬',  'LowerLeftArrow;': '↙',  'NestedLessLess;': '≪',  'NotGreaterLess;': '≹',  'NotLessGreater;': '≸',  'NotSubsetEqual;': '⊈',  'NotVerticalBar;': '∤',  'nshortparallel;': '∦',  'ntriangleright;': '⋫',  'OpenCurlyQuote;': '‘',  'ReverseElement;': '∋',  'rightarrowtail;': '↣',  'rightharpoonup;': '⇀',  'RightTeeVector;': '⥛',  'RightVectorBar;': '⥓',  'ShortDownArrow;': '↓',  'ShortLeftArrow;': '←',  'SquareSuperset;': '⊐',  'TildeFullEqual;': '≅',  'trianglelefteq;': '⊴',  'upharpoonright;': '↾',  'UpperLeftArrow;': '↖',  'ZeroWidthSpace;': '​',  'bigtriangledown;': '▽',  'circlearrowleft;': '↺',  'CloseCurlyQuote;': '’',  'ContourIntegral;': '∮',  'curvearrowright;': '↷',  'DoubleDownArrow;': '⇓',  'DoubleLeftArrow;': '⇐',  'downharpoonleft;': '⇃',  'DownRightVector;': '⇁',  'leftharpoondown;': '↽',  'leftrightarrows;': '⇆',  'LeftRightVector;': '⥎',  'LeftTriangleBar;': '⧏',  'LeftUpTeeVector;': '⥠',  'LeftUpVectorBar;': '⥘',  'LowerRightArrow;': '↘',  'nLeftrightarrow;': '⇎',  'nleftrightarrow;': '↮',  'NotGreaterEqual;': '≱',  'NotGreaterTilde;': '≵',  'NotHumpDownHump;': '≎̸',  'NotLeftTriangle;': '⋪',  'NotSquareSubset;': '⊏̸',  'ntrianglelefteq;': '⋬',  'OverParenthesis;': '⏜',  'RightDownVector;': '⇂',  'rightleftarrows;': '⇄',  'rightsquigarrow;': '↝',  'rightthreetimes;': '⋌',  'ShortRightArrow;': '→',  'straightepsilon;': 'ϵ',  'trianglerighteq;': '⊵',  'UpperRightArrow;': '↗',  'vartriangleleft;': '⊲',  'circlearrowright;': '↻',  'DiacriticalAcute;': '´',  'DiacriticalGrave;': '`',  'DiacriticalTilde;': '˜',  'DoubleRightArrow;': '⇒',  'DownArrowUpArrow;': '⇵',  'downharpoonright;': '⇂',  'EmptySmallSquare;': '◻',  'GreaterEqualLess;': '⋛',  'GreaterFullEqual;': '≧',  'LeftAngleBracket;': '⟨',  'LeftUpDownVector;': '⥑',  'LessEqualGreater;': '⋚',  'NonBreakingSpace;': ' ',  'NotPrecedesEqual;': '⪯̸',  'NotRightTriangle;': '⋫',  'NotSucceedsEqual;': '⪰̸',  'NotSucceedsTilde;': '≿̸',  'NotSupersetEqual;': '⊉',  'ntrianglerighteq;': '⋭',  'rightharpoondown;': '⇁',  'rightrightarrows;': '⇉',  'RightTriangleBar;': '⧐',  'RightUpTeeVector;': '⥜',  'RightUpVectorBar;': '⥔',  'twoheadleftarrow;': '↞',  'UnderParenthesis;': '⏝',  'UpArrowDownArrow;': '⇅',  'vartriangleright;': '⊳',  'blacktriangledown;': '▾',  'blacktriangleleft;': '◂',  'DoubleUpDownArrow;': '⇕',  'DoubleVerticalBar;': '∥',  'DownLeftTeeVector;': '⥞',  'DownLeftVectorBar;': '⥖',  'FilledSmallSquare;': '◼',  'GreaterSlantEqual;': '⩾',  'LeftDoubleBracket;': '⟦',  'LeftDownTeeVector;': '⥡',  'LeftDownVectorBar;': '⥙',  'leftrightharpoons;': '⇋',  'LeftTriangleEqual;': '⊴',  'NegativeThinSpace;': '​',  'NotGreaterGreater;': '≫̸',  'NotLessSlantEqual;': '⩽̸',  'NotNestedLessLess;': '⪡̸',  'NotReverseElement;': '∌',  'NotSquareSuperset;': '⊐̸',  'NotTildeFullEqual;': '≇',  'RightAngleBracket;': '⟩',  'rightleftharpoons;': '⇌',  'RightUpDownVector;': '⥏',  'SquareSubsetEqual;': '⊑',  'twoheadrightarrow;': '↠',  'VerticalSeparator;': '❘',  'blacktriangleright;': '▸',  'DownRightTeeVector;': '⥟',  'DownRightVectorBar;': '⥗',  'LongLeftRightArrow;': '⟷',  'Longleftrightarrow;': '⟺',  'longleftrightarrow;': '⟷',  'NegativeThickSpace;': '​',  'NotLeftTriangleBar;': '⧏̸',  'PrecedesSlantEqual;': '≼',  'ReverseEquilibrium;': '⇋',  'RightDoubleBracket;': '⟧',  'RightDownTeeVector;': '⥝',  'RightDownVectorBar;': '⥕',  'RightTriangleEqual;': '⊵',  'SquareIntersection;': '⊓',  'SucceedsSlantEqual;': '≽',  'DoubleLongLeftArrow;': '⟸',  'DownLeftRightVector;': '⥐',  'LeftArrowRightArrow;': '⇆',  'leftrightsquigarrow;': '↭',  'NegativeMediumSpace;': '​',  'NotGreaterFullEqual;': '≧̸',  'NotRightTriangleBar;': '⧐̸',  'RightArrowLeftArrow;': '⇄',  'SquareSupersetEqual;': '⊒',  'CapitalDifferentialD;': 'ⅅ',  'DoubleLeftRightArrow;': '⇔',  'DoubleLongRightArrow;': '⟹',  'EmptyVerySmallSquare;': '▫',  'NestedGreaterGreater;': '≫',  'NotDoubleVerticalBar;': '∦',  'NotGreaterSlantEqual;': '⩾̸',  'NotLeftTriangleEqual;': '⋬',  'NotSquareSubsetEqual;': '⋢',  'OpenCurlyDoubleQuote;': '“',  'ReverseUpEquilibrium;': '⥯',  'CloseCurlyDoubleQuote;': '”',  'DoubleContourIntegral;': '∯',  'FilledVerySmallSquare;': '▪',  'NegativeVeryThinSpace;': '​',  'NotPrecedesSlantEqual;': '⋠',  'NotRightTriangleEqual;': '⋭',  'NotSucceedsSlantEqual;': '⋡',  'DiacriticalDoubleAcute;': '˝',  'NotSquareSupersetEqual;': '⋣',  'NotNestedGreaterGreater;': '⪢̸',  'ClockwiseContourIntegral;': '∲',  'DoubleLongLeftRightArrow;': '⟺',  'CounterClockwiseContourIntegral;': '∳'}const decodeHtml = (rawText, asAttr) => {  let offset = 0  const end = rawText.length  let decodedText = ''  function advance(length) {    offset += length    rawText = rawText.slice(length)  }  while (offset < end) {    const head = /&(?:#x?)?/i.exec(rawText)    if (!head || offset + head.index >= end) {      const remaining = end - offset      decodedText += rawText.slice(0, remaining)      advance(remaining)      break    }    // Advance to the "&".    decodedText += rawText.slice(0, head.index)    advance(head.index)    if (head[0] === '&') {      // Named character reference.      let name = ''      let value = undefined      if (/[0-9a-z]/i.test(rawText[1])) {        if (!maxCRNameLength) {          maxCRNameLength = Object.keys(namedCharacterReferences).reduce(            (max, name) => Math.max(max, name.length),            0          )        }        for (let length = maxCRNameLength; !value && length > 0; --length) {          name = rawText.slice(1, 1 + length)          value = namedCharacterReferences[name]        }        if (value) {          const semi = name.endsWith(';')          if (            asAttr &&            !semi &&            /[=a-z0-9]/i.test(rawText[name.length + 1] || '')          ) {            decodedText += '&' + name            advance(1 + name.length)          } else {            decodedText += value            advance(1 + name.length)          }        } else {          decodedText += '&' + name          advance(1 + name.length)        }      } else {        decodedText += '&'        advance(1)      }    } else {      // Numeric character reference.      const hex = head[0] === '&#x'      const pattern = hex ? /^&#x([0-9a-f]+);?/i : /^&#([0-9]+);?/      const body = pattern.exec(rawText)      if (!body) {        decodedText += head[0]        advance(head[0].length)      } else {        // https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state        let cp = Number.parseInt(body[1], hex ? 16 : 10)        if (cp === 0) {          cp = 0xfffd        } else if (cp > 0x10ffff) {          cp = 0xfffd        } else if (cp >= 0xd800 && cp <= 0xdfff) {          cp = 0xfffd        } else if ((cp >= 0xfdd0 && cp <= 0xfdef) || (cp & 0xfffe) === 0xfffe) {          // noop        } else if (          (cp >= 0x01 && cp <= 0x08) ||          cp === 0x0b ||          (cp >= 0x0d && cp <= 0x1f) ||          (cp >= 0x7f && cp <= 0x9f)        ) {          cp = CCR_REPLACEMENTS[cp] || cp        }        decodedText += String.fromCodePoint(cp)        advance(body[0].length)      }    }  }  return decodedText}// https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-stateconst CCR_REPLACEMENTS = {  0x80: 0x20ac,  0x82: 0x201a,  0x83: 0x0192,  0x84: 0x201e,  0x85: 0x2026,  0x86: 0x2020,  0x87: 0x2021,  0x88: 0x02c6,  0x89: 0x2030,  0x8a: 0x0160,  0x8b: 0x2039,  0x8c: 0x0152,  0x8e: 0x017d,  0x91: 0x2018,  0x92: 0x2019,  0x93: 0x201c,  0x94: 0x201d,  0x95: 0x2022,  0x96: 0x2013,  0x97: 0x2014,  0x98: 0x02dc,  0x99: 0x2122,  0x9a: 0x0161,  0x9b: 0x203a,  0x9c: 0x0153,  0x9e: 0x017e,  0x9f: 0x0178}let decoderfunction decodeHtmlBrowser(raw, asAttr = false) {  if (!decoder) {    decoder = document.createElement('div')  }  if (asAttr) {    decoder.innerHTML = `<div foo="${raw.replace(/"/g, '&quot;')}">`    return decoder.children[0].getAttribute('foo')  } else {    decoder.innerHTML = raw    return decoder.textContent  }}const V_MODEL_RADIO = Symbol(__DEV__ ? `vModelRadio` : ``)const V_MODEL_CHECKBOX = Symbol(__DEV__ ? `vModelCheckbox` : ``)const V_MODEL_TEXT = Symbol(__DEV__ ? `vModelText` : ``)const V_MODEL_SELECT = Symbol(__DEV__ ? `vModelSelect` : ``)const V_MODEL_DYNAMIC = Symbol(__DEV__ ? `vModelDynamic` : ``)const V_ON_WITH_MODIFIERS = Symbol(__DEV__ ? `vOnModifiersGuard` : ``)const V_ON_WITH_KEYS = Symbol(__DEV__ ? `vOnKeysGuard` : ``)const V_SHOW = Symbol(__DEV__ ? `vShow` : ``)const TRANSITION = Symbol(__DEV__ ? `Transition` : ``)const TRANSITION_GROUP = Symbol(__DEV__ ? `TransitionGroup` : ``)registerRuntimeHelpers({  [V_MODEL_RADIO]: `vModelRadio`,  [V_MODEL_CHECKBOX]: `vModelCheckbox`,  [V_MODEL_TEXT]: `vModelText`,  [V_MODEL_SELECT]: `vModelSelect`,  [V_MODEL_DYNAMIC]: `vModelDynamic`,  [V_ON_WITH_MODIFIERS]: `withModifiers`,  [V_ON_WITH_KEYS]: `withKeys`,  [V_SHOW]: `vShow`,  [TRANSITION]: `Transition`,  [TRANSITION_GROUP]: `TransitionGroup`})/** * On the client we only need to offer special cases for boolean attributes that * have different names from their corresponding dom properties: * - itemscope -> N/A * - allowfullscreen -> allowFullscreen * - formnovalidate -> formNoValidate * - ismap -> isMap * - nomodule -> noModule * - novalidate -> noValidate * - readonly -> readOnly */const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`const isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs)/** * The full list is needed during SSR to produce the correct initial markup. */const isBooleanAttr = /*#__PURE__*/ makeMap(  specialBooleanAttrs +    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +    `loop,open,required,reversed,scoped,seamless,` +    `checked,muted,multiple,selected`)/** * Boolean attributes should be included if the value is truthy or ''. * e.g. `<select multiple>` compiles to `{ multiple: '' }` */function includeBooleanAttr(value) {  return !!value || value === ''}const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/const attrValidationCache = {}function isSSRSafeAttrName(name) {  if (attrValidationCache.hasOwnProperty(name)) {    return attrValidationCache[name]  }  const isUnsafe = unsafeAttrCharRE.test(name)  if (isUnsafe) {    console.error(`unsafe attribute name: ${name}`)  }  return (attrValidationCache[name] = !isUnsafe)}const propsToAttrMap = {  acceptCharset: 'accept-charset',  className: 'class',  htmlFor: 'for',  httpEquiv: 'http-equiv'}/** * CSS properties that accept plain numbers */const isNoUnitNumericStyleProp = /*#__PURE__*/ makeMap(  `animation-iteration-count,border-image-outset,border-image-slice,` +    `border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,` +    `columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,` +    `grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,` +    `grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,` +    `line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,` +    // SVG    `fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,` +    `stroke-miterlimit,stroke-opacity,stroke-width`)/** * Known attributes, this is used for stringification of runtime static nodes * so that we don't stringify bindings that cannot be set from HTML. * Don't also forget to allow `data-*` and `aria-*`! * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes */const isKnownHtmlAttr = /*#__PURE__*/ makeMap(  `accept,accept-charset,accesskey,action,align,allow,alt,async,` +    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +    `value,width,wrap`)/** * Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute */const isKnownSvgAttr = /*#__PURE__*/ makeMap(  `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,` +    `arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,` +    `baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,` +    `clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,` +    `color-interpolation-filters,color-profile,color-rendering,` +    `contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,` +    `descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,` +    `dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,` +    `fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,` +    `font-family,font-size,font-size-adjust,font-stretch,font-style,` +    `font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,` +    `glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,` +    `gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,` +    `horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,` +    `k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,` +    `lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,` +    `marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,` +    `mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,` +    `name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,` +    `overflow,overline-position,overline-thickness,panose-1,paint-order,path,` +    `pathLength,patternContentUnits,patternTransform,patternUnits,ping,` +    `pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,` +    `preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,` +    `rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,` +    `restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,` +    `specularConstant,specularExponent,speed,spreadMethod,startOffset,` +    `stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,` +    `strikethrough-position,strikethrough-thickness,string,stroke,` +    `stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,` +    `stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,` +    `systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,` +    `text-decoration,text-rendering,textLength,to,transform,transform-origin,` +    `type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,` +    `unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,` +    `v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,` +    `vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,` +    `writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,` +    `xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,` +    `xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`)// https://developer.mozilla.org/en-US/docs/Web/HTML/Elementconst HTML_TAGS =  'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +  'header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +  'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +  'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +  'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +  'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +  'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +  'option,output,progress,select,textarea,details,dialog,menu,' +  'summary,template,blockquote,iframe,tfoot'// https://developer.mozilla.org/en-US/docs/Web/SVG/Elementconst SVG_TAGS =  'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +  'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +  'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +  'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +  'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +  'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +  'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +  'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +  'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +  'text,textPath,title,tspan,unknown,use,view'const VOID_TAGS =  'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr'const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS)/** * Compiler only. * Do NOT use in runtime code paths unless behind `__DEV__` flag. */const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS)const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS)function normalizeStyle(value) {  if (isArray(value)) {    const res = {}    for (let i = 0; i < value.length; i++) {      const item = value[i]      const normalized = isString(item)        ? parseStringStyle(item)        : normalizeStyle(item)      if (normalized) {        for (const key in normalized) {          res[key] = normalized[key]        }      }    }    return res  } else if (isString(value)) {    return value  } else if (isObject(value)) {    return value  }}const listDelimiterRE = /;(?![^(]*\))/gconst propertyDelimiterRE = /:(.+)/function parseStringStyle(cssText) {  const ret = {}  cssText.split(listDelimiterRE).forEach((item) => {    if (item) {      const tmp = item.split(propertyDelimiterRE)      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim())    }  })  return ret}function stringifyStyle(styles) {  let ret = ''  if (!styles || isString(styles)) {    return ret  }  for (const key in styles) {    const value = styles[key]    const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key)    if (      isString(value) ||      (typeof value === 'number' && isNoUnitNumericStyleProp(normalizedKey))    ) {      // only render valid values      ret += `${normalizedKey}:${value};`    }  }  return ret}function normalizeClass(value) {  let res = ''  if (isString(value)) {    res = value  } else if (isArray(value)) {    for (let i = 0; i < value.length; i++) {      const normalized = normalizeClass(value[i])      if (normalized) {        res += normalized + ' '      }    }  } else if (isObject(value)) {    for (const name in value) {      if (value[name]) {        res += name + ' '      }    }  }  return res.trim()}function normalizeProps(props) {  if (!props) return null  let { class: klass, style } = props  if (klass && !isString(klass)) {    props.class = normalizeClass(klass)  }  if (style) {    props.style = normalizeStyle(style)  }  return props}const escapeRE = /["'&<>]/function escapeHtml(string) {  const str = '' + string  const match = escapeRE.exec(str)  if (!match) {    return str  }  let html = ''  let escaped  let index  let lastIndex = 0  for (index = match.index; index < str.length; index++) {    switch (str.charCodeAt(index)) {      case 34: // "        escaped = '&quot;'        break      case 38: // &        escaped = '&amp;'        break      case 39: // '        escaped = '&#39;'        break      case 60: // <        escaped = '&lt;'        break      case 62: // >        escaped = '&gt;'        break      default:        continue    }    if (lastIndex !== index) {      html += str.slice(lastIndex, index)    }    lastIndex = index + 1    html += escaped  }  return lastIndex !== index ? html + str.slice(lastIndex, index) : html}// https://www.w3.org/TR/html52/syntax.html#commentsconst commentStripRE = /^-?>|<!--|-->|--!>|<!-$/gfunction escapeHtmlComment(src) {  return src.replace(commentStripRE, '')}const toDisplayString = (val) => {  return isString(val)    ? val    : val == null    ? ''    : isArray(val) ||      (isObject(val) &&        (val.toString === objectToString || !isFunction(val.toString)))    ? JSON.stringify(val, replacer, 2)    : String(val)}const replacer = (_key, val) => {  // can't use isRef here since @vue/shared has no deps  if (val && val.__v_isRef) {    return replacer(_key, val.value)  } else if (isMap(val)) {    return {      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {        entries[`${key} =>`] = val        return entries      }, {})    }  } else if (isSet(val)) {    return {      [`Set(${val.size})`]: [...val.values()]    }  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {    return String(val)  }  return val}const noopDirectiveTransform = () => ({ props: [] })const isRawTextContainer = /*#__PURE__*/ makeMap(  'style,iframe,script,noscript',  true)const DOMNamespaces = {  HTML: Namespaces.HTML,  SVG: 1,  MATH_ML: 2}const parserOptions = {  isVoidTag,  isNativeTag: (tag) => isHTMLTag(tag) || isSVGTag(tag),  isPreTag: (tag) => tag === 'pre',  decodeEntities: __BROWSER__ ? decodeHtmlBrowser : decodeHtml,  isBuiltInComponent: (tag) => {    if (isBuiltInType(tag, `Transition`)) {      return TRANSITION    } else if (isBuiltInType(tag, `TransitionGroup`)) {      return TRANSITION_GROUP    }  },  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher  getNamespace(tag, parent) {    let ns = parent ? parent.ns : DOMNamespaces.HTML    if (parent && ns === DOMNamespaces.MATH_ML) {      if (parent.tag === 'annotation-xml') {        if (tag === 'svg') {          return DOMNamespaces.SVG        }        if (          parent.props.some(            (a) =>              a.type === NodeTypes.ATTRIBUTE &&              a.name === 'encoding' &&              a.value != null &&              (a.value.content === 'text/html' ||                a.value.content === 'application/xhtml+xml')          )        ) {          ns = DOMNamespaces.HTML        }      } else if (        /^m(?:[ions]|text)$/.test(parent.tag) &&        tag !== 'mglyph' &&        tag !== 'malignmark'      ) {        ns = DOMNamespaces.HTML      }    } else if (parent && ns === DOMNamespaces.SVG) {      if (        parent.tag === 'foreignObject' ||        parent.tag === 'desc' ||        parent.tag === 'title'      ) {        ns = DOMNamespaces.HTML      }    }    if (ns === DOMNamespaces.HTML) {      if (tag === 'svg') {        return DOMNamespaces.SVG      }      if (tag === 'math') {        return DOMNamespaces.MATH_ML      }    }    return ns  },  // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments  getTextMode({ tag, ns }) {    if (ns === DOMNamespaces.HTML) {      if (tag === 'textarea' || tag === 'title') {        return TextModes.RCDATA      }      if (isRawTextContainer(tag)) {        return TextModes.RAWTEXT      }    }    return TextModes.DATA  }}function hasDynamicKeyVBind(node) {  return node.props.some(    (p) =>      p.type === NodeTypes.DIRECTIVE &&      p.name === 'bind' &&      (!p.arg || // v-bind="obj"        p.arg.type !== NodeTypes.SIMPLE_EXPRESSION || // v-bind:[_ctx.foo]        !p.arg.isStatic) // v-bind:[foo]  )}function hasMultipleChildren(node) {  // #1352 filter out potential comment nodes.  const children = (node.children = node.children.filter(    (c) =>      c.type !== NodeTypes.COMMENT &&      !(c.type === NodeTypes.TEXT && !c.content.trim())  ))  const child = children[0]  return (    children.length !== 1 ||    child.type === NodeTypes.FOR ||    (child.type === NodeTypes.IF && child.branches.some(hasMultipleChildren))  )}const warnTransitionChildren = (node, context) => {  if (    node.type === NodeTypes.ELEMENT &&    node.tagType === ElementTypes.COMPONENT  ) {    const component = context.isBuiltInComponent(node.tag)    if (component === TRANSITION) {      return () => {        if (node.children.length && hasMultipleChildren(node)) {          console.warn(`X_TRANSITION_INVALID_CHILDREN`, node)        }      }    }  }}const ignoreSideEffectTags = (node, context) => {  if (    node.type === NodeTypes.ELEMENT &&    node.tagType === ElementTypes.ELEMENT &&    (node.tag === 'script' || node.tag === 'style')  ) {    console.warn(`X_IGNORED_SIDE_EFFECT_TAG`)    context.removeNode()  }}// Parse inline CSS strings for static style attributes into an object.// This is a NodeTransform since it works on the static `style` attribute and// converts it into a dynamic equivalent:// style="color: red" -> :style='{ "color": "red" }'// It is then processed by `transformElement` and included in the generated// props.const transformStyleCD = (node) => {  if (node.type === NodeTypes.ELEMENT) {    node.props.forEach((p, i) => {      if (p.type === NodeTypes.ATTRIBUTE && p.name === 'style' && p.value) {        // replace p with an expression node        node.props[i] = {          type: NodeTypes.DIRECTIVE,          name: `bind`,          arg: createSimpleExpression(`style`, true, p.loc),          exp: parseInlineCSS(p.value.content, p.loc),          modifiers: [],          loc: p.loc        }      }    })  }}const parseInlineCSS = (cssText, loc) => {  const normalized = parseStringStyle(cssText)  return createSimpleExpression(    JSON.stringify(normalized),    false,    loc,    ConstantTypes.CAN_STRINGIFY  )}const transformVHtml = (dir, node, context) => {  const { exp, loc } = dir  if (!exp) {    logg('v-html no exp')  }  if (node.children.length) {    logg('v-html can not has children')    node.children.length = 0  }  return {    props: [      createObjectProperty(        createSimpleExpression(`innerHTML`, true, loc),        exp || createSimpleExpression('', true)      )    ]  }}const transformVText = (dir, node, context) => {  const { exp, loc } = dir  if (!exp) {    logg('v-text no exp')  }  if (node.children.length) {    logg('v-text can not have children')    node.children.length = 0  }  return {    props: [      createObjectProperty(        createSimpleExpression(`textContent`, true),        exp          ? createCallExpression(              context.helperString(TO_DISPLAY_STRING),              [exp],              loc            )          : createSimpleExpression('', true)      )    ]  }}const transformModelCD = (dir, node, context) => {  const baseResult = transformModel(dir, node, context)  // base transform has errors OR component v-model (only need props)  if (!baseResult.props.length || node.tagType === ElementTypes.COMPONENT) {    return baseResult  }  if (dir.arg) {    logg('transfromModelCD - X_V_MODEL_ARG_ON_ELEMENT')  }  function checkDuplicatedValue() {    const value = findProp(node, 'value')    if (value) {      logg('transfromModelCD - X_V_MODEL_UNNECESSARY_VALUE')    }  }  const { tag } = node  const isCustomElement = context.isCustomElement(tag)  if (    tag === 'input' ||    tag === 'textarea' ||    tag === 'select' ||    isCustomElement  ) {    let directiveToUse = V_MODEL_TEXT    let isInvalidType = false    if (tag === 'input' || isCustomElement) {      const type = findProp(node, `type`)      if (type) {        if (type.type === NodeTypes.DIRECTIVE) {          // :type="foo"          directiveToUse = V_MODEL_DYNAMIC        } else if (type.value) {          switch (type.value.content) {            case 'radio':              directiveToUse = V_MODEL_RADIO              break            case 'checkbox':              directiveToUse = V_MODEL_CHECKBOX              break            case 'file':              isInvalidType = true              logg('[DOM]transformModel - X_V_MODEL_ON_FILE_INPUT_ELEMENT')              break            default:              // text type              __DEV__ && checkDuplicatedValue()              break          }        }      } else if (hasDynamicKeyVBind(node)) {        // element has bindings with dynamic keys, which can possibly contain        // "type".        directiveToUse = V_MODEL_DYNAMIC      } else {        // text type        __DEV__ && checkDuplicatedValue()      }    } else if (tag === 'select') {      directiveToUse = V_MODEL_SELECT    } else {      // textarea      __DEV__ && checkDuplicatedValue()    }    // inject runtime directive    // by returning the helper symbol via needRuntime    // the import will replaced a resolveDirective call.    if (!isInvalidType) {      baseResult.needRuntime = context.helper(directiveToUse)    }  } else {    logg('[DOM]transformModel - X_V_MODEL_ON_INVALID_ELEMENT')  }  // native vmodel doesn't need the `modelValue` props since they are also  // passed to the runtime as `binding.value`. removing it reduces code size.  baseResult.props = baseResult.props.filter(    (p) =>      !(        p.key.type === NodeTypes.SIMPLE_EXPRESSION &&        p.key.content === 'modelValue'      )  )  return baseResult}const isEventOptionModifier = /*#__PURE__*/ makeMap(`passive,once,capture`)const isNonKeyModifier = /*#__PURE__*/ makeMap(  // event propagation management  `stop,prevent,self,` +    // system modifiers + exact    `ctrl,shift,alt,meta,exact,` +    // mouse    `middle`)// left & right could be mouse or key modifiers based on event typeconst maybeKeyModifier = /*#__PURE__*/ makeMap('left,right')const isKeyboardEvent = /*#__PURE__*/ makeMap(  `onkeyup,onkeydown,onkeypress`,  true)// 将修饰符分类const resolveModifiers = (key, modifiers, context, loc) => {  const keyModifiers = []  const nonKeyModifiers = []  const eventOptionModifiers = []  for (let i = 0; i < modifiers.length; i++) {    const modifier = modifiers[i]    if (isEventOptionModifier(modifier)) {      // eventOptionModifiers: modifiers for addEventListener() options,      // e.g. .passive & .capture      eventOptionModifiers.push(modifier)    } else {      // runtimeModifiers: modifiers that needs runtime guards      if (maybeKeyModifier(modifier)) {        if (isStaticExp(key)) {          if (isKeyboardEvent(key.content)) {            keyModifiers.push(modifier)          } else {            nonKeyModifiers.push(modifier)          }        } else {          keyModifiers.push(modifier)          nonKeyModifiers.push(modifier)        }      } else {        if (isNonKeyModifier(modifier)) {          nonKeyModifiers.push(modifier)        } else {          keyModifiers.push(modifier)        }      }    }  }  return {    keyModifiers,    nonKeyModifiers,    eventOptionModifiers  }}// 原生 click 事件const transformClick = (key, event) => {  const isStaticClick =    isStaticExp(key) && key.content.toLowerCase() === 'onclick'  return isStaticClick    ? createSimpleExpression(event, true)    : key.type !== NodeTypes.SIMPLE_EXPRESSION    ? createCompoundExpression([        `(`,        key,        `) === "onClick" ? "${event}" : (`,        key,        `)`      ])    : key}const transformOnCD = (dir, node, context) => {  return transformOn(dir, node, context, (baseResult) => {    const { modifiers } = dir    if (!modifiers.length) return baseResult    let { key, value: handlerExp } = baseResult.props[0]    const { keyModifiers, nonKeyModifiers, eventOptionModifiers } =      resolveModifiers(key, modifiers, context, dir.loc)    // normalize click.right and click.middle since they don't actually fire    if (nonKeyModifiers.includes('right')) {      key = transformClick(key, `onContextmenu`)    }    if (nonKeyModifiers.includes('middle')) {      key = transformClick(key, `onMouseup`)    }    if (nonKeyModifiers.length) {      handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [        handlerExp,        JSON.stringify(nonKeyModifiers)      ])    }    if (      keyModifiers.length &&      // if event name is dynamic, always wrap with keys guard      (!isStaticExp(key) || isKeyboardEvent(key.content))    ) {      handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [        handlerExp,        JSON.stringify(keyModifiers)      ])    }    if (eventOptionModifiers.length) {      const modifierPostfix = eventOptionModifiers.map(capitalize).join('')      key = isStaticExp(key)        ? createSimpleExpression(`${key.content}${modifierPostfix}`, true)        : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`])    }    return {      props: [createObjectProperty(key, handlerExp)]    }  })}const transformShowCD = (dir, node, context) => {  const { exp, loc } = dir  if (!exp) {    logg('transformShowCD no exp.')  }  return {    props: [],    needRuntime: context.helper(V_SHOW)  }}const StringifyThresholds = {  ELEMENT_WITH_BINDING_COUNT: 5,  NODE_COUNT: 20}/** * Regex for replacing placeholders for embedded constant variables * (e.g. import URL string constants generated by compiler-sfc) */const expReplaceRE = /__VUE_EXP_START__(.*?)__VUE_EXP_END__/g/** * Turn eligible hoisted static trees into stringified static nodes, e.g. * * ```js * const _hoisted_1 = createStaticVNode(`<div class="foo">bar</div>`) * ``` * * A single static vnode can contain stringified content for **multiple** * consecutive nodes (element and plain text), called a "chunk". * `@vue/runtime-dom` will create the content via innerHTML in a hidden * container element and insert all the nodes in place. The call must also * provide the number of nodes contained in the chunk so that during hydration * we can know how many nodes the static vnode should adopt. * * The optimization scans a children list that contains hoisted nodes, and * tries to find the largest chunk of consecutive hoisted nodes before running * into a non-hoisted node or the end of the list. A chunk is then converted * into a single static vnode and replaces the hoisted expression of the first * node in the chunk. Other nodes in the chunk are considered "merged" and * therefore removed from both the hoist list and the children array. * * This optimization is only performed in Node.js. */const stringifyStatic = (children, context, parent) => {  // bail stringification for slot content  if (context.scopes.vSlot > 0) {    return  }  let nc = 0 // current node count  let ec = 0 // current element with binding count  const currentChunk = []  logg(`stringifyStatic - children.length = ${children.length}`)  const stringifyCurrentChunk = (currentIndex) => {    if (      nc >= StringifyThresholds.NODE_COUNT ||      ec >= StringifyThresholds.ELEMENT_WITH_BINDING_COUNT    ) {      logg(`stringifyCurrentChunk - index = ${currentIndex}`)      // combine all currently eligible nodes into a single static vnode call      const staticCall = createCallExpression(context.helper(CREATE_STATIC), [        JSON.stringify(          currentChunk.map((node) => stringifyNode(node, context)).join('')        ).replace(expReplaceRE, `" + $1 + "`),        // the 2nd argument indicates the number of DOM nodes this static vnode        // will insert / hydrate        String(currentChunk.length)      ])      // replace the first node's hoisted expression with the static vnode call      replaceHoist(currentChunk[0], staticCall, context)      if (currentChunk.length > 1) {        for (let i = 1; i < currentChunk.length; i++) {          // for the merged nodes, set their hoisted expression to null          replaceHoist(currentChunk[i], null, context)        }        // also remove merged nodes from children        const deleteCount = currentChunk.length - 1        children.splice(currentIndex - currentChunk.length + 1, deleteCount)        return deleteCount      }    }    return 0  }  let i = 0  for (; i < children.length; i++) {    const child = children[i]    const hoisted = getHoistedNode(child)    if (hoisted) {      // presence of hoisted means child must be a stringifiable node      const node = child      const result = analyzeNode(node)      if (result) {        // node is stringifiable, record state        nc += result[0]        ec += result[1]        currentChunk.push(node)        continue      }    }    // we only reach here if we ran into a node that is not stringifiable    // check if currently analyzed nodes meet criteria for stringification.    // adjust iteration index    i -= stringifyCurrentChunk(i)    // reset state    nc = 0    ec = 0    currentChunk.length = 0  }  // in case the last node was also stringifiable  stringifyCurrentChunk(i)}const getHoistedNode = (node) =>  ((node.type === NodeTypes.ELEMENT && node.tagType === ElementTypes.ELEMENT) ||    node.type == NodeTypes.TEXT_CALL) &&  node.codegenNode &&  node.codegenNode.type === NodeTypes.SIMPLE_EXPRESSION &&  node.codegenNode.hoistedconst dataAriaRE = /^(data|aria)-/const isStringifiableAttr = (name, ns) => {  return (    (ns === DOMNamespaces.HTML      ? isKnownHtmlAttr(name)      : ns === DOMNamespaces.SVG      ? isKnownSvgAttr(name)      : false) || dataAriaRE.test(name)  )}const replaceHoist = (node, replacement, context) => {  const hoistToReplace = node.codegenNode.hoisted  context.hoists[context.hoists.indexOf(hoistToReplace)] = replacement}const isNonStringifiable = /*#__PURE__*/ makeMap(  `caption,thead,tr,th,tbody,td,tfoot,colgroup,col`)/** * for a hoisted node, analyze it and return: * - false: bailed (contains non-stringifiable props or runtime constant) * - [nc, ec] where *   - nc is the number of nodes inside *   - ec is the number of element with bindings inside */function analyzeNode(node) {  if (node.type === NodeTypes.ELEMENT && isNonStringifiable(node.tag)) {    return false  }  if (node.type === NodeTypes.TEXT_CALL) {    return [1, 0]  }  let nc = 1 // node count  let ec = node.props.length > 0 ? 1 : 0 // element w/ binding count  let bailed = false  const bail = () => {    bailed = true    return false  }  // TODO: check for cases where using innerHTML will result in different  // output compared to imperative node insertions.  // probably only need to check for most common case  // i.e. non-phrasing-content tags inside `<p>`  function walk(node) {    for (let i = 0; i < node.props.length; i++) {      const p = node.props[i]      // bail on non-attr bindings      if (        p.type === NodeTypes.ATTRIBUTE &&        !isStringifiableAttr(p.name, node.ns)      ) {        return bail()      }      if (p.type === NodeTypes.DIRECTIVE && p.name === 'bind') {        // bail on non-attr bindings        if (          p.arg &&          (p.arg.type === NodeTypes.COMPOUND_EXPRESSION ||            (p.arg.isStatic && !isStringifiableAttr(p.arg.content, node.ns)))        ) {          return bail()        }        if (          p.exp &&          (p.exp.type === NodeTypes.COMPOUND_EXPRESSION ||            p.exp.constType < ConstantTypes.CAN_STRINGIFY)        ) {          return bail()        }      }    }    for (let i = 0; i < node.children.length; i++) {      nc++      const child = node.children[i]      if (child.type === NodeTypes.ELEMENT) {        if (child.props.length > 0) {          ec++        }        walk(child)        if (bailed) {          return false        }      }    }    return true  }  return walk(node) ? [nc, ec] : false}function stringifyNode(node, context) {  if (isString(node)) {    return node  }  if (isSymbol(node)) {    return ``  }  switch (node.type) {    case NodeTypes.ELEMENT:      return stringifyElement(node, context)    case NodeTypes.TEXT:      return escapeHtml(node.content)    case NodeTypes.COMMENT:      return `<!--${escapeHtml(node.content)}-->`    case NodeTypes.INTERPOLATION:      return escapeHtml(toDisplayString(evaluateConstant(node.content)))    case NodeTypes.COMPOUND_EXPRESSION:      return escapeHtml(evaluateConstant(node))    case NodeTypes.TEXT_CALL:      return stringifyNode(node.content, context)    default:      // static trees will not contain if/for nodes      return ''  }}function stringifyElement(node, context) {  let res = `<${node.tag}`  for (let i = 0; i < node.props.length; i++) {    const p = node.props[i]    if (p.type === NodeTypes.ATTRIBUTE) {      res += ` ${p.name}`      if (p.value) {        res += `="${escapeHtml(p.value.content)}"`      }    } else if (p.type === NodeTypes.DIRECTIVE && p.name === 'bind') {      const exp = p.exp      if (exp.content[0] === '_') {        // internally generated string constant references        // e.g. imported URL strings via compiler-sfc transformAssetUrl plugin        res += ` ${p.arg.content}="__VUE_EXP_START__${exp.content}__VUE_EXP_END__"`        continue      }      // constant v-bind, e.g. :foo="1"      let evaluated = evaluateConstant(exp)      if (evaluated != null) {        const arg = p.arg && p.arg.content        if (arg === 'class') {          evaluated = normalizeClass(evaluated)        } else if (arg === 'style') {          evaluated = stringifyStyle(normalizeStyle(evaluated))        }        res += ` ${p.arg.content}="${escapeHtml(evaluated)}"`      }    }  }  if (context.scopeId) {    res += ` ${context.scopeId}`  }  res += `>`  for (let i = 0; i < node.children.length; i++) {    res += stringifyNode(node.children[i], context)  }  if (!isVoidTag(node.tag)) {    res += `</${node.tag}>`  }  return res}// __UNSAFE__// Reason: eval.// It's technically safe to eval because only constant expressions are possible// here, e.g. `{{ 1 }}` or `{{ 'foo' }}`// in addition, constant exps bail on presence of parens so you can't even// run JSFuck in here. But we mark it unsafe for security review purposes.// (see compiler-core/src/transformExpressions)function evaluateConstant(exp) {  if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {    return new Function(`return ${exp.content}`)()  } else {    // compound    let res = ``    exp.children.forEach((c) => {      if (isString(c) || isSymbol(c)) {        return      }      if (c.type === NodeTypes.TEXT) {        res += c.content      } else if (c.type === NodeTypes.INTERPOLATION) {        res += toDisplayString(evaluateConstant(c.content))      } else {        res += evaluateConstant(c)      }    })    return res  }}const DOMDirectiveTransforms = {  cloak: noopDirectiveTransform,  html: transformVHtml,  text: transformVText,  model: transformModelCD, // override compiler-core  on: transformOnCD, // override compiler-core  show: transformShowCD}const DOMNodeTransforms = [  transformStyleCD,  ...(__DEV__ ? [warnTransitionChildren] : [])]function compile(template, options = {}) {  return baseCompile(    template,    extend({}, parserOptions, options, {      nodeTransforms: [        // ignore <script> and <tag>        // this is not put inside DOMNodeTransforms because that list is used        // by compiler-ssr to generate vnode fallback branches        ignoreSideEffectTags,        ...DOMNodeTransforms,        ...(options.nodeTransforms || [])      ],      directiveTransforms: extend(        {},        DOMDirectiveTransforms,        options.directiveTransforms || {}      ),      transformHoist: __BROWSER__ ? null : stringifyStatic    })  )}function parse(template, options = {}) {  return baseParse(template, extend({}, parserOptions, options))}const __ESM_BROWSER__ = false,  __GLOBAL__ = truelet MagicString = require(process.env.NODE_LIB + '/magic-string')function createCache(size = 500) {  return new Map()}const defaultExportRE = /((?:^|\n|;)\s*)export(\s*)default/const namedDefaultExportRE = /((?:^|\n|;)\s*)export(.+)as(\s*)default/sconst exportDefaultClassRE =  /((?:^|\n|;)\s*)export\s+default\s+class\s+([\w$]+)//** * Utility for rewriting `export default` in a script block into a variable * declaration so that we can inject things into it */function rewriteDefault(input, as, parserPlugins) {  if (!hasDefaultExport(input)) {    return input + `\nconst ${as} = {}`  }  let replaced  const classMatch = input.match(exportDefaultClassRE)  if (classMatch) {    replaced =      input.replace(exportDefaultClassRE, '$1class $2') +      `\nconst ${as} = ${classMatch[2]}`  } else {    replaced = input.replace(defaultExportRE, `$1const ${as} =`)  }  if (!hasDefaultExport(replaced)) {    return replaced  }  // if the script somehow still contains `default export`, it probably has  // multi-line comments or template strings. fallback to a full parse.  const s = new MagicString(input)  const ast = babelParser.parse(input, {    sourceType: 'module',    plugins: [...parserPlugins, ...babelPlugins]  }).program.body  ast.forEach((node) => {    if (node.type === 'ExportDefaultDeclaration') {      s.overwrite(node.start, node.declaration.start, `const ${as} = `)    }    if (node.type === 'ExportNamedDeclaration') {      node.specifiers.forEach((specifier) => {        if (          specifier.type === 'ExportSpecifier' &&          specifier.exported.type === 'Identifier' &&          specifier.exported.name === 'default'        ) {          const end = specifier.end          s.overwrite(            specifier.start,            input.charAt(end) === ',' ? end + 1 : end,            ``          )          s.append(`\nconst ${as} = ${specifier.local.name}`)        }      })    }  })  return s.toString()}function hasDefaultExport(input) {  return defaultExportRE.test(input) || namedDefaultExportRE.test(input)}const RT = (function () {  const CONVERT_SYMBOL = '$'  const ESCAPE_SYMBOL = '$$'  const shorthands = ['ref', 'computed', 'shallowRef', 'toRef', 'customRef']  const transformCheckRE = /[^\w]\$(?:\$|ref|computed|shallowRef)?\s*(\(|\<)/  function shouldTransform(src) {    return transformCheckRE.test(src)  }  function transform(    src,    { filename, sourceMap, parserPlugins, importHelpersFrom = 'vue' } = {}  ) {    const plugins = parserPlugins || []    if (filename) {      if (/\.tsx?$/.test(filename)) {        plugins.push('typescript')      }      if (filename.endsWith('x')) {        plugins.push('jsx')      }    }    const ast = babelParser.parse(src, {      sourceType: 'module',      plugins: [...plugins, ...babelPlugins]    })    const s = new MagicString(src)    const res = transformAST(ast.program, s, 0)    // inject helper imports    if (res.importedHelpers.length) {      s.prepend(        `import { ${res.importedHelpers          .map((h) => `${h} as _${h}`)          .join(', ')} } from '${importHelpersFrom}'\n`      )    }    return {      ...res,      code: s.toString(),      map: sourceMap        ? s.generateMap({            source: filename,            hires: true,            includeContent: true          })        : null    }  }  function transformAST(ast, s, offset = 0, knownRefs, knownProps) {    let convertSymbol = CONVERT_SYMBOL    let escapeSymbol = ESCAPE_SYMBOL    // macro import handling    for (const node of ast.body) {      if (        node.type === 'ImportDeclaration' &&        node.source.value === 'vue/macros'      ) {        // remove macro imports        s.remove(node.start + offset, node.end + offset)        // check aliasing        for (const specifier of node.specifiers) {          if (specifier.type === 'ImportSpecifier') {            const imported = specifier.imported.name            const local = specifier.local.name            if (local !== imported) {              if (imported === ESCAPE_SYMBOL) {                escapeSymbol = local              } else if (imported === CONVERT_SYMBOL) {                convertSymbol = local              } else {                error(                  `macro imports for ref-creating methods do not support aliasing.`,                  specifier                )              }            }          }        }      }    }    const importedHelpers = new Set()    const rootScope = {}    const scopeStack = [rootScope]    let currentScope = rootScope    let escapeScope // inside $$()    const excludedIds = new WeakSet()    const parentStack = []    const propsLocalToPublicMap = Object.create(null)    if (knownRefs) {      for (const key of knownRefs) {        rootScope[key] = true      }    }    if (knownProps) {      for (const key in knownProps) {        const { local } = knownProps[key]        rootScope[local] = 'prop'        propsLocalToPublicMap[local] = key      }    }    function isRefCreationCall(callee) {      if (callee === convertSymbol) {        return convertSymbol      }      if (callee[0] === '$' && shorthands.includes(callee.slice(1))) {        return callee      }      return false    }    function error(msg, node) {      const e = new Error(msg)      e.node = node      throw e    }    function helper(msg) {      importedHelpers.add(msg)      return `_${msg}`    }    function registerBinding(id, isRef = false) {      excludedIds.add(id)      if (currentScope) {        currentScope[id.name] = isRef      } else {        error(          'registerBinding called without active scope, something is wrong.',          id        )      }    }    const registerRefBinding = (id) => registerBinding(id, true)    let tempVarCount = 0    function genTempVar() {      return `__$temp_${++tempVarCount}`    }    function snip(node) {      return s.original.slice(node.start + offset, node.end + offset)    }    function walkScope(node, isRoot = false) {      for (const stmt of node.body) {        if (stmt.type === 'VariableDeclaration') {          walkVariableDeclaration(stmt, isRoot)        } else if (          stmt.type === 'FunctionDeclaration' ||          stmt.type === 'ClassDeclaration'        ) {          if (stmt.declare || !stmt.id) continue          registerBinding(stmt.id)        } else if (          (stmt.type === 'ForOfStatement' || stmt.type === 'ForInStatement') &&          stmt.left.type === 'VariableDeclaration'        ) {          walkVariableDeclaration(stmt.left)        } else if (          stmt.type === 'ExportNamedDeclaration' &&          stmt.declaration &&          stmt.declaration.type === 'VariableDeclaration'        ) {          walkVariableDeclaration(stmt.declaration, isRoot)        } else if (          stmt.type === 'LabeledStatement' &&          stmt.body.type === 'VariableDeclaration'        ) {          walkVariableDeclaration(stmt.body, isRoot)        }      }    }    function walkVariableDeclaration(stmt, isRoot = false) {      if (stmt.declare) {        return      }      for (const decl of stmt.declarations) {        let refCall        const isCall =          decl.init &&          decl.init.type === 'CallExpression' &&          decl.init.callee.type === 'Identifier'        if (isCall && (refCall = isRefCreationCall(decl.init.callee.name))) {          processRefDeclaration(refCall, decl.id, decl.init)        } else {          const isProps =            isRoot && isCall && decl.init.callee.name === 'defineProps'          for (const id of extractIdentifiers(decl.id)) {            if (isProps) {              // for defineProps destructure, only exclude them since they              // are already passed in as knownProps              excludedIds.add(id)            } else {              registerBinding(id)            }          }        }      }    }    function processRefDeclaration(method, id, call) {      excludedIds.add(call.callee)      if (method === convertSymbol) {        // $        // remove macro        s.remove(call.callee.start + offset, call.callee.end + offset)        if (id.type === 'Identifier') {          // single variable          registerRefBinding(id)        } else if (id.type === 'ObjectPattern') {          processRefObjectPattern(id, call)        } else if (id.type === 'ArrayPattern') {          processRefArrayPattern(id, call)        }      } else {        // shorthands        if (id.type === 'Identifier') {          registerRefBinding(id)          // replace call          s.overwrite(            call.start + offset,            call.start + method.length + offset,            helper(method.slice(1))          )        } else {          error(`${method}() cannot be used with destructure patterns.`, call)        }      }    }    function processRefObjectPattern(pattern, call, tempVar, path = []) {      if (!tempVar) {        tempVar = genTempVar()        // const { x } = $(useFoo()) --> const __$temp_1 = useFoo()        s.overwrite(pattern.start + offset, pattern.end + offset, tempVar)      }      for (const p of pattern.properties) {        let nameId        let key        let defaultValue        if (p.type === 'ObjectProperty') {          if (p.key.start === p.value.start) {            // shorthand { foo }            nameId = p.key            if (p.value.type === 'Identifier') {              // avoid shorthand value identifier from being processed              excludedIds.add(p.value)            } else if (              p.value.type === 'AssignmentPattern' &&              p.value.left.type === 'Identifier'            ) {              // { foo = 1 }              excludedIds.add(p.value.left)              defaultValue = p.value.right            }          } else {            key = p.computed ? p.key : p.key.name            if (p.value.type === 'Identifier') {              // { foo: bar }              nameId = p.value            } else if (p.value.type === 'ObjectPattern') {              processRefObjectPattern(p.value, call, tempVar, [...path, key])            } else if (p.value.type === 'ArrayPattern') {              processRefArrayPattern(p.value, call, tempVar, [...path, key])            } else if (p.value.type === 'AssignmentPattern') {              if (p.value.left.type === 'Identifier') {                // { foo: bar = 1 }                nameId = p.value.left                defaultValue = p.value.right              } else if (p.value.left.type === 'ObjectPattern') {                processRefObjectPattern(p.value.left, call, tempVar, [                  ...path,                  [key, p.value.right]                ])              } else if (p.value.left.type === 'ArrayPattern') {                processRefArrayPattern(p.value.left, call, tempVar, [                  ...path,                  [key, p.value.right]                ])              } else {                // MemberExpression case is not possible here, ignore              }            }          }        } else {          // rest element { ...foo }          error(`reactivity destructure does not support rest elements.`, p)        }        if (nameId) {          registerRefBinding(nameId)          // inject toRef() after original replaced pattern          const source = pathToString(tempVar, path)          const keyStr = isString(key)            ? `'${key}'`            : key            ? snip(key)            : `'${nameId.name}'`          const defaultStr = defaultValue ? `, ${snip(defaultValue)}` : ``          s.appendLeft(            call.end + offset,            `,\n  ${nameId.name} = ${helper(              'toRef'            )}(${source}, ${keyStr}${defaultStr})`          )        }      }    }    function processRefArrayPattern(pattern, call, tempVar, path = []) {      if (!tempVar) {        // const [x] = $(useFoo()) --> const __$temp_1 = useFoo()        tempVar = genTempVar()        s.overwrite(pattern.start + offset, pattern.end + offset, tempVar)      }      for (let i = 0; i < pattern.elements.length; i++) {        const e = pattern.elements[i]        if (!e) continue        let nameId        let defaultValue        if (e.type === 'Identifier') {          // [a] --> [__a]          nameId = e        } else if (e.type === 'AssignmentPattern') {          // [a = 1]          nameId = e.left          defaultValue = e.right        } else if (e.type === 'RestElement') {          // [...a]          error(`reactivity destructure does not support rest elements.`, e)        } else if (e.type === 'ObjectPattern') {          processRefObjectPattern(e, call, tempVar, [...path, i])        } else if (e.type === 'ArrayPattern') {          processRefArrayPattern(e, call, tempVar, [...path, i])        }        if (nameId) {          registerRefBinding(nameId)          // inject toRef() after original replaced pattern          const source = pathToString(tempVar, path)          const defaultStr = defaultValue ? `, ${snip(defaultValue)}` : ``          s.appendLeft(            call.end + offset,            `,\n  ${nameId.name} = ${helper(              'toRef'            )}(${source}, ${i}${defaultStr})`          )        }      }    }    function pathToString(source, path) {      if (path.length) {        for (const seg of path) {          if (isArray(seg)) {            source = `(${source}${segToString(seg[0])} || ${snip(seg[1])})`          } else {            source += segToString(seg)          }        }      }      return source    }    function segToString(seg) {      if (typeof seg === 'number') {        return `[${seg}]`      } else if (typeof seg === 'string') {        return `.${seg}`      } else {        return snip(seg)      }    }    function rewriteId(scope, id, parent, parentStack) {      if (hasOwn(scope, id.name)) {        const bindingType = scope[id.name]        if (bindingType) {          const isProp = bindingType === 'prop'          if (isStaticProperty(parent) && parent.shorthand) {            // let binding used in a property shorthand            // skip for destructure patterns            if (              !parent.inPattern ||              isInDestructureAssignment(parent, parentStack)            ) {              if (isProp) {                if (escapeScope) {                  // prop binding in $$()                  // { prop } -> { prop: __prop_prop }                  registerEscapedPropBinding(id)                  s.appendLeft(                    id.end + offset,                    `: __props_${propsLocalToPublicMap[id.name]}`                  )                } else {                  // { prop } -> { prop: __prop.prop }                  s.appendLeft(                    id.end + offset,                    `: __props.${propsLocalToPublicMap[id.name]}`                  )                }              } else {                // { foo } -> { foo: foo.value }                s.appendLeft(id.end + offset, `: ${id.name}.value`)              }            }          } else {            if (isProp) {              if (escapeScope) {                // x --> __props_x                registerEscapedPropBinding(id)                s.overwrite(                  id.start + offset,                  id.end + offset,                  `__props_${propsLocalToPublicMap[id.name]}`                )              } else {                // x --> __props.x                s.overwrite(                  id.start + offset,                  id.end + offset,                  `__props.${propsLocalToPublicMap[id.name]}`                )              }            } else {              // x --> x.value              s.appendLeft(id.end + offset, '.value')            }          }        }        return true      }      return false    }    const propBindingRefs = {}    function registerEscapedPropBinding(id) {      if (!propBindingRefs.hasOwnProperty(id.name)) {        propBindingRefs[id.name] = true        const publicKey = propsLocalToPublicMap[id.name]        s.prependRight(          offset,          `const __props_${publicKey} = ${helper(            `toRef`          )}(__props, '${publicKey}')\n`        )      }    }    // check root scope first    walkScope(ast, true)    walk(ast, {      enter(node, parent) {        parent && parentStack.push(parent)        // function scopes        if (isFunctionType(node)) {          scopeStack.push((currentScope = {}))          walkFunctionParams(node, registerBinding)          if (node.body.type === 'BlockStatement') {            walkScope(node.body)          }          return        }        // catch param        if (node.type === 'CatchClause') {          scopeStack.push((currentScope = {}))          if (node.param && node.param.type === 'Identifier') {            registerBinding(node.param)          }          walkScope(node.body)          return        }        // non-function block scopes        if (node.type === 'BlockStatement' && !isFunctionType(parent)) {          scopeStack.push((currentScope = {}))          walkScope(node)          return        }        // skip type nodes        if (          parent &&          parent.type.startsWith('TS') &&          parent.type !== 'TSAsExpression' &&          parent.type !== 'TSNonNullExpression' &&          parent.type !== 'TSTypeAssertion'        ) {          return this.skip()        }        if (          node.type === 'Identifier' &&          // if inside $$(), skip unless this is a destructured prop binding          !(escapeScope && rootScope[node.name] !== 'prop') &&          isReferencedIdentifier(node, parent, parentStack) &&          !excludedIds.has(node)        ) {          // walk up the scope chain to check if id should be appended .value          let i = scopeStack.length          while (i--) {            if (rewriteId(scopeStack[i], node, parent, parentStack)) {              return            }          }        }        if (          node.type === 'CallExpression' &&          node.callee.type === 'Identifier'        ) {          const callee = node.callee.name          const refCall = isRefCreationCall(callee)          if (refCall && (!parent || parent.type !== 'VariableDeclarator')) {            return error(              `${refCall} can only be used as the initializer of ` +                `a variable declaration.`,              node            )          }          if (callee === escapeSymbol) {            s.remove(node.callee.start + offset, node.callee.end + offset)            escapeScope = node          }          // TODO remove when out of experimental          if (callee === '$raw') {            error(              `$raw() has been replaced by $$(). ` +                `See ${RFC_LINK} for latest updates.`,              node            )          }          if (callee === '$fromRef') {            error(              `$fromRef() has been replaced by $(). ` +                `See ${RFC_LINK} for latest updates.`,              node            )          }        }      },      leave(node, parent) {        parent && parentStack.pop()        if (          (node.type === 'BlockStatement' && !isFunctionType(parent)) ||          isFunctionType(node)        ) {          scopeStack.pop()          currentScope = scopeStack[scopeStack.length - 1] || null        }        if (node === escapeScope) {          escapeScope = undefined        }      }    })    return {      rootRefs: Object.keys(rootScope).filter((key) => rootScope[key] === true),      importedHelpers: [...importedHelpers]    }  }  return { transformAST, transform, shouldTransform }})()const range = 2function generateCodeFrame(source, start = 0, end = source.length) {  // Split the content into individual lines but capture the newline sequence  // that separated each line. This is important because the actual sequence is  // needed to properly take into account the full line length for offset  // comparison  let lines = source.split(/(\r?\n)/)  // Separate the lines and newline sequences into separate arrays for easier referencing  const newlineSequences = lines.filter((_, idx) => idx % 2 === 1)  lines = lines.filter((_, idx) => idx % 2 === 0)  let count = 0  const res = []  for (let i = 0; i < lines.length; i++) {    count +=      lines[i].length +      ((newlineSequences[i] && newlineSequences[i].length) || 0)    if (count >= start) {      for (let j = i - range; j <= i + range || end > count; j++) {        if (j < 0 || j >= lines.length) continue        const line = j + 1        res.push(          `${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${            lines[j]          }`        )        const lineLength = lines[j].length        const newLineSeqLength =          (newlineSequences[j] && newlineSequences[j].length) || 0        if (j === i) {          // push underline          const pad = start - (count - (lineLength + newLineSeqLength))          const length = Math.max(            1,            end > count ? lineLength - pad : end - start          )          res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length))        } else if (j > i) {          if (end > count) {            const length = Math.max(Math.min(end - count, lineLength), 1)            res.push(`   |  ` + '^'.repeat(length))          }          count += lineLength + newLineSeqLength        }      }      break    }  }  return res.join('\n')}function registerBinding(bindings, node, type) {  bindings[node.name] = type}function walkDeclaration(node, bindings, userImportAlias) {  if (node.type === 'VariableDeclaration') {    const isConst = node.kind === 'const'    // export const foo = ...    for (const { id, init } of node.declarations) {      const isDefineCall = !!(        isConst &&        isCallOf(          init,          (c) => c === DEFINE_PROPS || c === DEFINE_EMITS || c === WITH_DEFAULTS        )      )      if (id.type === 'Identifier') {        let bindingType        const userReactiveBinding = userImportAlias['reactive'] || 'reactive'        if (isCallOf(init, userReactiveBinding)) {          // treat reactive() calls as let since it's meant to be mutable          bindingType = BindingTypes.SETUP_LET        } else if (          // if a declaration is a const literal, we can mark it so that          // the generated render fn code doesn't need to unref() it          isDefineCall ||          (isConst && canNeverBeRef(init, userReactiveBinding))        ) {          bindingType = BindingTypes.SETUP_CONST        } else if (isConst) {          if (isCallOf(init, userImportAlias['ref'] || 'ref')) {            bindingType = BindingTypes.SETUP_REF          } else {            bindingType = BindingTypes.SETUP_MAYBE_REF          }        } else {          bindingType = BindingTypes.SETUP_LET        }        registerBinding(bindings, id, bindingType)      } else {        if (isCallOf(init, DEFINE_PROPS)) {          // skip walking props destructure          return        }        if (id.type === 'ObjectPattern') {          walkObjectPattern(id, bindings, isConst, isDefineCall)        } else if (id.type === 'ArrayPattern') {          walkArrayPattern(id, bindings, isConst, isDefineCall)        }      }    }  } else if (    node.type === 'TSEnumDeclaration' ||    node.type === 'FunctionDeclaration' ||    node.type === 'ClassDeclaration'  ) {    // export function foo() {} / export class Foo {}    // export declarations must be named.    bindings[node.id.name] = BindingTypes.SETUP_CONST  }}function walkObjectPattern(node, bindings, isConst, isDefineCall = false) {  for (const p of node.properties) {    if (p.type === 'ObjectProperty') {      if (p.key.type === 'Identifier' && p.key === p.value) {        // shorthand: const { x } = ...        const type = isDefineCall          ? BindingTypes.SETUP_CONST          : isConst          ? BindingTypes.SETUP_MAYBE_REF          : BindingTypes.SETUP_LET        registerBinding(bindings, p.key, type)      } else {        walkPattern(p.value, bindings, isConst, isDefineCall)      }    } else {      // ...rest      // argument can only be identifier when destructuring      const type = isConst ? BindingTypes.SETUP_CONST : BindingTypes.SETUP_LET      registerBinding(bindings, p.argument, type)    }  }}function walkArrayPattern(node, bindings, isConst, isDefineCall = false) {  for (const e of node.elements) {    e && walkPattern(e, bindings, isConst, isDefineCall)  }}function walkPattern(node, bindings, isConst, isDefineCall = false) {  if (node.type === 'Identifier') {    const type = isDefineCall      ? BindingTypes.SETUP_CONST      : isConst      ? BindingTypes.SETUP_MAYBE_REF      : BindingTypes.SETUP_LET    registerBinding(bindings, node, type)  } else if (node.type === 'RestElement') {    // argument can only be identifier when destructuring    const type = isConst ? BindingTypes.SETUP_CONST : BindingTypes.SETUP_LET    registerBinding(bindings, node.argument, type)  } else if (node.type === 'ObjectPattern') {    walkObjectPattern(node, bindings, isConst)  } else if (node.type === 'ArrayPattern') {    walkArrayPattern(node, bindings, isConst)  } else if (node.type === 'AssignmentPattern') {    if (node.left.type === 'Identifier') {      const type = isDefineCall        ? BindingTypes.SETUP_CONST        : isConst        ? BindingTypes.SETUP_MAYBE_REF        : BindingTypes.SETUP_LET      registerBinding(bindings, node.left, type)    } else {      walkPattern(node.left, bindings, isConst)    }  }}function recordType(node, declaredTypes) {  if (node.type === 'TSInterfaceDeclaration') {    declaredTypes[node.id.name] = [`Object`]  } else if (node.type === 'TSTypeAliasDeclaration') {    declaredTypes[node.id.name] = inferRuntimeType(      node.typeAnnotation,      declaredTypes    )  } else if (node.type === 'ExportNamedDeclaration' && node.declaration) {    recordType(node.declaration, declaredTypes)  }}function extractRuntimeProps(node, props, declaredTypes, isProd) {  const members = node.type === 'TSTypeLiteral' ? node.members : node.body  for (const m of members) {    if (      (m.type === 'TSPropertySignature' || m.type === 'TSMethodSignature') &&      m.key.type === 'Identifier'    ) {      let type      if (m.type === 'TSMethodSignature') {        type = ['Function']      } else if (m.typeAnnotation) {        type = inferRuntimeType(m.typeAnnotation.typeAnnotation, declaredTypes)      }      props[m.key.name] = {        key: m.key.name,        required: !m.optional,        type: type || [`null`]      }    }  }}function inferRuntimeType(node, declaredTypes) {  switch (node.type) {    case 'TSStringKeyword':      return ['String']    case 'TSNumberKeyword':      return ['Number']    case 'TSBooleanKeyword':      return ['Boolean']    case 'TSObjectKeyword':      return ['Object']    case 'TSTypeLiteral':      // TODO (nice to have) generate runtime property validation      return ['Object']    case 'TSFunctionType':      return ['Function']    case 'TSArrayType':    case 'TSTupleType':      // TODO (nice to have) generate runtime element type/length checks      return ['Array']    case 'TSLiteralType':      switch (node.literal.type) {        case 'StringLiteral':          return ['String']        case 'BooleanLiteral':          return ['Boolean']        case 'NumericLiteral':        case 'BigIntLiteral':          return ['Number']        default:          return [`null`]      }    case 'TSTypeReference':      if (node.typeName.type === 'Identifier') {        if (declaredTypes[node.typeName.name]) {          return declaredTypes[node.typeName.name]        }        switch (node.typeName.name) {          case 'Array':          case 'Function':          case 'Object':          case 'Set':          case 'Map':          case 'WeakSet':          case 'WeakMap':          case 'Date':            return [node.typeName.name]          case 'Record':          case 'Partial':          case 'Readonly':          case 'Pick':          case 'Omit':          case 'Exclude':          case 'Extract':          case 'Required':          case 'InstanceType':            return ['Object']        }      }      return [`null`]    case 'TSParenthesizedType':      return inferRuntimeType(node.typeAnnotation, declaredTypes)    case 'TSUnionType':      return [        ...new Set(          [].concat(            ...node.types.map((t) => inferRuntimeType(t, declaredTypes))          )        )      ]    case 'TSIntersectionType':      return ['Object']    case 'TSSymbolKeyword':      return ['Symbol']    default:      return [`null`] // no runtime check  }}function toRuntimeTypeString(types) {  return types.length > 1 ? `[${types.join(', ')}]` : types[0]}function extractRuntimeEmits(node, emits) {  if (node.type === 'TSTypeLiteral' || node.type === 'TSInterfaceBody') {    const members = node.type === 'TSTypeLiteral' ? node.members : node.body    for (let t of members) {      if (t.type === 'TSCallSignatureDeclaration') {        extractEventNames(t.parameters[0], emits)      }    }    return  } else {    extractEventNames(node.parameters[0], emits)  }}function extractEventNames(eventName, emits) {  if (    eventName.type === 'Identifier' &&    eventName.typeAnnotation &&    eventName.typeAnnotation.type === 'TSTypeAnnotation'  ) {    const typeNode = eventName.typeAnnotation.typeAnnotation    if (typeNode.type === 'TSLiteralType') {      if (typeNode.literal.type !== 'UnaryExpression') {        emits.add(String(typeNode.literal.value))      }    } else if (typeNode.type === 'TSUnionType') {      for (const t of typeNode.types) {        if (          t.type === 'TSLiteralType' &&          t.literal.type !== 'UnaryExpression'        ) {          emits.add(String(t.literal.value))        }      }    }  }}function genRuntimeEmits(emits) {  return emits.size    ? `\n  emits: [${Array.from(emits)        .map((p) => JSON.stringify(p))        .join(', ')}],`    : ``}function isCallOf(node, test) {  return !!(    node &&    node.type === 'CallExpression' &&    node.callee.type === 'Identifier' &&    (typeof test === 'string'      ? node.callee.name === test      : test(node.callee.name))  )}function canNeverBeRef(node, userReactiveImport) {  if (isCallOf(node, userReactiveImport)) {    return true  }  switch (node.type) {    case 'UnaryExpression':    case 'BinaryExpression':    case 'ArrayExpression':    case 'ObjectExpression':    case 'FunctionExpression':    case 'ArrowFunctionExpression':    case 'UpdateExpression':    case 'ClassExpression':    case 'TaggedTemplateExpression':      return true    case 'SequenceExpression':      return canNeverBeRef(        node.expressions[node.expressions.length - 1],        userReactiveImport      )    default:      if (node.type.endsWith('Literal')) {        return true      }      return false  }}/** * Analyze bindings in normal `<script>` * Note that `compileScriptSetup` already analyzes bindings as part of its * compilation process so this should only be used on single `<script>` SFCs. */function analyzeScriptBindings(ast) {  for (const node of ast) {    if (      node.type === 'ExportDefaultDeclaration' &&      node.declaration.type === 'ObjectExpression'    ) {      return analyzeBindingsFromOptions(node.declaration)    }  }  return {}}function analyzeBindingsFromOptions(node) {  const bindings = {}  // #3270, #3275  // mark non-script-setup so we don't resolve components/directives from these  Object.defineProperty(bindings, '__isScriptSetup', {    enumerable: false,    value: false  })  for (const property of node.properties) {    if (      property.type === 'ObjectProperty' &&      !property.computed &&      property.key.type === 'Identifier'    ) {      // props      if (property.key.name === 'props') {        // props: ['foo']        // props: { foo: ... }        for (const key of getObjectOrArrayExpressionKeys(property.value)) {          bindings[key] = BindingTypes.PROPS        }      }      // inject      else if (property.key.name === 'inject') {        // inject: ['foo']        // inject: { foo: {} }        for (const key of getObjectOrArrayExpressionKeys(property.value)) {          bindings[key] = BindingTypes.OPTIONS        }      }      // computed & methods      else if (        property.value.type === 'ObjectExpression' &&        (property.key.name === 'computed' || property.key.name === 'methods')      ) {        // methods: { foo() {} }        // computed: { foo() {} }        for (const key of getObjectExpressionKeys(property.value)) {          bindings[key] = BindingTypes.OPTIONS        }      }    }    // setup & data    else if (      property.type === 'ObjectMethod' &&      property.key.type === 'Identifier' &&      (property.key.name === 'setup' || property.key.name === 'data')    ) {      for (const bodyItem of property.body.body) {        // setup() {        //   return {        //     foo: null        //   }        // }        if (          bodyItem.type === 'ReturnStatement' &&          bodyItem.argument &&          bodyItem.argument.type === 'ObjectExpression'        ) {          for (const key of getObjectExpressionKeys(bodyItem.argument)) {            bindings[key] =              property.key.name === 'setup'                ? BindingTypes.SETUP_MAYBE_REF                : BindingTypes.DATA          }        }      }    }  }  return bindings}function getObjectExpressionKeys(node) {  const keys = []  for (const prop of node.properties) {    if (      (prop.type === 'ObjectProperty' || prop.type === 'ObjectMethod') &&      !prop.computed    ) {      if (prop.key.type === 'Identifier') {        keys.push(prop.key.name)      } else if (prop.key.type === 'StringLiteral') {        keys.push(prop.key.value)      }    }  }  return keys}function getArrayExpressionKeys(node) {  const keys = []  for (const element of node.elements) {    if (element && element.type === 'StringLiteral') {      keys.push(element.value)    }  }  return keys}function getObjectOrArrayExpressionKeys(value) {  if (value.type === 'ArrayExpression') {    return getArrayExpressionKeys(value)  }  if (value.type === 'ObjectExpression') {    return getObjectExpressionKeys(value)  }  return []}function resolveTemplateUsageCheckString(sfc) {  const { content, ast } = sfc.template  const cached = templateUsageCheckCache.get(content)  if (cached) {    return cached  }  let code = ''  transform(createRoot([ast]), {    nodeTransforms: [      (node) => {        if (node.type === NodeTypes.ELEMENT) {          if (            !parserOptions.isNativeTag(node.tag) &&            !parserOptions.isBuiltInComponent(node.tag)          ) {            code += `,${camelize(node.tag)},${capitalize(camelize(node.tag))}`          }          for (let i = 0; i < node.props.length; i++) {            const prop = node.props[i]            if (prop.type === NodeTypes.DIRECTIVE) {              if (!isBuiltInDir(prop.name)) {                code += `,v${capitalize(camelize(prop.name))}`              }              if (prop.exp) {                code += `,${stripStrings(prop.exp.content)}`              }            }          }        } else if (node.type === NodeTypes.INTERPOLATION) {          code += `,${stripStrings(node.content.content)}`        }      }    ]  })  code += ';'  templateUsageCheckCache.set(content, code)  return code}function stripStrings(exp) {  return exp    .replace(/'[^']*'|"[^"]*"/g, '')    .replace(/`[^`]+`/g, stripTemplateString)}function isImportUsed(local, sfc) {  return new RegExp(    // #4274 escape $ since it's a special char in regex    // (and is the only regex special char that is valid in identifiers)    `[^\\w$_]${local.replace(/\$/g, '\\$')}[^\\w$_]`  ).test(resolveTemplateUsageCheckString(sfc))}/** * Note: this comparison assumes the prev/next script are already identical, * and only checks the special case where <script setup lang="ts"> unused import * pruning result changes due to template changes. */function hmrShouldReload(prevImports, next) {  if (    !next.scriptSetup ||    (next.scriptSetup.lang !== 'ts' && next.scriptSetup.lang !== 'tsx')  ) {    return false  }  // for each previous import, check if its used status remain the same based on  // the next descriptor's template  for (const key in prevImports) {    // if an import was previous unused, but now is used, we need to force    // reload so that the script now includes that import.    if (!prevImports[key].isUsedInTemplate && isImportUsed(key, next)) {      return true    }  }  return false}function compileTemplate(options) {  // ...省略直接使用现有的 compile  return doCompileTemplate(options)}function doCompileTemplate({  filename,  id,  scoped,  slotted,  inMap,  source,  ssr = false,  ssrCssVars,  isProd = false,  compiler,  compilerOptions = {},  transformAssetUrls}) {  const errors = []  const warnings = []  let nodeTransforms = []  if (isObject(transformAssetUrls)) {    const assetOptions = normalizeOptions(transformAssetUrls)    nodeTransforms = [      createAssetUrlTransformWithOptions(assetOptions),      createSrcsetTransformWithOptions(assetOptions)    ]  } else if (transformAssetUrls !== false) {    nodeTransforms = [transformAssetUrl, transformSrcset]  }  if (!id) {    id = ''  }  const shortId = id.replace(/^data-v-/, '')  const longId = `data-v-${shortId}`  let { code, ast, preamble, map } = baseCompile(source, {    mode: 'module',    prefixIdentifiers: true,    hoistStatic: true,    cacheHandlers: true,    ssrCssVars:      ssr && ssrCssVars && ssrCssVars.length        ? genCssVarsFromList(ssrCssVars, shortId, isProd)        : '',    scopeId: scoped ? longId : undefined,    slotted,    sourceMap: true,    ...compilerOptions,    nodeTransforms: nodeTransforms.concat(compilerOptions.nodeTransforms || []),    filename,    onError: (e) => errors.push(e),    onWarn: (w) => warnings.push(w)  })  return { code, ast, preamble, source, errors, tips, map }}const hash = require(process.env.NODE_LIB + '/hash-sum')const CSS_VARS_HELPER = `useCssVars`// match v-bind() with max 2-levels of nested parens.const cssVarRE = /v-bind\s*\(((?:[^)(]+|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gfunction genCssVarsFromList(vars, id, isProd) {  return `{\n  ${vars    .map((key) => `"${genVarName(id, key, isProd)}": (${key})`)    .join(',\n  ')}\n}`}function genVarName(id, raw, isProd) {  if (isProd) {    return hash(id + raw)  } else {    return `${id}-${raw.replace(/([^\w-])/g, '_')}`  }}function noramlizeExpression(exp) {  exp = exp.trim()  if (    (exp[0] === `'` && exp[exp.length - 1] === `'`) ||    (exp[0] === `"` && exp[exp.length - 1] === `"`)  ) {    return exp.slice(1, -1)  }  return exp}function parseCssVars(sfc) {  const vars = []  sfc.styles.forEach((style) => {    let match    // ignore v-bind() in comments /* ... */    const content = style.content.replace(/\/\*([\s\S]*?)\*\//g, '')    while ((match = cssVarRE.exec(content))) {      const variable = noramlizeExpression(match[1])      if (!vars.includes(variable)) {        vars.push(variable)      }    }  })  return vars}// for compileStyleconst cssVarsPlugin = (opts) => {  const { id, isProd } = opts  return {    postcssPlugin: 'vue-sfc-vars',    Declaration(decl) {      // rewrite CSS variables      if (cssVarRE.test(decl.value)) {        decl.value = decl.value.replace(cssVarRE, (_, $1) => {          return `var(--${genVarName(id, noramlizeExpression($1), isProd)})`        })      }    }  }}cssVarsPlugin.postcss = truefunction genCssVarsCode(vars, bindings, id, isProd) {  const varsExp = genCssVarsFromList(vars, id, isProd)  const exp = createSimpleExpression(varsExp, false)  const context = createTransformContext(createRoot([]), {    prefixIdentifiers: true,    inline: true,    bindingMetadata: bindings.__isScriptSetup === false ? undefined : bindings  })  const transformed = processExpression(exp, context)  const transformedString =    transformed.type === NodeTypes.SIMPLE_EXPRESSION      ? transformed.content      : transformed.children          .map((c) => {            return typeof c === 'string' ? c : c.content          })          .join('')  return `_${CSS_VARS_HELPER}(_ctx => (${transformedString}))`}// <script setup> already gets the calls injected as part of the transform// this is only for single normal <script>function genNormalScriptCssVarsCode(cssVars, bindings, id, isProd) {  return (    `\nimport { ${CSS_VARS_HELPER} as _${CSS_VARS_HELPER} } from 'vue'\n` +    `const __injectCSSVars__ = () => {\n${genCssVarsCode(      cssVars,      bindings,      id,      isProd    )}}\n` +    `const __setup__ = __default__.setup\n` +    `__default__.setup = __setup__\n` +    `  ? (props, ctx) => { __injectCSSVars__();return __setup__(props, ctx) }\n` +    `  : __injectCSSVars__\n`  )}// Special compiler macrosconst DEFINE_PROPS = 'defineProps'const DEFINE_EMITS = 'defineEmits'const DEFINE_EXPOSE = 'defineExpose'const WITH_DEFAULTS = 'withDefaults'const templateUsageCheckCache = createCache()// constantsconst DEFAULT_VAR = `__default__`const isBuiltInDir = makeMap(  `once,memo,if,else,else-if,slot,text,html,on,bind,model,show,cloak,is`)function compileScript(sfc, options) {  let { script, scriptSetup, source, filename } = sfc  // feature flags  // TODO remove support for deprecated options when out of experimental  const enableReactivityTransform =    !!options.reactivityTransform ||    !!options.refSugar ||    !!options.refTransform  const enablePropsTransform =    !!options.reactivityTransform || !!options.propsDestructureTransform  const isProd = !!options.isProd  const genSourceMap = options.sourceMap !== false  // ref 声明的变量  let refBindings  const scopeId = options.id ? options.id.replace(/^data-v-/, '') : ''  const cssVars = sfc.cssVars  const scriptLang = script && script.lang  const scriptSetupLang = scriptSetup && scriptSetup.lang  const isTS =    scriptLang === 'ts' ||    scriptLang === 'tsx' ||    scriptSetupLang === 'ts' ||    scriptSetupLang === 'tsx'  // resolve parser plugins  const plugins = []  if (!isTS || scriptLang === 'tsx' || scriptSetupLang === 'tsx') {    plugins.push('jsx')  }  if (options.babelParserPlugins) plugins.push(...options.babelParserPlugins)  if (isTS) plugins.push('typescript', 'decorators-legacy')  if (!scriptSetup) {    if (!script) {      throw new Error(`[@vue/compiler-sfc] SFC contains no <script> tags.`)    }    if (scriptLang && !isTS && scriptLang !== 'jsx') {      // do not process non js/ts script blocks      return script    }    try {      let content = script.content      let map = script.map      const scriptAst = babelParser.parse(content, {        plugins: [...plugins, ...babelPlugins],        sourceType: 'module'      }).program      const bindings = analyzeScriptBindings(scriptAst.body)      if (enableReactivityTransform && RT.shouldTransform(content)) {        const s = new MagicString(source)        const startOffset = script.loc.start.offset        const endOffset = script.loc.end.offset        const { importedHelpers } = RT.transformAST(scriptAst, s, startOffset)        if (importedHelpers.length) {          s.prepend(            `import { ${importedHelpers              .map((h) => `${h} as _${h}`)              .join(', ')} } from 'vue'\n`          )        }        s.remove(0, startOffset)        s.remove(endOffset, source.length)        content = s.toString()        if (genSourceMap) {          map = s.generateMap({            source: filename,            hires: true,            includeContent: true          })        }      }      if (cssVars.length) {        content = rewriteDefault(content, DEFAULT_VAR, plugins)        content += genNormalScriptCssVarsCode(          cssVars,          bindings,          scopeId,          isProd        )        content += `\nexport default ${DEFAULT_VAR}`      }      return {        ...script,        content,        map,        bindings,        scriptAst: scriptAst.body      }    } catch (e) {      // silently fallback if parse fails since user may be using custom      // babel syntax      return script    }  }  // script 和 script setup 的语言必须一致  if (script && scriptLang !== scriptSetupLang) {    throw new Error(      `[@vue/compiler-sfc] <script> and <script setup> must have the same ` +        `language type.`    )  }  // 只处理 js/ts script  if (scriptSetupLang && !isTS && scriptSetupLang !== 'jsx') {    return scriptSetup  }  // 变量，imports 都需要导出  const bindingMetadata = {}  const helperImports = new Set()  const userImports = Object.create(null)  const userImportAlias = Object.create(null)  const scriptBindings = Object.create(null)  const setupBindings = Object.create(null)  let defaultExport // export default  let hasDefinePropsCall = false // defineProps()  let hasDefineEmitCall = false // defineEmits()  let hasDefineExposeCall = false // defineExpose()  let propsRuntimeDecl // 属性声明  let propsRuntimeDefaults // 属性默认值  let propsDestructureDecl // 属性解构声明  let propsDestructureRestId // 属性解构的 ... 符号  let propsTypeDecl // 属性类型声明  let propsTypeDeclRaw  let propsIdentifier  let emitsRuntimeDecl  let emitsTypeDecl  let emitsTypeDeclRaw  let emitIdentifier  let hasAwait = false // 有没 await 符号，如果有则会转成 async setup  let hasInlinedSsrRenderFn = false  // props/emits declared via types  const typeDeclaredProps = {}  const typeDeclaredEmits = new Set()  // record declared types for runtime props type generation  const declaredTypes = {}  // props destructure data  const propsDestructuredBindings = Object.create(null)  // magic-string state  const s = new MagicString(source)  const startOffset = scriptSetup.loc.start.offset  const endOffset = scriptSetup.loc.end.offset  const scriptStartOffset = script && script.loc.start.offset  const scriptEndOffset = script && script.loc.end.offset  function helper(key) {    helperImports.add(key)    return `_${key}`  }  function parse(input, options, offset) {    try {      return babelParser.parse(input, options).program    } catch (e) {      e.message = `[@vue/compiler-sfc] ${e.message}\n\n${        sfc.filename      }\n${generateCodeFrame(source, e.pos + offset, e.pos + offset + 1)}`      throw e    }  }  function error(msg, node, end = node.end + startOffset) {    throw new Error(      `[@vue/compiler-sfc] ${msg}\n\n${sfc.filename}\n${generateCodeFrame(        source,        node.start + startOffset,        end      )}`    )  }  function registerUserImport(source, local, imported, isType, isFromSetup) {    if (source === 'vue' && imported) {      userImportAlias[imported] = local    }    let isUsedInTemplate = true    if (isTS && sfc.template && !sfc.template.src && !sfc.template.lang) {      isUsedInTemplate = isImportUsed(local, sfc)    }    userImports[local] = {      isType,      imported: imported || 'default',      source,      isFromSetup,      isUsedInTemplate    }  }  function processDefineProps(node, declId) {    if (!isCallOf(node, DEFINE_PROPS)) {      return false    }    if (hasDefinePropsCall) {      error(`duplicate ${DEFINE_PROPS}() call`, node)    }    hasDefinePropsCall = true    propsRuntimeDecl = node.arguments[0]    // call has type parameters - infer runtime types from it    if (node.typeParameters) {      if (propsRuntimeDecl) {        error(          `${DEFINE_PROPS}() cannot accept both type and non-type arguments ` +            `at the same time. Use one or the other.`,          node        )      }      propsTypeDeclRaw = node.typeParameters.params[0]      propsTypeDecl = resolveQualifiedType(        propsTypeDeclRaw,        (node) => node.type === 'TSTypeLiteral'      )      if (!propsTypeDecl) {        error(          `type argument passed to ${DEFINE_PROPS}() must be a literal type, ` +            `or a reference to an interface or literal type.`,          propsTypeDeclRaw        )      }    }    if (declId) {      if (enablePropsTransform && declId.type === 'ObjectPattern') {        propsDestructureDecl = declId        // props destructure - handle compilation sugar        for (const prop of declId.properties) {          if (prop.type === 'ObjectProperty') {            if (prop.computed) {              error(                `${DEFINE_PROPS}() destructure cannot use computed key.`,                prop.key              )            }            const propKey = prop.key.name            if (prop.value.type === 'AssignmentPattern') {              // default value { foo = 123 }              const { left, right } = prop.value              if (left.type !== 'Identifier') {                error(                  `${DEFINE_PROPS}() destructure does not support nested patterns.`,                  left                )              }              // store default value              propsDestructuredBindings[propKey] = {                local: left.name,                default: right              }            } else if (prop.value.type === 'Identifier') {              // simple destructure              propsDestructuredBindings[propKey] = {                local: prop.value.name              }            } else {              error(                `${DEFINE_PROPS}() destructure does not support nested patterns.`,                prop.value              )            }          } else {            // rest spread            propsDestructureRestId = prop.argument.name          }        }      } else {        propsIdentifier = scriptSetup.content.slice(declId.start, declId.end)      }    }    return true  }  function processWithDefaults(node, declId) {    if (!isCallOf(node, WITH_DEFAULTS)) {      return false    }    if (processDefineProps(node.arguments[0], declId)) {      if (propsRuntimeDecl) {        error(          `${WITH_DEFAULTS} can only be used with type-based ` +            `${DEFINE_PROPS} declaration.`,          node        )      }      if (propsDestructureDecl) {        error(          `${WITH_DEFAULTS}() is unnecessary when using destructure with ${DEFINE_PROPS}().\n` +            `Prefer using destructure default values, e.g. const { foo = 1 } = defineProps(...).`,          node.callee        )      }      propsRuntimeDefaults = node.arguments[1]      if (        !propsRuntimeDefaults ||        propsRuntimeDefaults.type !== 'ObjectExpression'      ) {        error(          `The 2nd argument of ${WITH_DEFAULTS} must be an object literal.`,          propsRuntimeDefaults || node        )      }    } else {      error(        `${WITH_DEFAULTS}' first argument must be a ${DEFINE_PROPS} call.`,        node.arguments[0] || node      )    }    return true  }  function processDefineEmits(node, declId) {    if (!isCallOf(node, DEFINE_EMITS)) {      return false    }    if (hasDefineEmitCall) {      error(`duplicate ${DEFINE_EMITS}() call`, node)    }    hasDefineEmitCall = true    emitsRuntimeDecl = node.arguments[0]    if (node.typeParameters) {      if (emitsRuntimeDecl) {        error(          `${DEFINE_EMITS}() cannot accept both type and non-type arguments ` +            `at the same time. Use one or the other.`,          node        )      }      emitsTypeDeclRaw = node.typeParameters.params[0]      emitsTypeDecl = resolveQualifiedType(        emitsTypeDeclRaw,        (node) =>          node.type === 'TSFunctionType' || node.type === 'TSTypeLiteral'      )      if (!emitsTypeDecl) {        error(          `type argument passed to ${DEFINE_EMITS}() must be a function type, ` +            `a literal type with call signatures, or a reference to the above types.`,          emitsTypeDeclRaw        )      }    }    if (declId) {      emitIdentifier = scriptSetup.content.slice(declId.start, declId.end)    }    return true  }  function resolveQualifiedType(node, qualifier) {    if (qualifier(node)) {      return node    }    if (      node.type === 'TSTypeReference' &&      node.typeName.type === 'Identifier'    ) {      const refName = node.typeName.name      const isQualifiedType = (node) => {        if (          node.type === 'TSInterfaceDeclaration' &&          node.id.name === refName        ) {          return node.body        } else if (          node.type === 'TSTypeAliasDeclaration' &&          node.id.name === refName &&          qualifier(node.typeAnnotation)        ) {          return node.typeAnnotation        } else if (node.type === 'ExportNamedDeclaration' && node.declaration) {          return isQualifiedType(node.declaration)        }      }      const body = scriptAst        ? [...scriptSetupAst.body, ...scriptAst.body]        : scriptSetupAst.body      for (const node of body) {        const qualified = isQualifiedType(node)        if (qualified) {          return qualified        }      }    }  }  function processDefineExpose(node) {    if (isCallOf(node, DEFINE_EXPOSE)) {      if (hasDefineExposeCall) {        error(`duplicate ${DEFINE_EXPOSE}() call`, node)      }      hasDefineExposeCall = true      return true    }    return false  }  /**   * await foo()   * -->   * ;(   *   ([__temp,__restore] = withAsyncContext(() => foo())),   *   await __temp,   *   __restore()   * )   *   * const a = await foo()   * -->   * const a = (   *   ([__temp, __restore] = withAsyncContext(() => foo())),   *   __temp = await __temp,   *   __restore(),   *   __temp   * )   */  function processAwait(node, needSemi, isStatement) {    const argumentStart =      node.argument.extra && node.argument.extra.parenthesized        ? node.argument.extra.parenStart        : node.argument.start    const argumentStr = source.slice(      argumentStart + startOffset,      node.argument.end + startOffset    )    const containsNestedAwait = /\bawait\b/.test(argumentStr)    s.overwrite(      node.start + startOffset,      argumentStart + startOffset,      `${needSemi ? `;` : ``}(\n  ([__temp,__restore] = ${helper(        `withAsyncContext`      )}(${containsNestedAwait ? `async ` : ``}() => `    )    s.appendLeft(      node.end + startOffset,      `)),\n  ${isStatement ? `` : `__temp = `}await __temp,\n  __restore()${        isStatement ? `` : `,\n  __temp`      }\n)`    )  }  /**   * check defaults. If the default object is an object literal with only   * static properties, we can directly generate more optimized default   * declarations. Otherwise we will have to fallback to runtime merging.   */  function hasStaticWithDefaults() {    return (      propsRuntimeDefaults &&      propsRuntimeDefaults.type === 'ObjectExpression' &&      propsRuntimeDefaults.properties.every(        (node) =>          (node.type === 'ObjectProperty' && !node.computed) ||          node.type === 'ObjectMethod'      )    )  }  function genRuntimeProps(props) {    const keys = Object.keys(props)    if (!keys.length) {      return ``    }    const hasStaticDefaults = hasStaticWithDefaults()    const scriptSetupSource = scriptSetup.content    let propsDecls = `{       ${keys         .map((key) => {           let defaultString           const destructured = genDestructuredDefaultValue(key)           if (destructured) {             defaultString = `default: ${destructured}`           } else if (hasStaticDefaults) {             const prop = propsRuntimeDefaults.properties.find(               (node) => node.key.name === key             )             if (prop) {               if (prop.type === 'ObjectProperty') {                 // prop has corresponding static default value                 defaultString = `default: ${scriptSetupSource.slice(                   prop.value.start,                   prop.value.end                 )}`               } else {                 defaultString = `default() ${scriptSetupSource.slice(                   prop.body.start,                   prop.body.end                 )}`               }             }           }           const { type, required } = props[key]           if (!isProd) {             return `${key}: { type: ${toRuntimeTypeString(               type             )}, required: ${required}${               defaultString ? `, ${defaultString}` : ``             } }`           } else if (             type.some(               (el) => el === 'Boolean' || (defaultString && el === 'Function')             )           ) {             // #4783 production: if boolean or defaultString and function exists, should keep the type.             return `${key}: { type: ${toRuntimeTypeString(type)}${               defaultString ? `, ${defaultString}` : ``             } }`           } else {             // production: checks are useless             return `${key}: ${defaultString ? `{ ${defaultString} }` : 'null'}`           }         })         .join(',\n    ')}\n  }`    if (propsRuntimeDefaults && !hasStaticDefaults) {      propsDecls = `${helper('mergeDefaults')}(${propsDecls}, ${source.slice(        propsRuntimeDefaults.start + startOffset,        propsRuntimeDefaults.end + startOffset      )})`    }    return `\n  props: ${propsDecls},`  }  function genDestructuredDefaultValue(key) {    const destructured = propsDestructuredBindings[key]    if (destructured && destructured.default) {      const value = scriptSetup.content.slice(        destructured.default.start,        destructured.default.end      )      const isLiteral = destructured.default.type.endsWith('Literal')      return isLiteral ? value : `() => ${value}`    }  }  function genSetupPropsType(node) {    const scriptSetupSource = scriptSetup.content    if (hasStaticWithDefaults()) {      // if withDefaults() is used, we need to remove the optional flags      // on props that have default values      let res = `{ `      const members = node.type === 'TSTypeLiteral' ? node.members : node.body      for (const m of members) {        if (          (m.type === 'TSPropertySignature' ||            m.type === 'TSMethodSignature') &&          m.typeAnnotation &&          m.key.type === 'Identifier'        ) {          if (            propsRuntimeDefaults.properties.some(              (p) => p.key.name === m.key.name            )          ) {            res +=              m.key.name +              (m.type === 'TSMethodSignature' ? '()' : '') +              scriptSetupSource.slice(                m.typeAnnotation.start,                m.typeAnnotation.end              ) +              ', '          } else {            res += scriptSetupSource.slice(m.start, m.typeAnnotation.end) + `, `          }        }      }      return (res.length ? res.slice(0, -2) : res) + ` }`    } else {      return scriptSetupSource.slice(node.start, node.end)    }  }  function processNormalScript() {    let scriptAst    if (script) {      scriptAst = parse(        script.content,        {          plugins,          sourceType: 'module'        },        scriptStartOffset      )      for (const node of scriptAst.body) {        if (node.type === 'ImportDeclaration') {          // record imports for dedupe          for (const specifier of node.specifiers) {            const imported =              specifier.type === 'ImportSpecifier' &&              specifier.imported.type === 'Identifier' &&              specifier.imported.name            registerUserImport(              node.source.value,              specifier.local.name,              imported,              node.importKind === 'type' ||                (specifier.type === 'ImportSpecifier' &&                  specifier.importKind === 'type'),              false            )          }        } else if (node.type === 'ExportDefaultDeclaration') {          // export default          defaultExport = node          // export default { ... } --> const __default__ = { ... }          const start = node.start + scriptStartOffset          const end = node.declaration.start + scriptStartOffset          s.overwrite(start, end, `const ${DEFAULT_VAR} = `)        } else if (node.type === 'ExportNamedDeclaration') {          const defaultSpecifier = node.specifiers.find(            (s) =>              s.exported.type === 'Identifier' && s.exported.name === 'default'          )          if (defaultSpecifier) {            defaultExport = node            // 1. remove specifier            if (node.specifiers.length > 1) {              s.remove(                defaultSpecifier.start + scriptStartOffset,                defaultSpecifier.end + scriptStartOffset              )            } else {              s.remove(                node.start + scriptStartOffset,                node.end + scriptStartOffset              )            }            if (node.source) {              // export { x as default } from './x'              // rewrite to `import { x as __default__ } from './x'` and              // add to top              s.prepend(                `import { ${defaultSpecifier.local.name} as ${DEFAULT_VAR} } from '${node.source.value}'\n`              )            } else {              // export { x as default }              // rewrite to `const __default__ = x` and move to end              s.appendLeft(                scriptEndOffset,                `\nconst ${DEFAULT_VAR} = ${defaultSpecifier.local.name}\n`              )            }          }          if (node.declaration) {            walkDeclaration(node.declaration, scriptBindings, userImportAlias)          }        } else if (          (node.type === 'VariableDeclaration' ||            node.type === 'FunctionDeclaration' ||            node.type === 'ClassDeclaration' ||            node.type === 'TSEnumDeclaration') &&          !node.declare        ) {          walkDeclaration(node, scriptBindings, userImportAlias)        }      }      // apply reactivity transform      if (enableReactivityTransform && RT.shouldTransform(script.content)) {        const { rootRefs, importedHelpers } = transformAST(          scriptAst,          s,          scriptStartOffset        )        refBindings = rootRefs        for (const h of importedHelpers) {          helperImports.add(h)        }      }      // <script> after <script setup>      // we need to move the block up so that `const __default__` is      // declared before being used in the actual component definition      if (scriptStartOffset > startOffset) {        s.move(scriptStartOffset, scriptEndOffset, 0)      }    }    return scriptAst  }  function processSetupScript() {    const scriptSetupAst = babelParser.parse(      scriptSetup.content,      {        plugins: [          ...plugins,          ...babelPlugins,          // allow top level await but only inside <script setup>          'topLevelAwait'        ],        sourceType: 'module'      },      startOffset    )    for (const node of scriptSetupAst.body) {      const start = node.start + startOffset      let end = node.end + startOffset      // locate comment      if (node.trailingComments && node.trailingComments.length > 0) {        const lastCommentNode =          node.trailingComments[node.trailingComments.length - 1]        end = lastCommentNode.end + startOffset      }      // locate the end of whitespace between this statement and the next      while (end <= source.length) {        if (!/\s/.test(source.charAt(end))) {          break        }        end++      }      // (Dropped) `ref: x` bindings      if (        node.type === 'LabeledStatement' &&        node.label.name === 'ref' &&        node.body.type === 'ExpressionStatement'      ) {        error(          `ref sugar using the label syntax was an experimental proposal and ` +            `has been dropped based on community feedback. Please check out ` +            `the new proposal at https://github.com/vuejs/rfcs/discussions/369`,          node        )      }      if (node.type === 'ImportDeclaration') {        // import declarations are moved to top        s.move(start, end, 0)        // dedupe imports        let removed = 0        const removeSpecifier = (i) => {          const removeLeft = i > removed          removed++          const current = node.specifiers[i]          const next = node.specifiers[i + 1]          s.remove(            removeLeft              ? node.specifiers[i - 1].end + startOffset              : current.start + startOffset,            next && !removeLeft              ? next.start + startOffset              : current.end + startOffset          )        }        for (let i = 0; i < node.specifiers.length; i++) {          const specifier = node.specifiers[i]          const local = specifier.local.name          const imported =            specifier.type === 'ImportSpecifier' &&            specifier.imported.type === 'Identifier' &&            specifier.imported.name          const source = node.source.value          const existing = userImports[local]          if (            source === 'vue' &&            (imported === DEFINE_PROPS ||              imported === DEFINE_EMITS ||              imported === DEFINE_EXPOSE)          ) {            removeSpecifier(i)          } else if (existing) {            if (existing.source === source && existing.imported === imported) {              // already imported in <script setup>, dedupe              removeSpecifier(i)            } else {              error(`different imports aliased to same local name.`, specifier)            }          } else {            registerUserImport(              source,              local,              imported,              node.importKind === 'type' ||                (specifier.type === 'ImportSpecifier' &&                  specifier.importKind === 'type'),              true            )          }        }        if (node.specifiers.length && removed === node.specifiers.length) {          s.remove(node.start + startOffset, node.end + startOffset)        }      }      if (node.type === 'ExpressionStatement') {        // process `defineProps` and `defineEmit(s)` calls        if (          processDefineProps(node.expression) ||          processDefineEmits(node.expression) ||          processWithDefaults(node.expression)        ) {          s.remove(node.start + startOffset, node.end + startOffset)        } else if (processDefineExpose(node.expression)) {          // defineExpose({}) -> expose({})          const callee = node.expression.callee          s.overwrite(            callee.start + startOffset,            callee.end + startOffset,            'expose'          )        }      }      if (node.type === 'VariableDeclaration' && !node.declare) {        const total = node.declarations.length        let left = total        for (let i = 0; i < total; i++) {          const decl = node.declarations[i]          if (decl.init) {            // defineProps / defineEmits            const isDefineProps =              processDefineProps(decl.init, decl.id) ||              processWithDefaults(decl.init, decl.id)            const isDefineEmits = processDefineEmits(decl.init, decl.id)            if (isDefineProps || isDefineEmits) {              if (left === 1) {                s.remove(node.start + startOffset, node.end + startOffset)              } else {                let start = decl.start + startOffset                let end = decl.end + startOffset                if (i < total - 1) {                  // not the last one, locate the start of the next                  end = node.declarations[i + 1].start + startOffset                } else {                  // last one, locate the end of the prev                  start = node.declarations[i - 1].end + startOffset                }                s.remove(start, end)                left--              }            }          }        }      }      // walk declarations to record declared bindings      if (        (node.type === 'VariableDeclaration' ||          node.type === 'FunctionDeclaration' ||          node.type === 'ClassDeclaration') &&        !node.declare      ) {        walkDeclaration(node, setupBindings, userImportAlias)      }      // walk statements & named exports / variable declarations for top level      // await      if (        (node.type === 'VariableDeclaration' && !node.declare) ||        node.type.endsWith('Statement')      ) {        walk(node, {          enter(child, parent) {            if (isFunctionType(child)) {              this.skip()            }            if (child.type === 'AwaitExpression') {              hasAwait = true              const needsSemi = scriptSetupAst.body.some((n) => {                return (                  n.type === 'ExpressionStatement' && n.start === child.start                )              })              processAwait(                child,                needsSemi,                parent.type === 'ExpressionStatement'              )            }          }        })      }      if (        (node.type === 'ExportNamedDeclaration' &&          node.exportKind !== 'type') ||        node.type === 'ExportAllDeclaration' ||        node.type === 'ExportDefaultDeclaration'      ) {        error(          `<script setup> cannot contain ES module exports. ` +            `If you are using a previous version of <script setup>, please ` +            `consult the updated RFC at https://github.com/vuejs/rfcs/pull/227.`,          node        )      }      if (isTS) {        // runtime enum        if (node.type === 'TSEnumDeclaration') {          registerBinding(setupBindings, node.id, BindingTypes.SETUP_CONST)        }        // move all Type declarations to outer scope        if (          node.type.startsWith('TS') ||          (node.type === 'ExportNamedDeclaration' &&            node.exportKind === 'type') ||          (node.type === 'VariableDeclaration' && node.declare)        ) {          recordType(node, declaredTypes)          s.move(start, end, 0)        }      }    }    return scriptSetupAst  }  function applyReactivityTransform() {    if (      (enableReactivityTransform &&        // normal <script> had ref bindings that maybe used in <script setup>        (refBindings || RT.shouldTransform(scriptSetup.content))) ||      propsDestructureDecl    ) {      const { rootRefs, importedHelpers } = transformAST(        scriptSetupAst,        s,        startOffset,        refBindings,        propsDestructuredBindings      )      refBindings = refBindings ? [...refBindings, ...rootRefs] : rootRefs      for (const h of importedHelpers) {        helperImports.add(h)      }    }  }  function extractRuntimePropsEmits() {    if (propsTypeDecl) {      extractRuntimeProps(        propsTypeDecl,        typeDeclaredProps,        declaredTypes,        isProd      )    }    if (emitsTypeDecl) {      extractRuntimeEmits(emitsTypeDecl, typeDeclaredEmits)    }  }  function checkUseOptions() {    checkInvalidScopeReference(propsRuntimeDecl, DEFINE_PROPS)    checkInvalidScopeReference(propsRuntimeDefaults, DEFINE_PROPS)    checkInvalidScopeReference(propsDestructureDecl, DEFINE_PROPS)    checkInvalidScopeReference(emitsRuntimeDecl, DEFINE_PROPS)  }  function removeNonScriptContent() {    if (script) {      if (startOffset < scriptStartOffset) {        // <script setup> before <script>        s.remove(0, startOffset)        s.remove(endOffset, scriptStartOffset)        s.remove(scriptEndOffset, source.length)      } else {        // <script> before <script setup>        s.remove(0, scriptStartOffset)        s.remove(scriptEndOffset, startOffset)        s.remove(endOffset, source.length)      }    } else {      // only <script setup>      s.remove(0, startOffset)      s.remove(endOffset, source.length)    }  }  function analyzeBindingMetadata() {    if (scriptAst) {      Object.assign(bindingMetadata, analyzeScriptBindings(scriptAst.body))    }    if (propsRuntimeDecl) {      for (const key of getObjectOrArrayExpressionKeys(propsRuntimeDecl)) {        bindingMetadata[key] = BindingTypes.PROPS      }    }    for (const key in typeDeclaredProps) {      bindingMetadata[key] = BindingTypes.PROPS    }    // props aliases    if (propsDestructureDecl) {      if (propsDestructureRestId) {        bindingMetadata[propsDestructureRestId] = BindingTypes.SETUP_CONST      }      for (const key in propsDestructuredBindings) {        const { local } = propsDestructuredBindings[key]        if (local !== key) {          bindingMetadata[local] = BindingTypes.PROPS_ALIASED          ;(bindingMetadata.__propsAliases ||            (bindingMetadata.__propsAliases = {}))[local] = key        }      }    }    for (const [key, { isType, imported, source }] of Object.entries(      userImports    )) {      if (isType) continue      bindingMetadata[key] =        (imported === 'default' && source.endsWith('.vue')) || source === 'vue'          ? BindingTypes.SETUP_CONST          : BindingTypes.SETUP_MAYBE_REF    }    for (const key in scriptBindings) {      bindingMetadata[key] = scriptBindings[key]    }    for (const key in setupBindings) {      bindingMetadata[key] = setupBindings[key]    }    // known ref bindings    if (refBindings) {      for (const key of refBindings) {        bindingMetadata[key] = BindingTypes.SETUP_REF      }    }  }  function injectUseCssVarsCalls() {    if (cssVars.length) {      helperImports.add(CSS_VARS_HELPER)      helperImports.add('unref')      s.prependRight(        startOffset,        `\n${genCssVarsCode(cssVars, bindingMetadata, scopeId, isProd)}\n`      )    }  }  function finalizeSetupArgumentSignature() {    if (propsTypeDecl) {      // mark as any and only cast on assignment      // since the user defined complex types may be incompatible with the      // inferred type from generated runtime declarations      args += `: any`    }    // inject user assignment of props    // we use a default __props so that template expressions referencing props    // can use it directly    if (propsIdentifier) {      s.prependLeft(        startOffset,        `\nconst ${propsIdentifier} = __props${          propsTypeDecl ? ` as ${genSetupPropsType(propsTypeDecl)}` : ``        }\n`      )    }    if (propsDestructureRestId) {      s.prependLeft(        startOffset,        `\nconst ${propsDestructureRestId} = ${helper(          `createPropsRestProxy`        )}(__props, ${JSON.stringify(          Object.keys(propsDestructuredBindings)        )})\n`      )    }    // inject temp variables for async context preservation    if (hasAwait) {      const any = isTS ? `: any` : ``      s.prependLeft(startOffset, `\nlet __temp${any}, __restore${any}\n`)    }    const destructureElements =      hasDefineExposeCall || !options.inlineTemplate ? [`expose`] : []    if (emitIdentifier) {      destructureElements.push(        emitIdentifier === `emit` ? `emit` : `emit: ${emitIdentifier}`      )    }    if (destructureElements.length) {      args += `, { ${destructureElements.join(', ')} }`      if (emitsTypeDecl) {        args += `: { emit: (${scriptSetup.content.slice(          emitsTypeDecl.start,          emitsTypeDecl.end        )}), expose: any, slots: any, attrs: any }`      }    }  }  function finalizeSetupArgumentSignature() {    if (propsTypeDecl) {      // mark as any and only cast on assignment      // since the user defined complex types may be incompatible with the      // inferred type from generated runtime declarations      args += `: any`    }    // inject user assignment of props    // we use a default __props so that template expressions referencing props    // can use it directly    if (propsIdentifier) {      s.prependLeft(        startOffset,        `\nconst ${propsIdentifier} = __props${          propsTypeDecl ? ` as ${genSetupPropsType(propsTypeDecl)}` : ``        }\n`      )    }    if (propsDestructureRestId) {      s.prependLeft(        startOffset,        `\nconst ${propsDestructureRestId} = ${helper(          `createPropsRestProxy`        )}(__props, ${JSON.stringify(          Object.keys(propsDestructuredBindings)        )})\n`      )    }    // inject temp variables for async context preservation    if (hasAwait) {      const any = isTS ? `: any` : ``      s.prependLeft(startOffset, `\nlet __temp${any}, __restore${any}\n`)    }    const destructureElements =      hasDefineExposeCall || !options.inlineTemplate ? [`expose`] : []    if (emitIdentifier) {      destructureElements.push(        emitIdentifier === `emit` ? `emit` : `emit: ${emitIdentifier}`      )    }    if (destructureElements.length) {      args += `, { ${destructureElements.join(', ')} }`      if (emitsTypeDecl) {        args += `: { emit: (${scriptSetup.content.slice(          emitsTypeDecl.start,          emitsTypeDecl.end        )}), expose: any, slots: any, attrs: any }`      }    }  }  function generateReturnStatement() {    if (options.inlineTemplate) {      if (sfc.template && !sfc.template.src) {        if (options.templateOptions && options.templateOptions.ssr) {          hasInlinedSsrRenderFn = true        }        // inline render function mode - we are going to compile the template and        // inline it right here        const { code, ast, preamble, tips, errors } = compileTemplate({          filename,          source: sfc.template.content,          inMap: sfc.template.map,          ...options.templateOptions,          id: scopeId,          scoped: sfc.styles.some((s) => s.scoped),          isProd: options.isProd,          ssrCssVarscssVars,          compilerOptions: {            ...(options.templateOptions &&              options.templateOptions.compilerOptions),            inline: true,            isTS,            bindingMetadata          }        })        const err = errors[0]        if (typeof err === 'string') {          throw new Error(err)        } else if (err) {          if (err.loc) {            err.message +=              `\n\n` +              sfc.filename +              '\n' +              generateCodeFrame(                source,                err.loc.start.offset,                err.loc.end.offset              ) +              `\n`          }          throw err        }        if (preamble) {          s.prepend(preamble)        }        // avoid duplicated unref import        // as this may get injected by the render function preamble OR the        // css vars codegen        if (ast && ast.helpers.includes(UNREF)) {          helperImports.delete('unref')        }        returned = code      } else {        returned = `() => {}`      }    } else {      // return bindings from script and script setup      const allBindings = {        ...scriptBindings,        ...setupBindings      }      for (const key in userImports) {        if (!userImports[key].isType && userImports[key].isUsedInTemplate) {          allBindings[key] = true        }      }      returned = `{ ${Object.keys(allBindings).join(', ')} }`    }    if (!options.inlineTemplate) {      // in non-inline mode, the `__isScriptSetup: true` flag is used by      // componentPublicInstance proxy to allow properties that start with $ or _      s.appendRight(        endOffset,        `\nconst __returned__ = ${returned}\n` +          `Object.defineProperty(__returned__, '__isScriptSetup', { enumerable: false, value: true })\n` +          `return __returned__` +          `\n}\n\n`      )    } else {      s.appendRight(endOffset, `\nreturn ${returned}\n}\n\n`)    }  }  function finalizeDefaultExport() {    let runtimeOptions = ``    if (hasInlinedSsrRenderFn) {      runtimeOptions += `\n  __ssrInlineRender: true,`    }    if (propsRuntimeDecl) {      let declCode = scriptSetup.content        .slice(propsRuntimeDecl.start, propsRuntimeDecl.end)        .trim()      if (propsDestructureDecl) {        const defaults = []        for (const key in propsDestructuredBindings) {          const d = genDestructuredDefaultValue(key)          if (d) defaults.push(`${key}: ${d}`)        }        if (defaults.length) {          declCode = `${helper(            `mergeDefaults`          )}(${declCode}, {\n  ${defaults.join(',\n  ')}\n})`        }      }      runtimeOptions += `\n  props: ${declCode},`    } else if (propsTypeDecl) {      runtimeOptions += genRuntimeProps(typeDeclaredProps)    }    if (emitsRuntimeDecl) {      runtimeOptions += `\n  emits: ${scriptSetup.content        .slice(emitsRuntimeDecl.start, emitsRuntimeDecl.end)        .trim()},`    } else if (emitsTypeDecl) {      runtimeOptions += genRuntimeEmits(typeDeclaredEmits)    }    // <script setup> components are closed by default. If the user did not    // explicitly call `defineExpose`, call expose() with no args.    const exposeCall =      hasDefineExposeCall || options.inlineTemplate ? `` : `  expose();\n`    // wrap setup code with function.    if (isTS) {      // for TS, make sure the exported type is still valid type with      // correct props information      // we have to use object spread for types to be merged properly      // user's TS setting should compile it down to proper targets      // export default defineComponent({ ...__default__, ... })      const def = defaultExport ? `\n  ...${DEFAULT_VAR},` : ``      s.prependLeft(        startOffset,        `\nexport default /*#__PURE__*/${helper(          `defineComponent`        )}({${def}${runtimeOptions}\n  ${          hasAwait ? `async ` : ``        }setup(${args}) {\n${exposeCall}`      )      s.appendRight(endOffset, `})`)    } else {      if (defaultExport) {        // without TS, can't rely on rest spread, so we use Object.assign        // export default Object.assign(__default__, { ... })        s.prependLeft(          startOffset,          `\nexport default /*#__PURE__*/Object.assign(${DEFAULT_VAR}, {${runtimeOptions}\n  ` +            `${hasAwait ? `async ` : ``}setup(${args}) {\n${exposeCall}`        )        s.appendRight(endOffset, `})`)      } else {        s.prependLeft(          startOffset,          `\nexport default {${runtimeOptions}\n  ` +            `${hasAwait ? `async ` : ``}setup(${args}) {\n${exposeCall}`        )        s.appendRight(endOffset, `}`)      }    }  }  function finalizeVueHelperImports() {    if (helperImports.size > 0) {      s.prepend(        `import { ${[...helperImports]          .map((h) => `${h} as _${h}`)          .join(', ')} } from 'vue'\n`      )    }  }  // 1. process normal <script> first if it exists  let scriptAst = processNormalScript()  // 2. parse <script setup> and  walk over top level statements  const scriptSetupAst = processSetupScript()  // 3. Apply reactivity transform  applyReactivityTransform()  // 4. extract runtime props/emits code from setup context type  extractRuntimePropsEmits()  // 5. check useOptions args to make sure it doesn't reference setup scope  // variables  checkUseOptions()  // 6. remove non-script content  removeNonScriptContent()  // 7. analyze binding metadata  analyzeBindingMetadata()  // 8. inject `useCssVars` calls  injectUseCssVarsCalls()  // 9. finalize setup() argument signature  let args = `__props`  finalizeSetupArgumentSignature()  // 10. generate return statement  let returned  generateReturnStatement()  // 11. finalize default export  let runtimeOptions = ''  finalizeDefaultExport()  // 12. finalize Vue helper imports  finalizeVueHelperImports()  s.trim()  return {    ...scriptSetup,    bindings: bindingMetadata,    imports: userImports,    content: s.toString(),    map: genSourceMap      ? s.generateMap({          source: filename,          hires: true,          includeContent: true        })      : undefined,    scriptAst: scriptAst?.body,    scriptSetupAst: scriptSetupAst?.body  }}  const mockId = 'xxxxxxxx'function compileSFCScript(src, options) {  const { descriptor } = babelParser.parse(src)  return compileScript(descriptor, {    ...options,    id: mockId  })}const result = compileSFCScript(`      <script setup>      import { x } from './x'      let a = 1      const b = 2      function c() {}      class d {}      </script>      <script>      import { xx } from './x'      let aa = 1      const bb = 2      function cc() {}      class dd {}      </script>      `)console.log(result)