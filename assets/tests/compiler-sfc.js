/** jsx?|tsx? file header */let __BROWSER__ = typeof window !== 'undefined'let logs = {},  currentLogKey = 'cc'const babelPlugins = ['typescript']let w = {}let debugEle = nullif (__BROWSER__) {  w = typeof window !== 'undefined' ? window : {}}w.log = (msg, isLine = false) => {  if (debugEle) {    const cls = ['debug', isLine ? 'line' : ''].filter(Boolen)    ele.innerHTML = `${debugEl.innerHTML}<pre class="${cls.join(' ')}"><code>${      typeof msg === 'object' ? syntaxHighlight(msg) : msg    }</code></pre>`    return ele.innerHTML  }}function syntaxHighlight(json) {  if (typeof json != 'string') {    json = JSON.stringify(json, undefined, 2)  }  json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')  return json.replace(    /("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g,    function (match) {      var cls = 'number'      if (/^"/.test(match)) {        if (/:$/.test(match)) {          cls = 'key'        } else {          cls = 'string'        }      } else if (/true|false/.test(match)) {        cls = 'boolean'      } else if (/null/.test(match)) {        cls = 'null'      }      return '<span class="' + cls + '">' + match + '</span>'    }  )}let babelParserif (!__BROWSER__) {  babelParser = require(process.env.NODE_LIB + '/@babel/parser')}// The default decoder only provides escapes for characters reserved as part of// the template syntax, and is only used if the custom renderer did not provide// a platform-specific decoder.const decodeRE = /&(gt|lt|amp|apos|quot);/gconst decodeMap = {  gt: '>',  lt: '<',  amp: '&',  apos: "'",  quot: '"'}const EMPTY_OBJ = {}const NO = () => falseconst NOOP = () => {}const locStub = {  source: '',  start: { line: 1, column: 1, offset: 0 },  end: { line: 1, column: 1, offset: 0 }}const ConstantTypes = {  NOT_CONSTANT: 0,  CAN_SKIP_PATCH: 1,  CAN_HOIST: 2,  CAN_STRINGIFY: 3}const ElementTypes = {  ELEMENT: 0,  COMPONENT: 1,  SLOT: 2,  TEMPLATE: 3}const Namespaces = {  HTML: 0}const NodeTypes = {  ROOT: 0,  ELEMENT: 1,  TEXT: 2,  COMMENT: 3,  SIMPLE_EXPRESSION: 4,  INTERPOLATION: 5,  ATTRIBUTE: 6,  DIRECTIVE: 7,  // containers  COMPOUND_EXPRESSION: 8,  IF: 9,  IF_BRANCH: 10,  FOR: 11,  TEXT_CALL: 12,  // codegen  VNODE_CALL: 13,  JS_CALL_EXPRESSION: 14,  JS_OBJECT_EXPRESSION: 15,  JS_PROPERTY: 16,  JS_ARRAY_EXPRESSION: 17,  JS_FUNCTION_EXPRESSION: 18,  JS_CONDITIONAL_EXPRESSION: 19,  JS_CACHE_EXPRESSION: 20,  // ssr codegen  JS_BLOCK_STATEMENT: 21,  JS_TEMPLATE_LITERAL: 22,  JS_IF_STATEMENT: 23,  JS_ASSIGNMENT_EXPRESSION: 24,  JS_SEQUENCE_EXPRESSION: 25,  JS_RETURN_STATEMENT: 26}const __DEV__ = trueconst defaultParserOptions = {  delimiters: [`{{`, `}}`],  getNamespace: () => Namespaces.HTML,  getTextMode: () => TextModes.DATA,  isVoidTag: NO,  isPreTag: NO,  isCustomElement: NO,  decodeEntities: (rawText) =>    rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),  onError: defaultOnError,  onWarn: defaultOnWarn,  comments: __DEV__}const TagType = {  Start: 0,  End: 1}const TextModes = {  DATA: 0,  RCDATA: 1,  RAWTEXT: 2,  CDATA: 3,  ATTRIBUTE_VALUE: 4}let debugOn = trueconst log = (fn, message) => {  if (debugOn) {    if (message === undefined) {      console.log(fn)    } else {      console.log(`[${fn}] ${message}`)    }  }}const logOn = () => (debugOn = true)const logOff = () => (debugOn = false)const logEnd = (hint = 'END') => {  const m = `--------- ${hint} ---------`  if (debugOn) pushLog(m, 'title')  return m}const logBr = () => console.log('\n')let debugTraverseOn = falseconst logTraverseOn = () => (debugTraverseOn = true)const logTraverseOff = () => (debugTraverseOn = false)const logg = (hint, ...msg) => {  if (!debugTraverseOn && hint === 'traverseNode') return  if (debugOn) {    const m = logEnd(hint)    msg.forEach((m) => pushLog(m))  }}function pushLog(m, type = 'normal') {  ;(logs[currentLogKey] || (logs[currentLogKey] = [])).push({ value: m, type })  log(m)}function clearLog(key) {  if (key) {    logs[key] = []  } else {    logs = {}  }}const extend = Object.assignfunction defaultOnError(error) {  throw error}function defaultOnWarn(msg) {  __DEV__ && console.warn(`[Vue warn] ${msg.message}`)}function makeMap(str, expectsLowerCase) {  const map = Object.create(null)  const list = str.split(',')  for (let i = 0; i < list.length; i++) {    map[list[i]] = true  }  return expectsLowerCase    ? (val) => !!map[val.toLowerCase()]    : (val) => !!map[val]}const hasOwnProperty = Object.prototype.hasOwnPropertyconst hasOwn = (val, key) => hasOwnProperty.call(val, key)const isArray = Array.isArrayconst isMap = (val) => toTypeString(val) === '[object Map]'const isSet = (val) => toTypeString(val) === '[object Set]'const isDate = (val) => val instanceof Dateconst isFunction = (val) => typeof val === 'function'const isString = (val) => typeof val === 'string'const isSymbol = (val) => typeof val === 'symbol'const isObject = (val) => val !== null && typeof val === 'object'const onRE = /^on[^a-z]/const isOn = (key) => onRE.test(key)const isPromise = (val) => {  return isObject(val) && isFunction(val.then) && isFunction(val.catch)}const objectToString = Object.prototype.toStringconst toTypeString = (value) => objectToString.call(value)const toRawType = (value) => {  // extract "RawType" from strings like "[object RawType]"  return toTypeString(value).slice(8, -1)}function isText(node) {  return node.type === NodeTypes.INTERPOLATION || node.type === NodeTypes.TEXT}const isPlainObject = (val) => toTypeString(val) === '[object Object]'const isIntegerKey = (key) =>  isString(key) &&  key !== 'NaN' &&  key[0] !== '-' &&  '' + parseInt(key, 10) === keyconst isReservedProp = /*#__PURE__*/ makeMap(  // the leading comma is intentional so empty string "" is also included  ',key,ref,ref_for,ref_key,' +    'onVnodeBeforeMount,onVnodeMounted,' +    'onVnodeBeforeUpdate,onVnodeUpdated,' +    'onVnodeBeforeUnmount,onVnodeUnmounted')const GLOBALS_WHITE_LISTED =  'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +  'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +  'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt'const isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED)const nonIdentifierRE = /^\d|[^\$\w]/const isSimpleIdentifier = (name) => !nonIdentifierRE.test(name)const isBuiltInDirective = /*#__PURE__*/ makeMap(  'bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo')function getCursor(context) {  const { column, line, offset } = context  return { column, line, offset }}function getSelection(context, start, end) {  end = end || getCursor(context)  return {    start,    end,    source: context.originalSource.slice(start.offset, end.offset)  }}function last(xs) {  return xs[xs.length - 1]}function startsWith(source, searchString) {  return source.startsWith(searchString)}function advancePositionWithMutation(  pos,  source,  numberOfCharacters = source.length) {  let linesCount = 0  let lastNewLinePos = -1  for (let i = 0; i < numberOfCharacters; i++) {    if (source.charCodeAt(i) === 10 /* newline char code */) {      linesCount++      lastNewLinePos = i    }  }  pos.offset += numberOfCharacters  pos.line += linesCount  pos.column =    lastNewLinePos === -1      ? pos.column + numberOfCharacters      : numberOfCharacters - lastNewLinePos  return pos}function advancePositionWithClone(  pos,  source,  numberOfCharacters = source.length) {  return advancePositionWithMutation(    extend({}, pos),    source,    numberOfCharacters  )}function advanceBy(context, numberOfCharacters) {  const { source } = context  advancePositionWithMutation(context, source, numberOfCharacters)  context.source = source.slice(numberOfCharacters)}function advanceSpaces(context) {  const match = /^[\t\r\n\f ]+/.exec(context.source)  if (match) {    advanceBy(context, match[0].length)  }}function getNewPosition(context, start, numberOfCharacters) {  return advancePositionWithClone(    start,    context.originalSource.slice(start.offset, numberOfCharacters),    numberOfCharacters  )}function emitError(context, code, offset, loc = getCursor(context)) {  if (offset) {    loc.offset += offset    loc.column += offset  }  // ignore...}function isEnd(context, mode, ancestors) {  const s = context.source  switch (mode) {    case TextModes.DATA:      if (startsWith(s, '</')) {        // TODO: probably bad performance        for (let i = ancestors.length - 1; i >= 0; --i) {          if (startsWithEndTagOpen(s, ancestors[i].tag)) {            return true          }        }      }      break    case TextModes.RCDATA:    case TextModes.RAWTEXT: {      const parent = last(ancestors)      if (parent && startsWithEndTagOpen(s, parent.tag)) {        return true      }      break    }    case TextModes.CDATA:      if (startsWith(s, ']]>')) {        return true      }      break  }  return !s}function startsWithEndTagOpen(source, tag) {  return (    startsWith(source, '</') &&    source.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase() &&    /[\t\r\n\f />]/.test(source[2 + tag.length] || '>')  )}const cacheStringFunction = (fn) => {  const cache = Object.create(null)  return (str) => {    const hit = cache[str]    return hit || (cache[str] = fn(str))  }}const camelizeRE = /-(\w)/gconst camelize = cacheStringFunction((str) => {  return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''))})const hyphenateRE = /\B([A-Z])/gconst hyphenate = cacheStringFunction((str) =>  str.replace(hyphenateRE, '-$1').toLowerCase())const capitalize = cacheStringFunction(  (str) => str.charAt(0).toUpperCase() + str.slice(1))const toHandlerKey = cacheStringFunction((str) =>  str ? `on${capitalize(str)}` : ``)const isBuiltInType = (tag, expected) =>  tag === expected || tag === hyphenate(expected)function isCoreComponent(tag) {  if (isBuiltInType(tag, 'Teleport')) {    return TELEPORT  } else if (isBuiltInType(tag, 'Suspense')) {    return SUSPENSE  } else if (isBuiltInType(tag, 'KeepAlive')) {    return KEEP_ALIVE  } else if (isBuiltInType(tag, 'BaseTransition')) {    return BASE_TRANSITION  }}const isSpecialTemplateDirective = /*#__PURE__*/ makeMap(  `if,else,else-if,for,slot`)function isComponent(tag, props, context) {  const options = context.options  if (options.isCustomElement(tag)) {    return false  }  if (    tag === 'component' ||    /^[A-Z]/.test(tag) ||    isCoreComponent(tag) ||    (options.isBuiltInComponent && options.isBuiltInComponent(tag)) ||    (options.isNativeTag && !options.isNativeTag(tag))  ) {    return true  }  // at this point the tag should be a native tag, but check for potential "is"  // casting  for (let i = 0; i < props.length; i++) {    const p = props[i]    if (p.type === NodeTypes.ATTRIBUTE) {      if (p.name === 'is' && p.value) {        if (p.value.content.startsWith('vue:')) {          return true        }      }    } else {      // directive      // v-is (TODO Deprecate)      if (p.name === 'is') {        return true      }    }  }}function pushNode(nodes, node) {  if (node.type === NodeTypes.TEXT) {    const prev = last(nodes)    // Merge if both this and the previous node are text and those are    // consecutive. This happens for cases like "a < b".    if (      prev &&      prev.type === NodeTypes.TEXT &&      prev.loc.end.offset === node.loc.start.offset    ) {      prev.content += node.content      prev.loc.end = node.loc.end      prev.loc.source += node.loc.source      return    }  }  nodes.push(node)}function getVNodeHelper(ssr, isComponent) {  return ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE}function getVNodeBlockHelper(ssr, isComponent) {  return ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK}function isSingleElementRoot(root, child) {  const { children } = root  return (    children.length === 1 &&    child.type === NodeTypes.ELEMENT &&    !isSlotOutlet(child)  )}function isSlotOutlet(node) {  return node.type === NodeTypes.ELEMENT && node.tagType === ElementTypes.SLOT}function findDir(node, name, allowEmpty = false) {  for (let i = 0; i < node.props.length; i++) {    const p = node.props[i]    if (      p.type === NodeTypes.DIRECTIVE &&      (allowEmpty || p.exp) &&      (isString(name) ? p.name === name : name.test(p.name))    ) {      return p    }  }}function findProp(node, name, dynamicOnly = false, allowEmpty = false) {  for (let i = 0; i < node.props.length; i++) {    const p = node.props[i]    if (p.type === NodeTypes.ATTRIBUTE) {      if (dynamicOnly) continue      if (p.name === name && (p.value || allowEmpty)) {        return p      }    } else if (      p.name === 'bind' &&      (p.exp || allowEmpty) &&      isStaticArgOf(p.arg, name)    ) {      return p    }  }}const isStaticExp = (p) => p.type === NodeTypes.SIMPLE_EXPRESSION && p.isStaticfunction isStaticArgOf(arg, name) {  return !!(arg && isStaticExp(arg) && arg.content === name)}function isVSlot(p) {  return p.type === NodeTypes.DIRECTIVE && p.name === 'slot'}function getMemoedVNodeCall(node) {  if (node.type === NodeTypes.JS_CALL_EXPRESSION && node.callee === WITH_MEMO) {    return node.arguments[1].returns  } else {    return node  }}function getInnerRange(loc, offset, length) {  const source = loc.source.slice(offset, offset + length)  const newLoc = {    source,    start: advancePositionWithClone(loc.start, loc.source, offset),    end: loc.end  }  if (length != null) {    newLoc.end = advancePositionWithClone(      loc.start,      loc.source,      offset + length    )  }  return newLoc}function toValidAssetId(name, type) {  // see issue#4422, we need adding identifier on validAssetId if variable `name` has specific character  return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {    return searchValue === '-' ? '_' : name.charCodeAt(replaceValue).toString()  })}`}function isTemplateNode(node) {  return (    node.type === NodeTypes.ELEMENT && node.tagType === ElementTypes.TEMPLATE  )}const FRAGMENT = Symbol(__DEV__ ? `Fragment` : ``)const TELEPORT = Symbol(__DEV__ ? `Teleport` : ``)const SUSPENSE = Symbol(__DEV__ ? `Suspense` : ``)const KEEP_ALIVE = Symbol(__DEV__ ? `KeepAlive` : ``)const BASE_TRANSITION = Symbol(__DEV__ ? `BaseTransition` : ``)const OPEN_BLOCK = Symbol(__DEV__ ? `openBlock` : ``)const CREATE_BLOCK = Symbol(__DEV__ ? `createBlock` : ``)const CREATE_ELEMENT_BLOCK = Symbol(__DEV__ ? `createElementBlock` : ``)const CREATE_VNODE = Symbol(__DEV__ ? `createVNode` : ``)const CREATE_ELEMENT_VNODE = Symbol(__DEV__ ? `createElementVNode` : ``)const CREATE_COMMENT = Symbol(__DEV__ ? `createCommentVNode` : ``)const CREATE_TEXT = Symbol(__DEV__ ? `createTextVNode` : ``)const CREATE_STATIC = Symbol(__DEV__ ? `createStaticVNode` : ``)const RESOLVE_COMPONENT = Symbol(__DEV__ ? `resolveComponent` : ``)const RESOLVE_DYNAMIC_COMPONENT = Symbol(  __DEV__ ? `resolveDynamicComponent` : ``)const RESOLVE_DIRECTIVE = Symbol(__DEV__ ? `resolveDirective` : ``)const RESOLVE_FILTER = Symbol(__DEV__ ? `resolveFilter` : ``)const WITH_DIRECTIVES = Symbol(__DEV__ ? `withDirectives` : ``)const RENDER_LIST = Symbol(__DEV__ ? `renderList` : ``)const RENDER_SLOT = Symbol(__DEV__ ? `renderSlot` : ``)const CREATE_SLOTS = Symbol(__DEV__ ? `createSlots` : ``)const TO_DISPLAY_STRING = Symbol(__DEV__ ? `toDisplayString` : ``)const MERGE_PROPS = Symbol(__DEV__ ? `mergeProps` : ``)const NORMALIZE_CLASS = Symbol(__DEV__ ? `normalizeClass` : ``)const NORMALIZE_STYLE = Symbol(__DEV__ ? `normalizeStyle` : ``)const NORMALIZE_PROPS = Symbol(__DEV__ ? `normalizeProps` : ``)const GUARD_REACTIVE_PROPS = Symbol(__DEV__ ? `guardReactiveProps` : ``)const TO_HANDLERS = Symbol(__DEV__ ? `toHandlers` : ``)const CAMELIZE = Symbol(__DEV__ ? `camelize` : ``)const CAPITALIZE = Symbol(__DEV__ ? `capitalize` : ``)const TO_HANDLER_KEY = Symbol(__DEV__ ? `toHandlerKey` : ``)const SET_BLOCK_TRACKING = Symbol(__DEV__ ? `setBlockTracking` : ``)const PUSH_SCOPE_ID = Symbol(__DEV__ ? `pushScopeId` : ``)const POP_SCOPE_ID = Symbol(__DEV__ ? `popScopeId` : ``)const WITH_CTX = Symbol(__DEV__ ? `withCtx` : ``)const UNREF = Symbol(__DEV__ ? `unref` : ``)const IS_REF = Symbol(__DEV__ ? `isRef` : ``)const WITH_MEMO = Symbol(__DEV__ ? `withMemo` : ``)const IS_MEMO_SAME = Symbol(__DEV__ ? `isMemoSame` : ``)// Name mapping for runtime helpers that need to be imported from 'vue' in// generated code. Make sure these are correctly exported in the runtime!// Using `any` here because TS doesn't allow symbols as index type.const helperNameMap = {  [FRAGMENT]: `Fragment`,  [TELEPORT]: `Teleport`,  [SUSPENSE]: `Suspense`,  [KEEP_ALIVE]: `KeepAlive`,  [BASE_TRANSITION]: `BaseTransition`,  [OPEN_BLOCK]: `openBlock`,  [CREATE_BLOCK]: `createBlock`,  [CREATE_ELEMENT_BLOCK]: `createElementBlock`,  [CREATE_VNODE]: `createVNode`,  [CREATE_ELEMENT_VNODE]: `createElementVNode`,  [CREATE_COMMENT]: `createCommentVNode`,  [CREATE_TEXT]: `createTextVNode`,  [CREATE_STATIC]: `createStaticVNode`,  [RESOLVE_COMPONENT]: `resolveComponent`,  [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,  [RESOLVE_DIRECTIVE]: `resolveDirective`,  [RESOLVE_FILTER]: `resolveFilter`,  [WITH_DIRECTIVES]: `withDirectives`,  [RENDER_LIST]: `renderList`,  [RENDER_SLOT]: `renderSlot`,  [CREATE_SLOTS]: `createSlots`,  [TO_DISPLAY_STRING]: `toDisplayString`,  [MERGE_PROPS]: `mergeProps`,  [NORMALIZE_CLASS]: `normalizeClass`,  [NORMALIZE_STYLE]: `normalizeStyle`,  [NORMALIZE_PROPS]: `normalizeProps`,  [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,  [TO_HANDLERS]: `toHandlers`,  [CAMELIZE]: `camelize`,  [CAPITALIZE]: `capitalize`,  [TO_HANDLER_KEY]: `toHandlerKey`,  [SET_BLOCK_TRACKING]: `setBlockTracking`,  [PUSH_SCOPE_ID]: `pushScopeId`,  [POP_SCOPE_ID]: `popScopeId`,  [WITH_CTX]: `withCtx`,  [UNREF]: `unref`,  [IS_REF]: `isRef`,  [WITH_MEMO]: `withMemo`,  [IS_MEMO_SAME]: `isMemoSame`}function registerRuntimeHelpers(helpers) {  Object.getOwnPropertySymbols(helpers).forEach((s) => {    helperNameMap[s] = helpers[s]  })}/** * Patch flags are optimization hints generated by the compiler. * when a block with dynamicChildren is encountered during diff, the algorithm * enters "optimized mode". In this mode, we know that the vdom is produced by * a render function generated by the compiler, so the algorithm only needs to * handle updates explicitly marked by these patch flags. * * Patch flags can be combined using the | bitwise operator and can be checked * using the & operator, e.g. * * ```js * const flag = TEXT | CLASS * if (flag & TEXT) { ... } * ``` * * Check the `patchElement` function in '../../runtime-core/src/renderer.ts' to see how the * flags are handled during diff. */const PatchFlags = {  /**   * Indicates an element with dynamic textContent (children fast path)   */  TEXT: 1,  /**   * Indicates an element with dynamic class binding.   */  CLASS: 1 << 1,  /**   * Indicates an element with dynamic style   * The compiler pre-compiles static string styles into static objects   * + detects and hoists inline static objects   * e.g. `style="color: red"` and `:style="{ color: 'red' }"` both get hoisted   * as:   * ```js   * const style = { color: 'red' }   * render() { return e('div', { style }) }   * ```   */  STYLE: 1 << 2,  /**   * Indicates an element that has non-class/style dynamic props.   * Can also be on a component that has any dynamic props (includes   * class/style). when this flag is present, the vnode also has a dynamicProps   * array that contains the keys of the props that may change so the runtime   * can diff them faster (without having to worry about removed props)   */  PROPS: 1 << 3,  /**   * Indicates an element with props with dynamic keys. When keys change, a full   * diff is always needed to remove the old key. This flag is mutually   * exclusive with CLASS, STYLE and PROPS.   */  FULL_PROPS: 1 << 4,  /**   * Indicates an element with event listeners (which need to be attached   * during hydration)   */  HYDRATE_EVENTS: 1 << 5,  /**   * Indicates a fragment whose children order doesn't change.   */  STABLE_FRAGMENT: 1 << 6,  /**   * Indicates a fragment with keyed or partially keyed children   */  KEYED_FRAGMENT: 1 << 7,  /**   * Indicates a fragment with unkeyed children.   */  UNKEYED_FRAGMENT: 1 << 8,  /**   * Indicates an element that only needs non-props patching, e.g. ref or   * directives (onVnodeXXX hooks). since every patched vnode checks for refs   * and onVnodeXXX hooks, it simply marks the vnode so that a parent block   * will track it.   */  NEED_PATCH: 1 << 9,  /**   * Indicates a component with dynamic slots (e.g. slot that references a v-for   * iterated value, or dynamic slot names).   * Components with this flag are always force updated.   */  DYNAMIC_SLOTS: 1 << 10,  /**   * Indicates a fragment that was created only because the user has placed   * comments at the root level of a template. This is a dev-only flag since   * comments are stripped in production.   */  DEV_ROOT_FRAGMENT: 1 << 11,  /**   * SPECIAL FLAGS -------------------------------------------------------------   * Special flags are negative integers. They are never matched against using   * bitwise operators (bitwise matching should only happen in branches where   * patchFlag > 0), and are mutually exclusive. When checking for a special   * flag, simply check patchFlag === FLAG.   */  /**   * Indicates a hoisted static vnode. This is a hint for hydration to skip   * the entire sub tree since static content never needs to be updated.   */  HOISTED: -1,  /**   * A special flag that indicates that the diffing algorithm should bail out   * of optimized mode. For example, on block fragments created by renderSlot()   * when encountering non-compiler generated slots (i.e. manually written   * render functions, which should always be fully diffed)   * OR manually cloneVNodes   */  BAIL: -2}/** * dev only flag -> name mapping */const PatchFlagNames = {  [PatchFlags.TEXT]: `TEXT`,  [PatchFlags.CLASS]: `CLASS`,  [PatchFlags.STYLE]: `STYLE`,  [PatchFlags.PROPS]: `PROPS`,  [PatchFlags.FULL_PROPS]: `FULL_PROPS`,  [PatchFlags.HYDRATE_EVENTS]: `HYDRATE_EVENTS`,  [PatchFlags.STABLE_FRAGMENT]: `STABLE_FRAGMENT`,  [PatchFlags.KEYED_FRAGMENT]: `KEYED_FRAGMENT`,  [PatchFlags.UNKEYED_FRAGMENT]: `UNKEYED_FRAGMENT`,  [PatchFlags.NEED_PATCH]: `NEED_PATCH`,  [PatchFlags.DYNAMIC_SLOTS]: `DYNAMIC_SLOTS`,  [PatchFlags.DEV_ROOT_FRAGMENT]: `DEV_ROOT_FRAGMENT`,  [PatchFlags.HOISTED]: `HOISTED`,  [PatchFlags.BAIL]: `BAIL`}function genFlagText(flag, names = PatchFlagNames) {  if (isArray(flag)) {    let f = 0    flag.forEach((ff) => {      f |= ff    })    return `${f} /* ${flag.map((f) => names[f]).join(', ')} */`  } else {    return `${flag} /* ${names[flag]} */`  }}const propsHelperSet = new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS])function getUnnormalizedProps(props, callPath = []) {  if (    props &&    !isString(props) &&    props.type === NodeTypes.JS_CALL_EXPRESSION  ) {    const callee = props.callee    if (!isString(callee) && propsHelperSet.has(callee)) {      return getUnnormalizedProps(props.arguments[0], callPath.concat(props))    }  }  return [props, callPath]}function injectProp(node, prop, context) {  let propsWithInjection  /**   * 1. mergeProps(...)   * 2. toHandlers(...)   * 3. normalizeProps(...)   * 4. normalizeProps(guardReactiveProps(...))   *   * we need to get the real props before normalization   */  let props =    node.type === NodeTypes.VNODE_CALL ? node.props : node.arguments[2]  let callPath = []  let parentCall  if (    props &&    !isString(props) &&    props.type === NodeTypes.JS_CALL_EXPRESSION  ) {    const ret = getUnnormalizedProps(props)    props = ret[0]    callPath = ret[1]    parentCall = callPath[callPath.length - 1]  }  if (props == null || isString(props)) {    propsWithInjection = createObjectExpression([prop])  } else if (props.type === NodeTypes.JS_CALL_EXPRESSION) {    // merged props... add ours    // only inject key to object literal if it's the first argument so that    // if doesn't override user provided keys    const first = props.arguments[0] | JSChildNode    if (!isString(first) && first.type === NodeTypes.JS_OBJECT_EXPRESSION) {      first.properties.unshift(prop)    } else {      if (props.callee === TO_HANDLERS) {        // #2366        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [          createObjectExpression([prop]),          props        ])      } else {        props.arguments.unshift(createObjectExpression([prop]))      }    }    !propsWithInjection && (propsWithInjection = props)  } else if (props.type === NodeTypes.JS_OBJECT_EXPRESSION) {    let alreadyExists = false    // check existing key to avoid overriding user provided keys    if (prop.key.type === NodeTypes.SIMPLE_EXPRESSION) {      const propKeyName = prop.key.content      alreadyExists = props.properties.some(        (p) =>          p.key.type === NodeTypes.SIMPLE_EXPRESSION &&          p.key.content === propKeyName      )    }    if (!alreadyExists) {      props.properties.unshift(prop)    }    propsWithInjection = props  } else {    // single v-bind with expression, return a merged replacement    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [      createObjectExpression([prop]),      props    ])    // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(props))`,    // it will be rewritten as `normalizeProps(mergeProps({ key: 0 }, props))`,    // the `guardReactiveProps` will no longer be needed    if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {      parentCall = callPath[callPath.length - 2]    }  }  if (node.type === NodeTypes.VNODE_CALL) {    if (parentCall) {      parentCall.arguments[0] = propsWithInjection    } else {      node.props = propsWithInjection    }  } else {    if (parentCall) {      parentCall.arguments[0] = propsWithInjection    } else {      node.arguments[2] = propsWithInjection    }  }}const BindingTypes = {  /**   * returned from data()   */  DATA: 'data',  /**   * declared as a prop   */  PROPS: 'props',  /**   * a local alias of a `<script setup>` destructured prop.   * the original is stored in __propsAliases of the bindingMetadata object.   */  PROPS_ALIASED: 'props-aliased',  /**   * a let binding (may or may not be a ref)   */  SETUP_LET: 'setup-let',  /**   * a const binding that can never be a ref.   * these bindings don't need `unref()` calls when processed in inlined   * template expressions.   */  SETUP_CONST: 'setup-const',  /**   * a const binding that may be a ref.   */  SETUP_MAYBE_REF: 'setup-maybe-ref',  /**   * bindings that are guaranteed to be refs   */  SETUP_REF: 'setup-ref',  /**   * declared by other options, e.g. computed, inject   */  OPTIONS: 'options'}class WalkerBase {  constructor() {    /** @type {boolean} */    this.should_skip = false    /** @type {boolean} */    this.should_remove = false    /** @type {BaseNode | null} */    this.replacement = null    /** @type {WalkerContext} */    this.context = {      skip: () => (this.should_skip = true),      remove: () => (this.should_remove = true),      replace: (node) => (this.replacement = node)    }  }  replace(parent, prop, index, node) {    if (parent) {      if (index !== null) {        parent[prop][index] = node      } else {        parent[prop] = node      }    }  }  remove(parent, prop, index) {    if (parent) {      if (index !== null) {        parent[prop].splice(index, 1)      } else {        delete parent[prop]      }    }  }}class SyncWalker extends WalkerBase {  constructor(enter, leave) {    super()    /** @type {SyncHandler} */    this.enter = enter    /** @type {SyncHandler} */    this.leave = leave  }  visit(node, parent, prop, index) {    if (node) {      if (this.enter) {        const _should_skip = this.should_skip        const _should_remove = this.should_remove        const _replacement = this.replacement        this.should_skip = false        this.should_remove = false        this.replacement = null        this.enter.call(this.context, node, parent, prop, index)        if (this.replacement) {          node = this.replacement          this.replace(parent, prop, index, node)        }        if (this.should_remove) {          this.remove(parent, prop, index)        }        const skipped = this.should_skip        const removed = this.should_remove        this.should_skip = _should_skip        this.should_remove = _should_remove        this.replacement = _replacement        if (skipped) return node        if (removed) return null      }      for (const key in node) {        const value = node[key]        if (typeof value !== 'object') {          continue        } else if (Array.isArray(value)) {          for (let i = 0; i < value.length; i += 1) {            if (value[i] !== null && typeof value[i].type === 'string') {              if (!this.visit(value[i], node, key, i)) {                // removed                i--              }            }          }        } else if (value !== null && typeof value.type === 'string') {          this.visit(value, node, key, null)        }      }      if (this.leave) {        const _replacement = this.replacement        const _should_remove = this.should_remove        this.replacement = null        this.should_remove = false        this.leave.call(this.context, node, parent, prop, index)        if (this.replacement) {          node = this.replacement          this.replace(parent, prop, index, node)        }        if (this.should_remove) {          this.remove(parent, prop, index)        }        const removed = this.should_remove        this.replacement = _replacement        this.should_remove = _should_remove        if (removed) return null      }    }    return node  }}class AsyncWalker extends WalkerBase {  constructor(enter, leave) {    super()    /** @type {AsyncHandler} */    this.enter = enter    /** @type {AsyncHandler} */    this.leave = leave  }  async visit(node, parent, prop, index) {    if (node) {      if (this.enter) {        const _should_skip = this.should_skip        const _should_remove = this.should_remove        const _replacement = this.replacement        this.should_skip = false        this.should_remove = false        this.replacement = null        await this.enter.call(this.context, node, parent, prop, index)        if (this.replacement) {          node = this.replacement          this.replace(parent, prop, index, node)        }        if (this.should_remove) {          this.remove(parent, prop, index)        }        const skipped = this.should_skip        const removed = this.should_remove        this.should_skip = _should_skip        this.should_remove = _should_remove        this.replacement = _replacement        if (skipped) return node        if (removed) return null      }      for (const key in node) {        const value = node[key]        if (typeof value !== 'object') {          continue        } else if (Array.isArray(value)) {          for (let i = 0; i < value.length; i += 1) {            if (value[i] !== null && typeof value[i].type === 'string') {              if (!(await this.visit(value[i], node, key, i))) {                // removed                i--              }            }          }        } else if (value !== null && typeof value.type === 'string') {          await this.visit(value, node, key, null)        }      }      if (this.leave) {        const _replacement = this.replacement        const _should_remove = this.should_remove        this.replacement = null        this.should_remove = false        await this.leave.call(this.context, node, parent, prop, index)        if (this.replacement) {          node = this.replacement          this.replace(parent, prop, index, node)        }        if (this.should_remove) {          this.remove(parent, prop, index)        }        const removed = this.should_remove        this.replacement = _replacement        this.should_remove = _should_remove        if (removed) return null      }    }    return node  }}function walk(ast, { enter, leave }) {  const instance = new SyncWalker(enter, leave)  return instance.visit(ast, null)}async function asyncWalk(ast, { enter, leave }) {  const instance = new AsyncWalker(enter, leave)  return await instance.visit(ast, null)}function isInDestructureAssignment(parent, parentStack) {  if (    parent &&    (parent.type === 'ObjectProperty' || parent.type === 'ArrayPattern')  ) {    let i = parentStack.length    while (i--) {      const p = parentStack[i]      if (p.type === 'AssignmentExpression') {        return true      } else if (p.type !== 'ObjectProperty' && !p.type.endsWith('Pattern')) {        break      }    }  }  return false}function walkIdentifiers(  root,  onIdentifier,  includeAll = false,  parentStack = [],  knownIds = Object.create(null)) {  if (__BROWSER__) {    return  }  const rootExp =    root.type === 'Program' &&    root.body[0].type === 'ExpressionStatement' &&    root.body[0].expression  walk(root, {    enter(node, parent) {      parent && parentStack.push(parent)      if (        parent &&        parent.type.startsWith('TS') &&        parent.type !== 'TSAsExpression' &&        parent.type !== 'TSNonNullExpression' &&        parent.type !== 'TSTypeAssertion'      ) {        return this.skip()      }      if (node.type === 'Identifier') {        const isLocal = !!knownIds[node.name]        const isRefed = isReferencedIdentifier(node, parent, parentStack)        if (includeAll || (isRefed && !isLocal)) {          onIdentifier(node, parent, parentStack, isRefed, isLocal)        }      } else if (        node.type === 'ObjectProperty' &&        parent.type === 'ObjectPattern'      ) {        // mark property in destructure pattern        node.inPattern = true      } else if (isFunctionType(node)) {        // walk function expressions and add its arguments to known identifiers        // so that we don't prefix them        walkFunctionParams(node, (id) =>          markScopeIdentifier(node, id, knownIds)        )      } else if (node.type === 'BlockStatement') {        // #3445 record block-level local variables        walkBlockDeclarations(node, (id) =>          markScopeIdentifier(node, id, knownIds)        )      }    },    leave(node, parent) {      parent && parentStack.pop()      if (node !== rootExp && node.scopeIds) {        for (const id of node.scopeIds) {          knownIds[id]--          if (knownIds[id] === 0) {            delete knownIds[id]          }        }      }    }  })}function isReferencedIdentifier(id, parent, parentStack) {  if (__BROWSER__) {    return false  }  if (!parent) {    return true  }  // is a special keyword but parsed as identifier  if (id.name === 'arguments') {    return false  }  if (isReferenced(id, parent)) {    return true  }  // babel's isReferenced check returns false for ids being assigned to, so we  // need to cover those cases here  switch (parent.type) {    case 'AssignmentExpression':    case 'AssignmentPattern':      return true    case 'ObjectPattern':    case 'ArrayPattern':      return isInDestructureAssignment(parent, parentStack)  }  return false}function isInDestructureAssignment(parent, parentStack) {  if (    parent &&    (parent.type === 'ObjectProperty' || parent.type === 'ArrayPattern')  ) {    let i = parentStack.length    while (i--) {      const p = parentStack[i]      if (p.type === 'AssignmentExpression') {        return true      } else if (p.type !== 'ObjectProperty' && !p.type.endsWith('Pattern')) {        break      }    }  }  return false}function walkFunctionParams(node, onIdent) {  for (const p of node.params) {    for (const id of extractIdentifiers(p)) {      onIdent(id)    }  }}function walkBlockDeclarations(block, onIdent) {  for (const stmt of block.body) {    if (stmt.type === 'VariableDeclaration') {      if (stmt.declare) continue      for (const decl of stmt.declarations) {        for (const id of extractIdentifiers(decl.id)) {          onIdent(id)        }      }    } else if (      stmt.type === 'FunctionDeclaration' ||      stmt.type === 'ClassDeclaration'    ) {      if (stmt.declare || !stmt.id) continue      onIdent(stmt.id)    }  }}function extractIdentifiers(param, nodes = []) {  switch (param.type) {    case 'Identifier':      nodes.push(param)      break    case 'MemberExpression':      let object = param      while (object.type === 'MemberExpression') {        object = object.object      }      nodes.push(object)      break    case 'ObjectPattern':      for (const prop of param.properties) {        if (prop.type === 'RestElement') {          extractIdentifiers(prop.argument, nodes)        } else {          extractIdentifiers(prop.value, nodes)        }      }      break    case 'ArrayPattern':      param.elements.forEach((element) => {        if (element) extractIdentifiers(element, nodes)      })      break    case 'RestElement':      extractIdentifiers(param.argument, nodes)      break    case 'AssignmentPattern':      extractIdentifiers(param.left, nodes)      break  }  return nodes}function markScopeIdentifier(node, child, knownIds) {  const { name } = child  if (node.scopeIds && node.scopeIds.has(name)) {    return  }  if (name in knownIds) {    knownIds[name]++  } else {    knownIds[name] = 1  }  ;(node.scopeIds || (node.scopeIds = new Set())).add(name)}const isFunctionType = (node) => {  return /Function(?:Expression|Declaration)$|Method$/.test(node.type)}const isStaticProperty = (node) =>  node &&  (node.type === 'ObjectProperty' || node.type === 'ObjectMethod') &&  !node.computedconst isStaticPropertyKey = (node, parent) =>  isStaticProperty(parent) && parent.key === node/** * Copied from https://github.com/babel/babel/blob/main/packages/babel-types/src/validators/isReferenced.ts * To avoid runtime dependency on @babel/types (which includes process references) * This file should not change very often in babel but we may need to keep it * up-to-date from time to time. * * https://github.com/babel/babel/blob/main/LICENSE * */function isReferenced(node, parent, grandparent) {  switch (parent.type) {    // yes: PARENT[NODE]    // yes: NODE.child    // no: parent.NODE    case 'MemberExpression':    case 'OptionalMemberExpression':      if (parent.property === node) {        return !!parent.computed      }      return parent.object === node    case 'JSXMemberExpression':      return parent.object === node    // no: let NODE = init;    // yes: let id = NODE;    case 'VariableDeclarator':      return parent.init === node    // yes: () => NODE    // no: (NODE) => {}    case 'ArrowFunctionExpression':      return parent.body === node    // no: class { #NODE; }    // no: class { get #NODE() {} }    // no: class { #NODE() {} }    // no: class { fn() { return this.#NODE; } }    case 'PrivateName':      return false    // no: class { NODE() {} }    // yes: class { [NODE]() {} }    // no: class { foo(NODE) {} }    case 'ClassMethod':    case 'ClassPrivateMethod':    case 'ObjectMethod':      if (parent.key === node) {        return !!parent.computed      }      return false    // yes: { [NODE]: "" }    // no: { NODE: "" }    // depends: { NODE }    // depends: { key: NODE }    case 'ObjectProperty':      if (parent.key === node) {        return !!parent.computed      }      // parent.value === node      return !grandparent || grandparent.type !== 'ObjectPattern'    // no: class { NODE = value; }    // yes: class { [NODE] = value; }    // yes: class { key = NODE; }    case 'ClassProperty':      if (parent.key === node) {        return !!parent.computed      }      return true    case 'ClassPrivateProperty':      return parent.key !== node    // no: class NODE {}    // yes: class Foo extends NODE {}    case 'ClassDeclaration':    case 'ClassExpression':      return parent.superClass === node    // yes: left = NODE;    // no: NODE = right;    case 'AssignmentExpression':      return parent.right === node    // no: [NODE = foo] = [];    // yes: [foo = NODE] = [];    case 'AssignmentPattern':      return parent.right === node    // no: NODE: for (;;) {}    case 'LabeledStatement':      return false    // no: try {} catch (NODE) {}    case 'CatchClause':      return false    // no: function foo(...NODE) {}    case 'RestElement':      return false    case 'BreakStatement':    case 'ContinueStatement':      return false    // no: function NODE() {}    // no: function foo(NODE) {}    case 'FunctionDeclaration':    case 'FunctionExpression':      return false    // no: export NODE from "foo";    // no: export * as NODE from "foo";    case 'ExportNamespaceSpecifier':    case 'ExportDefaultSpecifier':      return false    // no: export { foo as NODE };    // yes: export { NODE as foo };    // no: export { NODE as foo } from "foo";    case 'ExportSpecifier':      // @ts-expect-error      if (grandparent?.source) {        return false      }      return parent.local === node    // no: import NODE from "foo";    // no: import * as NODE from "foo";    // no: import { NODE as foo } from "foo";    // no: import { foo as NODE } from "foo";    // no: import NODE from "bar";    case 'ImportDefaultSpecifier':    case 'ImportNamespaceSpecifier':    case 'ImportSpecifier':      return false    // no: import "foo" assert { NODE: "json" }    case 'ImportAttribute':      return false    // no: <div NODE="foo" />    case 'JSXAttribute':      return false    // no: [NODE] = [];    // no: ({ NODE }) = [];    case 'ObjectPattern':    case 'ArrayPattern':      return false    // no: new.NODE    // no: NODE.target    case 'MetaProperty':      return false    // yes: type X = { someProperty: NODE }    // no: type X = { NODE: OtherType }    case 'ObjectTypeProperty':      return parent.key !== node    // yes: enum X { Foo = NODE }    // no: enum X { NODE }    case 'TSEnumMember':      return parent.id !== node    // yes: { [NODE]: value }    // no: { NODE: value }    case 'TSPropertySignature':      if (parent.key === node) {        return !!parent.computed      }      return true  }  return true}const validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/const validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/const whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/gconst MemberExpLexState = {  inMemberExp: 0,  inBrackets: 1,  inParens: 2,  inString: 3}const isMemberExpressionBrowser = (path) => {  // remove whitespaces around . or [ first  path = path.trim().replace(whitespaceRE, (s) => s.trim())  let state = MemberExpLexState.inMemberExp  let stateStack = []  let currentOpenBracketCount = 0  let currentOpenParensCount = 0  let currentStringType = null  for (let i = 0; i < path.length; i++) {    const char = path.charAt(i)    switch (state) {      case MemberExpLexState.inMemberExp:        if (char === '[') {          stateStack.push(state)          state = MemberExpLexState.inBrackets          currentOpenBracketCount++        } else if (char === '(') {          stateStack.push(state)          state = MemberExpLexState.inParens          currentOpenParensCount++        } else if (          !(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)        ) {          return false        }        break      case MemberExpLexState.inBrackets:        if (char === `'` || char === `"` || char === '`') {          stateStack.push(state)          state = MemberExpLexState.inString          currentStringType = char        } else if (char === `[`) {          currentOpenBracketCount++        } else if (char === `]`) {          if (!--currentOpenBracketCount) {            state = stateStack.pop()          }        }        break      case MemberExpLexState.inParens:        if (char === `'` || char === `"` || char === '`') {          stateStack.push(state)          state = MemberExpLexState.inString          currentStringType = char        } else if (char === `(`) {          currentOpenParensCount++        } else if (char === `)`) {          // if the exp ends as a call then it should not be considered valid          if (i === path.length - 1) {            return false          }          if (!--currentOpenParensCount) {            state = stateStack.pop()          }        }        break      case MemberExpLexState.inString:        if (char === currentStringType) {          state = stateStack.pop()          currentStringType = null        }        break    }  }  return !currentOpenBracketCount && !currentOpenParensCount}const isMemberExpressionNode = __BROWSER__  ? NOOP  : (path, context) => {      try {        let ret = babelParser.parseExpression(path, {          plugins: [...context.expressionPlugins, ...babelPlugins]        })        if (ret.type === 'TSAsExpression' || ret.type === 'TSTypeAssertion') {          ret = ret.expression        }        return (          ret.type === 'MemberExpression' ||          ret.type === 'OptionalMemberExpression' ||          ret.type === 'Identifier'        )      } catch (e) {        return false      }    }const isMemberExpression = __BROWSER__  ? isMemberExpressionBrowser  : isMemberExpressionNode// Check if a node contains expressions that reference current context scope idsfunction hasScopeRef(node, ids) {  if (!node || Object.keys(ids).length === 0) {    return false  }  switch (node.type) {    case NodeTypes.ELEMENT:      for (let i = 0; i < node.props.length; i++) {        const p = node.props[i]        if (          p.type === NodeTypes.DIRECTIVE &&          (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))        ) {          return true        }      }      return node.children.some((c) => hasScopeRef(c, ids))    case NodeTypes.FOR:      if (hasScopeRef(node.source, ids)) {        return true      }      return node.children.some((c) => hasScopeRef(c, ids))    case NodeTypes.IF:      return node.branches.some((b) => hasScopeRef(b, ids))    case NodeTypes.IF_BRANCH:      if (hasScopeRef(node.condition, ids)) {        return true      }      return node.children.some((c) => hasScopeRef(c, ids))    case NodeTypes.SIMPLE_EXPRESSION:      return (        !node.isStatic &&        isSimpleIdentifier(node.content) &&        !!ids[node.content]      )    case NodeTypes.COMPOUND_EXPRESSION:      return node.children.some((c) => isObject(c) && hasScopeRef(c, ids))    case NodeTypes.INTERPOLATION:    case NodeTypes.TEXT_CALL:      return hasScopeRef(node.content, ids)    case NodeTypes.TEXT:    case NodeTypes.COMMENT:      return false    default:      if (__DEV__) {        const exhaustiveCheck = node        exhaustiveCheck      }      return false  }}const SlotFlags = {  /**   * Stable slots that only reference slot props or context state. The slot   * can fully capture its own dependencies so when passed down the parent won't   * need to force the child to update.   */  STABLE: 1,  /**   * Slots that reference scope variables (v-for or an outer slot prop), or   * has conditional structure (v-if, v-for). The parent will need to force   * the child to update because the slot does not fully capture its dependencies.   */  DYNAMIC: 2,  /**   * `<slot/>` being forwarded into a child component. Whether the parent needs   * to update the child is dependent on what kind of slots the parent itself   * received. This has to be refined at runtime, when the child's vnode   * is being created (in `normalizeChildren`)   */  FORWARDED: 3}/** * Dev only */const slotFlagsText = {  [SlotFlags.STABLE]: 'STABLE',  [SlotFlags.DYNAMIC]: 'DYNAMIC',  [SlotFlags.FORWARDED]: 'FORWARDED'}function createElementWithCodegen(  tag,  props,  children,  patchFlag,  dynamicProps) {  return {    type: NodeTypes.ELEMENT,    loc: locStub,    ns: Namespaces.HTML,    tag: 'div',    tagType: ElementTypes.ELEMENT,    isSelfClosing: false,    props: [],    children: [],    codegenNode: {      type: NodeTypes.VNODE_CALL,      tag,      props,      children,      patchFlag,      dynamicProps,      directives: undefined,      isBlock: false,      disableTracking: false,      isComponent: false,      loc: locStub    }  }}function createParserContext(content, rawOptions) {  const options = extend({}, defaultParserOptions)  let key  for (key in rawOptions) {    // @ts-ignore    options[key] =      rawOptions[key] === undefined        ? defaultParserOptions[key]        : rawOptions[key]  }  return {    options,    column: 1,    line: 1,    offset: 0,    originalSource: content,    source: content,    inPre: false,    inVPre: false,    onWarn: options.onWarn  }}function createRoot(children, loc = locStub) {  return {    type: NodeTypes.ROOT,    children,    helpers: [],    components: [],    directives: [],    hoists: [],    imports: [],    cached: 0,    temps: 0,    codegenNode: undefined,    loc  }}function parseChildren(context, mode, ancestors) {  const parent = last(ancestors)  const ns = parent ? parent.ns : Namespaces.HTML  const nodes = [] // -> ancestors  // 1. while -> isEnd ?  source   while (!isEnd(context, mode, ancestors)) {    const s = context.source    let node = undefined    if (mode === TextModes.DATA || mode === TextModes.RCDATA) {      if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {        // '{{'         node = parseInterpolation(context, mode)      } else if (mode === TextModes.DATA && s[0] === '<') {        if (s[1] === '/') {          //           if (/[a-z]/i.test(s[2])) {            // `<div>some text<a`            emitError(context, 'X_INVALID_END_TAG')            parseTag(context, TagType.End, parent)            continue          }        } else if (/[a-z]/i.test(s[1])) {          //           node = parseElement(context, ancestors)          // 2.x <template>  3.x         }      }    }    //     if (!node) {      node = parseText(context, mode)    }    //  pushNode     if (isArray(node)) {      for (let i = 0; i < node.length; i++) {        pushNode(nodes, node[i])      }    } else {      pushNode(nodes, node)    }  }  // 2.   let removedWhitespace = false  if (mode !== TextModes.RAWTEXT && mode !== TextModes.RCDATA) {    removedWhitespace = _removeWhitespace(nodes, context)  }  // 3.   return removedWhitespace ? nodes.filter(Boolean) : nodes}function _removeWhitespace(nodes, context) {  let removedWhitespace = false  //   const shouldCondense = context.options.whitespace !== 'preserve'  for (let i = 0; i < nodes.length; i++) {    const node = nodes[i]    if (!context.inPre && node.type === NodeTypes.TEXT) {      if (!/[^\t\r\n\f]/.test(node.content)) {        const prev = nodes[i - 1]        const next = nodes[i + 1]        if (          !prev ||          !next ||          (shouldCondense &&            (prev.type === NodeTypes.COMMENT ||              next.type === NodeTypes.COMMENT ||              (prev.type === NodeTypes.ELEMENT &&                next.type === NodeTypes.ELEMENT &&                /[\r\n]/.test(node.content))))        ) {          removedWhitespace = true          nodes[i] = null        } else {          //           node.content = ' '        }      } else if (shouldCondense) {        //         node.content = node.content.replace(/[\t\r\n\f]+/g, ' ')      }    } else if (node.type === NodeTypes.COMMENT && !context.options.comments) {      //       removedWhitespace = true      nodes[i] = null    }  }  if (context.inPre && parent && context.options.isPreTag(parent.tag)) {    //  <pre>     const first = nodes[0]    if (first && first.type === NodeTypes.TEXT) {      first.content = first.content.replace(/^\r?\n/, '')    }  }  return removedWhitespace}function parseElement(context, ancestors) {  const parent = last(ancestors)  // 1.   const element = parseTag(context, TagType.Start, parent)  //  <div/>  if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {    return element  }  // children  ancestors.push(element)  const mode = context.options.getTextMode(element, parent)  //   const children = parseChildren(context, mode, ancestors)  //  [root, parent1, parent2, ...]   // <root><parent1><parent2></parent><parent1></root> ->   // ancestors   ancestors.pop()  element.children = children  // 2.   if (startsWithEndTagOpen(context.source, element.tag)) {    parseTag(context, TagType.End, parent)  }  //   element.loc = getSelection(context, element.loc.start)  return element}function parseTag(context, type, parent) {  // 1.   const start = getCursor(context)  //   const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source)  const tag = match[1]  const ns = context.options.getNamespace(tag, parent)  //  <div id="foo"> -> ` id="foo">`  advanceBy(context, match[0].length)  //   advanceSpaces(context)  // parse attributes  let props = parseAttributes(context, type)  // TODO v-pre   // 2.   let isSelfClosing = false  if (context.source.length === 0) {    // , ignore  } else {    isSelfClosing = startsWith(context.source, '/>')    advanceBy(context, isSelfClosing ? 2 : 1)  }  if (type === TagType.End) {    return  }  // 3.   let tagType = ElementTypes.ELEMENT  if (!context.inVPre) {    if (tag === 'slot') {      tagType = ElementTypes.SLOT    } else if (tag === 'template') {      if (        props.some(          (p) =>            p.type === NodeTypes.DIRECTIVE && isSpecialTemplateDirective(p.name)        )      ) {        tagType = ElementTypes.TEMPLATE      }    } else if (isComponent(tag, props, context)) {      tagType = ElementTypes.COMPONENT    }  }  return {    type: NodeTypes.ELEMENT,    ns,    tag,    tagType,    props,    isSelfClosing,    children: [],    loc: getSelection(context, start),    codegenNode: undefined //  transform   }}function parseText(context, mode) {  const endTokens =    mode === TextModes.CDATA ? [']]>'] : ['<', context.options.delimiters[0]]  let endIndex = context.source.length  for (let i = 0; i < endTokens.length; i++) {    const index = context.source.indexOf(endTokens[i], 1)    if (index !== -1 && endIndex > index) {      endIndex = index    }  }  const start = getCursor(context)  const content = parseTextData(context, endIndex, mode)  return {    type: NodeTypes.TEXT,    content,    loc: getSelection(context, start)  }}function parseTextData(context, length, mode) {  const rawText = context.source.slice(0, length)  advanceBy(context, length)  // HTML entities  if (    mode === TextModes.RAWTEXT ||    mode === TextModes.CDATA ||    !rawText.includes('&')  ) {    return rawText  } else {    //  &gt; -> `>`, &lt; -> `<`, &amp; -> `&`, &apos; -> `'`, &quot; -> `"`    return context.options.decodeEntities(      rawText,      mode === TextModes.ATTRIBUTE_VALUE    )  }}function parseInterpolation(context, mode) {  const [open, close] = context.options.delimiters  //  source = "{{ a + b }}"  // closeIndex = indexOf("}}", "{{".length) = 9  const closeIndex = context.source.indexOf(close, open.length)  if (closeIndex === -1) {    emitError(context, 'X_MISSING_INTERPOLATION_END')    return undefined  }  const start = getCursor(context)  // >> 2 -> " a + b }}"  advanceBy(context, open.length)  // { line, column, offset }  const innerStart = getCursor(context)  const innerEnd = getCursor(context)  // 9 - '{{'.length = 7  const rawContentLength = closeIndex - open.length  // " a + b }}".slice(0, 7) => " a + b "  const rawContent = context.source.slice(0, rawContentLength)  const preTrimContent = parseTextData(context, rawContentLength, mode)  // " a + b " => "a + b"  const content = preTrimContent.trim()  const startOffset = preTrimContent.indexOf(content)  if (startOffset > 0) {    //     advancePositionWithMutation(innerStart, rawContent, startOffset)  }  const endOffset =    rawContentLength - (preTrimContent.length - content.length - startOffset)  advancePositionWithMutation(innerEnd, rawContent, endOffset)  advanceBy(context, close.length)  return {    type: NodeTypes.INTERPOLATION,    content: {      type: NodeTypes.SIMPLE_EXPRESSION,      isStatic: false,      // Set `isConstant` to false by default and will decide in transformExpression      constType: ConstantTypes.NOT_CONSTANT,      content,      loc: getSelection(context, innerStart, innerEnd)    },    loc: getSelection(context, start)  }}function parseAttributes(context, type) {  const props = []  //  set   const attributeNames = new Set()  while (    context.source.length > 0 &&    !startsWith(context.source, '>') &&    !startsWith(context.source, '/>')  ) {    // , ignore    const attr = parseAttribute(context, attributeNames)    logg('ATTR', attr)    //  class  `foo   bar  ` -> `foo bar`    if (      attr.type === NodeTypes.ATTRIBUTE &&      attr.value &&      attr.name === 'class'    ) {      attr.value.content = attr.value.content.replace(/\s+/g, ' ').trim()    }    if (type === TagType.Start) {      props.push(attr)    }    advanceSpaces(context)  }  return props}function parseAttribute(context, nameSet) {  const start = getCursor(context)  const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source)  const name = match[0]  nameSet.add(name)  advanceBy(context, name.length)  let value = undefined  if (/^[\t\r\n\f ]*=/.test(context.source)) {    advanceSpaces(context)    advanceBy(context, 1)    advanceSpaces(context)    value = parseAttributeValue(context)  }  const loc = getSelection(context, start)  // v-on(@), v-bind(:), v-if, v-else, v-slot(#)   if (!context.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(name)) {    const match =      /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(        name      )    log(`parseAttribute| match=${match}`)    let isPropShorthand = startsWith(name, '.')    let dirName =      match[1] ||      (isPropShorthand || startsWith(name, ':')        ? 'bind'        : startsWith(name, '@')        ? 'on'        : 'slot')    let arg    if (match[2]) {      const isSlot = dirName === 'slot'      const startOffset = name.lastIndexOf(match[2])      const loc = getSelection(        context,        getNewPosition(context, start, startOffset),        getNewPosition(          context,          start,          startOffset + match[2].length + ((isSlot && match[3]) || '').length        )      )      let content = match[2]      let isStatic = true      if (content.startsWith('[')) {        isStatic = false        content = content.slice(1, content.length - 1)      } else if (isSlot) {        content += match[3] || ''      }      arg = {        type: NodeTypes.SIMPLE_EXPRESSION,        content,        isStatic,        constType: isStatic          ? ConstantTypes.CAN_STRINGIFY          : ConstantTypes.NOT_CONSTANT,        loc      }    }    // quoted: `foo="bar"`, not quoted: `foo=bar`    if (value && value.isQuoted) {      const valueLoc = value.loc      valueLoc.start.offset++      valueLoc.start.column++      valueLoc.end = advancePositionWithClone(valueLoc.start, value.content)      valueLoc.source = valueLoc.source.slice(1, -1)    }    //  v-bind.number="foo" => '.number' => ['number']    const modifiers = match[3] ? match[3].slice(1).split('.') : []    // `<div foo.prop="bar">`  `.prop`  `$attrs`     //  `.prop`  `$props`     if (isPropShorthand) {      modifiers.push('prop')    }    return {      type: NodeTypes.DIRECTIVE,      name: dirName,      exp: value && {        type: NodeTypes.SIMPLE_EXPRESSION,        content: value.content,        isStatic: false,        // Treat as non-constant by default. This can be potentially set to        // other values by `transformExpression` to make it eligible for hoisting.        constType: ConstantTypes.NOT_CONSTANT,        loc: value.loc      },      arg,      modifiers,      loc    }  }  return {    type: NodeTypes.ATTRIBUTE,    name,    value: value && {      type: NodeTypes.TEXT,      content: value.content,      loc: value.loc    },    loc  }}function parseAttributeValue(context) {  const start = getCursor(context)  let content  const quote = context.source[0]  // value   // `<div foo="value">`  `<div foo=value>`  const isQuoted = quote === `"` || quote === `'`  if (isQuoted) {    // Quoted value.    advanceBy(context, 1)    const endIndex = context.source.indexOf(quote)    if (endIndex === -1) {      content = parseTextData(        context,        context.source.length,        TextModes.ATTRIBUTE_VALUE      )    } else {      content = parseTextData(context, endIndex, TextModes.ATTRIBUTE_VALUE)      advanceBy(context, 1)    }  } else {    // Unquoted    const match = /^[^\t\r\n\f >]+/.exec(context.source)    if (!match) {      return undefined    }    content = parseTextData(context, match[0].length, TextModes.ATTRIBUTE_VALUE)  }  return { content, isQuoted, loc: getSelection(context, start) }}function baseParse(content, options = {}) {  const context = createParserContext(content, options)  const start = getCursor(context)  return createRoot(    parseChildren(context, TextModes.DATA, []),    getSelection(context, start)  )}function createTransformContext(  root,  {    filename = '',    prefixIdentifiers = false,    hoistStatic = false,    cacheHandlers = false,    nodeTransforms = [],    directiveTransforms = {},    transformHoist = null,    isBuiltInComponent = NOOP,    isCustomElement = NOOP,    expressionPlugins = ['typescript'],    scopeId = null,    slotted = true,    ssr = false,    inSSR = false,    ssrCssVars = ``,    bindingMetadata = EMPTY_OBJ,    inline = false,    isTS = false,    onError = defaultOnError,    onWarn = defaultOnWarn,    compatConfig  }) {  const nameMatch = filename.replace(/\?.*$/, '').match(/([^/\\]+)\.\w+$/)  const context = {    // options    selfName: nameMatch && capitalize(camelize(nameMatch[1])),    prefixIdentifiers,    hoistStatic,    cacheHandlers,    nodeTransforms,    directiveTransforms,    transformHoist,    isBuiltInComponent,    isCustomElement,    expressionPlugins,    scopeId,    slotted,    ssr,    inSSR,    ssrCssVars,    bindingMetadata,    inline,    isTS,    onError,    onWarn,    compatConfig,    // state    root,    helpers: new Map(),    components: new Set(),    directives: new Set(),    hoists: [],    imports: [],    constantCache: new Map(),    temps: 0,    cached: 0,    identifiers: Object.create(null),    scopes: {      //       vFor: 0,      vSlot: 0,      vPre: 0,      vOnce: 0    },    parent: null,    currentNode: root,    childIndex: 0,    inVOnce: false,    // methods    helper(name) {      const count = context.helpers.get(name) || 0      context.helpers.set(name, count + 1)      return name    },    removeHelper(name) {      const count = context.helpers.get(name)      if (count) {        const currentCount = count - 1        if (!currentCount) {          context.helpers.delete(name)        } else {          context.helpers.set(name, currentCount)        }      }    },    helperString(name) {      return `_${helperNameMap[context.helper(name)]}`    },    replaceNode(node) {      context.parent.children[context.childIndex] = context.currentNode = node    },    removeNode(node) {      const list = context.parent.children      const removalIndex = node        ? list.indexOf(node)        : context.currentNode        ? context.childIndex        : -1      if (!node || node === context.currentNode) {        // current node removed        context.currentNode = null        context.onNodeRemoved()      } else {        // sibling node removed        if (context.childIndex > removalIndex) {          context.childIndex--          context.onNodeRemoved()        }      }      context.parent.children.splice(removalIndex, 1)    },    onNodeRemoved: () => {},    addIdentifiers(exp) {      // identifier tracking only happens in non-browser builds.      if (!__BROWSER__) {        if (isString(exp)) {          addId(exp)        } else if (exp.identifiers) {          exp.identifiers.forEach(addId)        } else if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {          addId(exp.content)        }      }    },    removeIdentifiers(exp) {      if (!__BROWSER__) {        if (isString(exp)) {          removeId(exp)        } else if (exp.identifiers) {          exp.identifiers.forEach(removeId)        } else if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {          removeId(exp.content)        }      }    },    hoist(exp) {      if (isString(exp)) exp = createSimpleExpression(exp)      context.hoists.push(exp)      const identifier = createSimpleExpression(        `_hoisted_${context.hoists.length}`,        false,        exp.loc,        ConstantTypes.CAN_HOIST      )      identifier.hoisted = exp      return identifier    },    cache(exp, isVNode = false) {      return createCacheExpression(context.cached++, exp, isVNode)    }  }  function addId(id) {    const { identifiers } = context    if (identifiers[id] === undefined) {      identifiers[id] = 0    }    identifiers[id]++  }  function removeId(id) {    context.identifiers[id]--  }  return context}function traverseNode(node, context) {  //   context.currentNode = node  // ()  const { nodeTransforms } = context  //   //   //  for   const exitFns = []  logg('traverseNode', node)  for (let i = 0; i < nodeTransforms.length; i++) {    const onExit = nodeTransforms[i](node, context)    if (onExit) {      if (isArray(onExit)) {        exitFns.push(...onExit)      } else {        exitFns.push(onExit)      }    }    if (!context.currentNode) {      // node was removed      return    } else {      // node may have been replaced      node = context.currentNode    }  }  //   switch (node.type) {    case NodeTypes.INTERPOLATION:      // no need to traverse, but we need to inject toString helper      if (!context.ssr) {        context.helper(TO_DISPLAY_STRING)      }      break    // for container types, further traverse downwards    //  if...else if...else     case NodeTypes.IF:      for (let i = 0; i < node.branches.length; i++) {        traverseNode(node.branches[i], context)      }      break    case NodeTypes.IF_BRANCH: // else..if    case NodeTypes.FOR: // for    case NodeTypes.ELEMENT:    case NodeTypes.ROOT:      traverseChildren(node, context)      break  }  //   context.currentNode = node  let i = exitFns.length  while (i--) {    exitFns[i]()  }}function traverseChildren(parent, context) {  let i = 0  const nodeRemoved = () => {    i--  }  for (; i < parent.children.length; i++) {    const child = parent.children[i]    if (isString(child)) continue    context.parent = parent    context.childIndex = i    context.onNodeRemoved = nodeRemoved    traverseNode(child, context)  }}function hoistStatic(root, context) {  _walk(    root,    context,    // Root node is unfortunately non-hoistable due to potential parent    // fallthrough attributes.    isSingleElementRoot(root, root.children[0])  )}function isSingleElementRoot(root, child) {  const { children } = root  return (    children.length === 1 &&    child.type === NodeTypes.ELEMENT &&    !isSlotOutlet(child)  )}function _walk(node, context, doNotHoistNode = false) {  const { children } = node  const originalCount = children.length  let hoistedCount = 0  for (let i = 0; i < children.length; i++) {    const child = children[i]    // only plain elements & text calls are eligible for hoisting.    if (      child.type === NodeTypes.ELEMENT &&      child.tagType === ElementTypes.ELEMENT    ) {      const constantType = doNotHoistNode        ? ConstantTypes.NOT_CONSTANT        : getConstantType(child, context)      if (constantType > ConstantTypes.NOT_CONSTANT) {        if (constantType >= ConstantTypes.CAN_HOIST) {          child.codegenNode.patchFlag =            PatchFlags.HOISTED + (__DEV__ ? ` /* HOISTED */` : ``)          child.codegenNode = context.hoist(child.codegenNode)          hoistedCount++          continue        }      } else {        // node may contain dynamic children, but its props may be eligible for        // hoisting.        const codegenNode = child.codegenNode        if (codegenNode.type === NodeTypes.VNODE_CALL) {          const flag = getPatchFlag(codegenNode)          if (            (!flag ||              flag === PatchFlags.NEED_PATCH ||              flag === PatchFlags.TEXT) &&            getGeneratedPropsConstantType(child, context) >=              ConstantTypes.CAN_HOIST          ) {            const props = getNodeProps(child)            if (props) {              codegenNode.props = context.hoist(props)            }          }          if (codegenNode.dynamicProps) {            codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps)          }        }      }    } else if (      child.type === NodeTypes.TEXT_CALL &&      getConstantType(child.content, context) >= ConstantTypes.CAN_HOIST    ) {      child.codegenNode = context.hoist(child.codegenNode)      hoistedCount++    }    // walk further    if (child.type === NodeTypes.ELEMENT) {      const isComponent = child.tagType === ElementTypes.COMPONENT      if (isComponent) {        context.scopes.vSlot++      }      _walk(child, context)      if (isComponent) {        context.scopes.vSlot--      }    } else if (child.type === NodeTypes.FOR) {      // Do not hoist v-for single child because it has to be a block      _walk(child, context, child.children.length === 1)    } else if (child.type === NodeTypes.IF) {      for (let i = 0; i < child.branches.length; i++) {        // Do not hoist v-if single child because it has to be a block        _walk(          child.branches[i],          context,          child.branches[i].children.length === 1        )      }    }  }  if (hoistedCount && context.transformHoist) {    logg(`hoist walk -> transformHoist, hoistedCount = ${hoistedCount}`)    context.transformHoist(children, context, node)  }  // all children were hoisted - the entire children array is hoistable.  if (    hoistedCount &&    hoistedCount === originalCount &&    node.type === NodeTypes.ELEMENT &&    node.tagType === ElementTypes.ELEMENT &&    node.codegenNode &&    node.codegenNode.type === NodeTypes.VNODE_CALL &&    isArray(node.codegenNode.children)  ) {    node.codegenNode.children = context.hoist(      createArrayExpression(node.codegenNode.children)    )  }}function getConstantType(node, context) {  const { constantCache } = context  switch (node.type) {    case NodeTypes.ELEMENT:      if (node.tagType !== ElementTypes.ELEMENT) {        return ConstantTypes.NOT_CONSTANT      }      const cached = constantCache.get(node)      if (cached !== undefined) {        return cached      }      const codegenNode = node.codegenNode      if (codegenNode.type !== NodeTypes.VNODE_CALL) {        return ConstantTypes.NOT_CONSTANT      }      if (        codegenNode.isBlock &&        node.tag !== 'svg' &&        node.tag !== 'foreignObject'      ) {        return ConstantTypes.NOT_CONSTANT      }      const flag = getPatchFlag(codegenNode)      if (!flag) {        let returnType = ConstantTypes.CAN_STRINGIFY        // Element itself has no patch flag. However we still need to check:        // 1. Even for a node with no patch flag, it is possible for it to contain        // non-hoistable expressions that refers to scope variables, e.g. compiler        // injected keys or cached event handlers. Therefore we need to always        // check the codegenNode's props to be sure.        const generatedPropsType = getGeneratedPropsConstantType(node, context)        if (generatedPropsType === ConstantTypes.NOT_CONSTANT) {          constantCache.set(node, ConstantTypes.NOT_CONSTANT)          return ConstantTypes.NOT_CONSTANT        }        if (generatedPropsType < returnType) {          returnType = generatedPropsType        }        // 2. its children.        for (let i = 0; i < node.children.length; i++) {          const childType = getConstantType(node.children[i], context)          if (childType === ConstantTypes.NOT_CONSTANT) {            constantCache.set(node, ConstantTypes.NOT_CONSTANT)            return ConstantTypes.NOT_CONSTANT          }          if (childType < returnType) {            returnType = childType          }        }        // 3. if the type is not already CAN_SKIP_PATCH which is the lowest non-0        // type, check if any of the props can cause the type to be lowered        // we can skip can_patch because it's guaranteed by the absence of a        // patchFlag.        if (returnType > ConstantTypes.CAN_SKIP_PATCH) {          for (let i = 0; i < node.props.length; i++) {            const p = node.props[i]            if (p.type === NodeTypes.DIRECTIVE && p.name === 'bind' && p.exp) {              const expType = getConstantType(p.exp, context)              if (expType === ConstantTypes.NOT_CONSTANT) {                constantCache.set(node, ConstantTypes.NOT_CONSTANT)                return ConstantTypes.NOT_CONSTANT              }              if (expType < returnType) {                returnType = expType              }            }          }        }        // only svg/foreignObject could be block here, however if they are        // static then they don't need to be blocks since there will be no        // nested updates.        if (codegenNode.isBlock) {          context.removeHelper(OPEN_BLOCK)          context.removeHelper(            getVNodeBlockHelper(context.inSSR, codegenNode.isComponent)          )          codegenNode.isBlock = false          context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent))        }        constantCache.set(node, returnType)        return returnType      } else {        constantCache.set(node, ConstantTypes.NOT_CONSTANT)        return ConstantTypes.NOT_CONSTANT      }    case NodeTypes.TEXT:    case NodeTypes.COMMENT:      return ConstantTypes.CAN_STRINGIFY    case NodeTypes.IF:    case NodeTypes.FOR:    case NodeTypes.IF_BRANCH:      return ConstantTypes.NOT_CONSTANT    case NodeTypes.INTERPOLATION:    case NodeTypes.TEXT_CALL:      return getConstantType(node.content, context)    case NodeTypes.SIMPLE_EXPRESSION:      return node.constType    case NodeTypes.COMPOUND_EXPRESSION:      let returnType = ConstantTypes.CAN_STRINGIFY      for (let i = 0; i < node.children.length; i++) {        const child = node.children[i]        if (isString(child) || isSymbol(child)) {          continue        }        const childType = getConstantType(child, context)        if (childType === ConstantTypes.NOT_CONSTANT) {          return ConstantTypes.NOT_CONSTANT        } else if (childType < returnType) {          returnType = childType        }      }      return returnType    default:      return ConstantTypes.NOT_CONSTANT  }}const allowHoistedHelperSet = new Set([  NORMALIZE_CLASS,  NORMALIZE_STYLE,  NORMALIZE_PROPS,  GUARD_REACTIVE_PROPS])function getConstantTypeOfHelperCall(value, context) {  if (    value.type === NodeTypes.JS_CALL_EXPRESSION &&    !isString(value.callee) &&    allowHoistedHelperSet.has(value.callee)  ) {    const arg = value.arguments[0]    if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {      return getConstantType(arg, context)    } else if (arg.type === NodeTypes.JS_CALL_EXPRESSION) {      // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(exp))`      return getConstantTypeOfHelperCall(arg, context)    }  }  return ConstantTypes.NOT_CONSTANT}function getGeneratedPropsConstantType(node, context) {  let returnType = ConstantTypes.CAN_STRINGIFY  const props = getNodeProps(node)  if (props && props.type === NodeTypes.JS_OBJECT_EXPRESSION) {    const { properties } = props    for (let i = 0; i < properties.length; i++) {      const { key, value } = properties[i]      const keyType = getConstantType(key, context)      if (keyType === ConstantTypes.NOT_CONSTANT) {        return keyType      }      if (keyType < returnType) {        returnType = keyType      }      let valueType      if (value.type === NodeTypes.SIMPLE_EXPRESSION) {        valueType = getConstantType(value, context)      } else if (value.type === NodeTypes.JS_CALL_EXPRESSION) {        // some helper calls can be hoisted,        // such as the `normalizeProps` generated by the compiler for pre-normalize class,        // in this case we need to respect the ConstantType of the helper's arguments        valueType = getConstantTypeOfHelperCall(value, context)      } else {        valueType = ConstantTypes.NOT_CONSTANT      }      if (valueType === ConstantTypes.NOT_CONSTANT) {        return valueType      }      if (valueType < returnType) {        returnType = valueType      }    }  }  return returnType}function getNodeProps(node) {  const codegenNode = node.codegenNode  if (codegenNode.type === NodeTypes.VNODE_CALL) {    return codegenNode.props  }}function getPatchFlag(node) {  const flag = node.patchFlag  return flag ? parseInt(flag, 10) : undefined}function createRootCodegen(root, context) {  const { helper } = context  const { children } = root  logg(    'createRootCodegen',    `children=${children.length},  block, Fragment`  )  if (children.length === 1) {    const child = children[0]    // if the single child is an element, turn it into a block.    //  <template><div>...</div></template>    if (isSingleElementRoot(root, child) && child.codegenNode) {      // single element root is never hoisted so codegenNode will never be      // SimpleExpressionNode      const codegenNode = child.codegenNode      if (codegenNode.type === NodeTypes.VNODE_CALL) {        makeBlock(codegenNode, context)      }      root.codegenNode = codegenNode    } else {      // - single <slot/>, IfNode, ForNode: already blocks.      // - single text node: always patched.      // root codegen falls through via genNode()      root.codegenNode = child    }  } else if (children.length > 1) {    // root  fragment block3.x 2.x    let patchFlag = PatchFlags.STABLE_FRAGMENT    let patchFlagText = PatchFlagNames[PatchFlags.STABLE_FRAGMENT]    root.codegenNode = createVNodeCall(      context,      helper(FRAGMENT),      undefined,      root.children,      patchFlag + (__DEV__ ? ` /* ${patchFlagText} */` : ``),      undefined,      undefined,      true,      undefined,      false /* isComponent */    )  } else {    // no children = noop. codegen will return null.  }}function createStructuralDirectiveTransform(name, fn) {  //  test   const matches = isString(name) ? (n) => n === name : (n) => name.test(n)  logg('createStructuralDirectiveTransform', `name=${name}, matches=${matches}`)  return (node, context) => {    if (node.type === NodeTypes.ELEMENT) {      const { props } = node      // v-slot  vSlot.ts       if (node.tagType === ElementTypes.TEMPLATE && props.some(isVSlot)) {        return      }      const exitFns = []      for (let i = 0; i < props.length; i++) {        const prop = props[i]        if (prop.type === NodeTypes.DIRECTIVE && matches(prop.name)) {          // structural directives are removed to avoid infinite recursion          // also we remove them *before* applying so that it can further          // traverse itself in case it moves the node around          props.splice(i, 1)          i--          const onExit = fn(node, prop, context)          if (onExit) exitFns.push(onExit)        }      }      return exitFns    }  }}function getBaseTransformPreset(prefixIdentifiers) {  return [    [      transformOnce,      transformIf,      transformMemo,      transformFor,      ...(!__BROWSER__ && prefixIdentifiers        ? [            // order is important            trackVForSlotScopes,            transformExpression          ]        : __BROWSER__ && __DEV__        ? [transformExpression]        : []),      transformSlotOutlet,      transformElement,      trackSlotScopes,      transformText    ],    {      on: transformOn,      bind: transformBind,      model: transformModel    }  ]}function makeBlock(node, { helper, removeHelper, inSSR }) {  if (!node.isBlock) {    node.isBlock = true    removeHelper(getVNodeHelper(inSSR, node.isComponent))    helper(OPEN_BLOCK)    helper(getVNodeBlockHelper(inSSR, node.isComponent))  }}const defaultFallback = createSimpleExpression(`undefined`, false)// A NodeTransform that:// 1. Tracks scope identifiers for scoped slots so that they don't get prefixed//    by transformExpression. This is only applied in non-browser builds with//    { prefixIdentifiers: true }.// 2. Track v-slot depths so that we know a slot is inside another slot.//    Note the exit callback is executed before buildSlots() on the same node,//    so only nested slots see positive numbers.const trackSlotScopes = (node, context) => {  if (    node.type === NodeTypes.ELEMENT &&    (node.tagType === ElementTypes.COMPONENT ||      node.tagType === ElementTypes.TEMPLATE)  ) {    // We are only checking non-empty v-slot here    // since we only care about slots that introduce scope variables.    const vSlot = findDir(node, 'slot')    if (vSlot) {      const slotProps = vSlot.exp      if (!__BROWSER__ && context.prefixIdentifiers) {        slotProps && context.addIdentifiers(slotProps)      }      context.scopes.vSlot++      return () => {        if (!__BROWSER__ && context.prefixIdentifiers) {          slotProps && context.removeIdentifiers(slotProps)        }        context.scopes.vSlot--      }    }  }}// A NodeTransform that tracks scope identifiers for scoped slots with v-for.// This transform is only applied in non-browser builds with { prefixIdentifiers: true }const trackVForSlotScopes = (node, context) => {  let vFor  if (    isTemplateNode(node) &&    node.props.some(isVSlot) &&    (vFor = findDir(node, 'for'))  ) {    const result = (vFor.parseResult = parseForExpression(vFor.exp, context))    if (result) {      const { value, key, index } = result      const { addIdentifiers, removeIdentifiers } = context      value && addIdentifiers(value)      key && addIdentifiers(key)      index && addIdentifiers(index)      return () => {        value && removeIdentifiers(value)        key && removeIdentifiers(key)        index && removeIdentifiers(index)      }    }  }}const buildClientSlotFn = (props, children, loc) =>  createFunctionExpression(    props,    children,    false /* newline */,    true /* isSlot */,    children.length ? children[0].loc : loc  )// Instead of being a DirectiveTransform, v-slot processing is called during// transformElement to build the slots object for a component.function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {  context.helper(WITH_CTX)  const { children, loc } = node  const slotsProperties = []  const dynamicSlots = []  // If the slot is inside a v-for or another v-slot, force it to be dynamic  // since it likely uses a scope variable.  let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0  // with `prefixIdentifiers: true`, this can be further optimized to make  // it dynamic only when the slot actually uses the scope variables.  if (!__BROWSER__ && !context.ssr && context.prefixIdentifiers) {    hasDynamicSlots = hasScopeRef(node, context.identifiers)  }  // 1. Check for slot with slotProps on component itself.  //    <Comp v-slot="{ prop }"/>  const onComponentSlot = findDir(node, 'slot', true)  if (onComponentSlot) {    const { arg, exp } = onComponentSlot    if (arg && !isStaticExp(arg)) {      hasDynamicSlots = true    }    slotsProperties.push(      createObjectProperty(        arg || createSimpleExpression('default', true),        buildSlotFn(exp, children, loc)      )    )  }  // 2. Iterate through children and check for template slots  //    <template v-slot:foo="{ prop }">  let hasTemplateSlots = false  let hasNamedDefaultSlot = false  const implicitDefaultChildren = []  const seenSlotNames = new Set()  for (let i = 0; i < children.length; i++) {    const slotElement = children[i]    let slotDir    if (      !isTemplateNode(slotElement) ||      !(slotDir = findDir(slotElement, 'slot', true))    ) {      //  template v-slot /      if (slotElement.type !== NodeTypes.COMMENT) {        implicitDefaultChildren.push(slotElement)      }      continue    }    if (onComponentSlot) {      logg(`buildSlots already has on-component slot - this is incorrect usage`)      break    }    hasTemplateSlots = true    const { children: slotChildren, loc: slotLoc } = slotElement    const {      arg: slotName = createSimpleExpression(`default`, true),      exp: slotProps,      loc: dirLoc    } = slotDir    // check if name is dynamic.    let staticSlotName    if (isStaticExp(slotName)) {      staticSlotName = slotName ? slotName.content : `default`    } else {      hasDynamicSlots = true    }    const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc)    // check if this slot is conditional (v-if/v-for)    let vIf    let vElse    let vFor    if ((vIf = findDir(slotElement, 'if'))) {      hasDynamicSlots = true      dynamicSlots.push(        createConditionalExpression(          vIf.exp,          buildDynamicSlot(slotName, slotFunction),          defaultFallback        )      )    } else if (      (vElse = findDir(slotElement, /^else(-if)?$/, true /* allowEmpty */))    ) {      // find adjacent v-if      let j = i      let prev      while (j--) {        prev = children[j]        if (prev.type !== NodeTypes.COMMENT) {          break        }      }      if (prev && isTemplateNode(prev) && findDir(prev, 'if')) {        // remove node        children.splice(i, 1)        i--        // attach this slot to previous conditional        let conditional = dynamicSlots[dynamicSlots.length - 1]        while (          conditional.alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION        ) {          conditional = conditional.alternate        }        conditional.alternate = vElse.exp          ? createConditionalExpression(              vElse.exp,              buildDynamicSlot(slotName, slotFunction),              defaultFallback            )          : buildDynamicSlot(slotName, slotFunction)      }    } else if ((vFor = findDir(slotElement, 'for'))) {      hasDynamicSlots = true      const parseResult =        vFor.parseResult || parseForExpression(vFor.exp, context)      if (parseResult) {        // Render the dynamic slots as an array and add it to the createSlot()        // args. The runtime knows how to handle it appropriately.        dynamicSlots.push(          createCallExpression(context.helper(RENDER_LIST), [            parseResult.source,            createFunctionExpression(              createForLoopParams(parseResult),              buildDynamicSlot(slotName, slotFunction),              true /* force newline */            )          ])        )      }    } else {      // check duplicate static names      if (staticSlotName) {        if (seenSlotNames.has(staticSlotName)) {          logg(`buildSlots seenSlotNames has slot name`)          continue        }        seenSlotNames.add(staticSlotName)        if (staticSlotName === 'default') {          hasNamedDefaultSlot = true        }      }      slotsProperties.push(createObjectProperty(slotName, slotFunction))    }  }  if (!onComponentSlot) {    const buildDefaultSlotProperty = (props, children) => {      const fn = buildSlotFn(props, children, loc)      return createObjectProperty(`default`, fn)    }    if (!hasTemplateSlots) {      // implicit default slot (on component)      slotsProperties.push(buildDefaultSlotProperty(undefined, children))    } else if (      implicitDefaultChildren.length &&      // #3766      // with whitespace: 'preserve', whitespaces between slots will end up in      // implicitDefaultChildren. Ignore if all implicit children are whitespaces.      implicitDefaultChildren.some((node) => isNonWhitespaceContent(node))    ) {      // implicit default slot (mixed with named slots)      if (hasNamedDefaultSlot) {        logg(`buildSlots hasNamedDefaultSlot`)      } else {        //         slotsProperties.push(          buildDefaultSlotProperty(undefined, implicitDefaultChildren)        )      }    }  }  const slotFlag = hasDynamicSlots    ? SlotFlags.DYNAMIC    : hasForwardedSlots(node.children)    ? SlotFlags.FORWARDED    : SlotFlags.STABLE  let slots = createObjectExpression(    slotsProperties.concat(      createObjectProperty(        `_`,        // 2 = compiled but dynamic = can skip normalization, but must run diff        // 1 = compiled and static = can skip normalization AND diff as optimized        createSimpleExpression(          slotFlag + (__DEV__ ? ` /* ${slotFlagsText[slotFlag]} */` : ``),          false        )      )    ),    loc  )  if (dynamicSlots.length) {    slots = createCallExpression(context.helper(CREATE_SLOTS), [      slots,      createArrayExpression(dynamicSlots)    ])  }  return {    slots,    hasDynamicSlots  }}function buildDynamicSlot(name, fn) {  return createObjectExpression([    createObjectProperty(`name`, name),    createObjectProperty(`fn`, fn)  ])}function hasForwardedSlots(children) {  for (let i = 0; i < children.length; i++) {    const child = children[i]    switch (child.type) {      case NodeTypes.ELEMENT:        if (          child.tagType === ElementTypes.SLOT ||          hasForwardedSlots(child.children)        ) {          return true        }        break      case NodeTypes.IF:        if (hasForwardedSlots(child.branches)) return true        break      case NodeTypes.IF_BRANCH:      case NodeTypes.FOR:        if (hasForwardedSlots(child.children)) return true        break      default:        break    }  }  return false}function isNonWhitespaceContent(node) {  if (node.type !== NodeTypes.TEXT && node.type !== NodeTypes.TEXT_CALL)    return true  return node.type === NodeTypes.TEXT    ? !!node.content.trim()    : isNonWhitespaceContent(node.content)}// some directive transforms (e.g. v-model) may return a symbol for runtime// import, which should be used instead of a resolveDirective call.const directiveImportMap = new WeakMap()// generate a JavaScript AST for this element's codegenconst transformElement = (node, context) => {  // perform the work on exit, after all child expressions have been  // processed and merged.  return function postTransformElement() {    node = context.currentNode    if (      !(        node.type === NodeTypes.ELEMENT &&        (node.tagType === ElementTypes.ELEMENT ||          node.tagType === ElementTypes.COMPONENT)      )    ) {      return    }    const { tag, props } = node    const isComponent = node.tagType === ElementTypes.COMPONENT    // The goal of the transform is to create a codegenNode implementing the    // VNodeCall interface.    let vnodeTag = isComponent      ? resolveComponentType(node, context)      : `"${tag}"`    const isDynamicComponent =      isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT    let vnodeProps    let vnodeChildren    let vnodePatchFlag    let patchFlag = 0    let vnodeDynamicProps    let dynamicPropNames    let vnodeDirectives    let shouldUseBlock =      // dynamic component may resolve to plain elements      isDynamicComponent ||      vnodeTag === TELEPORT ||      vnodeTag === SUSPENSE ||      (!isComponent &&        // <svg> and <foreignObject> must be forced into blocks so that block        // updates inside get proper isSVG flag at runtime. (#639, #643)        // This is technically web-specific, but splitting the logic out of core        // leads to too much unnecessary complexity.        (tag === 'svg' || tag === 'foreignObject'))    // props    if (props.length > 0) {      const propsBuildResult = buildProps(node, context)      vnodeProps = propsBuildResult.props      patchFlag = propsBuildResult.patchFlag      dynamicPropNames = propsBuildResult.dynamicPropNames      const directives = propsBuildResult.directives      vnodeDirectives =        directives && directives.length          ? createArrayExpression(              directives.map((dir) => buildDirectiveArgs(dir, context))            )          : undefined      if (propsBuildResult.shouldUseBlock) {        shouldUseBlock = true      }    }    // children    if (node.children.length > 0) {      if (vnodeTag === KEEP_ALIVE) {        // Although a built-in component, we compile KeepAlive with raw children        // instead of slot functions so that it can be used inside Transition        // or other Transition-wrapping HOCs.        // To ensure correct updates with block optimizations, we need to:        // 1. Force keep-alive into a block. This avoids its children being        //    collected by a parent block.        shouldUseBlock = true        // 2. Force keep-alive to always be updated, since it uses raw children.        patchFlag |= PatchFlags.DYNAMIC_SLOTS      }      const shouldBuildAsSlots =        isComponent &&        // Teleport is not a real component and has dedicated runtime handling        vnodeTag !== TELEPORT &&        // explained above.        vnodeTag !== KEEP_ALIVE      if (shouldBuildAsSlots) {        const { slots, hasDynamicSlots } = buildSlots(node, context)        vnodeChildren = slots        if (hasDynamicSlots) {          patchFlag |= PatchFlags.DYNAMIC_SLOTS        }      } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {        const child = node.children[0]        const type = child.type        // check for dynamic text children        const hasDynamicTextChild =          type === NodeTypes.INTERPOLATION ||          type === NodeTypes.COMPOUND_EXPRESSION        if (          hasDynamicTextChild &&          getConstantType(child, context) === ConstantTypes.NOT_CONSTANT        ) {          patchFlag |= PatchFlags.TEXT        }        // pass directly if the only child is a text node        // (plain / interpolation / expression)        if (hasDynamicTextChild || type === NodeTypes.TEXT) {          vnodeChildren = child        } else {          vnodeChildren = node.children        }      } else {        vnodeChildren = node.children      }    }    // patchFlag & dynamicPropNames    if (patchFlag !== 0) {      vnodePatchFlag = String(patchFlag)      if (dynamicPropNames && dynamicPropNames.length) {        vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames)      }    }    node.codegenNode = createVNodeCall(      context,      vnodeTag,      vnodeProps,      vnodeChildren,      vnodePatchFlag,      vnodeDynamicProps,      vnodeDirectives,      !!shouldUseBlock,      false /* disableTracking */,      isComponent,      node.loc    )  }}function resolveComponentType(node, context, ssr = false) {  let { tag } = node  // 1. dynamic component  const isExplicitDynamic = isComponentTag(tag)  const isProp = findProp(node, 'is')  if (isProp) {    if (isExplicitDynamic) {      const exp =        isProp.type === NodeTypes.ATTRIBUTE          ? isProp.value && createSimpleExpression(isProp.value.content, true)          : isProp.exp      if (exp) {        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [          exp        ])      }    } else if (      isProp.type === NodeTypes.ATTRIBUTE &&      isProp.value.content.startsWith('vue:')    ) {      // <button is="vue:xxx">      // if not <component>, only is value that starts with "vue:" will be      // treated as component by the parse phase and reach here, unless it's      // compat mode where all is values are considered components      tag = isProp.value.content.slice(4)    }  }  // 1.5 v-is (TODO: Deprecate)  const isDir = !isExplicitDynamic && findDir(node, 'is')  if (isDir && isDir.exp) {    return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [      isDir.exp    ])  }  // 2. built-in components (Teleport, Transition, KeepAlive, Suspense...)  const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag)  if (builtIn) {    // built-ins are simply fallthroughs / have special handling during ssr    // so we don't need to import their runtime equivalents    if (!ssr) context.helper(builtIn)    return builtIn  }  // 3. user component (from setup bindings)  // this is skipped in browser build since browser builds do not perform  // binding analysis.  if (!__BROWSER__) {    const fromSetup = resolveSetupReference(tag, context)    if (fromSetup) {      return fromSetup    }    const dotIndex = tag.indexOf('.')    if (dotIndex > 0) {      const ns = resolveSetupReference(tag.slice(0, dotIndex), context)      if (ns) {        return ns + tag.slice(dotIndex)      }    }  }  // 4. Self referencing component (inferred from filename)  if (    !__BROWSER__ &&    context.selfName &&    capitalize(camelize(tag)) === context.selfName  ) {    context.helper(RESOLVE_COMPONENT)    // codegen.ts has special check for __self postfix when generating    // component imports, which will pass additional `maybeSelfReference` flag    // to `resolveComponent`.    context.components.add(tag + `__self`)    return toValidAssetId(tag, `component`)  }  // 5. user component (resolve)  context.helper(RESOLVE_COMPONENT)  context.components.add(tag)  return toValidAssetId(tag, `component`)}function resolveSetupReference(name, context) {  const bindings = context.bindingMetadata  if (!bindings || bindings.__isScriptSetup === false) {    return  }  const camelName = camelize(name)  const PascalName = capitalize(camelName)  const checkType = (type) => {    if (bindings[name] === type) {      return name    }    if (bindings[camelName] === type) {      return camelName    }    if (bindings[PascalName] === type) {      return PascalName    }  }  const fromConst = checkType(BindingTypes.SETUP_CONST)  if (fromConst) {    return context.inline      ? // in inline mode, const setup bindings (e.g. imports) can be used as-is        fromConst      : `$setup[${JSON.stringify(fromConst)}]`  }  const fromMaybeRef =    checkType(BindingTypes.SETUP_LET) ||    checkType(BindingTypes.SETUP_REF) ||    checkType(BindingTypes.SETUP_MAYBE_REF)  if (fromMaybeRef) {    return context.inline      ? // setup scope bindings that may be refs need to be unrefed        `${context.helperString(UNREF)}(${fromMaybeRef})`      : `$setup[${JSON.stringify(fromMaybeRef)}]`  }}function buildProps(node, context, props = node.props, ssr = false) {  const { tag, loc: elementLoc, children } = node  const isComponent = node.tagType === ElementTypes.COMPONENT  let properties = []  const mergeArgs = []  const runtimeDirectives = []  const hasChildren = children.length > 0  let shouldUseBlock = false  // patchFlag analysis  let patchFlag = 0  let hasRef = false  let hasClassBinding = false  let hasStyleBinding = false  let hasHydrationEventBinding = false  let hasDynamicKeys = false  let hasVnodeHook = false  const dynamicPropNames = []  const analyzePatchFlag = ({ key, value }) => {    if (isStaticExp(key)) {      const name = key.content      const isEventHandler = isOn(name)      if (        !isComponent &&        isEventHandler &&        // omit the flag for click handlers because hydration gives click        // dedicated fast path.        name.toLowerCase() !== 'onclick' &&        // omit v-model handlers        name !== 'onUpdate:modelValue' &&        // omit onVnodeXXX hooks        !isReservedProp(name)      ) {        hasHydrationEventBinding = true      }      if (isEventHandler && isReservedProp(name)) {        hasVnodeHook = true      }      if (        value.type === NodeTypes.JS_CACHE_EXPRESSION ||        ((value.type === NodeTypes.SIMPLE_EXPRESSION ||          value.type === NodeTypes.COMPOUND_EXPRESSION) &&          getConstantType(value, context) > 0)      ) {        // skip if the prop is a cached handler or has constant value        return      }      if (name === 'ref') {        hasRef = true      } else if (name === 'class') {        hasClassBinding = true      } else if (name === 'style') {        hasStyleBinding = true      } else if (name !== 'key' && !dynamicPropNames.includes(name)) {        dynamicPropNames.push(name)      }      // treat the dynamic class and style binding of the component as dynamic props      if (        isComponent &&        (name === 'class' || name === 'style') &&        !dynamicPropNames.includes(name)      ) {        dynamicPropNames.push(name)      }    } else {      hasDynamicKeys = true    }  }  for (let i = 0; i < props.length; i++) {    // static attribute    const prop = props[i]    if (prop.type === NodeTypes.ATTRIBUTE) {      const { loc, name, value } = prop      let isStatic = true      if (name === 'ref') {        hasRef = true        if (context.scopes.vFor > 0) {          properties.push(            createObjectProperty(              createSimpleExpression('ref_for', true),              createSimpleExpression('true')            )          )        }        // in inline mode there is no setupState object, so we can't use string        // keys to set the ref. Instead, we need to transform it to pass the        // actual ref instead.        if (          !__BROWSER__ &&          value &&          context.inline &&          context.bindingMetadata[value.content]        ) {          isStatic = false          properties.push(            createObjectProperty(              createSimpleExpression('ref_key', true),              createSimpleExpression(value.content, true, value.loc)            )          )        }      }      // skip is on <component>, or is="vue:xxx"      if (        name === 'is' &&        (isComponentTag(tag) || (value && value.content.startsWith('vue:')))      ) {        continue      }      properties.push(        createObjectProperty(          createSimpleExpression(            name,            true,            getInnerRange(loc, 0, name.length)          ),          createSimpleExpression(            value ? value.content : '',            isStatic,            value ? value.loc : loc          )        )      )    } else {      // directives      const { name, arg, exp, loc } = prop      const isVBind = name === 'bind'      const isVOn = name === 'on'      // skip v-slot - it is handled by its dedicated transform.      if (name === 'slot') {        continue      }      // skip v-once/v-memo - they are handled by dedicated transforms.      if (name === 'once' || name === 'memo') {        continue      }      // skip v-is and :is on <component>      if (        name === 'is' ||        (isVBind && isStaticArgOf(arg, 'is') && isComponentTag(tag))      ) {        continue      }      // skip v-on in SSR compilation      if (isVOn && ssr) {        continue      }      if (        // # elements with dynamic keys should be forced into blocks        (isVBind && isStaticArgOf(arg, 'key')) ||        // inline before-update hooks need to force block so that it is invoked        // before children        (isVOn && hasChildren && isStaticArgOf(arg, 'vue:before-update'))      ) {        shouldUseBlock = true      }      if (isVBind && isStaticArgOf(arg, 'ref') && context.scopes.vFor > 0) {        properties.push(          createObjectProperty(            createSimpleExpression('ref_for', true),            createSimpleExpression('true')          )        )      }      // special case for v-bind and v-on with no argument      if (!arg && (isVBind || isVOn)) {        hasDynamicKeys = true        if (exp) {          if (properties.length) {            mergeArgs.push(              createObjectExpression(dedupeProperties(properties), elementLoc)            )            properties = []          }          if (isVBind) {            mergeArgs.push(exp)          } else {            // v-on="obj" -> toHandlers(obj)            mergeArgs.push({              type: NodeTypes.JS_CALL_EXPRESSION,              loc,              callee: context.helper(TO_HANDLERS),              arguments: [exp]            })          }        }        continue      }      const directiveTransform = context.directiveTransforms[name]      if (directiveTransform) {        // has built-in directive transform.        const { props, needRuntime } = directiveTransform(prop, node, context)        !ssr && props.forEach(analyzePatchFlag)        properties.push(...props)        if (needRuntime) {          runtimeDirectives.push(prop)          if (isSymbol(needRuntime)) {            directiveImportMap.set(prop, needRuntime)          }        }      } else if (!isBuiltInDirective(name)) {        // no built-in transform, this is a user custom directive.        runtimeDirectives.push(prop)        // custom dirs may use beforeUpdate so they need to force blocks        // to ensure before-update gets called before children update        if (hasChildren) {          shouldUseBlock = true        }      }    }  }  let propsExpression = undefined  // has v-bind="object" or v-on="object", wrap with mergeProps  if (mergeArgs.length) {    if (properties.length) {      mergeArgs.push(        createObjectExpression(dedupeProperties(properties), elementLoc)      )    }    if (mergeArgs.length > 1) {      propsExpression = createCallExpression(        context.helper(MERGE_PROPS),        mergeArgs,        elementLoc      )    } else {      // single v-bind with nothing else - no need for a mergeProps call      propsExpression = mergeArgs[0]    }  } else if (properties.length) {    propsExpression = createObjectExpression(      dedupeProperties(properties),      elementLoc    )  }  // patchFlag analysis  if (hasDynamicKeys) {    patchFlag |= PatchFlags.FULL_PROPS  } else {    if (hasClassBinding && !isComponent) {      patchFlag |= PatchFlags.CLASS    }    if (hasStyleBinding && !isComponent) {      patchFlag |= PatchFlags.STYLE    }    if (dynamicPropNames.length) {      patchFlag |= PatchFlags.PROPS    }    if (hasHydrationEventBinding) {      patchFlag |= PatchFlags.HYDRATE_EVENTS    }  }  if (    !shouldUseBlock &&    (patchFlag === 0 || patchFlag === PatchFlags.HYDRATE_EVENTS) &&    (hasRef || hasVnodeHook || runtimeDirectives.length > 0)  ) {    patchFlag |= PatchFlags.NEED_PATCH  }  // pre-normalize props, SSR is skipped for now  if (!context.inSSR && propsExpression) {    switch (propsExpression.type) {      case NodeTypes.JS_OBJECT_EXPRESSION:        // means that there is no v-bind,        // but still need to deal with dynamic key binding        let classKeyIndex = -1        let styleKeyIndex = -1        let hasDynamicKey = false        for (let i = 0; i < propsExpression.properties.length; i++) {          const key = propsExpression.properties[i].key          if (isStaticExp(key)) {            if (key.content === 'class') {              classKeyIndex = i            } else if (key.content === 'style') {              styleKeyIndex = i            }          } else if (!key.isHandlerKey) {            hasDynamicKey = true          }        }        const classProp = propsExpression.properties[classKeyIndex]        const styleProp = propsExpression.properties[styleKeyIndex]        // no dynamic key        if (!hasDynamicKey) {          if (classProp && !isStaticExp(classProp.value)) {            classProp.value = createCallExpression(              context.helper(NORMALIZE_CLASS),              [classProp.value]            )          }          if (            styleProp &&            !isStaticExp(styleProp.value) &&            // the static style is compiled into an object,            // so use `hasStyleBinding` to ensure that it is a dynamic style binding            (hasStyleBinding ||              // v-bind:style and style both exist,              // v-bind:style with static literal object              styleProp.value.type === NodeTypes.JS_ARRAY_EXPRESSION)          ) {            styleProp.value = createCallExpression(              context.helper(NORMALIZE_STYLE),              [styleProp.value]            )          }        } else {          // dynamic key binding, wrap with `normalizeProps`          propsExpression = createCallExpression(            context.helper(NORMALIZE_PROPS),            [propsExpression]          )        }        break      case NodeTypes.JS_CALL_EXPRESSION:        // mergeProps call, do nothing        break      default:        // single v-bind        propsExpression = createCallExpression(          context.helper(NORMALIZE_PROPS),          [            createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [              propsExpression            ])          ]        )        break    }  }  return {    props: propsExpression,    directives: runtimeDirectives,    patchFlag,    dynamicPropNames,    shouldUseBlock  }}// Dedupe props in an object literal.// Literal duplicated attributes would have been warned during the parse phase,// however, it's possible to encounter duplicated `onXXX` handlers with different// modifiers. We also need to merge static and dynamic class / style attributes.// - onXXX handlers / style: merge into array// - class: merge into single expression with concatenationfunction dedupeProperties(properties) {  const knownProps = new Map()  const deduped = []  for (let i = 0; i < properties.length; i++) {    const prop = properties[i]    // dynamic keys are always allowed    if (prop.key.type === NodeTypes.COMPOUND_EXPRESSION || !prop.key.isStatic) {      deduped.push(prop)      continue    }    const name = prop.key.content    const existing = knownProps.get(name)    if (existing) {      if (name === 'style' || name === 'class' || isOn(name)) {        mergeAsArray(existing, prop)      }      // unexpected duplicate, should have emitted error during parse    } else {      knownProps.set(name, prop)      deduped.push(prop)    }  }  return deduped}function mergeAsArray(existing, incoming) {  if (existing.value.type === NodeTypes.JS_ARRAY_EXPRESSION) {    existing.value.elements.push(incoming.value)  } else {    existing.value = createArrayExpression(      [existing.value, incoming.value],      existing.loc    )  }}function buildDirectiveArgs(dir, context) {  const dirArgs = []  const runtime = directiveImportMap.get(dir)  if (runtime) {    // built-in directive with runtime    dirArgs.push(context.helperString(runtime))  } else {    // user directive.    // see if we have directives exposed via <script setup>    const fromSetup =      !__BROWSER__ && resolveSetupReference('v-' + dir.name, context)    if (fromSetup) {      dirArgs.push(fromSetup)    } else {      // inject statement for resolving directive      context.helper(RESOLVE_DIRECTIVE)      context.directives.add(dir.name)      dirArgs.push(toValidAssetId(dir.name, `directive`))    }  }  const { loc } = dir  if (dir.exp) dirArgs.push(dir.exp)  if (dir.arg) {    if (!dir.exp) {      dirArgs.push(`void 0`)    }    dirArgs.push(dir.arg)  }  if (Object.keys(dir.modifiers).length) {    if (!dir.arg) {      if (!dir.exp) {        dirArgs.push(`void 0`)      }      dirArgs.push(`void 0`)    }    const trueExpression = createSimpleExpression(`true`, false, loc)    dirArgs.push(      createObjectExpression(        dir.modifiers.map((modifier) =>          createObjectProperty(modifier, trueExpression)        ),        loc      )    )  }  return createArrayExpression(dirArgs, dir.loc)}function stringifyDynamicPropNames(props) {  let propsNamesString = `[`  for (let i = 0, l = props.length; i < l; i++) {    propsNamesString += JSON.stringify(props[i])    if (i < l - 1) propsNamesString += ', '  }  return propsNamesString + `]`}function isComponentTag(tag) {  return tag === 'component' || tag === 'Component'}const isLiteralWhitelisted = /*#__PURE__*/ makeMap('true,false,null,this')const transformExpression = (node, context) => {  logg(`transformExpression`, node)  //   if (node.type === NodeTypes.INTERPOLATION) {    node.content = processExpression(node.content, context)  } else if (node.type === NodeTypes.ELEMENT) {    //     for (let i = 0; i < node.props.length; i++) {      const dir = node.props[i]      logg(`transformExpression - prop[${i}] - directive`, node.props[i])      // do not process for v-on & v-for since they are special handled      if (dir.type === NodeTypes.DIRECTIVE && dir.name !== 'for') {        // v-for  vFor.ts         const exp = dir.exp        const arg = dir.arg        // do not process exp if this is v-on:arg - we need special handling        // for wrapping inline statements.        if (          exp &&          exp.type === NodeTypes.SIMPLE_EXPRESSION &&          !(dir.name === 'on' && arg)        ) {          dir.exp = processExpression(            exp,            context,            // slot args must be processed as function params            dir.name === 'slot'          )        }        if (arg && arg.type === NodeTypes.SIMPLE_EXPRESSION && !arg.isStatic) {          dir.arg = processExpression(arg, context)        }      }    }  }}// Important: since this function uses Node.js only dependencies, it should// always be used with a leading !__BROWSER__ check so that it can be// tree-shaken from the browser build.function processExpression(  node,  context,  // some expressions like v-slot props & v-for aliases should be parsed as  // function params  asParams = false,  // v-on handler values may contain multiple statements  asRawStatements = false,  localVars = Object.create(context.identifiers)) {  if (__BROWSER__) {    return node  }  if (!context.prefixIdentifiers || !node.content.trim()) {    return node  }  const { inline, bindingMetadata } = context  const rewriteIdentifier = (raw, parent, id) => {    const type = hasOwn(bindingMetadata, raw) && bindingMetadata[raw]    if (inline) {      // x = y      const isAssignmentLVal =        parent && parent.type === 'AssignmentExpression' && parent.left === id      // x++      const isUpdateArg =        parent && parent.type === 'UpdateExpression' && parent.argument === id      // ({ x } = y)      const isDestructureAssignment =        parent && isInDestructureAssignment(parent, parentStack)      if (type === BindingTypes.SETUP_CONST || localVars[raw]) {        return raw      } else if (type === BindingTypes.SETUP_REF) {        return `${raw}.value`      } else if (type === BindingTypes.SETUP_MAYBE_REF) {        // const binding that may or may not be ref        // if it's not a ref, then assignments don't make sense -        // so we ignore the non-ref assignment case and generate code        // that assumes the value to be a ref for more efficiency        return isAssignmentLVal || isUpdateArg || isDestructureAssignment          ? `${raw}.value`          : `${context.helperString(UNREF)}(${raw})`      } else if (type === BindingTypes.SETUP_LET) {        if (isAssignmentLVal) {          // let binding.          // this is a bit more tricky as we need to cover the case where          // let is a local non-ref value, and we need to replicate the          // right hand side value.          // x = y --> isRef(x) ? x.value = y : x = y          const { right: rVal, operator } = parent          const rExp = rawExp.slice(rVal.start - 1, rVal.end - 1)          const rExpString = stringifyExpression(            processExpression(              createSimpleExpression(rExp, false),              context,              false,              false,              knownIds            )          )          return `${context.helperString(            IS_REF          )}(${raw})${``} ? ${raw}.value ${operator} ${rExpString} : ${raw}`        } else if (isUpdateArg) {          // make id replace parent in the code range so the raw update operator          // is removed          id.start = parent.start          id.end = parent.end          const { prefix: isPrefix, operator } = parent          const prefix = isPrefix ? operator : ``          const postfix = isPrefix ? `` : operator          // let binding.          // x++ --> isRef(a) ? a.value++ : a++          return `${context.helperString(            IS_REF          )}(${raw})${``} ? ${prefix}${raw}.value${postfix} : ${prefix}${raw}${postfix}`        } else if (isDestructureAssignment) {          // TODO          // let binding in a destructure assignment - it's very tricky to          // handle both possible cases here without altering the original          // structure of the code, so we just assume it's not a ref here          // for now          return raw        } else {          return `${context.helperString(UNREF)}(${raw})`        }      } else if (type === BindingTypes.PROPS) {        // use __props which is generated by compileScript so in ts mode        // it gets correct type        return `__props.${raw}`      } else if (type === BindingTypes.PROPS_ALIASED) {        // prop with a different local alias (from defineProps() destructure)        return `__props.${bindingMetadata.__propsAliases[raw]}`      }    } else {      if (type && type.startsWith('setup')) {        // setup bindings in non-inline mode        return `$setup.${raw}`      } else if (type === BindingTypes.PROPS_ALIASED) {        return `$props.${bindingMetadata.__propsAliases[raw]}`      } else if (type) {        return `$${type}.${raw}`      }    }    // fallback to ctx    return `_ctx.${raw}`  }  // fast path if expression is a simple identifier.  const rawExp = node.content  // bail constant on parens (function invocation) and dot (member access)  const bailConstant = rawExp.indexOf(`(`) > -1 || rawExp.indexOf('.') > 0 logg(`processExpression - nde.content: ${rawExp}`)  if (isSimpleIdentifier(rawExp)) {    const isScopeVarReference = context.identifiers[rawExp]    const isAllowedGlobal = isGloballyWhitelisted(rawExp)    const isLiteral = isLiteralWhitelisted(rawExp)    if (!asParams && !isScopeVarReference && !isAllowedGlobal && !isLiteral) {      // const bindings exposed from setup can be skipped for patching but      // cannot be hoisted to module scope      if (bindingMetadata[node.content] === BindingTypes.SETUP_CONST) {        node.constType = ConstantTypes.CAN_SKIP_PATCH      }      node.content = rewriteIdentifier(rawExp)    } else if (!isScopeVarReference) {      if (isLiteral) {        node.constType = ConstantTypes.CAN_STRINGIFY      } else {        node.constType = ConstantTypes.CAN_HOIST      }    }    return node  }  let ast  // exp needs to be parsed differently:  // 1. Multiple inline statements (v-on, with presence of `;`): parse as raw  //    exp, but make sure to pad with spaces for consistent ranges  // 2. Expressions: wrap with parens (for e.g. object expressions)  // 3. Function arguments (v-for, v-slot): place in a function argument position  const source = asRawStatements    ? ` ${rawExp} `    : `(${rawExp})${asParams ? `=>{}` : ``}`  try {    ast = babelParser.parse(source, {      plugins: [ ...context.expressionPlugins , ...babelPlugins]    }).program  } catch (e) {    return node  }  logg(`processExpression - babel parse`, ast)  const ids = []  const parentStack = []  const knownIds = Object.create(context.identifiers)  walkIdentifiers(    ast,    (node, parent, _, isReferenced, isLocal) => {      if (isStaticPropertyKey(node, parent)) {        return      }      const needPrefix = isReferenced && canPrefix(node)      if (needPrefix && !isLocal) {        if (isStaticProperty(parent) && parent.shorthand) {          // property shorthand like { foo }, we need to add the key since          // we rewrite the value          node.prefix = `${node.name}: `        }        node.name = rewriteIdentifier(node.name, parent, node)        ids.push(node)      } else {        // The identifier is considered constant unless it's pointing to a        // local scope variable (a v-for alias, or a v-slot prop)        if (!(needPrefix && isLocal) && !bailConstant) {          node.isConstant = true        }        // also generate sub-expressions for other identifiers for better        // source map support. (except for property keys which are static)        ids.push(node)      }    },    true, // invoke on ALL identifiers    parentStack,    knownIds  )  // We break up the compound expression into an array of strings and sub  // expressions (for identifiers that have been prefixed). In codegen, if  // an ExpressionNode has the `.children` property, it will be used instead of  // `.content`.  const children = []  ids.sort((a, b) => a.start - b.start)  ids.forEach((id, i) => {    // range is offset by -1 due to the wrapping parens when parsed    const start = id.start - 1    const end = id.end - 1    const last = ids[i - 1]    const leadingText = rawExp.slice(last ? last.end - 1 : 0, start)    if (leadingText.length || id.prefix) {      children.push(leadingText + (id.prefix || ``))    }    const source = rawExp.slice(start, end)    children.push(      createSimpleExpression(        id.name,        false,        {          source,          start: advancePositionWithClone(node.loc.start, source, start),          end: advancePositionWithClone(node.loc.start, source, end)        },        id.isConstant ? ConstantTypes.CAN_STRINGIFY : ConstantTypes.NOT_CONSTANT      )    )    if (i === ids.length - 1 && end < rawExp.length) {      children.push(rawExp.slice(end))    }  })  let ret  if (children.length) {    ret = createCompoundExpression(children, node.loc)  } else {    ret = node    ret.constType = bailConstant      ? ConstantTypes.NOT_CONSTANT      : ConstantTypes.CAN_STRINGIFY  }  ret.identifiers = Object.keys(knownIds)  return ret}function canPrefix(id) {  // skip whitelisted globals  if (isGloballyWhitelisted(id.name)) {    return false  }  // special case for webpack compilation  if (id.name === 'require') {    return false  }  return true}function stringifyExpression(exp) {  if (isString(exp)) {    return exp  } else if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {    return exp.content  } else {    return exp.children.map(stringifyExpression).join('')  }}const transformSlotOutlet = (node, context) => {  if (isSlotOutlet(node)) {    // <slot/>    const { children, loc } = node    const { slotName, slotProps } = processSlotOutlet(node, context)    const slotArgs = [      context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,      slotName,      '{}', //  props      'undefined', // children      'true'    ]    let expectedLen = 2    if (slotProps) {      slotArgs[2] = slotProps      expectedLen = 3    }    if (children.length) {      slotArgs[3] = createFunctionExpression([], children, false, false, loc)      expectedLen = 4    }    if (context.scopeId && !context.slotted) {      expectedLen = 5    }    slotArgs.splice(expectedLen) // remove unused arguments    // -> renderSlot($slots, slotName, props, children, true)    node.codegenNode = createCallExpression(      context.helper(RENDER_SLOT), // renderSlot      slotArgs,      loc    )  }}function processSlotOutlet(node, context) {  let slotName = `"default"`  let slotProps = undefined  const nonNameProps = [] //   logg(`processSlotOutlet| props.length = ${node.props.length}`)  for (let i = 0; i < node.props.length; i++) {    const p = node.props[i]    logg(`processSlotOutlet| props[${i}]`, p)    if (p.type === NodeTypes.ATTRIBUTE) {      //  <slot name="xxx"/>      if (p.value) {        if (p.name === 'name') {          slotName = JSON.stringify(p.value.content)        } else {          p.name = camelize(p.name)          nonNameProps.push(p)        }      }    } else {      //  <slot :name="xxx"/>      //  <slot v-bind:name="slotName"/>      if (p.name === 'bind' && isStaticArgOf(p.arg, 'name')) {        if (p.exp) slotName = p.exp      } else {        if (p.name === 'bind' && p.arg && isStaticExp(p.arg)) {          p.arg.content = camelize(p.arg.content)        }        nonNameProps.push(p)      }    }  }  logg(`processSlotOutlet| nonNameProps.length=${nonNameProps.length}`)  if (nonNameProps.length > 0) {    const { props, directives } = buildProps(node, context, nonNameProps)    slotProps = props    if (directives.length) {      logg('[ERROR] X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET')    }  }  return {    slotName,    slotProps  }}// Merge adjacent text nodes and expressions into a single expression// e.g. <div>abc {{ d }} {{ e }}</div> should have a single expression node as child.const transformText = (node, context) => {  if (    node.type === NodeTypes.ROOT ||    node.type === NodeTypes.ELEMENT ||    node.type === NodeTypes.FOR ||    node.type === NodeTypes.IF_BRANCH  ) {    // perform the transform on node exit so that all expressions have already    // been processed.    return () => {      const children = node.children      let currentContainer = undefined      let hasText = false      for (let i = 0; i < children.length; i++) {        const child = children[i]        if (isText(child)) {          hasText = true          for (let j = i + 1; j < children.length; j++) {            const next = children[j]            if (isText(next)) {              if (!currentContainer) {                currentContainer = children[i] = {                  type: NodeTypes.COMPOUND_EXPRESSION,                  loc: child.loc,                  children: [child]                }              }              // merge adjacent text node into current              currentContainer.children.push(` + `, next)              children.splice(j, 1)              j--            } else {              currentContainer = undefined              break            }          }        }      }      if (        !hasText ||        // if this is a plain element with a single text child, leave it        // as-is since the runtime has dedicated fast path for this by directly        // setting textContent of the element.        // for component root it's always normalized anyway.        (children.length === 1 &&          (node.type === NodeTypes.ROOT ||            (node.type === NodeTypes.ELEMENT &&              node.tagType === ElementTypes.ELEMENT &&              // #3756              // custom directives can potentially add DOM elements arbitrarily,              // we need to avoid setting textContent of the element at runtime              // to avoid accidentally overwriting the DOM elements added              // by the user through custom directives.              !node.props.find(                (p) =>                  p.type === NodeTypes.DIRECTIVE &&                  !context.directiveTransforms[p.name]              ))))      ) {        return      }      // pre-convert text nodes into createTextVNode(text) calls to avoid      // runtime normalization.      for (let i = 0; i < children.length; i++) {        const child = children[i]        if (isText(child) || child.type === NodeTypes.COMPOUND_EXPRESSION) {          const callArgs = []          // createTextVNode defaults to single whitespace, so if it is a          // single space the code could be an empty call to save bytes.          if (child.type !== NodeTypes.TEXT || child.content !== ' ') {            callArgs.push(child)          }          // mark dynamic text with flag so it gets patched inside a block          if (            !context.ssr &&            getConstantType(child, context) === ConstantTypes.NOT_CONSTANT          ) {            callArgs.push(              PatchFlags.TEXT +                (__DEV__ ? ` /* ${PatchFlagNames[PatchFlags.TEXT]} */` : ``)            )          }          children[i] = {            type: NodeTypes.TEXT_CALL,            content: child,            loc: child.loc,            codegenNode: createCallExpression(              context.helper(CREATE_TEXT),              callArgs            )          }        }      }    }  }}// v-bind without arg is handled directly in ./transformElements.ts due to it affecting// codegen for the entire props object. This transform here is only for v-bind// *with* args.const transformBind = (dir, _node, context) => {  const { exp, modifiers, loc } = dir  const arg = dir.arg  if (arg.type !== NodeTypes.SIMPLE_EXPRESSION) {    arg.children.unshift(`(`)    arg.children.push(`) || ""`)  } else if (!arg.isStatic) {    arg.content = `${arg.content} || ""`  }  // .sync is replaced by v-model:arg  if (modifiers.includes('camel')) {    if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {      if (arg.isStatic) {        arg.content = camelize(arg.content)      } else {        arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`      }    } else {      arg.children.unshift(`${context.helperString(CAMELIZE)}(`)      arg.children.push(`)`)    }  }  if (!context.inSSR) {    if (modifiers.includes('prop')) {      injectPrefix(arg, '.')    }    if (modifiers.includes('attr')) {      injectPrefix(arg, '^')    }  }  if (    !exp ||    (exp.type === NodeTypes.SIMPLE_EXPRESSION && !exp.content.trim())  ) {    logg(`transformBind v-bind no expression`)    return {      props: [createObjectProperty(arg, createSimpleExpression('', true, loc))]    }  }  return {    props: [createObjectProperty(arg, exp)]  }}const injectPrefix = (arg, prefix) => {  if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {    if (arg.isStatic) {      arg.content = prefix + arg.content    } else {      arg.content = `\`${prefix}\${${arg.content}}\``    }  } else {    arg.children.unshift(`'${prefix}' + (`)    arg.children.push(`)`)  }}const transformFor = createStructuralDirectiveTransform(  'for',  (node, dir, context) => {    const { helper, removeHelper } = context    return processFor(node, dir, context, (forNode) => {      // create the loop render function expression now, and add the      // iterator on exit after all children have been traversed      const renderExp = createCallExpression(helper(RENDER_LIST), [        forNode.source      ])      const isTemplate = isTemplateNode(node)      const memo = findDir(node, 'memo')      const keyProp = findProp(node, `key`)      const keyExp =        keyProp &&        (keyProp.type === NodeTypes.ATTRIBUTE          ? createSimpleExpression(keyProp.value.content, true)          : keyProp.exp)      const keyProperty = keyProp ? createObjectProperty(`key`, keyExp) : null      if (!__BROWSER__ && isTemplate) {        // #2085 / #5288 process :key and v-memo expressions need to be        // processed on `<template v-for>`. In this case the node is discarded        // and never traversed so its binding expressions won't be processed        // by the normal transforms.        if (memo) {          memo.exp = processExpression(memo.exp, context)        }        if (keyProperty && keyProp.type !== NodeTypes.ATTRIBUTE) {          keyProperty.value = processExpression(keyProperty.value, context)        }      }      const isStableFragment =        forNode.source.type === NodeTypes.SIMPLE_EXPRESSION &&        forNode.source.constType > ConstantTypes.NOT_CONSTANT      const fragmentFlag = isStableFragment        ? PatchFlags.STABLE_FRAGMENT        : keyProp        ? PatchFlags.KEYED_FRAGMENT        : PatchFlags.UNKEYED_FRAGMENT      forNode.codegenNode = createVNodeCall(        context,        helper(FRAGMENT),        undefined,        renderExp,        fragmentFlag +          (__DEV__ ? ` /* ${PatchFlagNames[fragmentFlag]} */` : ``),        undefined,        undefined,        true /* isBlock */,        !isStableFragment /* disableTracking */,        false /* isComponent */,        node.loc      )      return () => {        // finish the codegen now that all children have been traversed        let childBlock        const { children } = forNode        // check <template v-for> key placement        if ((__DEV__ || !__BROWSER__) && isTemplate) {          node.children.some((c) => {            if (c.type === NodeTypes.ELEMENT) {              const key = findProp(c, 'key')              if (key) {                logg(`transformFor - key on template`)                return true              }            }          })        }        const needFragmentWrapper =          children.length !== 1 || children[0].type !== NodeTypes.ELEMENT        const slotOutlet = isSlotOutlet(node)          ? node          : isTemplate &&            node.children.length === 1 &&            isSlotOutlet(node.children[0])          ? node.children[0] // api-extractor somehow fails to infer this          : null        if (slotOutlet) {          // <slot v-for="..."> or <template v-for="..."><slot/></template>          childBlock = slotOutlet.codegenNode          if (isTemplate && keyProperty) {            // <template v-for="..." :key="..."><slot/></template>            // we need to inject the key to the renderSlot() call.            // the props for renderSlot is passed as the 3rd argument.            injectProp(childBlock, keyProperty, context)          }        } else if (needFragmentWrapper) {          // <template v-for="..."> with text or multi-elements          // should generate a fragment block for each loop          childBlock = createVNodeCall(            context,            helper(FRAGMENT),            keyProperty ? createObjectExpression([keyProperty]) : undefined,            node.children,            PatchFlags.STABLE_FRAGMENT +              (__DEV__                ? ` /* ${PatchFlagNames[PatchFlags.STABLE_FRAGMENT]} */`                : ``),            undefined,            undefined,            true,            undefined,            false /* isComponent */          )        } else {          // Normal element v-for. Directly use the child's codegenNode          // but mark it as a block.          childBlock = children[0].codegenNode          if (isTemplate && keyProperty) {            injectProp(childBlock, keyProperty, context)          }          if (childBlock.isBlock !== !isStableFragment) {            if (childBlock.isBlock) {              // switch from block to vnode              removeHelper(OPEN_BLOCK)              removeHelper(                getVNodeBlockHelper(context.inSSR, childBlock.isComponent)              )            } else {              // switch from vnode to block              removeHelper(                getVNodeHelper(context.inSSR, childBlock.isComponent)              )            }          }          childBlock.isBlock = !isStableFragment          if (childBlock.isBlock) {            helper(OPEN_BLOCK)            helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent))          } else {            helper(getVNodeHelper(context.inSSR, childBlock.isComponent))          }        }        if (memo) {          const loop = createFunctionExpression(            createForLoopParams(forNode.parseResult, [              createSimpleExpression(`_cached`)            ])          )          loop.body = createBlockStatement([            createCompoundExpression([`const _memo = (`, memo.exp, `)`]),            createCompoundExpression([              `if (_cached`,              ...(keyExp ? [` && _cached.key === `, keyExp] : []),              ` && ${context.helperString(                IS_MEMO_SAME              )}(_cached, _memo)) return _cached`            ]),            createCompoundExpression([`const _item = `, childBlock]),            createSimpleExpression(`_item.memo = _memo`),            createSimpleExpression(`return _item`)          ])          renderExp.arguments.push(            loop,            createSimpleExpression(`_cache`),            createSimpleExpression(String(context.cached++))          )        } else {          renderExp.arguments.push(            createFunctionExpression(              createForLoopParams(forNode.parseResult),              childBlock,              true /* force newline */            )          )        }      }    })  })// target-agnostic transform used for both Client and SSRfunction processFor(node, dir, context, processCodegen) {  if (!dir.exp) {    logg(`processFor - dir.exp is null`)    return  }  const parseResult = parseForExpression(    // can only be simple expression because vFor transform is applied    // before expression transform.    dir.exp,    context  )  if (!parseResult) {    logg(`processFor - parseResult is null`)    return  }  const { addIdentifiers, removeIdentifiers, scopes } = context  const { source, value, key, index } = parseResult  const forNode = {    type: NodeTypes.FOR,    loc: dir.loc,    source,    valueAlias: value,    keyAlias: key,    objectIndexAlias: index,    parseResult,    children: isTemplateNode(node) ? node.children : [node]  }  context.replaceNode(forNode)  // bookkeeping  scopes.vFor++  if (!__BROWSER__ && context.prefixIdentifiers) {    // scope management    // inject identifiers to context    value && addIdentifiers(value)    key && addIdentifiers(key)    index && addIdentifiers(index)  }  const onExit = processCodegen && processCodegen(forNode)  return () => {    scopes.vFor--    if (!__BROWSER__ && context.prefixIdentifiers) {      value && removeIdentifiers(value)      key && removeIdentifiers(key)      index && removeIdentifiers(index)    }    if (onExit) onExit()  }}const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/// This regex doesn't cover the case if key or index aliases have destructuring,// but those do not make sense in the first place, so this works in practice.const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/const stripParensRE = /^\(|\)$/gfunction parseForExpression(input, context) {  const loc = input.loc  const exp = input.content  const inMatch = exp.match(forAliasRE)  if (!inMatch) return  const [, LHS, RHS] = inMatch  const result = {    source: createAliasExpression(      loc,      RHS.trim(),      exp.indexOf(RHS, LHS.length)    ),    value: undefined,    key: undefined,    index: undefined  }  if (!__BROWSER__ && context.prefixIdentifiers) {    result.source = processExpression(result.source, context)  }  let valueContent = LHS.trim().replace(stripParensRE, '').trim()  const trimmedOffset = LHS.indexOf(valueContent)  const iteratorMatch = valueContent.match(forIteratorRE)  if (iteratorMatch) {    valueContent = valueContent.replace(forIteratorRE, '').trim()    const keyContent = iteratorMatch[1].trim()    let keyOffset    if (keyContent) {      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length)      result.key = createAliasExpression(loc, keyContent, keyOffset)      if (!__BROWSER__ && context.prefixIdentifiers) {        result.key = processExpression(result.key, context, true)      }    }    if (iteratorMatch[2]) {      const indexContent = iteratorMatch[2].trim()      if (indexContent) {        result.index = createAliasExpression(          loc,          indexContent,          exp.indexOf(            indexContent,            result.key              ? keyOffset + keyContent.length              : trimmedOffset + valueContent.length          )        )        if (!__BROWSER__ && context.prefixIdentifiers) {          result.index = processExpression(result.index, context, true)        }      }    }  }  if (valueContent) {    result.value = createAliasExpression(loc, valueContent, trimmedOffset)    if (!__BROWSER__ && context.prefixIdentifiers) {      result.value = processExpression(result.value, context, true)    }  }  return result}function createAliasExpression(range, content, offset) {  return createSimpleExpression(    content,    false,    getInnerRange(range, offset, content.length)  )}function createForLoopParams({ value, key, index }, memoArgs = []) {  return createParamsList([value, key, index, ...memoArgs])}function createParamsList(args) {  let i = args.length  while (i--) {    if (args[i]) break  }  return args    .slice(0, i + 1)    .map((arg, i) => arg || createSimpleExpression(`_`.repeat(i + 1), false))}function processIf(node, dir, context, processCodegen) {  logg('processIf - node - dir', node, dir)  if (dir.name !== 'else' && (!dir.exp || !dir.exp.content.trim())) {    const loc = dir.exp ? dir.exp.loc : node.loc    // <div v-if></div>  true    dir.exp = createSimpleExpression(`true`, false, loc)  }  if (!__BROWSER__ && context.prefixIdentifiers && dir.exp) {    // dir.exp can only be simple expression because vIf transform is applied    // before expression transform.    dir.exp = processExpression(dir.exp, context)  }  if (dir.name === 'if') {    // v-if    const branch = createIfBranch(node, dir)    const ifNode = {      type: NodeTypes.IF,      loc: node.loc,      branches: [branch]    }    context.replaceNode(ifNode)    if (processCodegen) {      return processCodegen(ifNode, branch, true)    }  } else {    // locate the adjacent v-if    const siblings = context.parent.children    const comments = []    let i = siblings.indexOf(node)    while (i-- >= -1) {      const sibling = siblings[i]      //       if (        sibling &&        sibling.type === NodeTypes.TEXT &&        !sibling.content.trim().length      ) {        context.removeNode(sibling)        continue      }      if (sibling && sibling.type === NodeTypes.IF) {        //  if (else-if, else node.branches[...])        context.removeNode()        const branch = createIfBranch(node, dir)        sibling.branches.push(branch)        const onExit = processCodegen && processCodegen(sibling, branch, false)        //         traverseNode(branch, context)        //  transformXxx         if (onExit) onExit()        // make sure to reset currentNode after traversal to indicate this        // node has been removed.        context.currentNode = null      }      break    }  }}function createIfBranch(node, dir) {  return {    type: NodeTypes.IF_BRANCH,    loc: node.loc,    condition: dir.name === 'else' ? undefined : dir.exp,    children:      node.tagType === ElementTypes.TEMPLATE && !findDir(node, 'for')        ? node.children        : [node],    userKey: findProp(node, `key`)  }}function createCodegenNodeForBranch(branch, keyIndex, context) {  if (branch.condition) {    return createConditionalExpression(      branch.condition,      createChildrenCodegenNode(branch, keyIndex, context),      //  v-if  v-if       //  <div v-if="foo"/><div v-else/> => foo ? ... : ...      //  <div v-if="foo"/><div v-else-if="bar"/><div v-else/> => foo ? ... : bar ? ... : ...      //  v-else `foo ? ...`       //  v-else       createCallExpression(context.helper(CREATE_COMMENT), [        __DEV__ ? '"v-if"' : '""',        'true'      ])    )  } else {    return createChildrenCodegenNode(branch, keyIndex, context)  }}function createChildrenCodegenNode(branch, keyIndex, context) {  const { helper } = context  const keyProperty = createObjectProperty(    `key`,    createSimpleExpression(      `${keyIndex}`,      false,      locStub,      ConstantTypes.CAN_HOIST    )  )  const { children } = branch  const firstChild = children[0]  const needFragmentWrapper =    children.length !== 1 || firstChild.type !== NodeTypes.ELEMENT  if (needFragmentWrapper) {    if (children.length === 1 && firstChild.type === NodeTypes.FOR) {      // optimize away nested fragments when child is a ForNode      const vnodeCall = firstChild.codegenNode      injectProp(vnodeCall, keyProperty, context)      return vnodeCall    } else {      let patchFlag = PatchFlags.STABLE_FRAGMENT      let patchFlagText = PatchFlagNames[PatchFlags.STABLE_FRAGMENT]      return createVNodeCall(        context,        helper(FRAGMENT),        createObjectExpression([keyProperty]),        children,        patchFlag + (__DEV__ ? ` /* ${patchFlagText} */` : ``),        undefined,        undefined,        true,        false,        false /* isComponent */,        branch.loc      )    }  } else {    const ret = firstChild.codegenNode    const vnodeCall = getMemoedVNodeCall(ret)    // Change createVNode to createBlock.    if (vnodeCall.type === NodeTypes.VNODE_CALL) {      makeBlock(vnodeCall, context)    }    // inject branch key    injectProp(vnodeCall, keyProperty, context)    return ret  }}function isSameKey(a, b) {  if (!a || a.type !== b.type) {    return false  }  if (a.type === NodeTypes.ATTRIBUTE) {    if (a.value.content !== b.value.content) {      return false    }  } else {    // directive    const exp = a.exp    const branchExp = b.exp    if (exp.type !== branchExp.type) {      return false    }    if (      exp.type !== NodeTypes.SIMPLE_EXPRESSION ||      exp.isStatic !== branchExp.isStatic ||      exp.content !== branchExp.content    ) {      return false    }  }  return true}function getParentCondition(node) {  while (true) {    if (node.type === NodeTypes.JS_CONDITIONAL_EXPRESSION) {      if (node.alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION) {        node = node.alternate      } else {        return node      }    } else if (node.type === NodeTypes.JS_CACHE_EXPRESSION) {      node = node.value    }  }}const transformIf = createStructuralDirectiveTransform(  /^(if|else|else-if)$/,  (node, dir, context) => {    return processIf(node, dir, context, (ifNode, branch, isRoot) => {      const siblings = context.parent.children      // if...else if...else       let i = siblings.indexOf(ifNode)      let key = 0      while (i-- >= 0) {        const sibling = siblings[i]        if (sibling && sibling.type === NodeTypes.IF) {          key += sibling.branches.length        }      }      logg('transformIf', ifNode, { isRoot, branch })      //  children  codegenNode      return () => {        if (isRoot) {          // v-if          ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context)          logg('transformIf - isRoot - v-if', ifNode)        } else {          // v-else, v-else-if          //  v-else-*  v-if           const parentCondition = getParentCondition(ifNode.codegenNode)          parentCondition.alternate = createCodegenNodeForBranch(            branch,            key + ifNode.branches.length - 1,            context          )          logg('transformIf - v-else-*', ifNode)        }      }    })  })const memoSeen = new WeakSet()const transformMemo = (node, context) => {  if (node.type === NodeTypes.ELEMENT) {    const dir = findDir(node, 'memo')    if (!dir || memoSeen.has(node)) {      return    }    memoSeen.add(node)    return () => {      const codegenNode = node.codegenNode || context.currentNode.codegenNode      if (codegenNode && codegenNode.type === NodeTypes.VNODE_CALL) {        // non-component sub tree should be turned into a block        if (node.tagType !== ElementTypes.COMPONENT) {          makeBlock(codegenNode, context)        }        node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [          dir.exp,          createFunctionExpression(undefined, codegenNode),          `_cache`,          String(context.cached++)        ])      }    }  }}const transformModel = (dir, node, context) => {  const { exp, arg } = dir  if (!exp) {    logg(`transformModel no exp`)    return createTransformProps()  }  const rawExp = exp.loc.source  const expString =    exp.type === NodeTypes.SIMPLE_EXPRESSION ? exp.content : rawExp  // im SFC <script setup> inline mode, the exp may have been transformed into  // _unref(exp)  const bindingType = context.bindingMetadata[rawExp]  const maybeRef =    !__BROWSER__ &&    context.inline &&    bindingType &&    bindingType !== BindingTypes.SETUP_CONST  if (    !expString.trim() ||    (!isMemberExpression(expString, context) && !maybeRef)  ) {    return createTransformProps()  }  if (    !__BROWSER__ &&    context.prefixIdentifiers &&    isSimpleIdentifier(expString) &&    context.identifiers[expString]  ) {    return createTransformProps()  }  const propName = arg ? arg : createSimpleExpression('modelValue', true)  const eventName = arg    ? isStaticExp(arg)      ? `onUpdate:${arg.content}`      : createCompoundExpression(['"onUpdate:" + ', arg])    : `onUpdate:modelValue`  let assignmentExp  const eventArg = context.isTS ? `($event: any)` : `$event`  if (maybeRef) {    if (bindingType === BindingTypes.SETUP_REF) {      // v-model used on known ref.      assignmentExp = createCompoundExpression([        `${eventArg} => ((`,        createSimpleExpression(rawExp, false, exp.loc),        `).value = $event)`      ])    } else {      // v-model used on a potentially ref binding in <script setup> inline mode.      // the assignment needs to check whether the binding is actually a ref.      const altAssignment =        bindingType === BindingTypes.SETUP_LET ? `${rawExp} = $event` : `null`      assignmentExp = createCompoundExpression([        `${eventArg} => (${context.helperString(IS_REF)}(${rawExp}) ? (`,        createSimpleExpression(rawExp, false, exp.loc),        `).value = $event : ${altAssignment})`      ])    }  } else {    assignmentExp = createCompoundExpression([      `${eventArg} => ((`,      exp,      `) = $event)`    ])  }  const props = [    // modelValue: foo    createObjectProperty(propName, dir.exp),    // "onUpdate:modelValue": $event => (foo = $event)    createObjectProperty(eventName, assignmentExp)  ]  // cache v-model handler if applicable (when it doesn't refer any scope vars)  if (    !__BROWSER__ &&    context.prefixIdentifiers &&    !context.inVOnce &&    context.cacheHandlers &&    !hasScopeRef(exp, context.identifiers)  ) {    props[1].value = context.cache(props[1].value)  }  // modelModifiers: { foo: true, "bar-baz": true }  if (dir.modifiers.length && node.tagType === ElementTypes.COMPONENT) {    const modifiers = dir.modifiers      .map((m) => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`)      .join(`, `)    const modifiersKey = arg      ? isStaticExp(arg)        ? `${arg.content}Modifiers`        : createCompoundExpression([arg, ' + "Modifiers"'])      : `modelModifiers`    props.push(      createObjectProperty(        modifiersKey,        createSimpleExpression(          `{ ${modifiers} }`,          false,          dir.loc,          ConstantTypes.CAN_HOIST        )      )    )  }  return createTransformProps(props)}function createTransformProps(props = []) {  return { props }}// , @click="fnExp"const fnExpRE =  /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/const transformOn = (dir, node, context, augmentor) => {  const { loc, modifiers, arg } = dir  let eventName  if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {    if (arg.isStatic) {      let rawName = arg.content      //       eventName = createSimpleExpression(        toHandlerKey(camelize(rawName)),        true,        arg.loc      )    } else {      // #2388 toHandlerKey  onXxx, eventName -> onEventName      eventName = createCompoundExpression([        `${context.helperString(TO_HANDLER_KEY)}(`,        arg,        `)`      ])    }  } else {    // already a compound expression.    eventName = arg    eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`)    eventName.children.push(`)`)  }  // handler processing,   let exp = dir.exp  if (exp && !exp.content.trim()) {    exp = undefined  }  //   let shouldCache = context.cacheHandlers && !exp && !context.inVOnce  if (exp) {    const isMemberExp = isMemberExpression(exp.content, context)    const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content))    const hasMultipleStatements = exp.content.includes(`;`)    // process the expression since it's been skipped    if (!__BROWSER__ && context.prefixIdentifiers) {      isInlineStatement && context.addIdentifiers(`$event`)      exp = dir.exp = processExpression(        exp,        context,        false,        hasMultipleStatements      )      isInlineStatement && context.removeIdentifiers(`$event`)      // with scope analysis, the function is hoistable if it has no reference      // to scope variables.      shouldCache =        context.cacheHandlers &&        // unnecessary to cache inside v-once        !context.inVOnce &&        // runtime constants don't need to be cached        // (this is analyzed by compileScript in SFC <script setup>)        !(exp.type === NodeTypes.SIMPLE_EXPRESSION && exp.constType > 0) &&        // #1541 bail if this is a member exp handler passed to a component -        // we need to use the original function to preserve arity,        // e.g. <transition> relies on checking cb.length to determine        // transition end handling. Inline function is ok since its arity        // is preserved even when cached.        !(isMemberExp && node.tagType === ElementTypes.COMPONENT) &&        // bail if the function references closure variables (v-for, v-slot)        // it must be passed fresh to avoid stale values.        !hasScopeRef(exp, context.identifiers)      // If the expression is optimizable and is a member expression pointing      // to a function, turn it into invocation (and wrap in an arrow function      // below) so that it always accesses the latest value when called - thus      // avoiding the need to be patched.      if (shouldCache && isMemberExp) {        if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {          exp.content = `${exp.content} && ${exp.content}(...args)`        } else {          exp.children = [...exp.children, ` && `, ...exp.children, `(...args)`]        }      }    }    if (isInlineStatement || (shouldCache && isMemberExp)) {      // wrap inline statement in a function expression      // ($event) => statement      // (...args) => { statement1;statement2 }      exp = createCompoundExpression([        `${isInlineStatement ? `$event` : `(...args)`} => ${          hasMultipleStatements ? `{` : `(`        }`,        exp,        hasMultipleStatements ? `}` : `)`      ])    }  }  let ret = {    props: [      createObjectProperty(        eventName,        exp || createSimpleExpression(`() => {}`, false, loc)      )    ]  }  // apply extended compiler augmentor  if (augmentor) {    ret = augmentor(ret)  }  if (shouldCache) {    // cache handlers so that it's always the same handler being passed down.    // this avoids unnecessary re-renders when users use inline handlers on    // components.    ret.props[0].value = context.cache(ret.props[0].value)  }  // mark the key as handler for props normalization check  ret.props.forEach((p) => (p.key.isHandlerKey = true))  return ret}const seen = new WeakSet()const transformOnce = (node, context) => {  if (node.type === NodeTypes.ELEMENT && findDir(node, 'once', true)) {    if (seen.has(node) || context.inVOnce) {      logg(`transformOnce node has seen`)      return    }    seen.add(node)    context.inVOnce = true    context.helper(SET_BLOCK_TRACKING)    return () => {      context.inVOnce = false      const cur = context.currentNode      if (cur.codegenNode) {        cur.codegenNode = context.cache(cur.codegenNode, true /* isVNode */)      }    }  }}// Important: since this function uses Node.js only dependencies, it should// always be used with a leading !__BROWSER__ check so that it can be// tree-shaken from the browser build.function processExpression(  node,  context,  // some expressions like v-slot props & v-for aliases should be parsed as  // function params  asParams = false,  // v-on handler values may contain multiple statements  asRawStatements = false,  localVars = Object.create(context.identifiers)) {  if (__BROWSER__) {    return node  }  if (!context.prefixIdentifiers || !node.content.trim()) {    return node  }  const { inline, bindingMetadata } = context  const rewriteIdentifier = (raw, parent, id) => {    const type = hasOwn(bindingMetadata, raw) && bindingMetadata[raw]    if (inline) {      // x = y      const isAssignmentLVal =        parent && parent.type === 'AssignmentExpression' && parent.left === id      // x++      const isUpdateArg =        parent && parent.type === 'UpdateExpression' && parent.argument === id      // ({ x } = y)      const isDestructureAssignment =        parent && isInDestructureAssignment(parent, parentStack)      if (type === BindingTypes.SETUP_CONST || localVars[raw]) {        return raw      } else if (type === BindingTypes.SETUP_REF) {        return `${raw}.value`      } else if (type === BindingTypes.SETUP_MAYBE_REF) {        // const binding that may or may not be ref        // if it's not a ref, then assignments don't make sense -        // so we ignore the non-ref assignment case and generate code        // that assumes the value to be a ref for more efficiency        return isAssignmentLVal || isUpdateArg || isDestructureAssignment          ? `${raw}.value`          : `${context.helperString(UNREF)}(${raw})`      } else if (type === BindingTypes.SETUP_LET) {        if (isAssignmentLVal) {          // let binding.          // this is a bit more tricky as we need to cover the case where          // let is a local non-ref value, and we need to replicate the          // right hand side value.          // x = y --> isRef(x) ? x.value = y : x = y          const { right: rVal, operator } = parent          const rExp = rawExp.slice(rVal.start - 1, rVal.end - 1)          const rExpString = stringifyExpression(            processExpression(              createSimpleExpression(rExp, false),              context,              false,              false,              knownIds            )          )          return `${context.helperString(            IS_REF          )}(${raw})${``} ? ${raw}.value ${operator} ${rExpString} : ${raw}`        } else if (isUpdateArg) {          // make id replace parent in the code range so the raw update operator          // is removed          id.start = parent.start          id.end = parent.end          const { prefix: isPrefix, operator } = parent          const prefix = isPrefix ? operator : ``          const postfix = isPrefix ? `` : operator          // let binding.          // x++ --> isRef(a) ? a.value++ : a++          return `${context.helperString(            IS_REF          )}(${raw})${``} ? ${prefix}${raw}.value${postfix} : ${prefix}${raw}${postfix}`        } else if (isDestructureAssignment) {          // TODO          // let binding in a destructure assignment - it's very tricky to          // handle both possible cases here without altering the original          // structure of the code, so we just assume it's not a ref here          // for now          return raw        } else {          return `${context.helperString(UNREF)}(${raw})`        }      } else if (type === BindingTypes.PROPS) {        // use __props which is generated by compileScript so in ts mode        // it gets correct type        return `__props.${raw}`      } else if (type === BindingTypes.PROPS_ALIASED) {        // prop with a different local alias (from defineProps() destructure)        return `__props.${bindingMetadata.__propsAliases[raw]}`      }   } else {      if (type & type.startsWith('setup')) {        // setup bindings in non-inline mode        return `$setup.${raw}`      } else if (type === BindingTypes.PROPS_ALIASED) {        return `$props.${bindingMetadata.__propsAliases[raw]}`      } else if (type) {        return `$${type}.${raw}`      }    }    // fallback to ctx    return `_ctx.${raw}`  }  // fast path if expression is a simple identifier.  const rawExp = node.content  // bail constant on parens (function invocation) and dot (member access)  const bailConstant = rawExp.indexOf(`(`) > -1 || rawExp.indexOf('.') > 0  if (isSimpleIdentifier(rawExp)) {    const isScopeVarReference = context.identifiers[rawExp]    const isAllowedGlobal = isGloballyWhitelisted(rawExp)    const isLiteral = isLiteralWhitelisted(rawExp)    if (!asParams && !isScopeVarReference && !isAllowedGlobal && !isLiteral) {      // const bindings exposed from setup can be skipped for patching but      // cannot be hoisted to module scope      if (bindingMetadata[node.content] === BindingTypes.SETUP_CONST) {        node.constType = ConstantTypes.CAN_SKIP_PATCH      }      node.content = rewriteIdentifier(rawExp)    } else if (!isScopeVarReference) {      if (isLiteral) {        node.constType = ConstantTypes.CAN_STRINGIFY      } else {        node.constType = ConstantTypes.CAN_HOIST      }    }    return node  }  let ast  // exp needs to be parsed differently:  // 1. Multiple inline statements (v-on, with presence of `;`): parse as raw  //    exp, but make sure to pad with spaces for consistent ranges  // 2. Expressions: wrap with parens (for e.g. object expressions)  // 3. Function arguments (v-for, v-slot): place in a function argument position  const source = asRawStatements    ? ` ${rawExp} `    : `(${rawExp})${asParams ? `=>{}` : ``}`  try {    ast = babelParser.parse(source, {      plugins: [ ...context.expressionPlugins , ...babelPlugins]    }).program  } catch (e) {    return node  }  const ids = []  const parentStack = []  const knownIds = Object.create(context.identifiers)  walkIdentifiers(    ast,    (node, parent, _, isReferenced, isLocal) => {      if (isStaticPropertyKey(node, parent)) {        return      }      const needPrefix = isReferenced && canPrefix(node)      if (needPrefix && !isLocal) {        if (isStaticProperty(parent) && parent.shorthand) {          // property shorthand like { foo }, we need to add the key since          // we rewrite the value          node.prefix = `${node.name}: `        }        node.name = rewriteIdentifier(node.name, parent, node)        ids.push(node)      } else {        // The identifier is considered constant unless it's pointing to a        // local scope variable (a v-for alias, or a v-slot prop)        if (!(needPrefix && isLocal) && !bailConstant) {          node.isConstant = true        }        // also generate sub-expressions for other identifiers for better        // source map support. (except for property keys which are static)        ids.push(node)      }    },    true, // invoke on ALL identifiers    parentStack,    knownIds  )  // We break up the compound expression into an array of strings and sub  // expressions (for identifiers that have been prefixed). In codegen, if  // an ExpressionNode has the `.children` property, it will be used instead of  // `.content`.  const children = []  ids.sort((a, b) => a.start - b.start)  ids.forEach((id, i) => {    // range is offset by -1 due to the wrapping parens when parsed    const start = id.start - 1    const end = id.end - 1    const last = ids[i - 1]    const leadingText = rawExp.slice(last ? last.end - 1 : 0, start)    if (leadingText.length || id.prefix) {      children.push(leadingText + (id.prefix || ``))    }    const source = rawExp.slice(start, end)    children.push(      createSimpleExpression(        id.name,        false,        {          source,          start: advancePositionWithClone(node.loc.start, source, start),          end: advancePositionWithClone(node.loc.start, source, end)        },        id.isConstant ? ConstantTypes.CAN_STRINGIFY : ConstantTypes.NOT_CONSTANT      )    )    if (i === ids.length - 1 && end < rawExp.length) {      children.push(rawExp.slice(end))    }  })  let ret  if (children.length) {    ret = createCompoundExpression(children, node.loc)  } else {    ret = node    ret.constType = bailConstant      ? ConstantTypes.NOT_CONSTANT      : ConstantTypes.CAN_STRINGIFY  }  ret.identifiers = Object.keys(knownIds)  return ret}function canPrefix(id) {  // skip whitelisted globals  if (isGloballyWhitelisted(id.name)) {    return false  }  // special case for webpack compilation  if (id.name === 'require') {    return false  }  return true}function stringifyExpression(exp) {  if (isString(exp)) {    return exp  } else if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {    return exp.content  } else {    return exp.children.map(stringifyExpression).join('')  }}function createRoot(children, loc = locStub) {  return {    type: NodeTypes.ROOT,    children,    helpers: [],    components: [],    directives: [],    hoists: [],    imports: [],    cached: 0,    temps: 0,    codegenNode: undefined,    loc  }}function createVNodeCall(  context,  tag,  props,  children,  patchFlag,  dynamicProps,  directives,  isBlock = false,  disableTracking = false,  isComponent = false,  loc = locStub) {  if (context) {    //  block    if (isBlock) {      context.helper(OPEN_BLOCK)      context.helper(getVNodeBlockHelper(context.inSSR, isComponent))    } else {      //  fragment      context.helper(getVNodeHelper(context.inSSR, isComponent))    }    if (directives) {      context.helper(WITH_DIRECTIVES)    }  }  return {    type: NodeTypes.VNODE_CALL,    tag,    props,    children,    patchFlag,    dynamicProps,    directives,    isBlock,    disableTracking,    isComponent,    loc  }}function createArrayExpression(elements, loc = locStub) {  return {    type: NodeTypes.JS_ARRAY_EXPRESSION,    loc,    elements  }}function createObjectExpression(properties, loc = locStub) {  return {    type: NodeTypes.JS_OBJECT_EXPRESSION,    loc,    properties  }}function createObjectProperty(key, value) {  return {    type: NodeTypes.JS_PROPERTY,    loc: locStub,    key: isString(key) ? createSimpleExpression(key, true) : key,    value  }}function createSimpleExpression(  content,  isStatic = false,  loc = locStub,  constType = ConstantTypes.NOT_CONSTANT) {  return {    type: NodeTypes.SIMPLE_EXPRESSION,    loc,    content,    isStatic,    constType: isStatic ? ConstantTypes.CAN_STRINGIFY : constType  }}function createInterpolation(content, loc) {  return {    type: NodeTypes.INTERPOLATION,    loc,    content: isString(content)      ? createSimpleExpression(content, false, loc)      : content  }}function createCompoundExpression(children, loc = locStub) {  return {    type: NodeTypes.COMPOUND_EXPRESSION,    loc,    children  }}function createCallExpression(callee, args = [], loc = locStub) {  return {    type: NodeTypes.JS_CALL_EXPRESSION,    loc,    callee,    arguments: args  }}function createFunctionExpression(  params,  returns = undefined,  newline = false,  isSlot = false,  loc = locStub) {  return {    type: NodeTypes.JS_FUNCTION_EXPRESSION,    params,    returns,    newline,    isSlot,    loc  }}function createConditionalExpression(  test,  consequent,  alternate,  newline = true) {  return {    type: NodeTypes.JS_CONDITIONAL_EXPRESSION,    test,    consequent,    alternate,    newline,    loc: locStub  }}function createCacheExpression(index, value, isVNode = false) {  return {    type: NodeTypes.JS_CACHE_EXPRESSION,    index,    value,    isVNode,    loc: locStub  }}function createBlockStatement(body) {  return {    type: NodeTypes.JS_BLOCK_STATEMENT,    body,    loc: locStub  }}function createTemplateLiteral(elements) {  return {    type: NodeTypes.JS_TEMPLATE_LITERAL,    elements,    loc: locStub  }}function createIfStatement(test, consequent, alternate) {  return {    type: NodeTypes.JS_IF_STATEMENT,    test,    consequent,    alternate,    loc: locStub  }}function createAssignmentExpression(left, right) {  return {    type: NodeTypes.JS_ASSIGNMENT_EXPRESSION,    left,    right,    loc: locStub  }}function createSequenceExpression(expressions) {  return {    type: NodeTypes.JS_SEQUENCE_EXPRESSION,    expressions,    loc: locStub  }}function createReturnStatement(returns) {  return {    type: NodeTypes.JS_RETURN_STATEMENT,    returns,    loc: locStub  }}function transform(root, options) {  // transform   const context = createTransformContext(root, options)  //  ast root  codegenNode  traverseNode(root, context)  //   if (options.hoistStatic) {    hoistStatic(root, context)  }  //  root codegenNode   if (!options.ssr) {    createRootCodegen(root, context)  }  // finalize meta information  root.helpers = [...context.helpers.keys()]  root.components = [...context.components]  root.directives = [...context.directives]  root.imports = context.imports  root.hoists = context.hoists  root.temps = context.temps  root.cached = context.cached}function getBaseTransformPreset(prefixIdentifiers) {  return [    [      transformOnce,      transformIf,      transformMemo,      transformFor,      ...(!__BROWSER__ && prefixIdentifiers        ? [            // order is important            trackVForSlotScopes,            transformExpression          ]        : __BROWSER__ && __DEV__        ? [transformExpression]        : []),      transformSlotOutlet,      transformElement,      trackSlotScopes,      transformText    ],    {      on: transformOn,      bind: transformBind,      model: transformModel    }  ]}const PURE_ANNOTATION = `/*#__PURE__*/`function isText$1(n) {  return (    isString(n) ||    n.type === NodeTypes.SIMPLE_EXPRESSION ||    n.type === NodeTypes.TEXT ||    n.type === NodeTypes.INTERPOLATION ||    n.type === NodeTypes.COMPOUND_EXPRESSION  )}// fn(a, b, c, null, undefined, '') => fn(a,b,c)function genNullableArgs(args) {  let i = args.length  while (i--) {    if (args[i] != null) break  }  return args.slice(0, i + 1).map((arg) => arg || `null`)}//  key  { [a + b + c]: value }function genExpressionAsPropertyKey(node, context) {  const { push } = context  if (node.type === NodeTypes.COMPOUND_EXPRESSION) {    push(`[`)    genCompoundExpression(node, context)    push(`]`)  } else if (node.isStatic) {    // only quote keys if necessary    const text = isSimpleIdentifier(node.content)      ? node.content      : JSON.stringify(node.content)    push(text, node)  } else {    push(`[${node.content}]`, node)  }}function createCodegenContext(  ast,  {    mode = 'function',    prefixIdentifiers = mode === 'module',    sourceMap = false,    filename = `template.vue.html`,    scopeId = null,    optimizeImports = false,    runtimeGlobalName = `Vue`,    runtimeModuleName = `vue`,    ssrRuntimeModuleName = 'vue/server-renderer',    ssr = false,    isTS = false,    inSSR = false  }) {  const context = {    mode,    prefixIdentifiers,    sourceMap,    filename,    scopeId,    optimizeImports,    runtimeGlobalName,    runtimeModuleName,    ssrRuntimeModuleName,    ssr,    isTS,    inSSR,    source: ast.loc.source,    code: ``,    column: 1,    line: 1,    offset: 0,    indentLevel: 0,    pure: false,    map: undefined,    helper(key) {      return `_${helperNameMap[key]}`    },    push(code, node) {      context.code += code      if (!__BROWSER__ && context.map) {        if (node) {          let name          if (node.type === NodeTypes.SIMPLE_EXPRESSION && !node.isStatic) {            const content = node.content.replace(/^_ctx\./, '')            if (content !== node.content && isSimpleIdentifier(content)) {              name = content            }          }          addMapping(node.loc.start, name)        }        advancePositionWithMutation(context, code)        if (node && node.loc !== locStub) {          addMapping(node.loc.end)        }      }    },    indent() {      newline(++context.indentLevel)    },    deindent(withoutNewLine = false) {      if (withoutNewLine) {        --context.indentLevel      } else {        newline(--context.indentLevel)      }    },    newline() {      newline(context.indentLevel)    }  }  function newline(n) {    context.push('\n' + `  `.repeat(n))  }  function addMapping(loc, name) {    context.map.addMapping({      name,      source: context.filename,      original: {        line: loc.line,        column: loc.column - 1 // source-map column is 0 based      },      generated: {        line: context.line,        column: context.column - 1      }    })  }  return context}function genModulePreamble(ast, context, genScopeId, inline) {  const {    push,    newline,    optimizeImports,    runtimeModuleName,    ssrRuntimeModuleName  } = context  if (genScopeId && ast.hoists.length) {    ast.helpers.push(PUSH_SCOPE_ID, POP_SCOPE_ID)  }  // generate import statements for helpers  if (ast.helpers.length) {    if (optimizeImports) {      // when bundled with webpack with code-split, calling an import binding      // as a function leads to it being wrapped with `Object(a.b)` or `(0,a.b)`,      // incurring both payload size increase and potential perf overhead.      // therefore we assign the imports to variables (which is a constant ~50b      // cost per-component instead of scaling with template size)      push(        `import { ${ast.helpers          .map((s) => helperNameMap[s])          .join(', ')} } from ${JSON.stringify(runtimeModuleName)}\n`      )      push(        `\n// Binding optimization for webpack code-split\nconst ${ast.helpers          .map((s) => `_${helperNameMap[s]} = ${helperNameMap[s]}`)          .join(', ')}\n`      )    } else {      push(        `import { ${ast.helpers          .map((s) => `${helperNameMap[s]} as _${helperNameMap[s]}`)          .join(', ')} } from ${JSON.stringify(runtimeModuleName)}\n`      )    }  }  if (ast.ssrHelpers && ast.ssrHelpers.length) {    push(      `import { ${ast.ssrHelpers        .map((s) => `${helperNameMap[s]} as _${helperNameMap[s]}`)        .join(', ')} } from "${ssrRuntimeModuleName}"\n`    )  }  if (ast.imports.length) {    genImports(ast.imports, context)    newline()  }  genHoists(ast.hoists, context)  newline()  if (!inline) {    push(`export `)  }}function genImports(importsOptions, context) {  if (!importsOptions.length) {    return  }  importsOptions.forEach((imports) => {    context.push(`import `)    genNode(imports.exp, context)    context.push(` from '${imports.path}'`)    context.newline()  })}function genFunctionPreamble(ast, context) {  const {    ssr,    prefixIdentifiers,    push,    newline,    runtimeModuleName,    runtimeGlobalName,    ssrRuntimeModuleName  } = context  const VueBinding =    !__BROWSER__ && ssr      ? `require(${JSON.stringify(runtimeModuleName)})`      : runtimeGlobalName  const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`  // Generate const declaration for helpers  // In prefix mode, we place the const declaration at top so it's done  // only once; But if we not prefixing, we place the declaration inside the  // with block so it doesn't incur the `in` check cost for every helper access.  if (ast.helpers.length > 0) {    if (!__BROWSER__ && prefixIdentifiers) {      push(        `const { ${ast.helpers.map(aliasHelper).join(', ')} } = ${VueBinding}\n`      )    } else {      // "with" mode.      // save Vue in a separate variable to avoid collision      push(`const _Vue = ${VueBinding}\n`)      // in "with" mode, helpers are declared inside the with block to avoid      // has check cost, but hoists are lifted out of the function - we need      // to provide the helper here.      if (ast.hoists.length) {        const staticHelpers = [          CREATE_VNODE,          CREATE_ELEMENT_VNODE,          CREATE_COMMENT,          CREATE_TEXT,          CREATE_STATIC        ]          .filter((helper) => ast.helpers.includes(helper))          .map(aliasHelper)          .join(', ')        push(`const { ${staticHelpers} } = _Vue\n`)      }    }  }  // generate variables for ssr helpers  if (!__BROWSER__ && ast.ssrHelpers && ast.ssrHelpers.length) {    // ssr guarantees prefixIdentifier: true    push(      `const { ${ast.ssrHelpers        .map(aliasHelper)        .join(', ')} } = require("${ssrRuntimeModuleName}")\n`    )  }  genHoists(ast.hoists, context)  newline()  push(`return `)}function genHoists(hoists, context) {  if (!hoists.length) {    return  }  context.pure = true  const { push, newline, helper, scopeId, mode } = context  const genScopeId = !__BROWSER__ && scopeId != null && mode !== 'function'  newline()  // generate inlined withScopeId helper  if (genScopeId) {    push(      `const _withScopeId = n => (${helper(        PUSH_SCOPE_ID      )}("${scopeId}"),n=n(),${helper(POP_SCOPE_ID)}(),n)`    )    newline()  }  for (let i = 0; i < hoists.length; i++) {    const exp = hoists[i]    if (exp) {      const needScopeIdWrapper = genScopeId && exp.type === NodeTypes.VNODE_CALL      push(        `const _hoisted_${i + 1} = ${          needScopeIdWrapper ? `${PURE_ANNOTATION} _withScopeId(() => ` : ``        }`      )      genNode(exp, context)      if (needScopeIdWrapper) {        push(`)`)      }      newline()    }  }  context.pure = false}// type = 'component' | 'directive' | 'filter'function genAssets(assets, type, { helper, push, newline, isTS }) {  const resolver = helper(    type === 'component' ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE  )  for (let i = 0; i < assets.length; i++) {    let id = assets[i]    // potential component implicit self-reference inferred from SFC filename    const maybeSelfReference = id.endsWith('__self')    if (maybeSelfReference) {      id = id.slice(0, -6)    }    push(      `const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${        maybeSelfReference ? `, true` : ``      })${isTS ? `!` : ``}`    )    if (i < assets.length - 1) {      newline()    }  }}function genText(node, context) {  context.push(JSON.stringify(node.content), node)}function genExpression(node, context) {  const { content, isStatic } = node  context.push(isStatic ? JSON.stringify(content) : content, node)}function genInterpolation(node, context) {  const { push, helper, pure } = context  if (pure) push(PURE_ANNOTATION)  push(`${helper(TO_DISPLAY_STRING)}(`)  genNode(node.content, context)  push(`)`)}function genCompoundExpression(node, context) {  for (let i = 0; i < node.children.length; i++) {    const child = node.children[i]    if (isString(child)) {      context.push(child)    } else {      genNode(child, context)    }  }}function genComment(node, context) {  const { push, helper, pure } = context  if (pure) {    push(PURE_ANNOTATION)  }  push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node)}function genVNodeCall(node, context) {  const { push, helper, pure } = context  const {    tag,    props,    children,    patchFlag,    dynamicProps,    directives,    isBlock,    disableTracking,    isComponent  } = node  if (directives) {    push(helper(WITH_DIRECTIVES) + `(`)  }  if (isBlock) {    push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `)  }  if (pure) {    push(PURE_ANNOTATION)  }  const callHelper = isBlock    ? getVNodeBlockHelper(context.inSSR, isComponent)    : getVNodeHelper(context.inSSR, isComponent)  push(helper(callHelper) + `(`, node)  genNodeList(    genNullableArgs([tag, props, children, patchFlag, dynamicProps]),    context  )  push(`)`)  if (isBlock) {    push(`)`)  }  if (directives) {    push(`, `)    genNode(directives, context)    push(`)`)  }}// JavaScriptfunction genCallExpression(node, context) {  const { push, helper, pure } = context  const callee = isString(node.callee) ? node.callee : helper(node.callee)  if (pure) {    push(PURE_ANNOTATION)  }  push(callee + `(`, node)  genNodeList(node.arguments, context)  push(`)`)}function genObjectExpression(node, context) {  const { push, indent, deindent, newline } = context  const { properties } = node  if (!properties.length) {    push(`{}`, node)    return  }  const multilines =    properties.length > 1 ||    ((!__BROWSER__ || __DEV__) &&      properties.some((p) => p.value.type !== NodeTypes.SIMPLE_EXPRESSION))  push(multilines ? `{` : `{ `)  multilines && indent()  for (let i = 0; i < properties.length; i++) {    const { key, value } = properties[i]    // key    genExpressionAsPropertyKey(key, context)    push(`: `)    // value    genNode(value, context)    if (i < properties.length - 1) {      // will only reach this if it's multilines      push(`,`)      newline()    }  }  multilines && deindent()  push(multilines ? `}` : ` }`)}function genArrayExpression(node, context) {  genNodeListAsArray(node.elements, context)}function genFunctionExpression(node, context) {  const { push, indent, deindent } = context  const { params, returns, body, newline, isSlot } = node  if (isSlot) {    // wrap slot functions with owner context    push(`_${helperNameMap[WITH_CTX]}(`)  }  push(`(`, node)  if (isArray(params)) {    genNodeList(params, context)  } else if (params) {    genNode(params, context)  }  push(`) => `)  if (newline || body) {    push(`{`)    indent()  }  if (returns) {    if (newline) {      push(`return `)    }    if (isArray(returns)) {      genNodeListAsArray(returns, context)    } else {      genNode(returns, context)    }  } else if (body) {    genNode(body, context)  }  if (newline || body) {    deindent()    push(`}`)  }  if (isSlot) {    push(`)`)  }}function genConditionalExpression(node, context) {  const { test, consequent, alternate, newline: needNewline } = node  const { push, indent, deindent, newline } = context  if (test.type === NodeTypes.SIMPLE_EXPRESSION) {    const needsParens = !isSimpleIdentifier(test.content)    needsParens && push(`(`)    genExpression(test, context)    needsParens && push(`)`)  } else {    push(`(`)    genNode(test, context)    push(`)`)  }  needNewline && indent()  context.indentLevel++  needNewline || push(` `)  push(`? `)  genNode(consequent, context)  context.indentLevel--  needNewline && newline()  needNewline || push(` `)  push(`: `)  const isNested = alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION  if (!isNested) {    context.indentLevel++  }  genNode(alternate, context)  if (!isNested) {    context.indentLevel--  }  needNewline && deindent(true /* without newline */)}function genCacheExpression(node, context) {  const { push, helper, indent, deindent, newline } = context  push(`_cache[${node.index}] || (`)  if (node.isVNode) {    indent()    push(`${helper(SET_BLOCK_TRACKING)}(-1),`)    newline()  }  push(`_cache[${node.index}] = `)  genNode(node.value, context)  if (node.isVNode) {    push(`,`)    newline()    push(`${helper(SET_BLOCK_TRACKING)}(1),`)    newline()    push(`_cache[${node.index}]`)    deindent()  }  push(`)`)}function genNodeList(nodes, context, multilines = false, comma = true) {  const { push, newline } = context  for (let i = 0; i < nodes.length; i++) {    const node = nodes[i]    if (isString(node)) {      push(node)    } else if (isArray(node)) {      genNodeListAsArray(node, context)    } else {      genNode(node, context)    }    if (i < nodes.length - 1) {      if (multilines) {        comma && push(',')        newline()      } else {        comma && push(', ')      }    }  }}function genTemplateLiteral(node, context) {  const { push, indent, deindent } = context  push('`')  const l = node.elements.length  const multilines = l > 3  for (let i = 0; i < l; i++) {    const e = node.elements[i]    if (isString(e)) {      push(e.replace(/(`|\$|\\)/g, '\\$1'))    } else {      push('${')      if (multilines) indent()      genNode(e, context)      if (multilines) deindent()      push('}')    }  }  push('`')}function genIfStatement(node, context) {  const { push, indent, deindent } = context  const { test, consequent, alternate } = node  push(`if (`)  genNode(test, context)  push(`) {`)  indent()  genNode(consequent, context)  deindent()  push(`}`)  if (alternate) {    push(` else `)    if (alternate.type === NodeTypes.JS_IF_STATEMENT) {      genIfStatement(alternate, context)    } else {      push(`{`)      indent()      genNode(alternate, context)      deindent()      push(`}`)    }  }}function genAssignmentExpression(node, context) {  genNode(node.left, context)  context.push(` = `)  genNode(node.right, context)}function genSequenceExpression(node, context) {  context.push(`(`)  genNodeList(node.expressions, context)  context.push(`)`)}function genReturnStatement({ returns }, context) {  context.push(`return `)  if (isArray(returns)) {    genNodeListAsArray(returns, context)  } else {    genNode(returns, context)  }}function genNode(node, context) {  if (isString(node)) {    context.push(node)    return  }  if (isSymbol(node)) {    context.push(context.helper(node))    return  }  switch (node.type) {    case NodeTypes.ELEMENT:    case NodeTypes.IF:    case NodeTypes.FOR:      genNode(node.codegenNode, context)      break    case NodeTypes.TEXT:      genText(node, context)      break    case NodeTypes.SIMPLE_EXPRESSION:      genExpression(node, context)      break    case NodeTypes.INTERPOLATION:      genInterpolation(node, context)      break    case NodeTypes.TEXT_CALL:      genNode(node.codegenNode, context)      break    case NodeTypes.COMPOUND_EXPRESSION:      genCompoundExpression(node, context)      break    case NodeTypes.COMMENT:      genComment(node, context)      break    case NodeTypes.VNODE_CALL:      genVNodeCall(node, context)      break    case NodeTypes.JS_CALL_EXPRESSION:      genCallExpression(node, context)      break    case NodeTypes.JS_OBJECT_EXPRESSION:      genObjectExpression(node, context)      break    case NodeTypes.JS_ARRAY_EXPRESSION:      genArrayExpression(node, context)      break    case NodeTypes.JS_FUNCTION_EXPRESSION:      genFunctionExpression(node, context)      break    case NodeTypes.JS_CONDITIONAL_EXPRESSION:      genConditionalExpression(node, context)      break    case NodeTypes.JS_CACHE_EXPRESSION:      genCacheExpression(node, context)      break    case NodeTypes.JS_BLOCK_STATEMENT:      genNodeList(node.body, context, true, false)      break    // SSR only types    case NodeTypes.JS_TEMPLATE_LITERAL:      !__BROWSER__ && genTemplateLiteral(node, context)      break    case NodeTypes.JS_IF_STATEMENT:      !__BROWSER__ && genIfStatement(node, context)      break    case NodeTypes.JS_ASSIGNMENT_EXPRESSION:      !__BROWSER__ && genAssignmentExpression(node, context)      break    case NodeTypes.JS_SEQUENCE_EXPRESSION:      !__BROWSER__ && genSequenceExpression(node, context)      break    case NodeTypes.JS_RETURN_STATEMENT:      !__BROWSER__ && genReturnStatement(node, context)      break    /* istanbul ignore next */    case NodeTypes.IF_BRANCH:      // noop      break    default:      logg(`unhandled codegen node type: ${node.type}`)  }}function genNodeListAsArray(nodes, context) {  const multilines =    nodes.length > 3 ||    ((!__BROWSER__ || __DEV__) && nodes.some((n) => isArray(n) || !isText(n)))  context.push(`[`)  multilines && context.indent()  genNodeList(nodes, context, multilines)  multilines && context.deindent()  context.push(`]`)}function generate(ast, options = {}) {  const context = createCodegenContext(ast, options)  if (options.onContextCreated) options.onContextCreated(context)  const {    mode,    push,    prefixIdentifiers,    indent,    deindent,    newline,    scopeId,    ssr  } = context  const hasHelpers = ast.helpers.length > 0  const useWithBlock = !prefixIdentifiers && mode !== 'module'  const genScopeId = !__BROWSER__ && scopeId != null && mode === 'module'  const isSetupInlined = !__BROWSER__ && !!options.inline  // preambles  // in setup() inline mode, the preamble is generated in a sub context  // and returned separately.  const preambleContext = isSetupInlined    ? createCodegenContext(ast, options)    : context  if (!__BROWSER__ && mode === 'module') {    genModulePreamble(ast, preambleContext, genScopeId, isSetupInlined)  } else {    genFunctionPreamble(ast, preambleContext)  }  // enter render function  const functionName = ssr ? `ssrRender` : `render`  const args = ssr ? ['_ctx', '_push', '_parent', '_attrs'] : ['_ctx', '_cache']  if (!__BROWSER__ && options.bindingMetadata && !options.inline) {    // binding optimization args    args.push('$props', '$setup', '$data', '$options')  }  const signature =    !__BROWSER__ && options.isTS      ? args.map((arg) => `${arg}: any`).join(',')      : args.join(', ')  if (isSetupInlined) {    push(`(${signature}) => {`)  } else {    push(`function ${functionName}(${signature}) {`)  }  indent()  if (useWithBlock) {    push(`with (_ctx) {`)    indent()    // function mode const declarations should be inside with block    // also they should be renamed to avoid collision with user properties    if (hasHelpers) {      push(        `const { ${ast.helpers          .map((s) => `${helperNameMap[s]}: _${helperNameMap[s]}`)          .join(', ')} } = _Vue`      )      push(`\n`)      newline()    }  }  // generate asset resolution statements  if (ast.components.length) {    genAssets(ast.components, 'component', context)    if (ast.directives.length || ast.temps > 0) {      newline()    }  }  if (ast.directives.length) {    genAssets(ast.directives, 'directive', context)    if (ast.temps > 0) {      newline()    }  }  //   if (ast.temps > 0) {    push(`let `)    for (let i = 0; i < ast.temps; i++) {      push(`${i > 0 ? `, ` : ``}_temp${i}`)    }  }  if (ast.components.length || ast.directives.length || ast.temps) {    push(`\n`)    newline()  }  // generate the VNode tree expression  if (!ssr) {    push(`return `)  }  if (ast.codegenNode) {    genNode(ast.codegenNode, context)  } else {    push(`null`)  }  if (useWithBlock) {    deindent()    push(`}`)  }  deindent()  push(`}`)  return {    ast,    code: context.code,    preamble: isSetupInlined ? preambleContext.code : ``,    // SourceMapGenerator does have toJSON() method but it's not in the types    map: context.map ? context.map.toJSON() : undefined  }}function baseCompile(template, options = {}) {  const isModuleMode = options.mode === 'module'  const prefixIdentifiers =    !__BROWSER__ && (options.prefixIdentifiers === true || isModuleMode)  const ast = isString(template) ? baseParse(template, options) : template  const [nodeTransforms, directiveTransforms] =    getBaseTransformPreset(prefixIdentifiers)  //  codegenNode  transform(    ast,    extend({}, options, {      prefixIdentifiers,      nodeTransforms: [        ...nodeTransforms,        ...(options.nodeTransforms || []) // user transforms      ],      directiveTransforms: extend(        {},        directiveTransforms,        options.directiveTransforms || {} // user transforms      )    })  )  //  codegen  return generate(ast, extend({}, options, { prefixIdentifiers }))}const namedCharacterReferences = {  GT: '>',  gt: '>',  LT: '<',  lt: '<',  'ac;': '',  'af;': '',  AMP: '&',  amp: '&',  'ap;': '',  'DD;': '',  'dd;': '',  deg: '',  'ee;': '',  'eg;': '',  'el;': '',  ETH: '',  eth: '',  'gE;': '',  'ge;': '',  'Gg;': '',  'gg;': '',  'gl;': '',  'GT;': '>',  'Gt;': '',  'gt;': '>',  'ic;': '',  'ii;': '',  'Im;': '',  'in;': '',  'it;': '',  'lE;': '',  'le;': '',  'lg;': '',  'Ll;': '',  'll;': '',  'LT;': '<',  'Lt;': '',  'lt;': '<',  'mp;': '',  'Mu;': '',  'mu;': '',  'ne;': '',  'ni;': '',  not: '',  'Nu;': '',  'nu;': '',  'Or;': '',  'or;': '',  'oS;': '',  'Pi;': '',  'pi;': '',  'pm;': '',  'Pr;': '',  'pr;': '',  'Re;': '',  REG: '',  reg: '',  'rx;': '',  'Sc;': '',  'sc;': '',  shy: '',  uml: '',  'wp;': '',  'wr;': '',  'Xi;': '',  'xi;': '',  yen: '',  'acd;': '',  'acE;': '',  'Acy;': '',  'acy;': '',  'Afr;': '',  'afr;': '',  'AMP;': '&',  'amp;': '&',  'And;': '',  'and;': '',  'ang;': '',  'apE;': '',  'ape;': '',  'ast;': '*',  Auml: '',  auml: '',  'Bcy;': '',  'bcy;': '',  'Bfr;': '',  'bfr;': '',  'bne;': '=',  'bot;': '',  'Cap;': '',  'cap;': '',  cent: '',  'Cfr;': '',  'cfr;': '',  'Chi;': '',  'chi;': '',  'cir;': '',  COPY: '',  copy: '',  'Cup;': '',  'cup;': '',  'Dcy;': '',  'dcy;': '',  'deg;': '',  'Del;': '',  'Dfr;': '',  'dfr;': '',  'die;': '',  'div;': '',  'Dot;': '',  'dot;': '',  'Ecy;': '',  'ecy;': '',  'Efr;': '',  'efr;': '',  'egs;': '',  'ell;': '',  'els;': '',  'ENG;': '',  'eng;': '',  'Eta;': '',  'eta;': '',  'ETH;': '',  'eth;': '',  Euml: '',  euml: '',  'Fcy;': '',  'fcy;': '',  'Ffr;': '',  'ffr;': '',  'gap;': '',  'Gcy;': '',  'gcy;': '',  'gEl;': '',  'gel;': '',  'geq;': '',  'ges;': '',  'Gfr;': '',  'gfr;': '',  'ggg;': '',  'gla;': '',  'glE;': '',  'glj;': '',  'gnE;': '',  'gne;': '',  'Hat;': '^',  'Hfr;': '',  'hfr;': '',  'Icy;': '',  'icy;': '',  'iff;': '',  'Ifr;': '',  'ifr;': '',  'Int;': '',  'int;': '',  Iuml: '',  iuml: '',  'Jcy;': '',  'jcy;': '',  'Jfr;': '',  'jfr;': '',  'Kcy;': '',  'kcy;': '',  'Kfr;': '',  'kfr;': '',  'lap;': '',  'lat;': '',  'Lcy;': '',  'lcy;': '',  'lEg;': '',  'leg;': '',  'leq;': '',  'les;': '',  'Lfr;': '',  'lfr;': '',  'lgE;': '',  'lnE;': '',  'lne;': '',  'loz;': '',  'lrm;': '',  'Lsh;': '',  'lsh;': '',  macr: '',  'Map;': '',  'map;': '',  'Mcy;': '',  'mcy;': '',  'Mfr;': '',  'mfr;': '',  'mho;': '',  'mid;': '',  'nap;': '',  nbsp: ' ',  'Ncy;': '',  'ncy;': '',  'Nfr;': '',  'nfr;': '',  'ngE;': '',  'nge;': '',  'nGg;': '',  'nGt;': '',  'ngt;': '',  'nis;': '',  'niv;': '',  'nlE;': '',  'nle;': '',  'nLl;': '',  'nLt;': '',  'nlt;': '',  'Not;': '',  'not;': '',  'npr;': '',  'nsc;': '',  'num;': '#',  'Ocy;': '',  'ocy;': '',  'Ofr;': '',  'ofr;': '',  'ogt;': '',  'ohm;': '',  'olt;': '',  'ord;': '',  ordf: '',  ordm: '',  'orv;': '',  Ouml: '',  ouml: '',  'par;': '',  para: '',  'Pcy;': '',  'pcy;': '',  'Pfr;': '',  'pfr;': '',  'Phi;': '',  'phi;': '',  'piv;': '',  'prE;': '',  'pre;': '',  'Psi;': '',  'psi;': '',  'Qfr;': '',  'qfr;': '',  QUOT: '"',  quot: '"',  'Rcy;': '',  'rcy;': '',  'REG;': '',  'reg;': '',  'Rfr;': '',  'rfr;': '',  'Rho;': '',  'rho;': '',  'rlm;': '',  'Rsh;': '',  'rsh;': '',  'scE;': '',  'sce;': '',  'Scy;': '',  'scy;': '',  sect: '',  'Sfr;': '',  'sfr;': '',  'shy;': '',  'sim;': '',  'smt;': '',  'sol;': '/',  'squ;': '',  'Sub;': '',  'sub;': '',  'Sum;': '',  'sum;': '',  'Sup;': '',  'sup;': '',  sup1: '',  sup2: '',  sup3: '',  'Tab;': '\t',  'Tau;': '',  'tau;': '',  'Tcy;': '',  'tcy;': '',  'Tfr;': '',  'tfr;': '',  'top;': '',  'Ucy;': '',  'ucy;': '',  'Ufr;': '',  'ufr;': '',  'uml;': '',  Uuml: '',  uuml: '',  'Vcy;': '',  'vcy;': '',  'Vee;': '',  'vee;': '',  'Vfr;': '',  'vfr;': '',  'Wfr;': '',  'wfr;': '',  'Xfr;': '',  'xfr;': '',  'Ycy;': '',  'ycy;': '',  'yen;': '',  'Yfr;': '',  'yfr;': '',  yuml: '',  'Zcy;': '',  'zcy;': '',  'Zfr;': '',  'zfr;': '',  'zwj;': '',  Acirc: '',  acirc: '',  acute: '',  AElig: '',  aelig: '',  'andd;': '',  'andv;': '',  'ange;': '',  'Aopf;': '',  'aopf;': '',  'apid;': '',  'apos;': "'",  Aring: '',  aring: '',  'Ascr;': '',  'ascr;': '',  'Auml;': '',  'auml;': '',  'Barv;': '',  'bbrk;': '',  'Beta;': '',  'beta;': '',  'beth;': '',  'bNot;': '',  'bnot;': '',  'Bopf;': '',  'bopf;': '',  'boxH;': '',  'boxh;': '',  'boxV;': '',  'boxv;': '',  'Bscr;': '',  'bscr;': '',  'bsim;': '',  'bsol;': '\\',  'bull;': '',  'bump;': '',  'caps;': '',  'Cdot;': '',  'cdot;': '',  cedil: '',  'cent;': '',  'CHcy;': '',  'chcy;': '',  'circ;': '',  'cirE;': '',  'cire;': '',  'comp;': '',  'cong;': '',  'Copf;': '',  'copf;': '',  'COPY;': '',  'copy;': '',  'Cscr;': '',  'cscr;': '',  'csub;': '',  'csup;': '',  'cups;': '',  'Darr;': '',  'dArr;': '',  'darr;': '',  'dash;': '',  'dHar;': '',  'diam;': '',  'DJcy;': '',  'djcy;': '',  'Dopf;': '',  'dopf;': '',  'Dscr;': '',  'dscr;': '',  'DScy;': '',  'dscy;': '',  'dsol;': '',  'dtri;': '',  'DZcy;': '',  'dzcy;': '',  'ecir;': '',  Ecirc: '',  ecirc: '',  'Edot;': '',  'eDot;': '',  'edot;': '',  'emsp;': '',  'ensp;': '',  'Eopf;': '',  'eopf;': '',  'epar;': '',  'epsi;': '',  'Escr;': '',  'escr;': '',  'Esim;': '',  'esim;': '',  'Euml;': '',  'euml;': '',  'euro;': '',  'excl;': '!',  'flat;': '',  'fnof;': '',  'Fopf;': '',  'fopf;': '',  'fork;': '',  'Fscr;': '',  'fscr;': '',  'Gdot;': '',  'gdot;': '',  'geqq;': '',  'gesl;': '',  'GJcy;': '',  'gjcy;': '',  'gnap;': '',  'gneq;': '',  'Gopf;': '',  'gopf;': '',  'Gscr;': '',  'gscr;': '',  'gsim;': '',  'gtcc;': '',  'gvnE;': '',  'half;': '',  'hArr;': '',  'harr;': '',  'hbar;': '',  'Hopf;': '',  'hopf;': '',  'Hscr;': '',  'hscr;': '',  Icirc: '',  icirc: '',  'Idot;': '',  'IEcy;': '',  'iecy;': '',  iexcl: '',  'imof;': '',  'IOcy;': '',  'iocy;': '',  'Iopf;': '',  'iopf;': '',  'Iota;': '',  'iota;': '',  'Iscr;': '',  'iscr;': '',  'isin;': '',  'Iuml;': '',  'iuml;': '',  'Jopf;': '',  'jopf;': '',  'Jscr;': '',  'jscr;': '',  'KHcy;': '',  'khcy;': '',  'KJcy;': '',  'kjcy;': '',  'Kopf;': '',  'kopf;': '',  'Kscr;': '',  'kscr;': '',  'Lang;': '',  'lang;': '',  laquo: '',  'Larr;': '',  'lArr;': '',  'larr;': '',  'late;': '',  'lcub;': '{',  'ldca;': '',  'ldsh;': '',  'leqq;': '',  'lesg;': '',  'lHar;': '',  'LJcy;': '',  'ljcy;': '',  'lnap;': '',  'lneq;': '',  'Lopf;': '',  'lopf;': '',  'lozf;': '',  'lpar;': '(',  'Lscr;': '',  'lscr;': '',  'lsim;': '',  'lsqb;': '[',  'ltcc;': '',  'ltri;': '',  'lvnE;': '',  'macr;': '',  'male;': '',  'malt;': '',  micro: '',  'mlcp;': '',  'mldr;': '',  'Mopf;': '',  'mopf;': '',  'Mscr;': '',  'mscr;': '',  'nang;': '',  'napE;': '',  'nbsp;': ' ',  'ncap;': '',  'ncup;': '',  'ngeq;': '',  'nges;': '',  'ngtr;': '',  'nGtv;': '',  'nisd;': '',  'NJcy;': '',  'njcy;': '',  'nldr;': '',  'nleq;': '',  'nles;': '',  'nLtv;': '',  'nmid;': '',  'Nopf;': '',  'nopf;': '',  'npar;': '',  'npre;': '',  'nsce;': '',  'Nscr;': '',  'nscr;': '',  'nsim;': '',  'nsub;': '',  'nsup;': '',  'ntgl;': '',  'ntlg;': '',  'nvap;': '',  'nvge;': '',  'nvgt;': '>',  'nvle;': '',  'nvlt;': '<',  'oast;': '',  'ocir;': '',  Ocirc: '',  ocirc: '',  'odiv;': '',  'odot;': '',  'ogon;': '',  'oint;': '',  'omid;': '',  'Oopf;': '',  'oopf;': '',  'opar;': '',  'ordf;': '',  'ordm;': '',  'oror;': '',  'Oscr;': '',  'oscr;': '',  'osol;': '',  'Ouml;': '',  'ouml;': '',  'para;': '',  'part;': '',  'perp;': '',  'phiv;': '',  'plus;': '+',  'Popf;': '',  'popf;': '',  pound: '',  'prap;': '',  'prec;': '',  'prnE;': '',  'prod;': '',  'prop;': '',  'Pscr;': '',  'pscr;': '',  'qint;': '',  'Qopf;': '',  'qopf;': '',  'Qscr;': '',  'qscr;': '',  'QUOT;': '"',  'quot;': '"',  'race;': '',  'Rang;': '',  'rang;': '',  raquo: '',  'Rarr;': '',  'rArr;': '',  'rarr;': '',  'rcub;': '}',  'rdca;': '',  'rdsh;': '',  'real;': '',  'rect;': '',  'rHar;': '',  'rhov;': '',  'ring;': '',  'Ropf;': '',  'ropf;': '',  'rpar;': ')',  'Rscr;': '',  'rscr;': '',  'rsqb;': ']',  'rtri;': '',  'scap;': '',  'scnE;': '',  'sdot;': '',  'sect;': '',  'semi;': ';',  'sext;': '',  'SHcy;': '',  'shcy;': '',  'sime;': '',  'simg;': '',  'siml;': '',  'smid;': '',  'smte;': '',  'solb;': '',  'Sopf;': '',  'sopf;': '',  'spar;': '',  'Sqrt;': '',  'squf;': '',  'Sscr;': '',  'sscr;': '',  'Star;': '',  'star;': '',  'subE;': '',  'sube;': '',  'succ;': '',  'sung;': '',  'sup1;': '',  'sup2;': '',  'sup3;': '',  'supE;': '',  'supe;': '',  szlig: '',  'tbrk;': '',  'tdot;': '',  THORN: '',  thorn: '',  times: '',  'tint;': '',  'toea;': '',  'Topf;': '',  'topf;': '',  'tosa;': '',  'trie;': '',  'Tscr;': '',  'tscr;': '',  'TScy;': '',  'tscy;': '',  'Uarr;': '',  'uArr;': '',  'uarr;': '',  Ucirc: '',  ucirc: '',  'uHar;': '',  'Uopf;': '',  'uopf;': '',  'Upsi;': '',  'upsi;': '',  'Uscr;': '',  'uscr;': '',  'utri;': '',  'Uuml;': '',  'uuml;': '',  'vArr;': '',  'varr;': '',  'Vbar;': '',  'vBar;': '',  'Vert;': '',  'vert;': '|',  'Vopf;': '',  'vopf;': '',  'Vscr;': '',  'vscr;': '',  'Wopf;': '',  'wopf;': '',  'Wscr;': '',  'wscr;': '',  'xcap;': '',  'xcup;': '',  'xmap;': '',  'xnis;': '',  'Xopf;': '',  'xopf;': '',  'Xscr;': '',  'xscr;': '',  'xvee;': '',  'YAcy;': '',  'yacy;': '',  'YIcy;': '',  'yicy;': '',  'Yopf;': '',  'yopf;': '',  'Yscr;': '',  'yscr;': '',  'YUcy;': '',  'yucy;': '',  'Yuml;': '',  'yuml;': '',  'Zdot;': '',  'zdot;': '',  'Zeta;': '',  'zeta;': '',  'ZHcy;': '',  'zhcy;': '',  'Zopf;': '',  'zopf;': '',  'Zscr;': '',  'zscr;': '',  'zwnj;': '',  Aacute: '',  aacute: '',  'Acirc;': '',  'acirc;': '',  'acute;': '',  'AElig;': '',  'aelig;': '',  Agrave: '',  agrave: '',  'aleph;': '',  'Alpha;': '',  'alpha;': '',  'Amacr;': '',  'amacr;': '',  'amalg;': '',  'angle;': '',  'angrt;': '',  'angst;': '',  'Aogon;': '',  'aogon;': '',  'Aring;': '',  'aring;': '',  'asymp;': '',  Atilde: '',  atilde: '',  'awint;': '',  'bcong;': '',  'bdquo;': '',  'bepsi;': '',  'blank;': '',  'blk12;': '',  'blk14;': '',  'blk34;': '',  'block;': '',  'boxDL;': '',  'boxDl;': '',  'boxdL;': '',  'boxdl;': '',  'boxDR;': '',  'boxDr;': '',  'boxdR;': '',  'boxdr;': '',  'boxHD;': '',  'boxHd;': '',  'boxhD;': '',  'boxhd;': '',  'boxHU;': '',  'boxHu;': '',  'boxhU;': '',  'boxhu;': '',  'boxUL;': '',  'boxUl;': '',  'boxuL;': '',  'boxul;': '',  'boxUR;': '',  'boxUr;': '',  'boxuR;': '',  'boxur;': '',  'boxVH;': '',  'boxVh;': '',  'boxvH;': '',  'boxvh;': '',  'boxVL;': '',  'boxVl;': '',  'boxvL;': '',  'boxvl;': '',  'boxVR;': '',  'boxVr;': '',  'boxvR;': '',  'boxvr;': '',  'Breve;': '',  'breve;': '',  brvbar: '',  'bsemi;': '',  'bsime;': '',  'bsolb;': '',  'bumpE;': '',  'bumpe;': '',  'caret;': '',  'caron;': '',  'ccaps;': '',  Ccedil: '',  ccedil: '',  'Ccirc;': '',  'ccirc;': '',  'ccups;': '',  'cedil;': '',  'check;': '',  'clubs;': '',  'Colon;': '',  'colon;': ':',  'comma;': ',',  'crarr;': '',  'Cross;': '',  'cross;': '',  'csube;': '',  'csupe;': '',  'ctdot;': '',  'cuepr;': '',  'cuesc;': '',  'cupor;': '',  curren: '',  'cuvee;': '',  'cuwed;': '',  'cwint;': '',  'Dashv;': '',  'dashv;': '',  'dblac;': '',  'ddarr;': '',  'Delta;': '',  'delta;': '',  'dharl;': '',  'dharr;': '',  'diams;': '',  'disin;': '',  divide: '',  'doteq;': '',  'dtdot;': '',  'dtrif;': '',  'duarr;': '',  'duhar;': '',  Eacute: '',  eacute: '',  'Ecirc;': '',  'ecirc;': '',  'eDDot;': '',  'efDot;': '',  Egrave: '',  egrave: '',  'Emacr;': '',  'emacr;': '',  'empty;': '',  'Eogon;': '',  'eogon;': '',  'eplus;': '',  'epsiv;': '',  'eqsim;': '',  'Equal;': '',  'equiv;': '',  'erarr;': '',  'erDot;': '',  'esdot;': '',  'exist;': '',  'fflig;': '',  'filig;': '',  'fjlig;': 'fj',  'fllig;': '',  'fltns;': '',  'forkv;': '',  frac12: '',  frac14: '',  frac34: '',  'frasl;': '',  'frown;': '',  'Gamma;': '',  'gamma;': '',  'Gcirc;': '',  'gcirc;': '',  'gescc;': '',  'gimel;': '',  'gneqq;': '',  'gnsim;': '',  'grave;': '`',  'gsime;': '',  'gsiml;': '',  'gtcir;': '',  'gtdot;': '',  'Hacek;': '',  'harrw;': '',  'Hcirc;': '',  'hcirc;': '',  'hoarr;': '',  Iacute: '',  iacute: '',  'Icirc;': '',  'icirc;': '',  'iexcl;': '',  Igrave: '',  igrave: '',  'iiint;': '',  'iiota;': '',  'IJlig;': '',  'ijlig;': '',  'Imacr;': '',  'imacr;': '',  'image;': '',  'imath;': '',  'imped;': '',  'infin;': '',  'Iogon;': '',  'iogon;': '',  'iprod;': '',  iquest: '',  'isinE;': '',  'isins;': '',  'isinv;': '',  'Iukcy;': '',  'iukcy;': '',  'Jcirc;': '',  'jcirc;': '',  'jmath;': '',  'Jukcy;': '',  'jukcy;': '',  'Kappa;': '',  'kappa;': '',  'lAarr;': '',  'langd;': '',  'laquo;': '',  'larrb;': '',  'lates;': '',  'lBarr;': '',  'lbarr;': '',  'lbbrk;': '',  'lbrke;': '',  'lceil;': '',  'ldquo;': '',  'lescc;': '',  'lhard;': '',  'lharu;': '',  'lhblk;': '',  'llarr;': '',  'lltri;': '',  'lneqq;': '',  'lnsim;': '',  'loang;': '',  'loarr;': '',  'lobrk;': '',  'lopar;': '',  'lrarr;': '',  'lrhar;': '',  'lrtri;': '',  'lsime;': '',  'lsimg;': '',  'lsquo;': '',  'ltcir;': '',  'ltdot;': '',  'ltrie;': '',  'ltrif;': '',  'mdash;': '',  'mDDot;': '',  'micro;': '',  middot: '',  'minus;': '',  'mumap;': '',  'nabla;': '',  'napid;': '',  'napos;': '',  'natur;': '',  'nbump;': '',  'ncong;': '',  'ndash;': '',  'neArr;': '',  'nearr;': '',  'nedot;': '',  'nesim;': '',  'ngeqq;': '',  'ngsim;': '',  'nhArr;': '',  'nharr;': '',  'nhpar;': '',  'nlArr;': '',  'nlarr;': '',  'nleqq;': '',  'nless;': '',  'nlsim;': '',  'nltri;': '',  'notin;': '',  'notni;': '',  'npart;': '',  'nprec;': '',  'nrArr;': '',  'nrarr;': '',  'nrtri;': '',  'nsime;': '',  'nsmid;': '',  'nspar;': '',  'nsubE;': '',  'nsube;': '',  'nsucc;': '',  'nsupE;': '',  'nsupe;': '',  Ntilde: '',  ntilde: '',  'numsp;': '',  'nvsim;': '',  'nwArr;': '',  'nwarr;': '',  Oacute: '',  oacute: '',  'Ocirc;': '',  'ocirc;': '',  'odash;': '',  'OElig;': '',  'oelig;': '',  'ofcir;': '',  Ograve: '',  ograve: '',  'ohbar;': '',  'olarr;': '',  'olcir;': '',  'oline;': '',  'Omacr;': '',  'omacr;': '',  'Omega;': '',  'omega;': '',  'operp;': '',  'oplus;': '',  'orarr;': '',  'order;': '',  Oslash: '',  oslash: '',  Otilde: '',  otilde: '',  'ovbar;': '',  'parsl;': '',  'phone;': '',  'plusb;': '',  'pluse;': '',  plusmn: '',  'pound;': '',  'prcue;': '',  'Prime;': '',  'prime;': '',  'prnap;': '',  'prsim;': '',  'quest;': '?',  'rAarr;': '',  'radic;': '',  'rangd;': '',  'range;': '',  'raquo;': '',  'rarrb;': '',  'rarrc;': '',  'rarrw;': '',  'ratio;': '',  'RBarr;': '',  'rBarr;': '',  'rbarr;': '',  'rbbrk;': '',  'rbrke;': '',  'rceil;': '',  'rdquo;': '',  'reals;': '',  'rhard;': '',  'rharu;': '',  'rlarr;': '',  'rlhar;': '',  'rnmid;': '',  'roang;': '',  'roarr;': '',  'robrk;': '',  'ropar;': '',  'rrarr;': '',  'rsquo;': '',  'rtrie;': '',  'rtrif;': '',  'sbquo;': '',  'sccue;': '',  'Scirc;': '',  'scirc;': '',  'scnap;': '',  'scsim;': '',  'sdotb;': '',  'sdote;': '',  'seArr;': '',  'searr;': '',  'setmn;': '',  'sharp;': '',  'Sigma;': '',  'sigma;': '',  'simeq;': '',  'simgE;': '',  'simlE;': '',  'simne;': '',  'slarr;': '',  'smile;': '',  'smtes;': '',  'sqcap;': '',  'sqcup;': '',  'sqsub;': '',  'sqsup;': '',  'srarr;': '',  'starf;': '',  'strns;': '',  'subnE;': '',  'subne;': '',  'supnE;': '',  'supne;': '',  'swArr;': '',  'swarr;': '',  'szlig;': '',  'Theta;': '',  'theta;': '',  'thkap;': '',  'THORN;': '',  'thorn;': '',  'Tilde;': '',  'tilde;': '',  'times;': '',  'TRADE;': '',  'trade;': '',  'trisb;': '',  'TSHcy;': '',  'tshcy;': '',  'twixt;': '',  Uacute: '',  uacute: '',  'Ubrcy;': '',  'ubrcy;': '',  'Ucirc;': '',  'ucirc;': '',  'udarr;': '',  'udhar;': '',  Ugrave: '',  ugrave: '',  'uharl;': '',  'uharr;': '',  'uhblk;': '',  'ultri;': '',  'Umacr;': '',  'umacr;': '',  'Union;': '',  'Uogon;': '',  'uogon;': '',  'uplus;': '',  'upsih;': '',  'UpTee;': '',  'Uring;': '',  'uring;': '',  'urtri;': '',  'utdot;': '',  'utrif;': '',  'uuarr;': '',  'varpi;': '',  'vBarv;': '',  'VDash;': '',  'Vdash;': '',  'vDash;': '',  'vdash;': '',  'veeeq;': '',  'vltri;': '',  'vnsub;': '',  'vnsup;': '',  'vprop;': '',  'vrtri;': '',  'Wcirc;': '',  'wcirc;': '',  'Wedge;': '',  'wedge;': '',  'xcirc;': '',  'xdtri;': '',  'xhArr;': '',  'xharr;': '',  'xlArr;': '',  'xlarr;': '',  'xodot;': '',  'xrArr;': '',  'xrarr;': '',  'xutri;': '',  Yacute: '',  yacute: '',  'Ycirc;': '',  'ycirc;': '',  'Aacute;': '',  'aacute;': '',  'Abreve;': '',  'abreve;': '',  'Agrave;': '',  'agrave;': '',  'andand;': '',  'angmsd;': '',  'angsph;': '',  'apacir;': '',  'approx;': '',  'Assign;': '',  'Atilde;': '',  'atilde;': '',  'barvee;': '',  'Barwed;': '',  'barwed;': '',  'becaus;': '',  'bernou;': '',  'bigcap;': '',  'bigcup;': '',  'bigvee;': '',  'bkarow;': '',  'bottom;': '',  'bowtie;': '',  'boxbox;': '',  'bprime;': '',  'brvbar;': '',  'bullet;': '',  'Bumpeq;': '',  'bumpeq;': '',  'Cacute;': '',  'cacute;': '',  'capand;': '',  'capcap;': '',  'capcup;': '',  'capdot;': '',  'Ccaron;': '',  'ccaron;': '',  'Ccedil;': '',  'ccedil;': '',  'circeq;': '',  'cirmid;': '',  'Colone;': '',  'colone;': '',  'commat;': '@',  'compfn;': '',  'Conint;': '',  'conint;': '',  'coprod;': '',  'copysr;': '',  'cularr;': '',  'CupCap;': '',  'cupcap;': '',  'cupcup;': '',  'cupdot;': '',  'curarr;': '',  'curren;': '',  'cylcty;': '',  'Dagger;': '',  'dagger;': '',  'daleth;': '',  'Dcaron;': '',  'dcaron;': '',  'dfisht;': '',  'divide;': '',  'divonx;': '',  'dlcorn;': '',  'dlcrop;': '',  'dollar;': '$',  'DotDot;': '',  'drcorn;': '',  'drcrop;': '',  'Dstrok;': '',  'dstrok;': '',  'Eacute;': '',  'eacute;': '',  'easter;': '',  'Ecaron;': '',  'ecaron;': '',  'ecolon;': '',  'Egrave;': '',  'egrave;': '',  'egsdot;': '',  'elsdot;': '',  'emptyv;': '',  'emsp13;': '',  'emsp14;': '',  'eparsl;': '',  'eqcirc;': '',  'equals;': '=',  'equest;': '',  'Exists;': '',  'female;': '',  'ffilig;': '',  'ffllig;': '',  'ForAll;': '',  'forall;': '',  'frac12;': '',  'frac13;': '',  'frac14;': '',  'frac15;': '',  'frac16;': '',  'frac18;': '',  'frac23;': '',  'frac25;': '',  'frac34;': '',  'frac35;': '',  'frac38;': '',  'frac45;': '',  'frac56;': '',  'frac58;': '',  'frac78;': '',  'gacute;': '',  'Gammad;': '',  'gammad;': '',  'Gbreve;': '',  'gbreve;': '',  'Gcedil;': '',  'gesdot;': '',  'gesles;': '',  'gtlPar;': '',  'gtrarr;': '',  'gtrdot;': '',  'gtrsim;': '',  'hairsp;': '',  'hamilt;': '',  'HARDcy;': '',  'hardcy;': '',  'hearts;': '',  'hellip;': '',  'hercon;': '',  'homtht;': '',  'horbar;': '',  'hslash;': '',  'Hstrok;': '',  'hstrok;': '',  'hybull;': '',  'hyphen;': '',  'Iacute;': '',  'iacute;': '',  'Igrave;': '',  'igrave;': '',  'iiiint;': '',  'iinfin;': '',  'incare;': '',  'inodot;': '',  'intcal;': '',  'iquest;': '',  'isinsv;': '',  'Itilde;': '',  'itilde;': '',  'Jsercy;': '',  'jsercy;': '',  'kappav;': '',  'Kcedil;': '',  'kcedil;': '',  'kgreen;': '',  'Lacute;': '',  'lacute;': '',  'lagran;': '',  'Lambda;': '',  'lambda;': '',  'langle;': '',  'larrfs;': '',  'larrhk;': '',  'larrlp;': '',  'larrpl;': '',  'larrtl;': '',  'lAtail;': '',  'latail;': '',  'lbrace;': '{',  'lbrack;': '[',  'Lcaron;': '',  'lcaron;': '',  'Lcedil;': '',  'lcedil;': '',  'ldquor;': '',  'lesdot;': '',  'lesges;': '',  'lfisht;': '',  'lfloor;': '',  'lharul;': '',  'llhard;': '',  'Lmidot;': '',  'lmidot;': '',  'lmoust;': '',  'loplus;': '',  'lowast;': '',  'lowbar;': '_',  'lparlt;': '',  'lrhard;': '',  'lsaquo;': '',  'lsquor;': '',  'Lstrok;': '',  'lstrok;': '',  'lthree;': '',  'ltimes;': '',  'ltlarr;': '',  'ltrPar;': '',  'mapsto;': '',  'marker;': '',  'mcomma;': '',  'midast;': '*',  'midcir;': '',  'middot;': '',  'minusb;': '',  'minusd;': '',  'mnplus;': '',  'models;': '',  'mstpos;': '',  'Nacute;': '',  'nacute;': '',  'nbumpe;': '',  'Ncaron;': '',  'ncaron;': '',  'Ncedil;': '',  'ncedil;': '',  'nearhk;': '',  'nequiv;': '',  'nesear;': '',  'nexist;': '',  'nltrie;': '',  'notinE;': '',  'nparsl;': '',  'nprcue;': '',  'nrarrc;': '',  'nrarrw;': '',  'nrtrie;': '',  'nsccue;': '',  'nsimeq;': '',  'Ntilde;': '',  'ntilde;': '',  'numero;': '',  'nVDash;': '',  'nVdash;': '',  'nvDash;': '',  'nvdash;': '',  'nvHarr;': '',  'nvlArr;': '',  'nvrArr;': '',  'nwarhk;': '',  'nwnear;': '',  'Oacute;': '',  'oacute;': '',  'Odblac;': '',  'odblac;': '',  'odsold;': '',  'Ograve;': '',  'ograve;': '',  'ominus;': '',  'origof;': '',  'Oslash;': '',  'oslash;': '',  'Otilde;': '',  'otilde;': '',  'Otimes;': '',  'otimes;': '',  'parsim;': '',  'percnt;': '%',  'period;': '.',  'permil;': '',  'phmmat;': '',  'planck;': '',  'plankv;': '',  'plusdo;': '',  'plusdu;': '',  'plusmn;': '',  'preceq;': '',  'primes;': '',  'prnsim;': '',  'propto;': '',  'prurel;': '',  'puncsp;': '',  'qprime;': '',  'Racute;': '',  'racute;': '',  'rangle;': '',  'rarrap;': '',  'rarrfs;': '',  'rarrhk;': '',  'rarrlp;': '',  'rarrpl;': '',  'Rarrtl;': '',  'rarrtl;': '',  'rAtail;': '',  'ratail;': '',  'rbrace;': '}',  'rbrack;': ']',  'Rcaron;': '',  'rcaron;': '',  'Rcedil;': '',  'rcedil;': '',  'rdquor;': '',  'rfisht;': '',  'rfloor;': '',  'rharul;': '',  'rmoust;': '',  'roplus;': '',  'rpargt;': '',  'rsaquo;': '',  'rsquor;': '',  'rthree;': '',  'rtimes;': '',  'Sacute;': '',  'sacute;': '',  'Scaron;': '',  'scaron;': '',  'Scedil;': '',  'scedil;': '',  'scnsim;': '',  'searhk;': '',  'seswar;': '',  'sfrown;': '',  'SHCHcy;': '',  'shchcy;': '',  'sigmaf;': '',  'sigmav;': '',  'simdot;': '',  'smashp;': '',  'SOFTcy;': '',  'softcy;': '',  'solbar;': '',  'spades;': '',  'sqcaps;': '',  'sqcups;': '',  'sqsube;': '',  'sqsupe;': '',  'Square;': '',  'square;': '',  'squarf;': '',  'ssetmn;': '',  'ssmile;': '',  'sstarf;': '',  'subdot;': '',  'Subset;': '',  'subset;': '',  'subsim;': '',  'subsub;': '',  'subsup;': '',  'succeq;': '',  'supdot;': '',  'Supset;': '',  'supset;': '',  'supsim;': '',  'supsub;': '',  'supsup;': '',  'swarhk;': '',  'swnwar;': '',  'target;': '',  'Tcaron;': '',  'tcaron;': '',  'Tcedil;': '',  'tcedil;': '',  'telrec;': '',  'there4;': '',  'thetav;': '',  'thinsp;': '',  'thksim;': '',  'timesb;': '',  'timesd;': '',  'topbot;': '',  'topcir;': '',  'tprime;': '',  'tridot;': '',  'Tstrok;': '',  'tstrok;': '',  'Uacute;': '',  'uacute;': '',  'Ubreve;': '',  'ubreve;': '',  'Udblac;': '',  'udblac;': '',  'ufisht;': '',  'Ugrave;': '',  'ugrave;': '',  'ulcorn;': '',  'ulcrop;': '',  'urcorn;': '',  'urcrop;': '',  'Utilde;': '',  'utilde;': '',  'vangrt;': '',  'varphi;': '',  'varrho;': '',  'Vdashl;': '',  'veebar;': '',  'vellip;': '',  'Verbar;': '',  'verbar;': '|',  'vsubnE;': '',  'vsubne;': '',  'vsupnE;': '',  'vsupne;': '',  'Vvdash;': '',  'wedbar;': '',  'wedgeq;': '',  'weierp;': '',  'wreath;': '',  'xoplus;': '',  'xotime;': '',  'xsqcup;': '',  'xuplus;': '',  'xwedge;': '',  'Yacute;': '',  'yacute;': '',  'Zacute;': '',  'zacute;': '',  'Zcaron;': '',  'zcaron;': '',  'zeetrf;': '',  'alefsym;': '',  'angrtvb;': '',  'angzarr;': '',  'asympeq;': '',  'backsim;': '',  'Because;': '',  'because;': '',  'bemptyv;': '',  'between;': '',  'bigcirc;': '',  'bigodot;': '',  'bigstar;': '',  'bnequiv;': '',  'boxplus;': '',  'Cayleys;': '',  'Cconint;': '',  'ccupssm;': '',  'Cedilla;': '',  'cemptyv;': '',  'cirscir;': '',  'coloneq;': '',  'congdot;': '',  'cudarrl;': '',  'cudarrr;': '',  'cularrp;': '',  'curarrm;': '',  'dbkarow;': '',  'ddagger;': '',  'ddotseq;': '',  'demptyv;': '',  'Diamond;': '',  'diamond;': '',  'digamma;': '',  'dotplus;': '',  'DownTee;': '',  'dwangle;': '',  'Element;': '',  'Epsilon;': '',  'epsilon;': '',  'eqcolon;': '',  'equivDD;': '',  'gesdoto;': '',  'gtquest;': '',  'gtrless;': '',  'harrcir;': '',  'Implies;': '',  'intprod;': '',  'isindot;': '',  'larrbfs;': '',  'larrsim;': '',  'lbrksld;': '',  'lbrkslu;': '',  'ldrdhar;': '',  'LeftTee;': '',  'lesdoto;': '',  'lessdot;': '',  'lessgtr;': '',  'lesssim;': '',  'lotimes;': '',  'lozenge;': '',  'ltquest;': '',  'luruhar;': '',  'maltese;': '',  'minusdu;': '',  'napprox;': '',  'natural;': '',  'nearrow;': '',  'NewLine;': '\n',  'nexists;': '',  'NoBreak;': '',  'notinva;': '',  'notinvb;': '',  'notinvc;': '',  'NotLess;': '',  'notniva;': '',  'notnivb;': '',  'notnivc;': '',  'npolint;': '',  'npreceq;': '',  'nsqsube;': '',  'nsqsupe;': '',  'nsubset;': '',  'nsucceq;': '',  'nsupset;': '',  'nvinfin;': '',  'nvltrie;': '',  'nvrtrie;': '',  'nwarrow;': '',  'olcross;': '',  'Omicron;': '',  'omicron;': '',  'orderof;': '',  'orslope;': '',  'OverBar;': '',  'pertenk;': '',  'planckh;': '',  'pluscir;': '',  'plussim;': '',  'plustwo;': '',  'precsim;': '',  'Product;': '',  'quatint;': '',  'questeq;': '',  'rarrbfs;': '',  'rarrsim;': '',  'rbrksld;': '',  'rbrkslu;': '',  'rdldhar;': '',  'realine;': '',  'rotimes;': '',  'ruluhar;': '',  'searrow;': '',  'simplus;': '',  'simrarr;': '',  'subedot;': '',  'submult;': '',  'subplus;': '',  'subrarr;': '',  'succsim;': '',  'supdsub;': '',  'supedot;': '',  'suphsol;': '',  'suphsub;': '',  'suplarr;': '',  'supmult;': '',  'supplus;': '',  'swarrow;': '',  'topfork;': '',  'triplus;': '',  'tritime;': '',  'UpArrow;': '',  'Uparrow;': '',  'uparrow;': '',  'Upsilon;': '',  'upsilon;': '',  'uwangle;': '',  'vzigzag;': '',  'zigrarr;': '',  'andslope;': '',  'angmsdaa;': '',  'angmsdab;': '',  'angmsdac;': '',  'angmsdad;': '',  'angmsdae;': '',  'angmsdaf;': '',  'angmsdag;': '',  'angmsdah;': '',  'angrtvbd;': '',  'approxeq;': '',  'awconint;': '',  'backcong;': '',  'barwedge;': '',  'bbrktbrk;': '',  'bigoplus;': '',  'bigsqcup;': '',  'biguplus;': '',  'bigwedge;': '',  'boxminus;': '',  'boxtimes;': '',  'bsolhsub;': '',  'capbrcup;': '',  'circledR;': '',  'circledS;': '',  'cirfnint;': '',  'clubsuit;': '',  'cupbrcap;': '',  'curlyvee;': '',  'cwconint;': '',  'DDotrahd;': '',  'doteqdot;': '',  'DotEqual;': '',  'dotminus;': '',  'drbkarow;': '',  'dzigrarr;': '',  'elinters;': '',  'emptyset;': '',  'eqvparsl;': '',  'fpartint;': '',  'geqslant;': '',  'gesdotol;': '',  'gnapprox;': '',  'hksearow;': '',  'hkswarow;': '',  'imagline;': '',  'imagpart;': '',  'infintie;': '',  'integers;': '',  'Integral;': '',  'intercal;': '',  'intlarhk;': '',  'laemptyv;': '',  'ldrushar;': '',  'leqslant;': '',  'lesdotor;': '',  'LessLess;': '',  'llcorner;': '',  'lnapprox;': '',  'lrcorner;': '',  'lurdshar;': '',  'mapstoup;': '',  'multimap;': '',  'naturals;': '',  'ncongdot;': '',  'NotEqual;': '',  'notindot;': '',  'NotTilde;': '',  'otimesas;': '',  'parallel;': '',  'PartialD;': '',  'plusacir;': '',  'pointint;': '',  'Precedes;': '',  'precneqq;': '',  'precnsim;': '',  'profalar;': '',  'profline;': '',  'profsurf;': '',  'raemptyv;': '',  'realpart;': '',  'RightTee;': '',  'rppolint;': '',  'rtriltri;': '',  'scpolint;': '',  'setminus;': '',  'shortmid;': '',  'smeparsl;': '',  'sqsubset;': '',  'sqsupset;': '',  'subseteq;': '',  'Succeeds;': '',  'succneqq;': '',  'succnsim;': '',  'SuchThat;': '',  'Superset;': '',  'supseteq;': '',  'thetasym;': '',  'thicksim;': '',  'timesbar;': '',  'triangle;': '',  'triminus;': '',  'trpezium;': '',  'Uarrocir;': '',  'ulcorner;': '',  'UnderBar;': '_',  'urcorner;': '',  'varkappa;': '',  'varsigma;': '',  'vartheta;': '',  'backprime;': '',  'backsimeq;': '',  'Backslash;': '',  'bigotimes;': '',  'CenterDot;': '',  'centerdot;': '',  'checkmark;': '',  'CircleDot;': '',  'complexes;': '',  'Congruent;': '',  'Coproduct;': '',  'dotsquare;': '',  'DoubleDot;': '',  'DownArrow;': '',  'Downarrow;': '',  'downarrow;': '',  'DownBreve;': '',  'gtrapprox;': '',  'gtreqless;': '',  'gvertneqq;': '',  'heartsuit;': '',  'HumpEqual;': '',  'LeftArrow;': '',  'Leftarrow;': '',  'leftarrow;': '',  'LeftFloor;': '',  'lesseqgtr;': '',  'LessTilde;': '',  'lvertneqq;': '',  'Mellintrf;': '',  'MinusPlus;': '',  'ngeqslant;': '',  'nleqslant;': '',  'NotCupCap;': '',  'NotExists;': '',  'NotSubset;': '',  'nparallel;': '',  'nshortmid;': '',  'nsubseteq;': '',  'nsupseteq;': '',  'OverBrace;': '',  'pitchfork;': '',  'PlusMinus;': '',  'rationals;': '',  'spadesuit;': '',  'subseteqq;': '',  'subsetneq;': '',  'supseteqq;': '',  'supsetneq;': '',  'Therefore;': '',  'therefore;': '',  'ThinSpace;': '',  'triangleq;': '',  'TripleDot;': '',  'UnionPlus;': '',  'varpropto;': '',  'Bernoullis;': '',  'circledast;': '',  'CirclePlus;': '',  'complement;': '',  'curlywedge;': '',  'eqslantgtr;': '',  'EqualTilde;': '',  'Fouriertrf;': '',  'gtreqqless;': '',  'ImaginaryI;': '',  'Laplacetrf;': '',  'LeftVector;': '',  'lessapprox;': '',  'lesseqqgtr;': '',  'Lleftarrow;': '',  'lmoustache;': '',  'longmapsto;': '',  'mapstodown;': '',  'mapstoleft;': '',  'nLeftarrow;': '',  'nleftarrow;': '',  'NotElement;': '',  'NotGreater;': '',  'nsubseteqq;': '',  'nsupseteqq;': '',  'precapprox;': '',  'Proportion;': '',  'RightArrow;': '',  'Rightarrow;': '',  'rightarrow;': '',  'RightFloor;': '',  'rmoustache;': '',  'sqsubseteq;': '',  'sqsupseteq;': '',  'subsetneqq;': '',  'succapprox;': '',  'supsetneqq;': '',  'ThickSpace;': '',  'TildeEqual;': '',  'TildeTilde;': '',  'UnderBrace;': '',  'UpArrowBar;': '',  'UpTeeArrow;': '',  'upuparrows;': '',  'varepsilon;': '',  'varnothing;': '',  'backepsilon;': '',  'blacksquare;': '',  'circledcirc;': '',  'circleddash;': '',  'CircleMinus;': '',  'CircleTimes;': '',  'curlyeqprec;': '',  'curlyeqsucc;': '',  'diamondsuit;': '',  'eqslantless;': '',  'Equilibrium;': '',  'expectation;': '',  'GreaterLess;': '',  'LeftCeiling;': '',  'LessGreater;': '',  'MediumSpace;': '',  'NotLessLess;': '',  'NotPrecedes;': '',  'NotSucceeds;': '',  'NotSuperset;': '',  'nRightarrow;': '',  'nrightarrow;': '',  'OverBracket;': '',  'preccurlyeq;': '',  'precnapprox;': '',  'quaternions;': '',  'RightVector;': '',  'Rrightarrow;': '',  'RuleDelayed;': '',  'SmallCircle;': '',  'SquareUnion;': '',  'straightphi;': '',  'SubsetEqual;': '',  'succcurlyeq;': '',  'succnapprox;': '',  'thickapprox;': '',  'UpDownArrow;': '',  'Updownarrow;': '',  'updownarrow;': '',  'VerticalBar;': '',  'blacklozenge;': '',  'DownArrowBar;': '',  'DownTeeArrow;': '',  'ExponentialE;': '',  'exponentiale;': '',  'GreaterEqual;': '',  'GreaterTilde;': '',  'HilbertSpace;': '',  'HumpDownHump;': '',  'Intersection;': '',  'LeftArrowBar;': '',  'LeftTeeArrow;': '',  'LeftTriangle;': '',  'LeftUpVector;': '',  'NotCongruent;': '',  'NotHumpEqual;': '',  'NotLessEqual;': '',  'NotLessTilde;': '',  'Proportional;': '',  'RightCeiling;': '',  'risingdotseq;': '',  'RoundImplies;': '',  'ShortUpArrow;': '',  'SquareSubset;': '',  'triangledown;': '',  'triangleleft;': '',  'UnderBracket;': '',  'varsubsetneq;': '',  'varsupsetneq;': '',  'VerticalLine;': '|',  'ApplyFunction;': '',  'bigtriangleup;': '',  'blacktriangle;': '',  'DifferentialD;': '',  'divideontimes;': '',  'DoubleLeftTee;': '',  'DoubleUpArrow;': '',  'fallingdotseq;': '',  'hookleftarrow;': '',  'leftarrowtail;': '',  'leftharpoonup;': '',  'LeftTeeVector;': '',  'LeftVectorBar;': '',  'LessFullEqual;': '',  'LongLeftArrow;': '',  'Longleftarrow;': '',  'longleftarrow;': '',  'looparrowleft;': '',  'measuredangle;': '',  'NotEqualTilde;': '',  'NotTildeEqual;': '',  'NotTildeTilde;': '',  'ntriangleleft;': '',  'Poincareplane;': '',  'PrecedesEqual;': '',  'PrecedesTilde;': '',  'RightArrowBar;': '',  'RightTeeArrow;': '',  'RightTriangle;': '',  'RightUpVector;': '',  'shortparallel;': '',  'smallsetminus;': '',  'SucceedsEqual;': '',  'SucceedsTilde;': '',  'SupersetEqual;': '',  'triangleright;': '',  'UpEquilibrium;': '',  'upharpoonleft;': '',  'varsubsetneqq;': '',  'varsupsetneqq;': '',  'VerticalTilde;': '',  'VeryThinSpace;': '',  'curvearrowleft;': '',  'DiacriticalDot;': '',  'doublebarwedge;': '',  'DoubleRightTee;': '',  'downdownarrows;': '',  'DownLeftVector;': '',  'GreaterGreater;': '',  'hookrightarrow;': '',  'HorizontalLine;': '',  'InvisibleComma;': '',  'InvisibleTimes;': '',  'LeftDownVector;': '',  'leftleftarrows;': '',  'LeftRightArrow;': '',  'Leftrightarrow;': '',  'leftrightarrow;': '',  'leftthreetimes;': '',  'LessSlantEqual;': '',  'LongRightArrow;': '',  'Longrightarrow;': '',  'longrightarrow;': '',  'looparrowright;': '',  'LowerLeftArrow;': '',  'NestedLessLess;': '',  'NotGreaterLess;': '',  'NotLessGreater;': '',  'NotSubsetEqual;': '',  'NotVerticalBar;': '',  'nshortparallel;': '',  'ntriangleright;': '',  'OpenCurlyQuote;': '',  'ReverseElement;': '',  'rightarrowtail;': '',  'rightharpoonup;': '',  'RightTeeVector;': '',  'RightVectorBar;': '',  'ShortDownArrow;': '',  'ShortLeftArrow;': '',  'SquareSuperset;': '',  'TildeFullEqual;': '',  'trianglelefteq;': '',  'upharpoonright;': '',  'UpperLeftArrow;': '',  'ZeroWidthSpace;': '',  'bigtriangledown;': '',  'circlearrowleft;': '',  'CloseCurlyQuote;': '',  'ContourIntegral;': '',  'curvearrowright;': '',  'DoubleDownArrow;': '',  'DoubleLeftArrow;': '',  'downharpoonleft;': '',  'DownRightVector;': '',  'leftharpoondown;': '',  'leftrightarrows;': '',  'LeftRightVector;': '',  'LeftTriangleBar;': '',  'LeftUpTeeVector;': '',  'LeftUpVectorBar;': '',  'LowerRightArrow;': '',  'nLeftrightarrow;': '',  'nleftrightarrow;': '',  'NotGreaterEqual;': '',  'NotGreaterTilde;': '',  'NotHumpDownHump;': '',  'NotLeftTriangle;': '',  'NotSquareSubset;': '',  'ntrianglelefteq;': '',  'OverParenthesis;': '',  'RightDownVector;': '',  'rightleftarrows;': '',  'rightsquigarrow;': '',  'rightthreetimes;': '',  'ShortRightArrow;': '',  'straightepsilon;': '',  'trianglerighteq;': '',  'UpperRightArrow;': '',  'vartriangleleft;': '',  'circlearrowright;': '',  'DiacriticalAcute;': '',  'DiacriticalGrave;': '`',  'DiacriticalTilde;': '',  'DoubleRightArrow;': '',  'DownArrowUpArrow;': '',  'downharpoonright;': '',  'EmptySmallSquare;': '',  'GreaterEqualLess;': '',  'GreaterFullEqual;': '',  'LeftAngleBracket;': '',  'LeftUpDownVector;': '',  'LessEqualGreater;': '',  'NonBreakingSpace;': ' ',  'NotPrecedesEqual;': '',  'NotRightTriangle;': '',  'NotSucceedsEqual;': '',  'NotSucceedsTilde;': '',  'NotSupersetEqual;': '',  'ntrianglerighteq;': '',  'rightharpoondown;': '',  'rightrightarrows;': '',  'RightTriangleBar;': '',  'RightUpTeeVector;': '',  'RightUpVectorBar;': '',  'twoheadleftarrow;': '',  'UnderParenthesis;': '',  'UpArrowDownArrow;': '',  'vartriangleright;': '',  'blacktriangledown;': '',  'blacktriangleleft;': '',  'DoubleUpDownArrow;': '',  'DoubleVerticalBar;': '',  'DownLeftTeeVector;': '',  'DownLeftVectorBar;': '',  'FilledSmallSquare;': '',  'GreaterSlantEqual;': '',  'LeftDoubleBracket;': '',  'LeftDownTeeVector;': '',  'LeftDownVectorBar;': '',  'leftrightharpoons;': '',  'LeftTriangleEqual;': '',  'NegativeThinSpace;': '',  'NotGreaterGreater;': '',  'NotLessSlantEqual;': '',  'NotNestedLessLess;': '',  'NotReverseElement;': '',  'NotSquareSuperset;': '',  'NotTildeFullEqual;': '',  'RightAngleBracket;': '',  'rightleftharpoons;': '',  'RightUpDownVector;': '',  'SquareSubsetEqual;': '',  'twoheadrightarrow;': '',  'VerticalSeparator;': '',  'blacktriangleright;': '',  'DownRightTeeVector;': '',  'DownRightVectorBar;': '',  'LongLeftRightArrow;': '',  'Longleftrightarrow;': '',  'longleftrightarrow;': '',  'NegativeThickSpace;': '',  'NotLeftTriangleBar;': '',  'PrecedesSlantEqual;': '',  'ReverseEquilibrium;': '',  'RightDoubleBracket;': '',  'RightDownTeeVector;': '',  'RightDownVectorBar;': '',  'RightTriangleEqual;': '',  'SquareIntersection;': '',  'SucceedsSlantEqual;': '',  'DoubleLongLeftArrow;': '',  'DownLeftRightVector;': '',  'LeftArrowRightArrow;': '',  'leftrightsquigarrow;': '',  'NegativeMediumSpace;': '',  'NotGreaterFullEqual;': '',  'NotRightTriangleBar;': '',  'RightArrowLeftArrow;': '',  'SquareSupersetEqual;': '',  'CapitalDifferentialD;': '',  'DoubleLeftRightArrow;': '',  'DoubleLongRightArrow;': '',  'EmptyVerySmallSquare;': '',  'NestedGreaterGreater;': '',  'NotDoubleVerticalBar;': '',  'NotGreaterSlantEqual;': '',  'NotLeftTriangleEqual;': '',  'NotSquareSubsetEqual;': '',  'OpenCurlyDoubleQuote;': '',  'ReverseUpEquilibrium;': '',  'CloseCurlyDoubleQuote;': '',  'DoubleContourIntegral;': '',  'FilledVerySmallSquare;': '',  'NegativeVeryThinSpace;': '',  'NotPrecedesSlantEqual;': '',  'NotRightTriangleEqual;': '',  'NotSucceedsSlantEqual;': '',  'DiacriticalDoubleAcute;': '',  'NotSquareSupersetEqual;': '',  'NotNestedGreaterGreater;': '',  'ClockwiseContourIntegral;': '',  'DoubleLongLeftRightArrow;': '',  'CounterClockwiseContourIntegral;': ''}const decodeHtml = (rawText, asAttr) => {  let offset = 0  const end = rawText.length  let decodedText = ''  function advance(length) {    offset += length    rawText = rawText.slice(length)  }  while (offset < end) {    const head = /&(?:#x?)?/i.exec(rawText)    if (!head || offset + head.index >= end) {      const remaining = end - offset      decodedText += rawText.slice(0, remaining)      advance(remaining)      break    }    // Advance to the "&".    decodedText += rawText.slice(0, head.index)    advance(head.index)    if (head[0] === '&') {      // Named character reference.      let name = ''      let value = undefined      if (/[0-9a-z]/i.test(rawText[1])) {        if (!maxCRNameLength) {          maxCRNameLength = Object.keys(namedCharacterReferences).reduce(            (max, name) => Math.max(max, name.length),            0          )        }        for (let length = maxCRNameLength; !value && length > 0; --length) {          name = rawText.slice(1, 1 + length)          value = namedCharacterReferences[name]        }        if (value) {          const semi = name.endsWith(';')          if (            asAttr &&            !semi &&            /[=a-z0-9]/i.test(rawText[name.length + 1] || '')          ) {            decodedText += '&' + name            advance(1 + name.length)          } else {            decodedText += value            advance(1 + name.length)          }        } else {          decodedText += '&' + name          advance(1 + name.length)        }      } else {        decodedText += '&'        advance(1)      }    } else {      // Numeric character reference.      const hex = head[0] === '&#x'      const pattern = hex ? /^&#x([0-9a-f]+);?/i : /^&#([0-9]+);?/      const body = pattern.exec(rawText)      if (!body) {        decodedText += head[0]        advance(head[0].length)      } else {        // https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state        let cp = Number.parseInt(body[1], hex ? 16 : 10)        if (cp === 0) {          cp = 0xfffd        } else if (cp > 0x10ffff) {          cp = 0xfffd        } else if (cp >= 0xd800 && cp <= 0xdfff) {          cp = 0xfffd        } else if ((cp >= 0xfdd0 && cp <= 0xfdef) || (cp & 0xfffe) === 0xfffe) {          // noop        } else if (          (cp >= 0x01 && cp <= 0x08) ||          cp === 0x0b ||          (cp >= 0x0d && cp <= 0x1f) ||          (cp >= 0x7f && cp <= 0x9f)        ) {          cp = CCR_REPLACEMENTS[cp] || cp        }        decodedText += String.fromCodePoint(cp)        advance(body[0].length)      }    }  }  return decodedText}// https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-stateconst CCR_REPLACEMENTS = {  0x80: 0x20ac,  0x82: 0x201a,  0x83: 0x0192,  0x84: 0x201e,  0x85: 0x2026,  0x86: 0x2020,  0x87: 0x2021,  0x88: 0x02c6,  0x89: 0x2030,  0x8a: 0x0160,  0x8b: 0x2039,  0x8c: 0x0152,  0x8e: 0x017d,  0x91: 0x2018,  0x92: 0x2019,  0x93: 0x201c,  0x94: 0x201d,  0x95: 0x2022,  0x96: 0x2013,  0x97: 0x2014,  0x98: 0x02dc,  0x99: 0x2122,  0x9a: 0x0161,  0x9b: 0x203a,  0x9c: 0x0153,  0x9e: 0x017e,  0x9f: 0x0178}let decoderfunction decodeHtmlBrowser(raw, asAttr = false) {  if (!decoder) {    decoder = document.createElement('div')  }  if (asAttr) {    decoder.innerHTML = `<div foo="${raw.replace(/"/g, '&quot;')}">`    return decoder.children[0].getAttribute('foo')  } else {    decoder.innerHTML = raw    return decoder.textContent  }}const V_MODEL_RADIO = Symbol(__DEV__ ? `vModelRadio` : ``)const V_MODEL_CHECKBOX = Symbol(__DEV__ ? `vModelCheckbox` : ``)const V_MODEL_TEXT = Symbol(__DEV__ ? `vModelText` : ``)const V_MODEL_SELECT = Symbol(__DEV__ ? `vModelSelect` : ``)const V_MODEL_DYNAMIC = Symbol(__DEV__ ? `vModelDynamic` : ``)const V_ON_WITH_MODIFIERS = Symbol(__DEV__ ? `vOnModifiersGuard` : ``)const V_ON_WITH_KEYS = Symbol(__DEV__ ? `vOnKeysGuard` : ``)const V_SHOW = Symbol(__DEV__ ? `vShow` : ``)const TRANSITION = Symbol(__DEV__ ? `Transition` : ``)const TRANSITION_GROUP = Symbol(__DEV__ ? `TransitionGroup` : ``)registerRuntimeHelpers({  [V_MODEL_RADIO]: `vModelRadio`,  [V_MODEL_CHECKBOX]: `vModelCheckbox`,  [V_MODEL_TEXT]: `vModelText`,  [V_MODEL_SELECT]: `vModelSelect`,  [V_MODEL_DYNAMIC]: `vModelDynamic`,  [V_ON_WITH_MODIFIERS]: `withModifiers`,  [V_ON_WITH_KEYS]: `withKeys`,  [V_SHOW]: `vShow`,  [TRANSITION]: `Transition`,  [TRANSITION_GROUP]: `TransitionGroup`})/** * On the client we only need to offer special cases for boolean attributes that * have different names from their corresponding dom properties: * - itemscope -> N/A * - allowfullscreen -> allowFullscreen * - formnovalidate -> formNoValidate * - ismap -> isMap * - nomodule -> noModule * - novalidate -> noValidate * - readonly -> readOnly */const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`const isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs)/** * The full list is needed during SSR to produce the correct initial markup. */const isBooleanAttr = /*#__PURE__*/ makeMap(  specialBooleanAttrs +    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +    `loop,open,required,reversed,scoped,seamless,` +    `checked,muted,multiple,selected`)/** * Boolean attributes should be included if the value is truthy or ''. * e.g. `<select multiple>` compiles to `{ multiple: '' }` */function includeBooleanAttr(value) {  return !!value || value === ''}const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/const attrValidationCache = {}function isSSRSafeAttrName(name) {  if (attrValidationCache.hasOwnProperty(name)) {    return attrValidationCache[name]  }  const isUnsafe = unsafeAttrCharRE.test(name)  if (isUnsafe) {    console.error(`unsafe attribute name: ${name}`)  }  return (attrValidationCache[name] = !isUnsafe)}const propsToAttrMap = {  acceptCharset: 'accept-charset',  className: 'class',  htmlFor: 'for',  httpEquiv: 'http-equiv'}/** * CSS properties that accept plain numbers */const isNoUnitNumericStyleProp = /*#__PURE__*/ makeMap(  `animation-iteration-count,border-image-outset,border-image-slice,` +    `border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,` +    `columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,` +    `grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,` +    `grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,` +    `line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,` +    // SVG    `fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,` +    `stroke-miterlimit,stroke-opacity,stroke-width`)/** * Known attributes, this is used for stringification of runtime static nodes * so that we don't stringify bindings that cannot be set from HTML. * Don't also forget to allow `data-*` and `aria-*`! * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes */const isKnownHtmlAttr = /*#__PURE__*/ makeMap(  `accept,accept-charset,accesskey,action,align,allow,alt,async,` +    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +    `value,width,wrap`)/** * Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute */const isKnownSvgAttr = /*#__PURE__*/ makeMap(  `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,` +    `arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,` +    `baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,` +    `clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,` +    `color-interpolation-filters,color-profile,color-rendering,` +    `contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,` +    `descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,` +    `dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,` +    `fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,` +    `font-family,font-size,font-size-adjust,font-stretch,font-style,` +    `font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,` +    `glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,` +    `gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,` +    `horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,` +    `k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,` +    `lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,` +    `marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,` +    `mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,` +    `name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,` +    `overflow,overline-position,overline-thickness,panose-1,paint-order,path,` +    `pathLength,patternContentUnits,patternTransform,patternUnits,ping,` +    `pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,` +    `preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,` +    `rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,` +    `restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,` +    `specularConstant,specularExponent,speed,spreadMethod,startOffset,` +    `stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,` +    `strikethrough-position,strikethrough-thickness,string,stroke,` +    `stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,` +    `stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,` +    `systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,` +    `text-decoration,text-rendering,textLength,to,transform,transform-origin,` +    `type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,` +    `unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,` +    `v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,` +    `vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,` +    `writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,` +    `xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,` +    `xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`)// https://developer.mozilla.org/en-US/docs/Web/HTML/Elementconst HTML_TAGS =  'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +  'header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +  'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +  'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +  'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +  'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +  'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +  'option,output,progress,select,textarea,details,dialog,menu,' +  'summary,template,blockquote,iframe,tfoot'// https://developer.mozilla.org/en-US/docs/Web/SVG/Elementconst SVG_TAGS =  'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +  'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +  'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +  'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +  'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +  'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +  'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +  'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +  'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +  'text,textPath,title,tspan,unknown,use,view'const VOID_TAGS =  'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr'const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS)/** * Compiler only. * Do NOT use in runtime code paths unless behind `__DEV__` flag. */const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS)const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS)function normalizeStyle(value) {  if (isArray(value)) {    const res = {}    for (let i = 0; i < value.length; i++) {      const item = value[i]      const normalized = isString(item)        ? parseStringStyle(item)        : normalizeStyle(item)      if (normalized) {        for (const key in normalized) {          res[key] = normalized[key]        }      }    }    return res  } else if (isString(value)) {    return value  } else if (isObject(value)) {    return value  }}const listDelimiterRE = /;(?![^(]*\))/gconst propertyDelimiterRE = /:(.+)/function parseStringStyle(cssText) {  const ret = {}  cssText.split(listDelimiterRE).forEach((item) => {    if (item) {      const tmp = item.split(propertyDelimiterRE)      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim())    }  })  return ret}function stringifyStyle(styles) {  let ret = ''  if (!styles || isString(styles)) {    return ret  }  for (const key in styles) {    const value = styles[key]    const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key)    if (      isString(value) ||      (typeof value === 'number' && isNoUnitNumericStyleProp(normalizedKey))    ) {      // only render valid values      ret += `${normalizedKey}:${value};`    }  }  return ret}function normalizeClass(value) {  let res = ''  if (isString(value)) {    res = value  } else if (isArray(value)) {    for (let i = 0; i < value.length; i++) {      const normalized = normalizeClass(value[i])      if (normalized) {        res += normalized + ' '      }    }  } else if (isObject(value)) {    for (const name in value) {      if (value[name]) {        res += name + ' '      }    }  }  return res.trim()}function normalizeProps(props) {  if (!props) return null  let { class: klass, style } = props  if (klass && !isString(klass)) {    props.class = normalizeClass(klass)  }  if (style) {    props.style = normalizeStyle(style)  }  return props}const escapeRE = /["'&<>]/function escapeHtml(string) {  const str = '' + string  const match = escapeRE.exec(str)  if (!match) {    return str  }  let html = ''  let escaped  let index  let lastIndex = 0  for (index = match.index; index < str.length; index++) {    switch (str.charCodeAt(index)) {      case 34: // "        escaped = '&quot;'        break      case 38: // &        escaped = '&amp;'        break      case 39: // '        escaped = '&#39;'        break      case 60: // <        escaped = '&lt;'        break      case 62: // >        escaped = '&gt;'        break      default:        continue    }    if (lastIndex !== index) {      html += str.slice(lastIndex, index)    }    lastIndex = index + 1    html += escaped  }  return lastIndex !== index ? html + str.slice(lastIndex, index) : html}// https://www.w3.org/TR/html52/syntax.html#commentsconst commentStripRE = /^-?>|<!--|-->|--!>|<!-$/gfunction escapeHtmlComment(src) {  return src.replace(commentStripRE, '')}const toDisplayString = (val) => {  return isString(val)    ? val    : val == null    ? ''    : isArray(val) ||      (isObject(val) &&        (val.toString === objectToString || !isFunction(val.toString)))    ? JSON.stringify(val, replacer, 2)    : String(val)}const replacer = (_key, val) => {  // can't use isRef here since @vue/shared has no deps  if (val && val.__v_isRef) {    return replacer(_key, val.value)  } else if (isMap(val)) {    return {      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {        entries[`${key} =>`] = val        return entries      }, {})    }  } else if (isSet(val)) {    return {      [`Set(${val.size})`]: [...val.values()]    }  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {    return String(val)  }  return val}const noopDirectiveTransform = () => ({ props: [] })const isRawTextContainer = /*#__PURE__*/ makeMap(  'style,iframe,script,noscript',  true)const DOMNamespaces = {  HTML: Namespaces.HTML,  SVG: 1,  MATH_ML: 2}const parserOptions = {  isVoidTag,  isNativeTag: (tag) => isHTMLTag(tag) || isSVGTag(tag),  isPreTag: (tag) => tag === 'pre',  decodeEntities: __BROWSER__ ? decodeHtmlBrowser : decodeHtml,  isBuiltInComponent: (tag) => {    if (isBuiltInType(tag, `Transition`)) {      return TRANSITION    } else if (isBuiltInType(tag, `TransitionGroup`)) {      return TRANSITION_GROUP    }  },  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher  getNamespace(tag, parent) {    let ns = parent ? parent.ns : DOMNamespaces.HTML    if (parent && ns === DOMNamespaces.MATH_ML) {      if (parent.tag === 'annotation-xml') {        if (tag === 'svg') {          return DOMNamespaces.SVG        }        if (          parent.props.some(            (a) =>              a.type === NodeTypes.ATTRIBUTE &&              a.name === 'encoding' &&              a.value != null &&              (a.value.content === 'text/html' ||                a.value.content === 'application/xhtml+xml')          )        ) {          ns = DOMNamespaces.HTML        }      } else if (        /^m(?:[ions]|text)$/.test(parent.tag) &&        tag !== 'mglyph' &&        tag !== 'malignmark'      ) {        ns = DOMNamespaces.HTML      }    } else if (parent && ns === DOMNamespaces.SVG) {      if (        parent.tag === 'foreignObject' ||        parent.tag === 'desc' ||        parent.tag === 'title'      ) {        ns = DOMNamespaces.HTML      }    }    if (ns === DOMNamespaces.HTML) {      if (tag === 'svg') {        return DOMNamespaces.SVG      }      if (tag === 'math') {        return DOMNamespaces.MATH_ML      }    }    return ns  },  // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments  getTextMode({ tag, ns }) {    if (ns === DOMNamespaces.HTML) {      if (tag === 'textarea' || tag === 'title') {        return TextModes.RCDATA      }      if (isRawTextContainer(tag)) {        return TextModes.RAWTEXT      }    }    return TextModes.DATA  }}function hasDynamicKeyVBind(node) {  return node.props.some(    (p) =>      p.type === NodeTypes.DIRECTIVE &&      p.name === 'bind' &&      (!p.arg || // v-bind="obj"        p.arg.type !== NodeTypes.SIMPLE_EXPRESSION || // v-bind:[_ctx.foo]        !p.arg.isStatic) // v-bind:[foo]  )}function hasMultipleChildren(node) {  // #1352 filter out potential comment nodes.  const children = (node.children = node.children.filter(    (c) =>      c.type !== NodeTypes.COMMENT &&      !(c.type === NodeTypes.TEXT && !c.content.trim())  ))  const child = children[0]  return (    children.length !== 1 ||    child.type === NodeTypes.FOR ||    (child.type === NodeTypes.IF && child.branches.some(hasMultipleChildren))  )}const warnTransitionChildren = (node, context) => {  if (    node.type === NodeTypes.ELEMENT &&    node.tagType === ElementTypes.COMPONENT  ) {    const component = context.isBuiltInComponent(node.tag)    if (component === TRANSITION) {      return () => {        if (node.children.length && hasMultipleChildren(node)) {          console.warn(`X_TRANSITION_INVALID_CHILDREN`, node)        }      }    }  }}const ignoreSideEffectTags = (node, context) => {  if (    node.type === NodeTypes.ELEMENT &&    node.tagType === ElementTypes.ELEMENT &&    (node.tag === 'script' || node.tag === 'style')  ) {    console.warn(`X_IGNORED_SIDE_EFFECT_TAG`)    context.removeNode()  }}// Parse inline CSS strings for static style attributes into an object.// This is a NodeTransform since it works on the static `style` attribute and// converts it into a dynamic equivalent:// style="color: red" -> :style='{ "color": "red" }'// It is then processed by `transformElement` and included in the generated// props.const transformStyleCD = (node) => {  if (node.type === NodeTypes.ELEMENT) {    node.props.forEach((p, i) => {      if (p.type === NodeTypes.ATTRIBUTE && p.name === 'style' && p.value) {        // replace p with an expression node        node.props[i] = {          type: NodeTypes.DIRECTIVE,          name: `bind`,          arg: createSimpleExpression(`style`, true, p.loc),          exp: parseInlineCSS(p.value.content, p.loc),          modifiers: [],          loc: p.loc        }      }    })  }}const parseInlineCSS = (cssText, loc) => {  const normalized = parseStringStyle(cssText)  return createSimpleExpression(    JSON.stringify(normalized),    false,    loc,    ConstantTypes.CAN_STRINGIFY  )}const transformVHtml = (dir, node, context) => {  const { exp, loc } = dir  if (!exp) {    logg('v-html no exp')  }  if (node.children.length) {    logg('v-html can not has children')    node.children.length = 0  }  return {    props: [      createObjectProperty(        createSimpleExpression(`innerHTML`, true, loc),        exp || createSimpleExpression('', true)      )    ]  }}const transformVText = (dir, node, context) => {  const { exp, loc } = dir  if (!exp) {    logg('v-text no exp')  }  if (node.children.length) {    logg('v-text can not have children')    node.children.length = 0  }  return {    props: [      createObjectProperty(        createSimpleExpression(`textContent`, true),        exp          ? createCallExpression(              context.helperString(TO_DISPLAY_STRING),              [exp],              loc            )          : createSimpleExpression('', true)      )    ]  }}const transformModelCD = (dir, node, context) => {  const baseResult = transformModel(dir, node, context)  // base transform has errors OR component v-model (only need props)  if (!baseResult.props.length || node.tagType === ElementTypes.COMPONENT) {    return baseResult  }  if (dir.arg) {    logg('transfromModelCD - X_V_MODEL_ARG_ON_ELEMENT')  }  function checkDuplicatedValue() {    const value = findProp(node, 'value')    if (value) {      logg('transfromModelCD - X_V_MODEL_UNNECESSARY_VALUE')    }  }  const { tag } = node  const isCustomElement = context.isCustomElement(tag)  if (    tag === 'input' ||    tag === 'textarea' ||    tag === 'select' ||    isCustomElement  ) {    let directiveToUse = V_MODEL_TEXT    let isInvalidType = false    if (tag === 'input' || isCustomElement) {      const type = findProp(node, `type`)      if (type) {        if (type.type === NodeTypes.DIRECTIVE) {          // :type="foo"          directiveToUse = V_MODEL_DYNAMIC        } else if (type.value) {          switch (type.value.content) {            case 'radio':              directiveToUse = V_MODEL_RADIO              break            case 'checkbox':              directiveToUse = V_MODEL_CHECKBOX              break            case 'file':              isInvalidType = true              logg('[DOM]transformModel - X_V_MODEL_ON_FILE_INPUT_ELEMENT')              break            default:              // text type              __DEV__ && checkDuplicatedValue()              break          }        }      } else if (hasDynamicKeyVBind(node)) {        // element has bindings with dynamic keys, which can possibly contain        // "type".        directiveToUse = V_MODEL_DYNAMIC      } else {        // text type        __DEV__ && checkDuplicatedValue()      }    } else if (tag === 'select') {      directiveToUse = V_MODEL_SELECT    } else {      // textarea      __DEV__ && checkDuplicatedValue()    }    // inject runtime directive    // by returning the helper symbol via needRuntime    // the import will replaced a resolveDirective call.    if (!isInvalidType) {      baseResult.needRuntime = context.helper(directiveToUse)    }  } else {    logg('[DOM]transformModel - X_V_MODEL_ON_INVALID_ELEMENT')  }  // native vmodel doesn't need the `modelValue` props since they are also  // passed to the runtime as `binding.value`. removing it reduces code size.  baseResult.props = baseResult.props.filter(    (p) =>      !(        p.key.type === NodeTypes.SIMPLE_EXPRESSION &&        p.key.content === 'modelValue'      )  )  return baseResult}const isEventOptionModifier = /*#__PURE__*/ makeMap(`passive,once,capture`)const isNonKeyModifier = /*#__PURE__*/ makeMap(  // event propagation management  `stop,prevent,self,` +    // system modifiers + exact    `ctrl,shift,alt,meta,exact,` +    // mouse    `middle`)// left & right could be mouse or key modifiers based on event typeconst maybeKeyModifier = /*#__PURE__*/ makeMap('left,right')const isKeyboardEvent = /*#__PURE__*/ makeMap(  `onkeyup,onkeydown,onkeypress`,  true)// const resolveModifiers = (key, modifiers, context, loc) => {  const keyModifiers = []  const nonKeyModifiers = []  const eventOptionModifiers = []  for (let i = 0; i < modifiers.length; i++) {    const modifier = modifiers[i]    if (isEventOptionModifier(modifier)) {      // eventOptionModifiers: modifiers for addEventListener() options,      // e.g. .passive & .capture      eventOptionModifiers.push(modifier)    } else {      // runtimeModifiers: modifiers that needs runtime guards      if (maybeKeyModifier(modifier)) {        if (isStaticExp(key)) {          if (isKeyboardEvent(key.content)) {            keyModifiers.push(modifier)          } else {            nonKeyModifiers.push(modifier)          }        } else {          keyModifiers.push(modifier)          nonKeyModifiers.push(modifier)        }      } else {        if (isNonKeyModifier(modifier)) {          nonKeyModifiers.push(modifier)        } else {          keyModifiers.push(modifier)        }      }    }  }  return {    keyModifiers,    nonKeyModifiers,    eventOptionModifiers  }}//  click const transformClick = (key, event) => {  const isStaticClick =    isStaticExp(key) && key.content.toLowerCase() === 'onclick'  return isStaticClick    ? createSimpleExpression(event, true)    : key.type !== NodeTypes.SIMPLE_EXPRESSION    ? createCompoundExpression([        `(`,        key,        `) === "onClick" ? "${event}" : (`,        key,        `)`      ])    : key}const transformOnCD = (dir, node, context) => {  return transformOn(dir, node, context, (baseResult) => {    const { modifiers } = dir    if (!modifiers.length) return baseResult    let { key, value: handlerExp } = baseResult.props[0]    const { keyModifiers, nonKeyModifiers, eventOptionModifiers } =      resolveModifiers(key, modifiers, context, dir.loc)    // normalize click.right and click.middle since they don't actually fire    if (nonKeyModifiers.includes('right')) {      key = transformClick(key, `onContextmenu`)    }    if (nonKeyModifiers.includes('middle')) {      key = transformClick(key, `onMouseup`)    }    if (nonKeyModifiers.length) {      handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [        handlerExp,        JSON.stringify(nonKeyModifiers)      ])    }    if (      keyModifiers.length &&      // if event name is dynamic, always wrap with keys guard      (!isStaticExp(key) || isKeyboardEvent(key.content))    ) {      handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [        handlerExp,        JSON.stringify(keyModifiers)      ])    }    if (eventOptionModifiers.length) {      const modifierPostfix = eventOptionModifiers.map(capitalize).join('')      key = isStaticExp(key)        ? createSimpleExpression(`${key.content}${modifierPostfix}`, true)        : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`])    }    return {      props: [createObjectProperty(key, handlerExp)]    }  })}const transformShowCD = (dir, node, context) => {  const { exp, loc } = dir  if (!exp) {    logg('transformShowCD no exp.')  }  return {    props: [],    needRuntime: context.helper(V_SHOW)  }}const StringifyThresholds = {  ELEMENT_WITH_BINDING_COUNT: 5,  NODE_COUNT: 20}/** * Regex for replacing placeholders for embedded constant variables * (e.g. import URL string constants generated by compiler-sfc) */const expReplaceRE = /__VUE_EXP_START__(.*?)__VUE_EXP_END__/g/** * Turn eligible hoisted static trees into stringified static nodes, e.g. * * ```js * const _hoisted_1 = createStaticVNode(`<div class="foo">bar</div>`) * ``` * * A single static vnode can contain stringified content for **multiple** * consecutive nodes (element and plain text), called a "chunk". * `@vue/runtime-dom` will create the content via innerHTML in a hidden * container element and insert all the nodes in place. The call must also * provide the number of nodes contained in the chunk so that during hydration * we can know how many nodes the static vnode should adopt. * * The optimization scans a children list that contains hoisted nodes, and * tries to find the largest chunk of consecutive hoisted nodes before running * into a non-hoisted node or the end of the list. A chunk is then converted * into a single static vnode and replaces the hoisted expression of the first * node in the chunk. Other nodes in the chunk are considered "merged" and * therefore removed from both the hoist list and the children array. * * This optimization is only performed in Node.js. */const stringifyStatic = (children, context, parent) => {  // bail stringification for slot content  if (context.scopes.vSlot > 0) {    return  }  let nc = 0 // current node count  let ec = 0 // current element with binding count  const currentChunk = []  logg(`stringifyStatic - children.length = ${children.length}`)  const stringifyCurrentChunk = (currentIndex) => {    if (      nc >= StringifyThresholds.NODE_COUNT ||      ec >= StringifyThresholds.ELEMENT_WITH_BINDING_COUNT    ) {      logg(`stringifyCurrentChunk - index = ${currentIndex}`)      // combine all currently eligible nodes into a single static vnode call      const staticCall = createCallExpression(context.helper(CREATE_STATIC), [        JSON.stringify(          currentChunk.map((node) => stringifyNode(node, context)).join('')        ).replace(expReplaceRE, `" + $1 + "`),        // the 2nd argument indicates the number of DOM nodes this static vnode        // will insert / hydrate        String(currentChunk.length)      ])      // replace the first node's hoisted expression with the static vnode call      replaceHoist(currentChunk[0], staticCall, context)      if (currentChunk.length > 1) {        for (let i = 1; i < currentChunk.length; i++) {          // for the merged nodes, set their hoisted expression to null          replaceHoist(currentChunk[i], null, context)        }        // also remove merged nodes from children        const deleteCount = currentChunk.length - 1        children.splice(currentIndex - currentChunk.length + 1, deleteCount)        return deleteCount      }    }    return 0  }  let i = 0  for (; i < children.length; i++) {    const child = children[i]    const hoisted = getHoistedNode(child)    if (hoisted) {      // presence of hoisted means child must be a stringifiable node      const node = child      const result = analyzeNode(node)      if (result) {        // node is stringifiable, record state        nc += result[0]        ec += result[1]        currentChunk.push(node)        continue      }    }    // we only reach here if we ran into a node that is not stringifiable    // check if currently analyzed nodes meet criteria for stringification.    // adjust iteration index    i -= stringifyCurrentChunk(i)    // reset state    nc = 0    ec = 0    currentChunk.length = 0  }  // in case the last node was also stringifiable  stringifyCurrentChunk(i)}const getHoistedNode = (node) =>  ((node.type === NodeTypes.ELEMENT && node.tagType === ElementTypes.ELEMENT) ||    node.type == NodeTypes.TEXT_CALL) &&  node.codegenNode &&  node.codegenNode.type === NodeTypes.SIMPLE_EXPRESSION &&  node.codegenNode.hoistedconst dataAriaRE = /^(data|aria)-/const isStringifiableAttr = (name, ns) => {  return (    (ns === DOMNamespaces.HTML      ? isKnownHtmlAttr(name)      : ns === DOMNamespaces.SVG      ? isKnownSvgAttr(name)      : false) || dataAriaRE.test(name)  )}const replaceHoist = (node, replacement, context) => {  const hoistToReplace = node.codegenNode.hoisted  context.hoists[context.hoists.indexOf(hoistToReplace)] = replacement}const isNonStringifiable = /*#__PURE__*/ makeMap(  `caption,thead,tr,th,tbody,td,tfoot,colgroup,col`)/** * for a hoisted node, analyze it and return: * - false: bailed (contains non-stringifiable props or runtime constant) * - [nc, ec] where *   - nc is the number of nodes inside *   - ec is the number of element with bindings inside */function analyzeNode(node) {  if (node.type === NodeTypes.ELEMENT && isNonStringifiable(node.tag)) {    return false  }  if (node.type === NodeTypes.TEXT_CALL) {    return [1, 0]  }  let nc = 1 // node count  let ec = node.props.length > 0 ? 1 : 0 // element w/ binding count  let bailed = false  const bail = () => {    bailed = true    return false  }  // TODO: check for cases where using innerHTML will result in different  // output compared to imperative node insertions.  // probably only need to check for most common case  // i.e. non-phrasing-content tags inside `<p>`  function walk(node) {    for (let i = 0; i < node.props.length; i++) {      const p = node.props[i]      // bail on non-attr bindings      if (        p.type === NodeTypes.ATTRIBUTE &&        !isStringifiableAttr(p.name, node.ns)      ) {        return bail()      }      if (p.type === NodeTypes.DIRECTIVE && p.name === 'bind') {        // bail on non-attr bindings        if (          p.arg &&          (p.arg.type === NodeTypes.COMPOUND_EXPRESSION ||            (p.arg.isStatic && !isStringifiableAttr(p.arg.content, node.ns)))        ) {          return bail()        }        if (          p.exp &&          (p.exp.type === NodeTypes.COMPOUND_EXPRESSION ||            p.exp.constType < ConstantTypes.CAN_STRINGIFY)        ) {          return bail()        }      }    }    for (let i = 0; i < node.children.length; i++) {      nc++      const child = node.children[i]      if (child.type === NodeTypes.ELEMENT) {        if (child.props.length > 0) {          ec++        }        walk(child)        if (bailed) {          return false        }      }    }    return true  }  return walk(node) ? [nc, ec] : false}function stringifyNode(node, context) {  if (isString(node)) {    return node  }  if (isSymbol(node)) {    return ``  }  switch (node.type) {    case NodeTypes.ELEMENT:      return stringifyElement(node, context)    case NodeTypes.TEXT:      return escapeHtml(node.content)    case NodeTypes.COMMENT:      return `<!--${escapeHtml(node.content)}-->`    case NodeTypes.INTERPOLATION:      return escapeHtml(toDisplayString(evaluateConstant(node.content)))    case NodeTypes.COMPOUND_EXPRESSION:      return escapeHtml(evaluateConstant(node))    case NodeTypes.TEXT_CALL:      return stringifyNode(node.content, context)    default:      // static trees will not contain if/for nodes      return ''  }}function stringifyElement(node, context) {  let res = `<${node.tag}`  for (let i = 0; i < node.props.length; i++) {    const p = node.props[i]    if (p.type === NodeTypes.ATTRIBUTE) {      res += ` ${p.name}`      if (p.value) {        res += `="${escapeHtml(p.value.content)}"`      }    } else if (p.type === NodeTypes.DIRECTIVE && p.name === 'bind') {      const exp = p.exp      if (exp.content[0] === '_') {        // internally generated string constant references        // e.g. imported URL strings via compiler-sfc transformAssetUrl plugin        res += ` ${p.arg.content}="__VUE_EXP_START__${exp.content}__VUE_EXP_END__"`        continue      }      // constant v-bind, e.g. :foo="1"      let evaluated = evaluateConstant(exp)      if (evaluated != null) {        const arg = p.arg && p.arg.content        if (arg === 'class') {          evaluated = normalizeClass(evaluated)        } else if (arg === 'style') {          evaluated = stringifyStyle(normalizeStyle(evaluated))        }        res += ` ${p.arg.content}="${escapeHtml(evaluated)}"`      }    }  }  if (context.scopeId) {    res += ` ${context.scopeId}`  }  res += `>`  for (let i = 0; i < node.children.length; i++) {    res += stringifyNode(node.children[i], context)  }  if (!isVoidTag(node.tag)) {    res += `</${node.tag}>`  }  return res}// __UNSAFE__// Reason: eval.// It's technically safe to eval because only constant expressions are possible// here, e.g. `{{ 1 }}` or `{{ 'foo' }}`// in addition, constant exps bail on presence of parens so you can't even// run JSFuck in here. But we mark it unsafe for security review purposes.// (see compiler-core/src/transformExpressions)function evaluateConstant(exp) {  if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {    return new Function(`return ${exp.content}`)()  } else {    // compound    let res = ``    exp.children.forEach((c) => {      if (isString(c) || isSymbol(c)) {        return      }      if (c.type === NodeTypes.TEXT) {        res += c.content      } else if (c.type === NodeTypes.INTERPOLATION) {        res += toDisplayString(evaluateConstant(c.content))      } else {        res += evaluateConstant(c)      }    })    return res  }}const DOMDirectiveTransforms = {  cloak: noopDirectiveTransform,  html: transformVHtml,  text: transformVText,  model: transformModelCD, // override compiler-core  on: transformOnCD, // override compiler-core  show: transformShowCD}const DOMNodeTransforms = [  transformStyleCD,  ...(__DEV__ ? [warnTransitionChildren] : [])]function compile(template, options = {}) {  return baseCompile(    template,    extend({}, parserOptions, options, {      nodeTransforms: [        // ignore <script> and <tag>        // this is not put inside DOMNodeTransforms because that list is used        // by compiler-ssr to generate vnode fallback branches        ignoreSideEffectTags,        ...DOMNodeTransforms,        ...(options.nodeTransforms || [])      ],      directiveTransforms: extend(        {},        DOMDirectiveTransforms,        options.directiveTransforms || {}      ),      transformHoist: __BROWSER__ ? null : stringifyStatic    })  )}function parse(template, options = {}) {  return baseParse(template, extend({}, parserOptions, options))}const __ESM_BROWSER__ = false,  __GLOBAL__ = truelet MagicString = require(process.env.NODE_LIB + '/magic-string')function createCache(size = 500) {  return new Map()}const defaultExportRE = /((?:^|\n|;)\s*)export(\s*)default/const namedDefaultExportRE = /((?:^|\n|;)\s*)export(.+)as(\s*)default/sconst exportDefaultClassRE =  /((?:^|\n|;)\s*)export\s+default\s+class\s+([\w$]+)//** * Utility for rewriting `export default` in a script block into a variable * declaration so that we can inject things into it */function rewriteDefault(input, as, parserPlugins) {  if (!hasDefaultExport(input)) {    return input + `\nconst ${as} = {}`  }  let replaced  const classMatch = input.match(exportDefaultClassRE)  if (classMatch) {    replaced =      input.replace(exportDefaultClassRE, '$1class $2') +      `\nconst ${as} = ${classMatch[2]}`  } else {    replaced = input.replace(defaultExportRE, `$1const ${as} =`)  }  if (!hasDefaultExport(replaced)) {    return replaced  }  // if the script somehow still contains `default export`, it probably has  // multi-line comments or template strings. fallback to a full parse.  const s = new MagicString(input)  const ast = babelParser.parse(input, {    sourceType: 'module',    plugins: [...parserPlugins, ...babelPlugins]  }).program.body  ast.forEach((node) => {    if (node.type === 'ExportDefaultDeclaration') {      s.overwrite(node.start, node.declaration.start, `const ${as} = `)    }    if (node.type === 'ExportNamedDeclaration') {      node.specifiers.forEach((specifier) => {        if (          specifier.type === 'ExportSpecifier' &&          specifier.exported.type === 'Identifier' &&          specifier.exported.name === 'default'        ) {          const end = specifier.end          s.overwrite(            specifier.start,            input.charAt(end) === ',' ? end + 1 : end,            ``          )          s.append(`\nconst ${as} = ${specifier.local.name}`)        }      })    }  })  return s.toString()}function hasDefaultExport(input) {  return defaultExportRE.test(input) || namedDefaultExportRE.test(input)}const RT = (function () {  const CONVERT_SYMBOL = '$'  const ESCAPE_SYMBOL = '$$'  const shorthands = ['ref', 'computed', 'shallowRef', 'toRef', 'customRef']  const transformCheckRE = /[^\w]\$(?:\$|ref|computed|shallowRef)?\s*(\(|\<)/  function shouldTransform(src) {    return transformCheckRE.test(src)  }  function transform(    src,    { filename, sourceMap, parserPlugins, importHelpersFrom = 'vue' } = {}  ) {    const plugins = parserPlugins || []    if (filename) {      if (/\.tsx?$/.test(filename)) {        plugins.push('typescript')      }      if (filename.endsWith('x')) {        plugins.push('jsx')      }    }    const ast = babelParser.parse(src, {      sourceType: 'module',      plugins: [...plugins, ...babelPlugins]    })    const s = new MagicString(src)    const res = transformAST(ast.program, s, 0)    // inject helper imports    if (res.importedHelpers.length) {      s.prepend(        `import { ${res.importedHelpers          .map((h) => `${h} as _${h}`)          .join(', ')} } from '${importHelpersFrom}'\n`      )    }    return {      ...res,      code: s.toString(),      map: sourceMap        ? s.generateMap({            source: filename,            hires: true,            includeContent: true          })        : null    }  }  function transformAST(ast, s, offset = 0, knownRefs, knownProps) {    let convertSymbol = CONVERT_SYMBOL    let escapeSymbol = ESCAPE_SYMBOL    // macro import handling    for (const node of ast.body) {      if (        node.type === 'ImportDeclaration' &&        node.source.value === 'vue/macros'      ) {        // remove macro imports        s.remove(node.start + offset, node.end + offset)        // check aliasing        for (const specifier of node.specifiers) {          if (specifier.type === 'ImportSpecifier') {            const imported = specifier.imported.name            const local = specifier.local.name            if (local !== imported) {              if (imported === ESCAPE_SYMBOL) {                escapeSymbol = local              } else if (imported === CONVERT_SYMBOL) {                convertSymbol = local              } else {                error(                  `macro imports for ref-creating methods do not support aliasing.`,                  specifier                )              }            }          }        }      }    }    const importedHelpers = new Set()    const rootScope = {}    const scopeStack = [rootScope]    let currentScope = rootScope    let escapeScope // inside $$()    const excludedIds = new WeakSet()    const parentStack = []    const propsLocalToPublicMap = Object.create(null)    if (knownRefs) {      for (const key of knownRefs) {        rootScope[key] = true      }    }    if (knownProps) {      for (const key in knownProps) {        const { local } = knownProps[key]        rootScope[local] = 'prop'        propsLocalToPublicMap[local] = key      }    }    function isRefCreationCall(callee) {      if (callee === convertSymbol) {        return convertSymbol      }      if (callee[0] === '$' && shorthands.includes(callee.slice(1))) {        return callee      }      return false    }    function error(msg, node) {      const e = new Error(msg)      e.node = node      throw e    }    function helper(msg) {      importedHelpers.add(msg)      return `_${msg}`    }    function registerBinding(id, isRef = false) {      excludedIds.add(id)      if (currentScope) {        currentScope[id.name] = isRef      } else {        error(          'registerBinding called without active scope, something is wrong.',          id        )      }    }    const registerRefBinding = (id) => registerBinding(id, true)    let tempVarCount = 0    function genTempVar() {      return `__$temp_${++tempVarCount}`    }    function snip(node) {      return s.original.slice(node.start + offset, node.end + offset)    }    function walkScope(node, isRoot = false) {      for (const stmt of node.body) {        if (stmt.type === 'VariableDeclaration') {          walkVariableDeclaration(stmt, isRoot)        } else if (          stmt.type === 'FunctionDeclaration' ||          stmt.type === 'ClassDeclaration'        ) {          if (stmt.declare || !stmt.id) continue          registerBinding(stmt.id)        } else if (          (stmt.type === 'ForOfStatement' || stmt.type === 'ForInStatement') &&          stmt.left.type === 'VariableDeclaration'        ) {          walkVariableDeclaration(stmt.left)        } else if (          stmt.type === 'ExportNamedDeclaration' &&          stmt.declaration &&          stmt.declaration.type === 'VariableDeclaration'        ) {          walkVariableDeclaration(stmt.declaration, isRoot)        } else if (          stmt.type === 'LabeledStatement' &&          stmt.body.type === 'VariableDeclaration'        ) {          walkVariableDeclaration(stmt.body, isRoot)        }      }    }    function walkVariableDeclaration(stmt, isRoot = false) {      if (stmt.declare) {        return      }      for (const decl of stmt.declarations) {        let refCall        const isCall =          decl.init &&          decl.init.type === 'CallExpression' &&          decl.init.callee.type === 'Identifier'        if (isCall && (refCall = isRefCreationCall(decl.init.callee.name))) {          processRefDeclaration(refCall, decl.id, decl.init)        } else {          const isProps =            isRoot && isCall && decl.init.callee.name === 'defineProps'          for (const id of extractIdentifiers(decl.id)) {            if (isProps) {              // for defineProps destructure, only exclude them since they              // are already passed in as knownProps              excludedIds.add(id)            } else {              registerBinding(id)            }          }        }      }    }    function processRefDeclaration(method, id, call) {      excludedIds.add(call.callee)      if (method === convertSymbol) {        // $        // remove macro        s.remove(call.callee.start + offset, call.callee.end + offset)        if (id.type === 'Identifier') {          // single variable          registerRefBinding(id)        } else if (id.type === 'ObjectPattern') {          processRefObjectPattern(id, call)        } else if (id.type === 'ArrayPattern') {          processRefArrayPattern(id, call)        }      } else {        // shorthands        if (id.type === 'Identifier') {          registerRefBinding(id)          // replace call          s.overwrite(            call.start + offset,            call.start + method.length + offset,            helper(method.slice(1))          )        } else {          error(`${method}() cannot be used with destructure patterns.`, call)        }      }    }    function processRefObjectPattern(pattern, call, tempVar, path = []) {      if (!tempVar) {        tempVar = genTempVar()        // const { x } = $(useFoo()) --> const __$temp_1 = useFoo()        s.overwrite(pattern.start + offset, pattern.end + offset, tempVar)      }      for (const p of pattern.properties) {        let nameId        let key        let defaultValue        if (p.type === 'ObjectProperty') {          if (p.key.start === p.value.start) {            // shorthand { foo }            nameId = p.key            if (p.value.type === 'Identifier') {              // avoid shorthand value identifier from being processed              excludedIds.add(p.value)            } else if (              p.value.type === 'AssignmentPattern' &&              p.value.left.type === 'Identifier'            ) {              // { foo = 1 }              excludedIds.add(p.value.left)              defaultValue = p.value.right            }          } else {            key = p.computed ? p.key : p.key.name            if (p.value.type === 'Identifier') {              // { foo: bar }              nameId = p.value            } else if (p.value.type === 'ObjectPattern') {              processRefObjectPattern(p.value, call, tempVar, [...path, key])            } else if (p.value.type === 'ArrayPattern') {              processRefArrayPattern(p.value, call, tempVar, [...path, key])            } else if (p.value.type === 'AssignmentPattern') {              if (p.value.left.type === 'Identifier') {                // { foo: bar = 1 }                nameId = p.value.left                defaultValue = p.value.right              } else if (p.value.left.type === 'ObjectPattern') {                processRefObjectPattern(p.value.left, call, tempVar, [                  ...path,                  [key, p.value.right]                ])              } else if (p.value.left.type === 'ArrayPattern') {                processRefArrayPattern(p.value.left, call, tempVar, [                  ...path,                  [key, p.value.right]                ])              } else {                // MemberExpression case is not possible here, ignore              }            }          }        } else {          // rest element { ...foo }          error(`reactivity destructure does not support rest elements.`, p)        }        if (nameId) {          registerRefBinding(nameId)          // inject toRef() after original replaced pattern          const source = pathToString(tempVar, path)          const keyStr = isString(key)            ? `'${key}'`            : key            ? snip(key)            : `'${nameId.name}'`          const defaultStr = defaultValue ? `, ${snip(defaultValue)}` : ``          s.appendLeft(            call.end + offset,            `,\n  ${nameId.name} = ${helper(              'toRef'            )}(${source}, ${keyStr}${defaultStr})`          )        }      }    }    function processRefArrayPattern(pattern, call, tempVar, path = []) {      if (!tempVar) {        // const [x] = $(useFoo()) --> const __$temp_1 = useFoo()        tempVar = genTempVar()        s.overwrite(pattern.start + offset, pattern.end + offset, tempVar)      }      for (let i = 0; i < pattern.elements.length; i++) {        const e = pattern.elements[i]        if (!e) continue        let nameId        let defaultValue        if (e.type === 'Identifier') {          // [a] --> [__a]          nameId = e        } else if (e.type === 'AssignmentPattern') {          // [a = 1]          nameId = e.left          defaultValue = e.right        } else if (e.type === 'RestElement') {          // [...a]          error(`reactivity destructure does not support rest elements.`, e)        } else if (e.type === 'ObjectPattern') {          processRefObjectPattern(e, call, tempVar, [...path, i])        } else if (e.type === 'ArrayPattern') {          processRefArrayPattern(e, call, tempVar, [...path, i])        }        if (nameId) {          registerRefBinding(nameId)          // inject toRef() after original replaced pattern          const source = pathToString(tempVar, path)          const defaultStr = defaultValue ? `, ${snip(defaultValue)}` : ``          s.appendLeft(            call.end + offset,            `,\n  ${nameId.name} = ${helper(              'toRef'            )}(${source}, ${i}${defaultStr})`          )        }      }    }    function pathToString(source, path) {      if (path.length) {        for (const seg of path) {          if (isArray(seg)) {            source = `(${source}${segToString(seg[0])} || ${snip(seg[1])})`          } else {            source += segToString(seg)          }        }      }      return source    }    function segToString(seg) {      if (typeof seg === 'number') {        return `[${seg}]`      } else if (typeof seg === 'string') {        return `.${seg}`      } else {        return snip(seg)      }    }    function rewriteId(scope, id, parent, parentStack) {      if (hasOwn(scope, id.name)) {        const bindingType = scope[id.name]        if (bindingType) {          const isProp = bindingType === 'prop'          if (isStaticProperty(parent) && parent.shorthand) {            // let binding used in a property shorthand            // skip for destructure patterns            if (              !parent.inPattern ||              isInDestructureAssignment(parent, parentStack)            ) {              if (isProp) {                if (escapeScope) {                  // prop binding in $$()                  // { prop } -> { prop: __prop_prop }                  registerEscapedPropBinding(id)                  s.appendLeft(                    id.end + offset,                    `: __props_${propsLocalToPublicMap[id.name]}`                  )                } else {                  // { prop } -> { prop: __prop.prop }                  s.appendLeft(                    id.end + offset,                    `: __props.${propsLocalToPublicMap[id.name]}`                  )                }              } else {                // { foo } -> { foo: foo.value }                s.appendLeft(id.end + offset, `: ${id.name}.value`)              }            }          } else {            if (isProp) {              if (escapeScope) {                // x --> __props_x                registerEscapedPropBinding(id)                s.overwrite(                  id.start + offset,                  id.end + offset,                  `__props_${propsLocalToPublicMap[id.name]}`                )              } else {                // x --> __props.x                s.overwrite(                  id.start + offset,                  id.end + offset,                  `__props.${propsLocalToPublicMap[id.name]}`                )              }            } else {              // x --> x.value              s.appendLeft(id.end + offset, '.value')            }          }        }        return true      }      return false    }    const propBindingRefs = {}    function registerEscapedPropBinding(id) {      if (!propBindingRefs.hasOwnProperty(id.name)) {        propBindingRefs[id.name] = true        const publicKey = propsLocalToPublicMap[id.name]        s.prependRight(          offset,          `const __props_${publicKey} = ${helper(            `toRef`          )}(__props, '${publicKey}')\n`        )      }    }    // check root scope first    walkScope(ast, true)    walk(ast, {      enter(node, parent) {        parent && parentStack.push(parent)        // function scopes        if (isFunctionType(node)) {          scopeStack.push((currentScope = {}))          walkFunctionParams(node, registerBinding)          if (node.body.type === 'BlockStatement') {            walkScope(node.body)          }          return        }        // catch param        if (node.type === 'CatchClause') {          scopeStack.push((currentScope = {}))          if (node.param && node.param.type === 'Identifier') {            registerBinding(node.param)          }          walkScope(node.body)          return        }        // non-function block scopes        if (node.type === 'BlockStatement' && !isFunctionType(parent)) {          scopeStack.push((currentScope = {}))          walkScope(node)          return        }        // skip type nodes        if (          parent &&          parent.type.startsWith('TS') &&          parent.type !== 'TSAsExpression' &&          parent.type !== 'TSNonNullExpression' &&          parent.type !== 'TSTypeAssertion'        ) {          return this.skip()        }        if (          node.type === 'Identifier' &&          // if inside $$(), skip unless this is a destructured prop binding          !(escapeScope && rootScope[node.name] !== 'prop') &&          isReferencedIdentifier(node, parent, parentStack) &&          !excludedIds.has(node)        ) {          // walk up the scope chain to check if id should be appended .value          let i = scopeStack.length          while (i--) {            if (rewriteId(scopeStack[i], node, parent, parentStack)) {              return            }          }        }        if (          node.type === 'CallExpression' &&          node.callee.type === 'Identifier'        ) {          const callee = node.callee.name          const refCall = isRefCreationCall(callee)          if (refCall && (!parent || parent.type !== 'VariableDeclarator')) {            return error(              `${refCall} can only be used as the initializer of ` +                `a variable declaration.`,              node            )          }          if (callee === escapeSymbol) {            s.remove(node.callee.start + offset, node.callee.end + offset)            escapeScope = node          }          // TODO remove when out of experimental          if (callee === '$raw') {            error(              `$raw() has been replaced by $$(). ` +                `See ${RFC_LINK} for latest updates.`,              node            )          }          if (callee === '$fromRef') {            error(              `$fromRef() has been replaced by $(). ` +                `See ${RFC_LINK} for latest updates.`,              node            )          }        }      },      leave(node, parent) {        parent && parentStack.pop()        if (          (node.type === 'BlockStatement' && !isFunctionType(parent)) ||          isFunctionType(node)        ) {          scopeStack.pop()          currentScope = scopeStack[scopeStack.length - 1] || null        }        if (node === escapeScope) {          escapeScope = undefined        }      }    })    return {      rootRefs: Object.keys(rootScope).filter((key) => rootScope[key] === true),      importedHelpers: [...importedHelpers]    }  }  return { transformAST, transform, shouldTransform }})()const range = 2function generateCodeFrame(source, start = 0, end = source.length) {  // Split the content into individual lines but capture the newline sequence  // that separated each line. This is important because the actual sequence is  // needed to properly take into account the full line length for offset  // comparison  let lines = source.split(/(\r?\n)/)  // Separate the lines and newline sequences into separate arrays for easier referencing  const newlineSequences = lines.filter((_, idx) => idx % 2 === 1)  lines = lines.filter((_, idx) => idx % 2 === 0)  let count = 0  const res = []  for (let i = 0; i < lines.length; i++) {    count +=      lines[i].length +      ((newlineSequences[i] && newlineSequences[i].length) || 0)    if (count >= start) {      for (let j = i - range; j <= i + range || end > count; j++) {        if (j < 0 || j >= lines.length) continue        const line = j + 1        res.push(          `${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${            lines[j]          }`        )        const lineLength = lines[j].length        const newLineSeqLength =          (newlineSequences[j] && newlineSequences[j].length) || 0        if (j === i) {          // push underline          const pad = start - (count - (lineLength + newLineSeqLength))          const length = Math.max(            1,            end > count ? lineLength - pad : end - start          )          res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length))        } else if (j > i) {          if (end > count) {            const length = Math.max(Math.min(end - count, lineLength), 1)            res.push(`   |  ` + '^'.repeat(length))          }          count += lineLength + newLineSeqLength        }      }      break    }  }  return res.join('\n')}function registerBinding(bindings, node, type) {  bindings[node.name] = type}function walkDeclaration(node, bindings, userImportAlias) {  if (node.type === 'VariableDeclaration') {    const isConst = node.kind === 'const'    // export const foo = ...    for (const { id, init } of node.declarations) {      const isDefineCall = !!(        isConst &&        isCallOf(          init,          (c) => c === DEFINE_PROPS || c === DEFINE_EMITS || c === WITH_DEFAULTS        )      )      if (id.type === 'Identifier') {        let bindingType        const userReactiveBinding = userImportAlias['reactive'] || 'reactive'        if (isCallOf(init, userReactiveBinding)) {          // treat reactive() calls as let since it's meant to be mutable          bindingType = BindingTypes.SETUP_LET        } else if (          // if a declaration is a const literal, we can mark it so that          // the generated render fn code doesn't need to unref() it          isDefineCall ||          (isConst && canNeverBeRef(init, userReactiveBinding))        ) {          bindingType = BindingTypes.SETUP_CONST        } else if (isConst) {          if (isCallOf(init, userImportAlias['ref'] || 'ref')) {            bindingType = BindingTypes.SETUP_REF          } else {            bindingType = BindingTypes.SETUP_MAYBE_REF          }        } else {          bindingType = BindingTypes.SETUP_LET        }        registerBinding(bindings, id, bindingType)      } else {        if (isCallOf(init, DEFINE_PROPS)) {          // skip walking props destructure          return        }        if (id.type === 'ObjectPattern') {          walkObjectPattern(id, bindings, isConst, isDefineCall)        } else if (id.type === 'ArrayPattern') {          walkArrayPattern(id, bindings, isConst, isDefineCall)        }      }    }  } else if (    node.type === 'TSEnumDeclaration' ||    node.type === 'FunctionDeclaration' ||    node.type === 'ClassDeclaration'  ) {    // export function foo() {} / export class Foo {}    // export declarations must be named.    bindings[node.id.name] = BindingTypes.SETUP_CONST  }}function walkObjectPattern(node, bindings, isConst, isDefineCall = false) {  for (const p of node.properties) {    if (p.type === 'ObjectProperty') {      if (p.key.type === 'Identifier' && p.key === p.value) {        // shorthand: const { x } = ...        const type = isDefineCall          ? BindingTypes.SETUP_CONST          : isConst          ? BindingTypes.SETUP_MAYBE_REF          : BindingTypes.SETUP_LET        registerBinding(bindings, p.key, type)      } else {        walkPattern(p.value, bindings, isConst, isDefineCall)      }    } else {      // ...rest      // argument can only be identifier when destructuring      const type = isConst ? BindingTypes.SETUP_CONST : BindingTypes.SETUP_LET      registerBinding(bindings, p.argument, type)    }  }}function walkArrayPattern(node, bindings, isConst, isDefineCall = false) {  for (const e of node.elements) {    e && walkPattern(e, bindings, isConst, isDefineCall)  }}function walkPattern(node, bindings, isConst, isDefineCall = false) {  if (node.type === 'Identifier') {    const type = isDefineCall      ? BindingTypes.SETUP_CONST      : isConst      ? BindingTypes.SETUP_MAYBE_REF      : BindingTypes.SETUP_LET    registerBinding(bindings, node, type)  } else if (node.type === 'RestElement') {    // argument can only be identifier when destructuring    const type = isConst ? BindingTypes.SETUP_CONST : BindingTypes.SETUP_LET    registerBinding(bindings, node.argument, type)  } else if (node.type === 'ObjectPattern') {    walkObjectPattern(node, bindings, isConst)  } else if (node.type === 'ArrayPattern') {    walkArrayPattern(node, bindings, isConst)  } else if (node.type === 'AssignmentPattern') {    if (node.left.type === 'Identifier') {      const type = isDefineCall        ? BindingTypes.SETUP_CONST        : isConst        ? BindingTypes.SETUP_MAYBE_REF        : BindingTypes.SETUP_LET      registerBinding(bindings, node.left, type)    } else {      walkPattern(node.left, bindings, isConst)    }  }}function recordType(node, declaredTypes) {  if (node.type === 'TSInterfaceDeclaration') {    declaredTypes[node.id.name] = [`Object`]  } else if (node.type === 'TSTypeAliasDeclaration') {    declaredTypes[node.id.name] = inferRuntimeType(      node.typeAnnotation,      declaredTypes    )  } else if (node.type === 'ExportNamedDeclaration' && node.declaration) {    recordType(node.declaration, declaredTypes)  }}function extractRuntimeProps(node, props, declaredTypes, isProd) {  const members = node.type === 'TSTypeLiteral' ? node.members : node.body  for (const m of members) {    if (      (m.type === 'TSPropertySignature' || m.type === 'TSMethodSignature') &&      m.key.type === 'Identifier'    ) {      let type      if (m.type === 'TSMethodSignature') {        type = ['Function']      } else if (m.typeAnnotation) {        type = inferRuntimeType(m.typeAnnotation.typeAnnotation, declaredTypes)      }      props[m.key.name] = {        key: m.key.name,        required: !m.optional,        type: type || [`null`]      }    }  }}function inferRuntimeType(node, declaredTypes) {  switch (node.type) {    case 'TSStringKeyword':      return ['String']    case 'TSNumberKeyword':      return ['Number']    case 'TSBooleanKeyword':      return ['Boolean']    case 'TSObjectKeyword':      return ['Object']    case 'TSTypeLiteral':      // TODO (nice to have) generate runtime property validation      return ['Object']    case 'TSFunctionType':      return ['Function']    case 'TSArrayType':    case 'TSTupleType':      // TODO (nice to have) generate runtime element type/length checks      return ['Array']    case 'TSLiteralType':      switch (node.literal.type) {        case 'StringLiteral':          return ['String']        case 'BooleanLiteral':          return ['Boolean']        case 'NumericLiteral':        case 'BigIntLiteral':          return ['Number']        default:          return [`null`]      }    case 'TSTypeReference':      if (node.typeName.type === 'Identifier') {        if (declaredTypes[node.typeName.name]) {          return declaredTypes[node.typeName.name]        }        switch (node.typeName.name) {          case 'Array':          case 'Function':          case 'Object':          case 'Set':          case 'Map':          case 'WeakSet':          case 'WeakMap':          case 'Date':            return [node.typeName.name]          case 'Record':          case 'Partial':          case 'Readonly':          case 'Pick':          case 'Omit':          case 'Exclude':          case 'Extract':          case 'Required':          case 'InstanceType':            return ['Object']        }      }      return [`null`]    case 'TSParenthesizedType':      return inferRuntimeType(node.typeAnnotation, declaredTypes)    case 'TSUnionType':      return [        ...new Set(          [].concat(            ...node.types.map((t) => inferRuntimeType(t, declaredTypes))          )        )      ]    case 'TSIntersectionType':      return ['Object']    case 'TSSymbolKeyword':      return ['Symbol']    default:      return [`null`] // no runtime check  }}function toRuntimeTypeString(types) {  return types.length > 1 ? `[${types.join(', ')}]` : types[0]}function extractRuntimeEmits(node, emits) {  if (node.type === 'TSTypeLiteral' || node.type === 'TSInterfaceBody') {    const members = node.type === 'TSTypeLiteral' ? node.members : node.body    for (let t of members) {      if (t.type === 'TSCallSignatureDeclaration') {        extractEventNames(t.parameters[0], emits)      }    }    return  } else {    extractEventNames(node.parameters[0], emits)  }}function extractEventNames(eventName, emits) {  if (    eventName.type === 'Identifier' &&    eventName.typeAnnotation &&    eventName.typeAnnotation.type === 'TSTypeAnnotation'  ) {    const typeNode = eventName.typeAnnotation.typeAnnotation    if (typeNode.type === 'TSLiteralType') {      if (typeNode.literal.type !== 'UnaryExpression') {        emits.add(String(typeNode.literal.value))      }    } else if (typeNode.type === 'TSUnionType') {      for (const t of typeNode.types) {        if (          t.type === 'TSLiteralType' &&          t.literal.type !== 'UnaryExpression'        ) {          emits.add(String(t.literal.value))        }      }    }  }}function genRuntimeEmits(emits) {  return emits.size    ? `\n  emits: [${Array.from(emits)        .map((p) => JSON.stringify(p))        .join(', ')}],`    : ``}function isCallOf(node, test) {  return !!(    node &&    node.type === 'CallExpression' &&    node.callee.type === 'Identifier' &&    (typeof test === 'string'      ? node.callee.name === test      : test(node.callee.name))  )}function canNeverBeRef(node, userReactiveImport) {  if (isCallOf(node, userReactiveImport)) {    return true  }  switch (node.type) {    case 'UnaryExpression':    case 'BinaryExpression':    case 'ArrayExpression':    case 'ObjectExpression':    case 'FunctionExpression':    case 'ArrowFunctionExpression':    case 'UpdateExpression':    case 'ClassExpression':    case 'TaggedTemplateExpression':      return true    case 'SequenceExpression':      return canNeverBeRef(        node.expressions[node.expressions.length - 1],        userReactiveImport      )    default:      if (node.type.endsWith('Literal')) {        return true      }      return false  }}/** * Analyze bindings in normal `<script>` * Note that `compileScriptSetup` already analyzes bindings as part of its * compilation process so this should only be used on single `<script>` SFCs. */function analyzeScriptBindings(ast) {  for (const node of ast) {    if (      node.type === 'ExportDefaultDeclaration' &&      node.declaration.type === 'ObjectExpression'    ) {      return analyzeBindingsFromOptions(node.declaration)    }  }  return {}}function analyzeBindingsFromOptions(node) {  const bindings = {}  // #3270, #3275  // mark non-script-setup so we don't resolve components/directives from these  Object.defineProperty(bindings, '__isScriptSetup', {    enumerable: false,    value: false  })  for (const property of node.properties) {    if (      property.type === 'ObjectProperty' &&      !property.computed &&      property.key.type === 'Identifier'    ) {      // props      if (property.key.name === 'props') {        // props: ['foo']        // props: { foo: ... }        for (const key of getObjectOrArrayExpressionKeys(property.value)) {          bindings[key] = BindingTypes.PROPS        }      }      // inject      else if (property.key.name === 'inject') {        // inject: ['foo']        // inject: { foo: {} }        for (const key of getObjectOrArrayExpressionKeys(property.value)) {          bindings[key] = BindingTypes.OPTIONS        }      }      // computed & methods      else if (        property.value.type === 'ObjectExpression' &&        (property.key.name === 'computed' || property.key.name === 'methods')      ) {        // methods: { foo() {} }        // computed: { foo() {} }        for (const key of getObjectExpressionKeys(property.value)) {          bindings[key] = BindingTypes.OPTIONS        }      }    }    // setup & data    else if (      property.type === 'ObjectMethod' &&      property.key.type === 'Identifier' &&      (property.key.name === 'setup' || property.key.name === 'data')    ) {      for (const bodyItem of property.body.body) {        // setup() {        //   return {        //     foo: null        //   }        // }        if (          bodyItem.type === 'ReturnStatement' &&          bodyItem.argument &&          bodyItem.argument.type === 'ObjectExpression'        ) {          for (const key of getObjectExpressionKeys(bodyItem.argument)) {            bindings[key] =              property.key.name === 'setup'                ? BindingTypes.SETUP_MAYBE_REF                : BindingTypes.DATA          }        }      }    }  }  return bindings}function getObjectExpressionKeys(node) {  const keys = []  for (const prop of node.properties) {    if (      (prop.type === 'ObjectProperty' || prop.type === 'ObjectMethod') &&      !prop.computed    ) {      if (prop.key.type === 'Identifier') {        keys.push(prop.key.name)      } else if (prop.key.type === 'StringLiteral') {        keys.push(prop.key.value)      }    }  }  return keys}function getArrayExpressionKeys(node) {  const keys = []  for (const element of node.elements) {    if (element && element.type === 'StringLiteral') {      keys.push(element.value)    }  }  return keys}function getObjectOrArrayExpressionKeys(value) {  if (value.type === 'ArrayExpression') {    return getArrayExpressionKeys(value)  }  if (value.type === 'ObjectExpression') {    return getObjectExpressionKeys(value)  }  return []}function resolveTemplateUsageCheckString(sfc) {  const { content, ast } = sfc.template  const cached = templateUsageCheckCache.get(content)  if (cached) {    return cached  }  let code = ''  transform(createRoot([ast]), {    nodeTransforms: [      (node) => {        if (node.type === NodeTypes.ELEMENT) {          if (            !parserOptions.isNativeTag(node.tag) &&            !parserOptions.isBuiltInComponent(node.tag)          ) {            code += `,${camelize(node.tag)},${capitalize(camelize(node.tag))}`          }          for (let i = 0; i < node.props.length; i++) {            const prop = node.props[i]            if (prop.type === NodeTypes.DIRECTIVE) {              if (!isBuiltInDir(prop.name)) {                code += `,v${capitalize(camelize(prop.name))}`              }              if (prop.exp) {                code += `,${stripStrings(prop.exp.content)}`              }            }          }        } else if (node.type === NodeTypes.INTERPOLATION) {          code += `,${stripStrings(node.content.content)}`        }      }    ]  })  code += ';'  templateUsageCheckCache.set(content, code)  return code}function stripStrings(exp) {  return exp    .replace(/'[^']*'|"[^"]*"/g, '')    .replace(/`[^`]+`/g, stripTemplateString)}function isImportUsed(local, sfc) {  return new RegExp(    // #4274 escape $ since it's a special char in regex    // (and is the only regex special char that is valid in identifiers)    `[^\\w$_]${local.replace(/\$/g, '\\$')}[^\\w$_]`  ).test(resolveTemplateUsageCheckString(sfc))}/** * Note: this comparison assumes the prev/next script are already identical, * and only checks the special case where <script setup lang="ts"> unused import * pruning result changes due to template changes. */function hmrShouldReload(prevImports, next) {  if (    !next.scriptSetup ||    (next.scriptSetup.lang !== 'ts' && next.scriptSetup.lang !== 'tsx')  ) {    return false  }  // for each previous import, check if its used status remain the same based on  // the next descriptor's template  for (const key in prevImports) {    // if an import was previous unused, but now is used, we need to force    // reload so that the script now includes that import.    if (!prevImports[key].isUsedInTemplate && isImportUsed(key, next)) {      return true    }  }  return false}function compileTemplate(options) {  // ... compile  return doCompileTemplate(options)}function doCompileTemplate({  filename,  id,  scoped,  slotted,  inMap,  source,  ssr = false,  ssrCssVars,  isProd = false,  compiler,  compilerOptions = {},  transformAssetUrls}) {  const errors = []  const warnings = []  let nodeTransforms = []  if (isObject(transformAssetUrls)) {    const assetOptions = normalizeOptions(transformAssetUrls)    nodeTransforms = [      createAssetUrlTransformWithOptions(assetOptions),      createSrcsetTransformWithOptions(assetOptions)    ]  } else if (transformAssetUrls !== false) {    nodeTransforms = [transformAssetUrl, transformSrcset]  }  if (!id) {    id = ''  }  const shortId = id.replace(/^data-v-/, '')  const longId = `data-v-${shortId}`  let { code, ast, preamble, map } = baseCompile(source, {    mode: 'module',    prefixIdentifiers: true,    hoistStatic: true,    cacheHandlers: true,    ssrCssVars:      ssr && ssrCssVars && ssrCssVars.length        ? genCssVarsFromList(ssrCssVars, shortId, isProd)        : '',    scopeId: scoped ? longId : undefined,    slotted,    sourceMap: true,    ...compilerOptions,    nodeTransforms: nodeTransforms.concat(compilerOptions.nodeTransforms || []),    filename,    onError: (e) => errors.push(e),    onWarn: (w) => warnings.push(w)  })  return { code, ast, preamble, source, errors, tips, map }}const hash = require(process.env.NODE_LIB + '/hash-sum')const CSS_VARS_HELPER = `useCssVars`// match v-bind() with max 2-levels of nested parens.const cssVarRE = /v-bind\s*\(((?:[^)(]+|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gfunction genCssVarsFromList(vars, id, isProd) {  return `{\n  ${vars    .map((key) => `"${genVarName(id, key, isProd)}": (${key})`)    .join(',\n  ')}\n}`}function genVarName(id, raw, isProd) {  if (isProd) {    return hash(id + raw)  } else {    return `${id}-${raw.replace(/([^\w-])/g, '_')}`  }}function noramlizeExpression(exp) {  exp = exp.trim()  if (    (exp[0] === `'` && exp[exp.length - 1] === `'`) ||    (exp[0] === `"` && exp[exp.length - 1] === `"`)  ) {    return exp.slice(1, -1)  }  return exp}function parseCssVars(sfc) {  const vars = []  sfc.styles.forEach((style) => {    let match    // ignore v-bind() in comments /* ... */    const content = style.content.replace(/\/\*([\s\S]*?)\*\//g, '')    while ((match = cssVarRE.exec(content))) {      const variable = noramlizeExpression(match[1])      if (!vars.includes(variable)) {        vars.push(variable)      }    }  })  return vars}// for compileStyleconst cssVarsPlugin = (opts) => {  const { id, isProd } = opts  return {    postcssPlugin: 'vue-sfc-vars',    Declaration(decl) {      // rewrite CSS variables      if (cssVarRE.test(decl.value)) {        decl.value = decl.value.replace(cssVarRE, (_, $1) => {          return `var(--${genVarName(id, noramlizeExpression($1), isProd)})`        })      }    }  }}cssVarsPlugin.postcss = truefunction genCssVarsCode(vars, bindings, id, isProd) {  const varsExp = genCssVarsFromList(vars, id, isProd)  const exp = createSimpleExpression(varsExp, false)  const context = createTransformContext(createRoot([]), {    prefixIdentifiers: true,    inline: true,    bindingMetadata: bindings.__isScriptSetup === false ? undefined : bindings  })  const transformed = processExpression(exp, context)  const transformedString =    transformed.type === NodeTypes.SIMPLE_EXPRESSION      ? transformed.content      : transformed.children          .map((c) => {            return typeof c === 'string' ? c : c.content          })          .join('')  return `_${CSS_VARS_HELPER}(_ctx => (${transformedString}))`}// <script setup> already gets the calls injected as part of the transform// this is only for single normal <script>function genNormalScriptCssVarsCode(cssVars, bindings, id, isProd) {  return (    `\nimport { ${CSS_VARS_HELPER} as _${CSS_VARS_HELPER} } from 'vue'\n` +    `const __injectCSSVars__ = () => {\n${genCssVarsCode(      cssVars,      bindings,      id,      isProd    )}}\n` +    `const __setup__ = __default__.setup\n` +    `__default__.setup = __setup__\n` +    `  ? (props, ctx) => { __injectCSSVars__();return __setup__(props, ctx) }\n` +    `  : __injectCSSVars__\n`  )}// Special compiler macrosconst DEFINE_PROPS = 'defineProps'const DEFINE_EMITS = 'defineEmits'const DEFINE_EXPOSE = 'defineExpose'const WITH_DEFAULTS = 'withDefaults'const templateUsageCheckCache = createCache()// constantsconst DEFAULT_VAR = `__default__`const isBuiltInDir = makeMap(  `once,memo,if,else,else-if,slot,text,html,on,bind,model,show,cloak,is`)function compileScript(sfc, options) {  let { script, scriptSetup, source, filename } = sfc  // feature flags  // TODO remove support for deprecated options when out of experimental  const enableReactivityTransform =    !!options.reactivityTransform ||    !!options.refSugar ||    !!options.refTransform  const enablePropsTransform =    !!options.reactivityTransform || !!options.propsDestructureTransform  const isProd = !!options.isProd  const genSourceMap = options.sourceMap !== false  // ref   let refBindings  const scopeId = options.id ? options.id.replace(/^data-v-/, '') : ''  const cssVars = sfc.cssVars  const scriptLang = script && script.lang  const scriptSetupLang = scriptSetup && scriptSetup.lang  const isTS =    scriptLang === 'ts' ||    scriptLang === 'tsx' ||    scriptSetupLang === 'ts' ||    scriptSetupLang === 'tsx'  // resolve parser plugins  const plugins = []  if (!isTS || scriptLang === 'tsx' || scriptSetupLang === 'tsx') {    plugins.push('jsx')  }  if (options.babelParserPlugins) plugins.push(...options.babelParserPlugins)  if (isTS) plugins.push('typescript', 'decorators-legacy')  if (!scriptSetup) {    if (!script) {      throw new Error(`[@vue/compiler-sfc] SFC contains no <script> tags.`)    }    if (scriptLang && !isTS && scriptLang !== 'jsx') {      // do not process non js/ts script blocks      return script    }    try {      let content = script.content      let map = script.map      const scriptAst = babelParser.parse(content, {        plugins: [...plugins, ...babelPlugins],        sourceType: 'module'      }).program      const bindings = analyzeScriptBindings(scriptAst.body)      if (enableReactivityTransform && RT.shouldTransform(content)) {        const s = new MagicString(source)        const startOffset = script.loc.start.offset        const endOffset = script.loc.end.offset        const { importedHelpers } = RT.transformAST(scriptAst, s, startOffset)        if (importedHelpers.length) {          s.prepend(            `import { ${importedHelpers              .map((h) => `${h} as _${h}`)              .join(', ')} } from 'vue'\n`          )        }        s.remove(0, startOffset)        s.remove(endOffset, source.length)        content = s.toString()        if (genSourceMap) {          map = s.generateMap({            source: filename,            hires: true,            includeContent: true          })        }      }      if (cssVars.length) {        content = rewriteDefault(content, DEFAULT_VAR, plugins)        content += genNormalScriptCssVarsCode(          cssVars,          bindings,          scopeId,          isProd        )        content += `\nexport default ${DEFAULT_VAR}`      }      return {        ...script,        content,        map,        bindings,        scriptAst: scriptAst.body      }    } catch (e) {      // silently fallback if parse fails since user may be using custom      // babel syntax      return script    }  }  // script  script setup   if (script && scriptLang !== scriptSetupLang) {    throw new Error(      `[@vue/compiler-sfc] <script> and <script setup> must have the same ` +        `language type.`    )  }  //  js/ts script  if (scriptSetupLang && !isTS && scriptSetupLang !== 'jsx') {    return scriptSetup  }  // imports   const bindingMetadata = {}  const helperImports = new Set()  const userImports = Object.create(null)  const userImportAlias = Object.create(null)  const scriptBindings = Object.create(null)  const setupBindings = Object.create(null)  let defaultExport // export default  let hasDefinePropsCall = false // defineProps()  let hasDefineEmitCall = false // defineEmits()  let hasDefineExposeCall = false // defineExpose()  let propsRuntimeDecl //   let propsRuntimeDefaults //   let propsDestructureDecl //   let propsDestructureRestId //  ...   let propsTypeDecl //   let propsTypeDeclRaw  let propsIdentifier  let emitsRuntimeDecl  let emitsTypeDecl  let emitsTypeDeclRaw  let emitIdentifier  let hasAwait = false //  await  async setup  let hasInlinedSsrRenderFn = false  // props/emits declared via types  const typeDeclaredProps = {}  const typeDeclaredEmits = new Set()  // record declared types for runtime props type generation  const declaredTypes = {}  // props destructure data  const propsDestructuredBindings = Object.create(null)  // magic-string state  const s = new MagicString(source)  const startOffset = scriptSetup.loc.start.offset  const endOffset = scriptSetup.loc.end.offset  const scriptStartOffset = script && script.loc.start.offset  const scriptEndOffset = script && script.loc.end.offset  function helper(key) {    helperImports.add(key)    return `_${key}`  }  function parse(input, options, offset) {    try {      return babelParser.parse(input, options).program    } catch (e) {      e.message = `[@vue/compiler-sfc] ${e.message}\n\n${        sfc.filename      }\n${generateCodeFrame(source, e.pos + offset, e.pos + offset + 1)}`      throw e    }  }  function error(msg, node, end = node.end + startOffset) {    throw new Error(      `[@vue/compiler-sfc] ${msg}\n\n${sfc.filename}\n${generateCodeFrame(        source,        node.start + startOffset,        end      )}`    )  }  function registerUserImport(source, local, imported, isType, isFromSetup) {    if (source === 'vue' && imported) {      userImportAlias[imported] = local    }    let isUsedInTemplate = true    if (isTS && sfc.template && !sfc.template.src && !sfc.template.lang) {      isUsedInTemplate = isImportUsed(local, sfc)    }    userImports[local] = {      isType,      imported: imported || 'default',      source,      isFromSetup,      isUsedInTemplate    }  }  function processDefineProps(node, declId) {    if (!isCallOf(node, DEFINE_PROPS)) {      return false    }    if (hasDefinePropsCall) {      error(`duplicate ${DEFINE_PROPS}() call`, node)    }    hasDefinePropsCall = true    propsRuntimeDecl = node.arguments[0]    // call has type parameters - infer runtime types from it    if (node.typeParameters) {      if (propsRuntimeDecl) {        error(          `${DEFINE_PROPS}() cannot accept both type and non-type arguments ` +            `at the same time. Use one or the other.`,          node        )      }      propsTypeDeclRaw = node.typeParameters.params[0]      propsTypeDecl = resolveQualifiedType(        propsTypeDeclRaw,        (node) => node.type === 'TSTypeLiteral'      )      if (!propsTypeDecl) {        error(          `type argument passed to ${DEFINE_PROPS}() must be a literal type, ` +            `or a reference to an interface or literal type.`,          propsTypeDeclRaw        )      }    }    if (declId) {      if (enablePropsTransform && declId.type === 'ObjectPattern') {        propsDestructureDecl = declId        // props destructure - handle compilation sugar        for (const prop of declId.properties) {          if (prop.type === 'ObjectProperty') {            if (prop.computed) {              error(                `${DEFINE_PROPS}() destructure cannot use computed key.`,                prop.key              )            }            const propKey = prop.key.name            if (prop.value.type === 'AssignmentPattern') {              // default value { foo = 123 }              const { left, right } = prop.value              if (left.type !== 'Identifier') {                error(                  `${DEFINE_PROPS}() destructure does not support nested patterns.`,                  left                )              }              // store default value              propsDestructuredBindings[propKey] = {                local: left.name,                default: right              }            } else if (prop.value.type === 'Identifier') {              // simple destructure              propsDestructuredBindings[propKey] = {                local: prop.value.name              }            } else {              error(                `${DEFINE_PROPS}() destructure does not support nested patterns.`,                prop.value              )            }          } else {            // rest spread            propsDestructureRestId = prop.argument.name          }        }      } else {        propsIdentifier = scriptSetup.content.slice(declId.start, declId.end)      }    }    return true  }  function processWithDefaults(node, declId) {    if (!isCallOf(node, WITH_DEFAULTS)) {      return false    }    if (processDefineProps(node.arguments[0], declId)) {      if (propsRuntimeDecl) {        error(          `${WITH_DEFAULTS} can only be used with type-based ` +            `${DEFINE_PROPS} declaration.`,          node        )      }      if (propsDestructureDecl) {        error(          `${WITH_DEFAULTS}() is unnecessary when using destructure with ${DEFINE_PROPS}().\n` +            `Prefer using destructure default values, e.g. const { foo = 1 } = defineProps(...).`,          node.callee        )      }      propsRuntimeDefaults = node.arguments[1]      if (        !propsRuntimeDefaults ||        propsRuntimeDefaults.type !== 'ObjectExpression'      ) {        error(          `The 2nd argument of ${WITH_DEFAULTS} must be an object literal.`,          propsRuntimeDefaults || node        )      }    } else {      error(        `${WITH_DEFAULTS}' first argument must be a ${DEFINE_PROPS} call.`,        node.arguments[0] || node      )    }    return true  }  function processDefineEmits(node, declId) {    if (!isCallOf(node, DEFINE_EMITS)) {      return false    }    if (hasDefineEmitCall) {      error(`duplicate ${DEFINE_EMITS}() call`, node)    }    hasDefineEmitCall = true    emitsRuntimeDecl = node.arguments[0]    if (node.typeParameters) {      if (emitsRuntimeDecl) {        error(          `${DEFINE_EMITS}() cannot accept both type and non-type arguments ` +            `at the same time. Use one or the other.`,          node        )      }      emitsTypeDeclRaw = node.typeParameters.params[0]      emitsTypeDecl = resolveQualifiedType(        emitsTypeDeclRaw,        (node) =>          node.type === 'TSFunctionType' || node.type === 'TSTypeLiteral'      )      if (!emitsTypeDecl) {        error(          `type argument passed to ${DEFINE_EMITS}() must be a function type, ` +            `a literal type with call signatures, or a reference to the above types.`,          emitsTypeDeclRaw        )      }    }    if (declId) {      emitIdentifier = scriptSetup.content.slice(declId.start, declId.end)    }    return true  }  function resolveQualifiedType(node, qualifier) {    if (qualifier(node)) {      return node    }    if (      node.type === 'TSTypeReference' &&      node.typeName.type === 'Identifier'    ) {      const refName = node.typeName.name      const isQualifiedType = (node) => {        if (          node.type === 'TSInterfaceDeclaration' &&          node.id.name === refName        ) {          return node.body        } else if (          node.type === 'TSTypeAliasDeclaration' &&          node.id.name === refName &&          qualifier(node.typeAnnotation)        ) {          return node.typeAnnotation        } else if (node.type === 'ExportNamedDeclaration' && node.declaration) {          return isQualifiedType(node.declaration)        }      }      const body = scriptAst        ? [...scriptSetupAst.body, ...scriptAst.body]        : scriptSetupAst.body      for (const node of body) {        const qualified = isQualifiedType(node)        if (qualified) {          return qualified        }      }    }  }  function processDefineExpose(node) {    if (isCallOf(node, DEFINE_EXPOSE)) {      if (hasDefineExposeCall) {        error(`duplicate ${DEFINE_EXPOSE}() call`, node)      }      hasDefineExposeCall = true      return true    }    return false  }  /**   * await foo()   * -->   * ;(   *   ([__temp,__restore] = withAsyncContext(() => foo())),   *   await __temp,   *   __restore()   * )   *   * const a = await foo()   * -->   * const a = (   *   ([__temp, __restore] = withAsyncContext(() => foo())),   *   __temp = await __temp,   *   __restore(),   *   __temp   * )   */  function processAwait(node, needSemi, isStatement) {    const argumentStart =      node.argument.extra && node.argument.extra.parenthesized        ? node.argument.extra.parenStart        : node.argument.start    const argumentStr = source.slice(      argumentStart + startOffset,      node.argument.end + startOffset    )    const containsNestedAwait = /\bawait\b/.test(argumentStr)    s.overwrite(      node.start + startOffset,      argumentStart + startOffset,      `${needSemi ? `;` : ``}(\n  ([__temp,__restore] = ${helper(        `withAsyncContext`      )}(${containsNestedAwait ? `async ` : ``}() => `    )    s.appendLeft(      node.end + startOffset,      `)),\n  ${isStatement ? `` : `__temp = `}await __temp,\n  __restore()${        isStatement ? `` : `,\n  __temp`      }\n)`    )  }  /**   * check defaults. If the default object is an object literal with only   * static properties, we can directly generate more optimized default   * declarations. Otherwise we will have to fallback to runtime merging.   */  function hasStaticWithDefaults() {    return (      propsRuntimeDefaults &&      propsRuntimeDefaults.type === 'ObjectExpression' &&      propsRuntimeDefaults.properties.every(        (node) =>          (node.type === 'ObjectProperty' && !node.computed) ||          node.type === 'ObjectMethod'      )    )  }  function genRuntimeProps(props) {    const keys = Object.keys(props)    if (!keys.length) {      return ``    }    const hasStaticDefaults = hasStaticWithDefaults()    const scriptSetupSource = scriptSetup.content    let propsDecls = `{       ${keys         .map((key) => {           let defaultString           const destructured = genDestructuredDefaultValue(key)           if (destructured) {             defaultString = `default: ${destructured}`           } else if (hasStaticDefaults) {             const prop = propsRuntimeDefaults.properties.find(               (node) => node.key.name === key             )             if (prop) {               if (prop.type === 'ObjectProperty') {                 // prop has corresponding static default value                 defaultString = `default: ${scriptSetupSource.slice(                   prop.value.start,                   prop.value.end                 )}`               } else {                 defaultString = `default() ${scriptSetupSource.slice(                   prop.body.start,                   prop.body.end                 )}`               }             }           }           const { type, required } = props[key]           if (!isProd) {             return `${key}: { type: ${toRuntimeTypeString(               type             )}, required: ${required}${               defaultString ? `, ${defaultString}` : ``             } }`           } else if (             type.some(               (el) => el === 'Boolean' || (defaultString && el === 'Function')             )           ) {             // #4783 production: if boolean or defaultString and function exists, should keep the type.             return `${key}: { type: ${toRuntimeTypeString(type)}${               defaultString ? `, ${defaultString}` : ``             } }`           } else {             // production: checks are useless             return `${key}: ${defaultString ? `{ ${defaultString} }` : 'null'}`           }         })         .join(',\n    ')}\n  }`    if (propsRuntimeDefaults && !hasStaticDefaults) {      propsDecls = `${helper('mergeDefaults')}(${propsDecls}, ${source.slice(        propsRuntimeDefaults.start + startOffset,        propsRuntimeDefaults.end + startOffset      )})`    }    return `\n  props: ${propsDecls},`  }  function genDestructuredDefaultValue(key) {    const destructured = propsDestructuredBindings[key]    if (destructured && destructured.default) {      const value = scriptSetup.content.slice(        destructured.default.start,        destructured.default.end      )      const isLiteral = destructured.default.type.endsWith('Literal')      return isLiteral ? value : `() => ${value}`    }  }  function genSetupPropsType(node) {    const scriptSetupSource = scriptSetup.content    if (hasStaticWithDefaults()) {      // if withDefaults() is used, we need to remove the optional flags      // on props that have default values      let res = `{ `      const members = node.type === 'TSTypeLiteral' ? node.members : node.body      for (const m of members) {        if (          (m.type === 'TSPropertySignature' ||            m.type === 'TSMethodSignature') &&          m.typeAnnotation &&          m.key.type === 'Identifier'        ) {          if (            propsRuntimeDefaults.properties.some(              (p) => p.key.name === m.key.name            )          ) {            res +=              m.key.name +              (m.type === 'TSMethodSignature' ? '()' : '') +              scriptSetupSource.slice(                m.typeAnnotation.start,                m.typeAnnotation.end              ) +              ', '          } else {            res += scriptSetupSource.slice(m.start, m.typeAnnotation.end) + `, `          }        }      }      return (res.length ? res.slice(0, -2) : res) + ` }`    } else {      return scriptSetupSource.slice(node.start, node.end)    }  }  function processNormalScript() {    let scriptAst    if (script) {      scriptAst = parse(        script.content,        {          plugins,          sourceType: 'module'        },        scriptStartOffset      )      for (const node of scriptAst.body) {        if (node.type === 'ImportDeclaration') {          // record imports for dedupe          for (const specifier of node.specifiers) {            const imported =              specifier.type === 'ImportSpecifier' &&              specifier.imported.type === 'Identifier' &&              specifier.imported.name            registerUserImport(              node.source.value,              specifier.local.name,              imported,              node.importKind === 'type' ||                (specifier.type === 'ImportSpecifier' &&                  specifier.importKind === 'type'),              false            )          }        } else if (node.type === 'ExportDefaultDeclaration') {          // export default          defaultExport = node          // export default { ... } --> const __default__ = { ... }          const start = node.start + scriptStartOffset          const end = node.declaration.start + scriptStartOffset          s.overwrite(start, end, `const ${DEFAULT_VAR} = `)        } else if (node.type === 'ExportNamedDeclaration') {          const defaultSpecifier = node.specifiers.find(            (s) =>              s.exported.type === 'Identifier' && s.exported.name === 'default'          )          if (defaultSpecifier) {            defaultExport = node            // 1. remove specifier            if (node.specifiers.length > 1) {              s.remove(                defaultSpecifier.start + scriptStartOffset,                defaultSpecifier.end + scriptStartOffset              )            } else {              s.remove(                node.start + scriptStartOffset,                node.end + scriptStartOffset              )            }            if (node.source) {              // export { x as default } from './x'              // rewrite to `import { x as __default__ } from './x'` and              // add to top              s.prepend(                `import { ${defaultSpecifier.local.name} as ${DEFAULT_VAR} } from '${node.source.value}'\n`              )            } else {              // export { x as default }              // rewrite to `const __default__ = x` and move to end              s.appendLeft(                scriptEndOffset,                `\nconst ${DEFAULT_VAR} = ${defaultSpecifier.local.name}\n`              )            }          }          if (node.declaration) {            walkDeclaration(node.declaration, scriptBindings, userImportAlias)          }        } else if (          (node.type === 'VariableDeclaration' ||            node.type === 'FunctionDeclaration' ||            node.type === 'ClassDeclaration' ||            node.type === 'TSEnumDeclaration') &&          !node.declare        ) {          walkDeclaration(node, scriptBindings, userImportAlias)        }      }      // apply reactivity transform      if (enableReactivityTransform && RT.shouldTransform(script.content)) {        const { rootRefs, importedHelpers } = transformAST(          scriptAst,          s,          scriptStartOffset        )        refBindings = rootRefs        for (const h of importedHelpers) {          helperImports.add(h)        }      }      // <script> after <script setup>      // we need to move the block up so that `const __default__` is      // declared before being used in the actual component definition      if (scriptStartOffset > startOffset) {        s.move(scriptStartOffset, scriptEndOffset, 0)      }    }    return scriptAst  }  function processSetupScript() {    const scriptSetupAst = babelParser.parse(      scriptSetup.content,      {        plugins: [          ...plugins,          ...babelPlugins,          // allow top level await but only inside <script setup>          'topLevelAwait'        ],        sourceType: 'module'      },      startOffset    )    for (const node of scriptSetupAst.body) {      const start = node.start + startOffset      let end = node.end + startOffset      // locate comment      if (node.trailingComments && node.trailingComments.length > 0) {        const lastCommentNode =          node.trailingComments[node.trailingComments.length - 1]        end = lastCommentNode.end + startOffset      }      // locate the end of whitespace between this statement and the next      while (end <= source.length) {        if (!/\s/.test(source.charAt(end))) {          break        }        end++      }      // (Dropped) `ref: x` bindings      if (        node.type === 'LabeledStatement' &&        node.label.name === 'ref' &&        node.body.type === 'ExpressionStatement'      ) {        error(          `ref sugar using the label syntax was an experimental proposal and ` +            `has been dropped based on community feedback. Please check out ` +            `the new proposal at https://github.com/vuejs/rfcs/discussions/369`,          node        )      }      if (node.type === 'ImportDeclaration') {        // import declarations are moved to top        s.move(start, end, 0)        // dedupe imports        let removed = 0        const removeSpecifier = (i) => {          const removeLeft = i > removed          removed++          const current = node.specifiers[i]          const next = node.specifiers[i + 1]          s.remove(            removeLeft              ? node.specifiers[i - 1].end + startOffset              : current.start + startOffset,            next && !removeLeft              ? next.start + startOffset              : current.end + startOffset          )        }        for (let i = 0; i < node.specifiers.length; i++) {          const specifier = node.specifiers[i]          const local = specifier.local.name          const imported =            specifier.type === 'ImportSpecifier' &&            specifier.imported.type === 'Identifier' &&            specifier.imported.name          const source = node.source.value          const existing = userImports[local]          if (            source === 'vue' &&            (imported === DEFINE_PROPS ||              imported === DEFINE_EMITS ||              imported === DEFINE_EXPOSE)          ) {            removeSpecifier(i)          } else if (existing) {            if (existing.source === source && existing.imported === imported) {              // already imported in <script setup>, dedupe              removeSpecifier(i)            } else {              error(`different imports aliased to same local name.`, specifier)            }          } else {            registerUserImport(              source,              local,              imported,              node.importKind === 'type' ||                (specifier.type === 'ImportSpecifier' &&                  specifier.importKind === 'type'),              true            )          }        }        if (node.specifiers.length && removed === node.specifiers.length) {          s.remove(node.start + startOffset, node.end + startOffset)        }      }      if (node.type === 'ExpressionStatement') {        // process `defineProps` and `defineEmit(s)` calls        if (          processDefineProps(node.expression) ||          processDefineEmits(node.expression) ||          processWithDefaults(node.expression)        ) {          s.remove(node.start + startOffset, node.end + startOffset)        } else if (processDefineExpose(node.expression)) {          // defineExpose({}) -> expose({})          const callee = node.expression.callee          s.overwrite(            callee.start + startOffset,            callee.end + startOffset,            'expose'          )        }      }      if (node.type === 'VariableDeclaration' && !node.declare) {        const total = node.declarations.length        let left = total        for (let i = 0; i < total; i++) {          const decl = node.declarations[i]          if (decl.init) {            // defineProps / defineEmits            const isDefineProps =              processDefineProps(decl.init, decl.id) ||              processWithDefaults(decl.init, decl.id)            const isDefineEmits = processDefineEmits(decl.init, decl.id)            if (isDefineProps || isDefineEmits) {              if (left === 1) {                s.remove(node.start + startOffset, node.end + startOffset)              } else {                let start = decl.start + startOffset                let end = decl.end + startOffset                if (i < total - 1) {                  // not the last one, locate the start of the next                  end = node.declarations[i + 1].start + startOffset                } else {                  // last one, locate the end of the prev                  start = node.declarations[i - 1].end + startOffset                }                s.remove(start, end)                left--              }            }          }        }      }      // walk declarations to record declared bindings      if (        (node.type === 'VariableDeclaration' ||          node.type === 'FunctionDeclaration' ||          node.type === 'ClassDeclaration') &&        !node.declare      ) {        walkDeclaration(node, setupBindings, userImportAlias)      }      // walk statements & named exports / variable declarations for top level      // await      if (        (node.type === 'VariableDeclaration' && !node.declare) ||        node.type.endsWith('Statement')      ) {        walk(node, {          enter(child, parent) {            if (isFunctionType(child)) {              this.skip()            }            if (child.type === 'AwaitExpression') {              hasAwait = true              const needsSemi = scriptSetupAst.body.some((n) => {                return (                  n.type === 'ExpressionStatement' && n.start === child.start                )              })              processAwait(                child,                needsSemi,                parent.type === 'ExpressionStatement'              )            }          }        })      }      if (        (node.type === 'ExportNamedDeclaration' &&          node.exportKind !== 'type') ||        node.type === 'ExportAllDeclaration' ||        node.type === 'ExportDefaultDeclaration'      ) {        error(          `<script setup> cannot contain ES module exports. ` +            `If you are using a previous version of <script setup>, please ` +            `consult the updated RFC at https://github.com/vuejs/rfcs/pull/227.`,          node        )      }      if (isTS) {        // runtime enum        if (node.type === 'TSEnumDeclaration') {          registerBinding(setupBindings, node.id, BindingTypes.SETUP_CONST)        }        // move all Type declarations to outer scope        if (          node.type.startsWith('TS') ||          (node.type === 'ExportNamedDeclaration' &&            node.exportKind === 'type') ||          (node.type === 'VariableDeclaration' && node.declare)        ) {          recordType(node, declaredTypes)          s.move(start, end, 0)        }      }    }    return scriptSetupAst  }  function applyReactivityTransform() {    if (      (enableReactivityTransform &&        // normal <script> had ref bindings that maybe used in <script setup>        (refBindings || RT.shouldTransform(scriptSetup.content))) ||      propsDestructureDecl    ) {      const { rootRefs, importedHelpers } = transformAST(        scriptSetupAst,        s,        startOffset,        refBindings,        propsDestructuredBindings      )      refBindings = refBindings ? [...refBindings, ...rootRefs] : rootRefs      for (const h of importedHelpers) {        helperImports.add(h)      }    }  }  function extractRuntimePropsEmits() {    if (propsTypeDecl) {      extractRuntimeProps(        propsTypeDecl,        typeDeclaredProps,        declaredTypes,        isProd      )    }    if (emitsTypeDecl) {      extractRuntimeEmits(emitsTypeDecl, typeDeclaredEmits)    }  }  function checkUseOptions() {    checkInvalidScopeReference(propsRuntimeDecl, DEFINE_PROPS)    checkInvalidScopeReference(propsRuntimeDefaults, DEFINE_PROPS)    checkInvalidScopeReference(propsDestructureDecl, DEFINE_PROPS)    checkInvalidScopeReference(emitsRuntimeDecl, DEFINE_PROPS)  }  function removeNonScriptContent() {    if (script) {      if (startOffset < scriptStartOffset) {        // <script setup> before <script>        s.remove(0, startOffset)        s.remove(endOffset, scriptStartOffset)        s.remove(scriptEndOffset, source.length)      } else {        // <script> before <script setup>        s.remove(0, scriptStartOffset)        s.remove(scriptEndOffset, startOffset)        s.remove(endOffset, source.length)      }    } else {      // only <script setup>      s.remove(0, startOffset)      s.remove(endOffset, source.length)    }  }  function analyzeBindingMetadata() {    if (scriptAst) {      Object.assign(bindingMetadata, analyzeScriptBindings(scriptAst.body))    }    if (propsRuntimeDecl) {      for (const key of getObjectOrArrayExpressionKeys(propsRuntimeDecl)) {        bindingMetadata[key] = BindingTypes.PROPS      }    }    for (const key in typeDeclaredProps) {      bindingMetadata[key] = BindingTypes.PROPS    }    // props aliases    if (propsDestructureDecl) {      if (propsDestructureRestId) {        bindingMetadata[propsDestructureRestId] = BindingTypes.SETUP_CONST      }      for (const key in propsDestructuredBindings) {        const { local } = propsDestructuredBindings[key]        if (local !== key) {          bindingMetadata[local] = BindingTypes.PROPS_ALIASED          ;(bindingMetadata.__propsAliases ||            (bindingMetadata.__propsAliases = {}))[local] = key        }      }    }    for (const [key, { isType, imported, source }] of Object.entries(      userImports    )) {      if (isType) continue      bindingMetadata[key] =        (imported === 'default' && source.endsWith('.vue')) || source === 'vue'          ? BindingTypes.SETUP_CONST          : BindingTypes.SETUP_MAYBE_REF    }    for (const key in scriptBindings) {      bindingMetadata[key] = scriptBindings[key]    }    for (const key in setupBindings) {      bindingMetadata[key] = setupBindings[key]    }    // known ref bindings    if (refBindings) {      for (const key of refBindings) {        bindingMetadata[key] = BindingTypes.SETUP_REF      }    }  }  function injectUseCssVarsCalls() {    if (cssVars.length) {      helperImports.add(CSS_VARS_HELPER)      helperImports.add('unref')      s.prependRight(        startOffset,        `\n${genCssVarsCode(cssVars, bindingMetadata, scopeId, isProd)}\n`      )    }  }  function finalizeSetupArgumentSignature() {    if (propsTypeDecl) {      // mark as any and only cast on assignment      // since the user defined complex types may be incompatible with the      // inferred type from generated runtime declarations      args += `: any`    }    // inject user assignment of props    // we use a default __props so that template expressions referencing props    // can use it directly    if (propsIdentifier) {      s.prependLeft(        startOffset,        `\nconst ${propsIdentifier} = __props${          propsTypeDecl ? ` as ${genSetupPropsType(propsTypeDecl)}` : ``        }\n`      )    }    if (propsDestructureRestId) {      s.prependLeft(        startOffset,        `\nconst ${propsDestructureRestId} = ${helper(          `createPropsRestProxy`        )}(__props, ${JSON.stringify(          Object.keys(propsDestructuredBindings)        )})\n`      )    }    // inject temp variables for async context preservation    if (hasAwait) {      const any = isTS ? `: any` : ``      s.prependLeft(startOffset, `\nlet __temp${any}, __restore${any}\n`)    }    const destructureElements =      hasDefineExposeCall || !options.inlineTemplate ? [`expose`] : []    if (emitIdentifier) {      destructureElements.push(        emitIdentifier === `emit` ? `emit` : `emit: ${emitIdentifier}`      )    }    if (destructureElements.length) {      args += `, { ${destructureElements.join(', ')} }`      if (emitsTypeDecl) {        args += `: { emit: (${scriptSetup.content.slice(          emitsTypeDecl.start,          emitsTypeDecl.end        )}), expose: any, slots: any, attrs: any }`      }    }  }  function finalizeSetupArgumentSignature() {    if (propsTypeDecl) {      // mark as any and only cast on assignment      // since the user defined complex types may be incompatible with the      // inferred type from generated runtime declarations      args += `: any`    }    // inject user assignment of props    // we use a default __props so that template expressions referencing props    // can use it directly    if (propsIdentifier) {      s.prependLeft(        startOffset,        `\nconst ${propsIdentifier} = __props${          propsTypeDecl ? ` as ${genSetupPropsType(propsTypeDecl)}` : ``        }\n`      )    }    if (propsDestructureRestId) {      s.prependLeft(        startOffset,        `\nconst ${propsDestructureRestId} = ${helper(          `createPropsRestProxy`        )}(__props, ${JSON.stringify(          Object.keys(propsDestructuredBindings)        )})\n`      )    }    // inject temp variables for async context preservation    if (hasAwait) {      const any = isTS ? `: any` : ``      s.prependLeft(startOffset, `\nlet __temp${any}, __restore${any}\n`)    }    const destructureElements =      hasDefineExposeCall || !options.inlineTemplate ? [`expose`] : []    if (emitIdentifier) {      destructureElements.push(        emitIdentifier === `emit` ? `emit` : `emit: ${emitIdentifier}`      )    }    if (destructureElements.length) {      args += `, { ${destructureElements.join(', ')} }`      if (emitsTypeDecl) {        args += `: { emit: (${scriptSetup.content.slice(          emitsTypeDecl.start,          emitsTypeDecl.end        )}), expose: any, slots: any, attrs: any }`      }    }  }  function generateReturnStatement() {    if (options.inlineTemplate) {      if (sfc.template && !sfc.template.src) {        if (options.templateOptions && options.templateOptions.ssr) {          hasInlinedSsrRenderFn = true        }        // inline render function mode - we are going to compile the template and        // inline it right here        const { code, ast, preamble, tips, errors } = compileTemplate({          filename,          source: sfc.template.content,          inMap: sfc.template.map,          ...options.templateOptions,          id: scopeId,          scoped: sfc.styles.some((s) => s.scoped),          isProd: options.isProd,          ssrCssVarscssVars,          compilerOptions: {            ...(options.templateOptions &&              options.templateOptions.compilerOptions),            inline: true,            isTS,            bindingMetadata          }        })        const err = errors[0]        if (typeof err === 'string') {          throw new Error(err)        } else if (err) {          if (err.loc) {            err.message +=              `\n\n` +              sfc.filename +              '\n' +              generateCodeFrame(                source,                err.loc.start.offset,                err.loc.end.offset              ) +              `\n`          }          throw err        }        if (preamble) {          s.prepend(preamble)        }        // avoid duplicated unref import        // as this may get injected by the render function preamble OR the        // css vars codegen        if (ast && ast.helpers.includes(UNREF)) {          helperImports.delete('unref')        }        returned = code      } else {        returned = `() => {}`      }    } else {      // return bindings from script and script setup      const allBindings = {        ...scriptBindings,        ...setupBindings      }      for (const key in userImports) {        if (!userImports[key].isType && userImports[key].isUsedInTemplate) {          allBindings[key] = true        }      }      returned = `{ ${Object.keys(allBindings).join(', ')} }`    }    if (!options.inlineTemplate) {      // in non-inline mode, the `__isScriptSetup: true` flag is used by      // componentPublicInstance proxy to allow properties that start with $ or _      s.appendRight(        endOffset,        `\nconst __returned__ = ${returned}\n` +          `Object.defineProperty(__returned__, '__isScriptSetup', { enumerable: false, value: true })\n` +          `return __returned__` +          `\n}\n\n`      )    } else {      s.appendRight(endOffset, `\nreturn ${returned}\n}\n\n`)    }  }  function finalizeDefaultExport() {    let runtimeOptions = ``    if (hasInlinedSsrRenderFn) {      runtimeOptions += `\n  __ssrInlineRender: true,`    }    if (propsRuntimeDecl) {      let declCode = scriptSetup.content        .slice(propsRuntimeDecl.start, propsRuntimeDecl.end)        .trim()      if (propsDestructureDecl) {        const defaults = []        for (const key in propsDestructuredBindings) {          const d = genDestructuredDefaultValue(key)          if (d) defaults.push(`${key}: ${d}`)        }        if (defaults.length) {          declCode = `${helper(            `mergeDefaults`          )}(${declCode}, {\n  ${defaults.join(',\n  ')}\n})`        }      }      runtimeOptions += `\n  props: ${declCode},`    } else if (propsTypeDecl) {      runtimeOptions += genRuntimeProps(typeDeclaredProps)    }    if (emitsRuntimeDecl) {      runtimeOptions += `\n  emits: ${scriptSetup.content        .slice(emitsRuntimeDecl.start, emitsRuntimeDecl.end)        .trim()},`    } else if (emitsTypeDecl) {      runtimeOptions += genRuntimeEmits(typeDeclaredEmits)    }    // <script setup> components are closed by default. If the user did not    // explicitly call `defineExpose`, call expose() with no args.    const exposeCall =      hasDefineExposeCall || options.inlineTemplate ? `` : `  expose();\n`    // wrap setup code with function.    if (isTS) {      // for TS, make sure the exported type is still valid type with      // correct props information      // we have to use object spread for types to be merged properly      // user's TS setting should compile it down to proper targets      // export default defineComponent({ ...__default__, ... })      const def = defaultExport ? `\n  ...${DEFAULT_VAR},` : ``      s.prependLeft(        startOffset,        `\nexport default /*#__PURE__*/${helper(          `defineComponent`        )}({${def}${runtimeOptions}\n  ${          hasAwait ? `async ` : ``        }setup(${args}) {\n${exposeCall}`      )      s.appendRight(endOffset, `})`)    } else {      if (defaultExport) {        // without TS, can't rely on rest spread, so we use Object.assign        // export default Object.assign(__default__, { ... })        s.prependLeft(          startOffset,          `\nexport default /*#__PURE__*/Object.assign(${DEFAULT_VAR}, {${runtimeOptions}\n  ` +            `${hasAwait ? `async ` : ``}setup(${args}) {\n${exposeCall}`        )        s.appendRight(endOffset, `})`)      } else {        s.prependLeft(          startOffset,          `\nexport default {${runtimeOptions}\n  ` +            `${hasAwait ? `async ` : ``}setup(${args}) {\n${exposeCall}`        )        s.appendRight(endOffset, `}`)      }    }  }  function finalizeVueHelperImports() {    if (helperImports.size > 0) {      s.prepend(        `import { ${[...helperImports]          .map((h) => `${h} as _${h}`)          .join(', ')} } from 'vue'\n`      )    }  }  // 1. process normal <script> first if it exists  let scriptAst = processNormalScript()  // 2. parse <script setup> and  walk over top level statements  const scriptSetupAst = processSetupScript()  // 3. Apply reactivity transform  applyReactivityTransform()  // 4. extract runtime props/emits code from setup context type  extractRuntimePropsEmits()  // 5. check useOptions args to make sure it doesn't reference setup scope  // variables  checkUseOptions()  // 6. remove non-script content  removeNonScriptContent()  // 7. analyze binding metadata  analyzeBindingMetadata()  // 8. inject `useCssVars` calls  injectUseCssVarsCalls()  // 9. finalize setup() argument signature  let args = `__props`  finalizeSetupArgumentSignature()  // 10. generate return statement  let returned  generateReturnStatement()  // 11. finalize default export  let runtimeOptions = ''  finalizeDefaultExport()  // 12. finalize Vue helper imports  finalizeVueHelperImports()  s.trim()  return {    ...scriptSetup,    bindings: bindingMetadata,    imports: userImports,    content: s.toString(),    map: genSourceMap      ? s.generateMap({          source: filename,          hires: true,          includeContent: true        })      : undefined,    scriptAst: scriptAst?.body,    scriptSetupAst: scriptSetupAst?.body  }}  const mockId = 'xxxxxxxx'function compileSFCScript(src, options) {  const { descriptor } = babelParser.parse(src)  return compileScript(descriptor, {    ...options,    id: mockId  })}const result = compileSFCScript(`      <script setup>      import { x } from './x'      let a = 1      const b = 2      function c() {}      class d {}      </script>      <script>      import { xx } from './x'      let aa = 1      const bb = 2      function cc() {}      class dd {}      </script>      `)console.log(result)