<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-02-22 Tue 11:07 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>emacs org-special-src-blocks</title>
<meta name="author" content="Zhicheng Lee" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
</style>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>

        <style>
        /* From: https://endlessparentheses.com/public/css/endless.css */
        /* See also: https://meta.superuser.com/questions/4788/css-for-the-new-kbd-style */
        kbd
        {
          -moz-border-radius: 6px;
          -moz-box-shadow: 0 1px 0 rgba(0,0,0,0.2),0 0 0 2px #fff inset;
          -webkit-border-radius: 6px;
          -webkit-box-shadow: 0 1px 0 rgba(0,0,0,0.2),0 0 0 2px #fff inset;
          background-color: #f7f7f7;
          border: 1px solid #ccc;
          border-radius: 6px;
          box-shadow: 0 1px 0 rgba(0,0,0,0.2),0 0 0 2px #fff inset;
          color: #333;
          display: inline-block;
          font-family: 'Droid Sans Mono', monospace;
          font-size: 80%;
          font-weight: normal;
          line-height: inherit;
          margin: 0 .1em;
          padding: .08em .4em;
          text-shadow: 0 1px 0 #fff;
          word-spacing: -4px;
        
          box-shadow: 2px 2px 2px #222; /* MA: An extra I've added. */
        }
        </style>
        <link rel="stylesheet" type="text/css" href="https://alhassy.github.io/org-special-block-extras/tooltipster/dist/css/tooltipster.bundle.min.css"/>
        
        <link rel="stylesheet" type="text/css" href="https://alhassy.github.io/org-special-block-extras/tooltipster/dist/css/plugins/tooltipster/sideTip/themes/tooltipster-sideTip-punk.min.css" />
        
        <script type="text/javascript">
            if (typeof jQuery == 'undefined') {
                document.write(unescape('%3Cscript src="https://code.jquery.com/jquery-1.10.0.min.js"%3E%3C/script%3E'));
            }
        </script>
        
         <script type="text/javascript"            src="https://alhassy.github.io/org-special-block-extras/tooltipster/dist/js/tooltipster.bundle.min.js"></script>
        
          <script>
                 $(document).ready(function() {
                     $('.tooltip').tooltipster({
                         theme: 'tooltipster-punk',
                         contentAsHTML: true,
                         animation: 'grow',
                         delay: [100,500],
                         // trigger: 'click'
                         trigger: 'custom',
                         triggerOpen: {
                             mouseenter: true
                         },
                         triggerClose: {
                             originClick: true,
                             scroll: true
                         }
         });
                 });
             </script>
        
        <style>
           abbr {color: red;}
        
           .tooltip { border-bottom: 1px dotted #000;
                      color:red;
                      text-decoration: none;}
        </style>
</head>
<body>
<div id="content" class="content">
<h1 class="title">emacs org-special-src-blocks</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org523d563">1. Minimal working example</a></li>
<li><a href="#org60b7244">2. å„ç§é“¾æ¥</a></li>
<li><a href="#orgd19b976">3. link here head</a></li>
</ul>
</div>
</div>
<p>
<a href="/"><img src="https://img.shields.io/badge/GCCLL-Homepage-green?logo=gnu-emacs"></a>
</p>

<p>
Examples: æˆ– <a href="https://alhassy.github.io/org-special-block-extras/">org-special-block-extras</a>
</p>

<div id="outline-container-org523d563" class="outline-2">
<h2 id="org523d563"><span class="section-number-2">1.</span> Minimal working example</h2>
<div class="outline-text-2" id="text-1">
<div style="column-rule-style: none;column-count: 2;">
<p>
<span style="color:orange;">Are you excited to learn some Lisp?</span> <span style="color:blue;">Yes!</span>
</p>

<p>
Pop-quiz: How does <abbr class="tooltip" title="Call FUNCTION with our remaining args, using our last arg as list of args.<br>Then return the value FUNCTION returns.<br>With a single argument, call the argumentâ€™s first element using the<br>other elements as args.<br>Thus, (apply '+ 1 2 '(3 4)) returns 10.<br><br>(fn FUNCTION &rest ARGUMENTS)">apply</abbr> work?
</p>

</div>

<details class="code-details"
                 style ="padding: 1em;
                          background-color: #e5f5e5;
                          /* background-color: pink; */
                          border-radius: 15px;
                          color: hsl(157 75%);
                          font-size: 0.9em;
                          box-shadow: 0.05em 0.1em 5px 0.01em  #00000057;">
                  <summary>
                    <strong>
                      <font face="Courier" size="3" color="green">
                         Answer
                      </font>
                    </strong>
                  </summary>
<p>
<a class="anchor" aria-hidden="true" id="solution" href="#solution"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16
   16" width="16" height="16"><path fill-rule="evenodd"
   d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69
   3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10
   5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0
   2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5
   0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55
   13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>
Syntactically, <code>(apply f '(x0 ... xN)) = (f x0 ... xN)</code>.
</p>

<p>
<p style="color: black;"><span style="border-width:1px;border-style:solid;padding:5px"><strong>[Musa:</strong></span> Ain&rsquo;t that cool?  <span style="border-width:1px;border-style:solid;padding:5px"><strong>]</strong></span></p>
</p>

<style> #g215 {color: aqua; background-color:aqua;}
       #g215:hover {color: black; background-color:white;} </style>
<p>
That is, <span style="color:magenta;">we can <span id="g215"> apply </span> a function to a list of arguments!</span>
</p>





</details>

<br>
<div style="padding: 1em; background-color: #CCFFCC;border-radius: 15px; font-size: 0.9em; box-shadow: 0.05em 0.1em 5px 0.01em #00000057;"><h3></h3>
<p>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M0 2a1 1 0 011-1h14a1 1 0 011 1v9a1 1 0 01-1 1H7l-4 4v-4H1a1 1 0 01-1-1V2zm1 0h14v9H6.5L4 13.5V11H1V2zm6 6h2v2H7V8zm0-5h2v4H7V3z"></path></svg> Note that <abbr class="tooltip" style="border: none; text-decoration: none;" title="C-x C-e âˆ· eros-eval-last-sexp<br>Wrapper for â€˜eval-last-sexpâ€™ that overlays results.<br><br>(fn EVAL-LAST-SEXP-ARG-INTERNAL)"><kbd style="border-color: red">C-x C-e</kbd></abbr> evaluates a Lisp form!
</p>

</div>

<p>
<abbr class="tooltip" title="This property generalises injectivity, univalence, and equivalence...<br><br>Recall,<br>- Univalent: Every source value <em>x</em> is associated <strong>at most one</strong> target value <em>y</em>.<br>&emsp;&emsp;+ I.e., if <em>x</em> goes to <em>y</em> and <em>yâ€²</em> then <em>y = yâ€²</em>.<br>&emsp;&emsp;+ I.e., <em>âˆ€ x, yâ€², y â€¢&#x2000;&emsp;x ã€”Rã€• y&emsp;ã€”RË˜ã€• x ã€”Rã€• yâ€² &#8195;â‡’&#8195; y ã€”Idã€• yâ€²</em><br>- Injective: Every source value <em>y</em> is associated <strong>at most</strong> one source value <em>x</em>.<br>&emsp;&emsp;+ I.e., if <em>y</em> comes from <em>x</em> and <em>xâ€²</em> then <em>x = xâ€²</em>.<br>&emsp;&emsp;+ I.e., <em>âˆ€ x, xâ€², y â€¢&#x2000;&emsp;x ã€”Rã€• y&emsp;ã€”RË˜ã€• xâ€² ã€”Rã€• y &#8195;â‡’&#8195; x ã€”Idã€• xâ€²</em><br>- Equivalence: Any given equivalence classes are either identical or disjoint.<br>&emsp;&emsp;&emsp;# + I.e., <em>âˆ€ x, y â€¢&#x2000;&emsp;x ã€”Rã€• y&emsp;ã€”RË˜ã€• x ã€”Rã€• yâ€² &#8195;â‡’&#8195; x ã€”Rã€• yâ€²</em><br>&emsp;&emsp;+ Moreover, it is a <em>homogenous</em> relation.<br><br> Now, a <em>possibly heterogenous</em> relation <em>R</em> is <em>difunctional</em> exactly when<br> <em>âˆ€ x, xâ€², yâ€², y â€¢&#x2000;&emsp;x ã€”Rã€• y&emsp;ã€”RË˜ã€• xâ€² ã€”Rã€• yâ€² &#8195;â‡’&#8195; x ã€”Rã€• yâ€²</em>.<br> That is, <EM>R â¨¾ R Ë˜ â¨¾ R âŠ† R</EM>; in-fact we have equality <EM>R â¨¾ R Ë˜ â¨¾ R = R</EM>.<br> Using SchroÌˆder, this amounts to <EM>R â¨¾ âˆ¼R Ë˜ â¨¾ R &#8195;âŠ†&#8195; âˆ¼R</EM>.<br><br> Clearly, converse preserves difunctionality.<br><br> For difunctional <em>R</em>,<br> 1. <em>R â¨¾ (Q âˆ© RË˜ â¨¾ S) = R â¨¾ Q âˆ© R â¨¾ RË˜ â¨¾ S</em><br> 2. <EM>R â¨¾ âˆ¼(R Ë˜ â¨¾ Q) &#8195;=&#8195; R â¨¾ âŠ¤ âˆ© âˆ¼(R â¨¾ RË˜ Q)</EM><br> 3. <em>âˆ¼(R â¨¾ R Ë˜ â¨¾ Q) &#8195;=&#8195; R â¨¾ âˆ¼(RË˜ â¨¾ Q) âˆª âˆ¼(R â¨¾ âŠ¤)</em><br> 4. <EM>R â¨¾ âˆ¼(R Ë˜ â¨¾ Q) &#8195;=&#8195; âˆ¼(R â¨¾ RË˜ Q)</EM>, if <em>R</em> is also total.<br><br>Where <em>â¨¾, âŠ¤, âŠ¥, Id, Ë˜, âˆ¼</em> are relation composition, the universal relation, the<br>empty relation, the identity relation, relation converse (transpose), and complement.<br><hr><br>The equivalence target-saturation of a univalent relation is difunctional; i.e.,<br>if <em>R</em> is univalent and Î is an equivalence, then <EM>R â¨¾ Î</EM> is difunctional.">Difunctional</abbr> <abbr class="tooltip" title="An <strong>iso</strong> is a bijective mapping, also known as a <strong>permutation.</strong><br><br>An isomorphism is a non-lossy protocol associating inputs to outputs.<br><hr><br>A relation <EM>R : V â†’ V</EM> can be visualised as a drawing: A dot for each element<br><em>x</em> of <EM>V</EM>, and a directed line <em>x âŸ¶ y</em> between two points exactly when <em>x ã€”Rã€•<br>y</em>. That is relations are <em>simple graphs</em>; one refers to the directed lines<br>as <em>edges</em> and the dots as <em>nodes</em>.<br><br>As a simple graph, an iso is a <em>bunch of circles</em>: Any number of cycles, such that<br>every node lies on exactly one.<br><hr><br>If relation <EM>R</EM> is finite, then<br><em>R â¨¾ R Ë˜ = Id &#x2000;â‰¡&#x2000;&emsp;(âˆƒ m â€¢ Ráµ = Id âˆ§ Ráµâ»Â¹ = R Ë˜)</em><br><br>Where <em>â¨¾, âŠ¤, âŠ¥, Id, Ë˜, âˆ¼</em> are relation composition, the universal relation, the<br>empty relation, the identity relation, relation converse (transpose), and complement.">Iso</abbr> <abbr class="tooltip" title="<strong>Bijective:</strong> <em>Every source value y is associated <strong>exactly one</strong> source value x.</em><br><br>&emsp; <EM>R</EM> is bijective<br>â‰¡&emsp;<EM>R</EM> is injective and surjective<br><hr><br>A relation <EM>R : V â†’ V</EM> can be visualised as a drawing: A dot for each element<br><em>x</em> of <EM>V</EM>, and a directed line <em>x âŸ¶ y</em> between two points exactly when <em>x ã€”Rã€•<br>y</em>. That is relations are <em>simple graphs</em>; one refers to the directed lines<br>as <em>edges</em> and the dots as <em>nodes</em>.<br><br>As a simple graph, bijectivity means: <em>Every node has exactly one outgoing edge</em>.">Bijective</abbr> <abbr class="tooltip" title="<strong>Injective:</strong> <em>Every source value y is associated <strong>at most</strong> one source value x.</em><br><hr><br>A relation <EM>R : V â†’ V</EM> can be visualised as a drawing: A dot for each element<br><em>x</em> of <EM>V</EM>, and a directed line <em>x âŸ¶ y</em> between two points exactly when <em>x ã€”Rã€•<br>y</em>. That is relations are <em>simple graphs</em>; one refers to the directed lines<br>as <em>edges</em> and the dots as <em>nodes</em>.<br><br>As a simple graph, injective means: <em>Every node has at most one incoming edge.</em><br><hr><br>&emsp; <EM>R</EM> is injective<br>â‰¡&emsp;<EM>RË˜</EM> is univalent<br>â‰¡&emsp;<em>R&emsp;â¨¾ R Ë˜ âŠ† Id</em><br>â‰¡&emsp;<em>âˆ¼ Id â¨¾ R &#8195;âŠ†&#8195; âˆ¼ R</em><br><br>Where <em>â¨¾, âŠ¤, âŠ¥, Id, Ë˜, âˆ¼</em> are relation composition, the universal relation, the<br>empty relation, the identity relation, relation converse (transpose), and complement.">Injective</abbr> <abbr class="tooltip" title="<strong>Surjective:</strong> <em>Every source value y is associated <strong>at least</strong> one source value x.</em><br><hr><br>A relation <EM>R : V â†’ V</EM> can be visualised as a drawing: A dot for each element<br><em>x</em> of <EM>V</EM>, and a directed line <em>x âŸ¶ y</em> between two points exactly when <em>x ã€”Rã€•<br>y</em>. That is relations are <em>simple graphs</em>; one refers to the directed lines<br>as <em>edges</em> and the dots as <em>nodes</em>.<br><br>As a simple graph, surjectivity means: <em>Every node has at least one incoming edge.</em><br><hr><br>&emsp; <EM>R</EM> is surjective<br>â‰¡&emsp;<EM>RË˜</EM> is total<br>â‰¡&emsp;<em>âŠ¤ â¨¾ R = âŠ¤</em><br>â‰¡&emsp;<em>Id âŠ† R Ë˜ â¨¾ R</em><br>â‰¡&emsp;<em>âˆ¼ R &#8195;âŠ†&#8195; âˆ¼ Id â¨¾ R</em><br>â‰¡&emsp;<em>âˆ€ S â€¢ R â¨¾ S = âŠ¥ â‰¡ S = âŠ¥</em><br><br>Where <em>â¨¾, âŠ¤, âŠ¥, Id, Ë˜, âˆ¼</em> are relation composition, the universal relation, the<br>empty relation, the identity relation, relation converse (transpose), and complement.">Surjective</abbr> <abbr class="tooltip" title="<strong>Map (totally defined function):</strong> <em>Every source value x is associated <strong>exactly one</strong><br>target value y.</em><br><hr><br>A relation <EM>R : V â†’ V</EM> can be visualised as a drawing: A dot for each element<br><em>x</em> of <EM>V</EM>, and a directed line <em>x âŸ¶ y</em> between two points exactly when <em>x ã€”Rã€•<br>y</em>. That is relations are <em>simple graphs</em>; one refers to the directed lines<br>as <em>edges</em> and the dots as <em>nodes</em>.<br><br>As a simple relation, being a mapping means: <em>Every node has exactly one outgoing edge.</em><br><hr><br>&emsp; <EM>F</EM> is a map<br>â‰¡&emsp;<EM>F</EM> is total and univalent<br>â‰¡&emsp;<em>F â¨¾ âˆ¼ Id &#8195;=&#8195; âˆ¼ F</em><br>â‰¡&emsp;<em>âˆ€ S â€¢ F â¨¾ âˆ¼ S &#8195;=&#8195; âˆ¼ (F â¨¾ S)</em><br><br>Where <em>â¨¾, âŠ¤, âŠ¥, Id, Ë˜, âˆ¼</em> are relation composition, the universal relation, the<br>empty relation, the identity relation, relation converse (transpose), and complement.<br><hr><br>The final rule says <em>the preimage of the complement is the complement of the<br>preimage</em>; or, using conventional direct image notation, <em>fâ»Â¹(âˆ¼ A) &#8195;=&#8195; âˆ¼<br>fâ»Â¹(A)</em>.<br><br>In conventional direct image notation, this amount to a Galois connection: <em>A âŠ†<br>fâ»Â¹(B) &#x2000;â‰¡&#x2000; f(A) âŠ† B</em>.<br><br>A mapping is so very close to being invertible since mappings <EM>F</EM> always<br>satisfy: <em>F Ë˜ â¨¾ F âŠ† Id</em> and <em>Id âŠ† F â¨¾ FË˜</em>.<br><br>Shunting rule:* If <EM>F</EM> is a map, then <em>R âŠ† S â¨¾ F Ë˜ &#x2000;â‰¡&#x2000; R â¨¾ F âŠ† S</em>.<br><br>More generally, given an equivalence Î, if relation <em>F</em> is total and Î-univalent<br>---i.e., <em>FË˜ â¨¾ F âŠ† Î</em>--- and if <em>S</em> is Î-target-saturated ---i.e., <em>S â¨¾ Î = S</em>---<br>then <em>R âŠ† S â¨¾ F Ë˜ &#x2000;â‰¡&#x2000; R â¨¾ F âŠ† S</em>.">Map</abbr> <abbr class="tooltip" title="<strong>Total:</strong> <em>Every source value x is associated <strong>at least one</strong> target value y.</em><br><hr><br>A relation <EM>R : V â†’ V</EM> can be visualised as a drawing: A dot for each element<br><em>x</em> of <EM>V</EM>, and a directed line <em>x âŸ¶ y</em> between two points exactly when <em>x ã€”Rã€•<br>y</em>. That is relations are <em>simple graphs</em>; one refers to the directed lines<br>as <em>edges</em> and the dots as <em>nodes</em>.<br><br>As a simple graph, totality means: <em>Every node has at least one outgoing edge</em>.<br><br>&emsp; <EM>R</EM> is total<br>â‰¡&emsp;<em>âˆ€ x â€¢ âˆƒ y â€¢ x ã€” R ã€• y</em><br>â‰¡&emsp;<em>âŠ¤ = R â¨¾ âŠ¤</em> (â€œdefined everywhereâ€)<br>â‰¡&emsp;<em>âŠ¥ = âˆ¼ (R â¨¾ âŠ¤)</em><br>â‰¡&emsp;<em>Id âŠ† R â¨¾ R Ë˜</em><br>â‰¡&emsp;<em>âˆ¼ R &#8195;âŠ†&#8195; R â¨¾ âˆ¼ Id</em><br>â‰¡&emsp;<em>âˆ€ S â€¢ âˆ¼ (R â¨¾ S) &#8195;âŠ†&#8195; R â¨¾ âˆ¼ S</em><br>â‰¡&emsp;<em>âˆ€ Q â€¢ Q â¨¾ R = âŠ¥ â‰¡ Q = âŠ¥</em><br><br>Where <em>â¨¾, âŠ¤, âŠ¥, Id, Ë˜, âˆ¼</em> are relation composition, the universal relation, the<br>empty relation, the identity relation, relation converse (transpose), and complement.<br><hr><br>The formula <em>âˆ¼ R &#8195;âŠ†&#8195; R â¨¾ âˆ¼ Id</em> reads â€œIf <em>x</em> is not <em>R</em>-related to y, then <em>x</em> is <em>R</em><br>related to some element different from <em>y</em>.â€&emsp;It continues to hold when we replace<br>the identity by an arbitrary relation.<br><br>The final formula says that <EM>R</EM> is post-annihilated by the empty relation only.<br><br>Note: <em>âˆ¼(R â¨¾ âŠ¤) = âŠ¤ &#8195;â‰¡&#8195; R = âŠ¥</em>, for any <EM>R</EM>; i.e., <em>the complement of a<br>relation's domain is everything precisely when the relation is empty.</em>">Total</abbr> <abbr class="tooltip" title="<strong>Univalent (partially defined function):</strong> <em>Equal elements are related to equal<br>elements; i.e., an element cannot be related to two different elements.</em><br><br><em>That is, every source value x is associated <strong>at most one</strong> target value y.</em><br><hr><br>A relation <EM>R : V â†’ V</EM> can be visualised as a drawing: A dot for each element<br><em>x</em> of <EM>V</EM>, and a directed line <em>x âŸ¶ y</em> between two points exactly when <em>x ã€”Rã€•<br>y</em>. That is relations are <em>simple graphs</em>; one refers to the directed lines<br>as <em>edges</em> and the dots as <em>nodes</em>.<br><br>As a simple graph, univalence means: <em>Any arcs from the same source actually coincide.</em><br>That is, <em>Every node has at most one outgoing edge.</em><br><hr><br>&emsp; <EM>R</EM> is univalent<br>â‰¡&emsp;<em>âˆ€ x, y, yâ€²&emsp;â€¢ x ã€” R ã€• y âˆ§ x ã€”Rã€• yâ€²&emsp;â‡’ y = yâ€²</em><br>â‰¡&emsp;<em>R Ë˜ â¨¾ R&emsp;âŠ† Id</em><br>â‰¡&emsp;<em>R â¨¾ âˆ¼ Id &#8195;âŠ†&#8195; âˆ¼ R</em><br>â‰¡&emsp;<em>âˆ€ S â€¢ R â¨¾ âˆ¼ S &#8195;âŠ†&#8195; âˆ¼ (R â¨¾ S)</em><br>â‰¡&emsp;<em>âˆ€ S â€¢ R â¨¾ âˆ¼ S = R â¨¾ âŠ¤ âˆ© âˆ¼(R â¨¾ S)</em><br>â‰¡&emsp;<em>âˆ€ Q, S â€¢&emsp;R â¨¾ (Q âˆ© S) = R â¨¾ Q âˆ© R â¨¾ S</em>&emsp; ---c.f., â¨¾ sub-distributes over âˆ©<br>â‰¡&emsp;<em>âˆ€ Q, S â€¢ Qâ¨¾R âˆ© S = (Q âˆ© S â¨¾ RË˜)â¨¾R</em>&emsp;&emsp;&emsp; ---c.f., the Dedekind rule<br><br>Where <em>â¨¾, âŠ¤, âŠ¥, Id, Ë˜, âˆ¼</em> are relation composition, the universal relation, the<br>empty relation, the identity relation, relation converse (transpose), and complement.<br><hr><br>The formula <em>R â¨¾ âˆ¼ Id &#8195;âŠ† âˆ¼ R</em> reads â€œIf <em>x</em> is <em>R</em>-related to a value different<br>from <em>y</em>, then it is not <em>R</em>-related to <em>y</em>.â€&emsp;It continues to hold when we replace<br>the identity by an arbitrary relation.<br><br>The 5th row reads, <em>the preimage of the complement is the same as the complement<br>of the preimage intersected with the domain</em>.&emsp;In fact, for univalent <EM>R</EM>, we<br>also have <em>âˆ¼(R â¨¾ S) = R â¨¾ âˆ¼ S âˆª âˆ¼(R â¨¾ âŠ¤)</em>; e.g., the people who do â€œnot (own an<br>Audi car)â€ are exactly the people who â€œ(own a non-Audi car) or do not(own any<br>car)â€ ---assuming a person can own at most one car.<br><br>For a map <em>f</em>, the 6th row becomes: <em>f(A âˆ© B) &#8195;=&#8195; f(A) âˆ© f(B)</em>, using<br>conventional direct image notation; i.e., for a function, <em>the preimage of an<br>intersection is the intersection of preimages</em>.<br><br>Likewise, for a map <em>f</em>, we have <em>the intersection of <EM>B</EM> with a function's image<br>is the same as the image of an intersection involving the preimage of <EM>B</EM></em>; i.e.,<br><em>f(A) âˆ© B = f(A âˆ© f^{-1}(B))</em>.">Univalent</abbr> <abbr class="tooltip" title="/Any two different members are related/; (the associated graph can be drawn<br>similar to a line).<br><br>( In graph terminology, semilinear is also referred to as <em>complete</em>; e.g., <em>â€œthe<br>complete graph on n nodesâ€</em> refers to <em>âŠ¤ âˆ© âˆ¼Id : 1..n â†” 1..n</em>. )<br><br>&emsp; <EM>R</EM> is semilinear<br>â‰¡&emsp;<em>âˆ€ x, y â€¢ x â‰  y&emsp;â‡’&emsp;x ã€”Rã€• y&emsp;âˆ¨&emsp;y ã€”Rã€• x</em><br>â‰¡&emsp;<em>âˆ¼Id âŠ† R âˆª R Ë˜</em><br>â‰¡&emsp;<em>âˆ¼ R âŠ† R Ë˜ âˆª Id</em><br>â‰¡&emsp;<em>âˆ¼ R</em> is antisymmetric<br><br>Where <em>â¨¾, âŠ¤, âŠ¥, Id, Ë˜, âˆ¼</em> are relation composition, the universal relation, the<br>empty relation, the identity relation, relation converse (transpose), and complement.<br><br>A relation without incomparable elements is semilinear.<br><br>A semilinear and asymmetric relation <EM>R</EM> is known as a <em>tournament</em> since it<br>models the win-loss situation of a typical sports tournament: Semilinearity and<br>asymmetry ensure teams do not play against themselves and that there is no draw<br>---i.e., there must be a winner. A tournament <em>R</em> is characterised by <em>R âˆª RË˜ =<br>âˆ¼Id</em>.">Semilinear</abbr> <abbr class="tooltip" title="/Any two (possibly identical) members are related/; (the associated<br>graph can be drawn <em>similar</em> to a line; i.e., the nodes can be arranged in a<br>sequence).<br><br>( In graph terminology, linear is also referred to as <em>strongly complete</em>. )<br><br>( Sometimes a linear <em>order</em> is called a <em>complete order</em>. )<br><br>&emsp; <EM>R</EM> is linear<br>â‰¡&emsp;<em>âˆ€ x, y â€¢ x ã€”Rã€• y&emsp;âˆ¨&emsp;y ã€”Rã€• x</em><br>â‰¡&emsp;<em>âŠ¤ âŠ† R âˆª R Ë˜</em><br>â‰¡&emsp;<em>âˆ¼ R âŠ† R Ë˜</em><br>â‰¡&emsp;<em>âˆ¼ R</em> is asymmetric<br><br>Where <em>â¨¾, âŠ¤, âŠ¥, Id, Ë˜, âˆ¼</em> are relation composition, the universal relation, the<br>empty relation, the identity relation, relation converse (transpose), and complement.<br><hr><br>A linear <em>order</em> corresponds to a full upper triangular matrix, <em>after</em> suitably<br>arranging rows and columns. A linear (pre)-<em>order</em> has no (distinct) incomparable<br>elements.<br><br>Any linear ordering <em>E</em>, with associated strict order <em>C</em>, satisfies <EM>CË˜ = âˆ¼E</EM>;<br>i.e., any linear order â€˜âŠ‘â€™ satisfies <em>âˆ€ x, y â€¢&#x2000; Â¬ (x âŠ‘ y) &#8195;â‰¡&#8195; y âŠ x</em>.<br><br>Likewise, for liner order, we have <em>transitivity Eâ¨¾Câ¨¾E = C</em> and <em>weakening C âŠ† E</em>;<br>i.e., <em>a âŠ‘ b âŠ c âŠ‘ d &#8195;â‡’&#8195; a âŠ d &#x2000;&#8195; and&#8195; &#x2000; x âŠ y &#8195;â‡’&#8195; x âŠ‘ y</em>.<br><br>Every order <em>E</em> can be extended to a linear order <em>Eâ€²</em>; i.e., <em>E âŠ† Eâ€²</em>.&emsp;For the<br>finite case this is known as <em>topological sort</em>, and for the infinite case this is<br>known as the <em>Szpilrajn extension</em>.<br><br>- For the finite case, the <em>idea</em> is as follows: If <em>E</em> is not linear, then there<br>&emsp;are two incomparable elements <em>x, y</em> (i.e., outside <em>E âˆª EË˜</em>), so we may define<br>&emsp;<em>an</em> ordering <em>Eâ‚ â‰” E âˆª {(x, y)}</em>. We iterate this process and <em>Eâ‚™</em> will<br>&emsp;eventually become linear.<br><br>&emsp;This process maintains â€œthe order <em>E</em>, less the incomparable elements, is<br>&emsp;linearâ€ invariant throughout. Since each step reduces the number of<br>&emsp;incomparable elements, it must terminate, and the invariant then ensures the<br>&emsp;resulting order is linear. (â€¢Ì€á´—â€¢Ì)Ùˆ">Linear</abbr> <abbr class="tooltip" title="An <em>equivalence</em> models the notion of â€˜similarityâ€™; <em>Everything is similar to<br>itself, being similar is a mutual relationship, and it is transitive</em>.<br><br>&emsp; <EM>R</EM> is an equivalence<br>â‰¡&emsp;<EM>R</EM> is a symmetric preorder<br>â‰¡&emsp;<EM>R</EM> is transitive and reflexive and symmetric<br>â‰¡&emsp;<em>R â¨¾ R âŠ† R &#8195;âˆ§&#8195; Id âŠ† R âŠ† RË˜</em><br>â‰¡&emsp;<em>R â¨¾ R = R = RË˜ &#8195;âˆ§&#8195; Id âŠ† R</em><br>â‰¡&emsp;<em>R â¨¾ R Ë˜ âŠ† R &#8195;âˆ§&#8195; Id âŠ† R</em><br><br>Where <em>â¨¾, âŠ¤, âŠ¥, Id, Ë˜, âˆ¼</em> are relation composition, the universal relation, the<br>empty relation, the identity relation, relation converse (transpose), and complement.<br><hr><br>For example, â€œ2 + 3â€ and â€œ5â€ are clearly <strong>not the same</strong>â€: The first is a string<br>of 3 symbols, whereas the latter is a string of a single symbol.&emsp;However, they<br>are <strong>equivalent</strong> when we evaluate them and so we want to pretend they are the<br>same, not by using equality, but by using an equivalence relation.&emsp;( This<br>equivalence relation is obtained using transitive closure as <em>(R â¨¾ R)^*</em> where<br><EM>R</EM> is the evaluation, reduction relation. )<br><br>In general, â€œsharing the same feature ğ’‡â€ is an equivalence relation.<br>That is, if <em>f : A â†’ B</em> is a function, then âˆ¼ is an equivalence relation<br>defined by <em>aâ‚ âˆ¼&emsp;aâ‚‚ &#x2000;â‰¡&#x2000; f(aâ‚) &#8195;=&#8195; f(aâ‚‚)</em>.<br><hr><br>Characterising Equivalences with â€œIndirect Equivalenceâ€:<br>Î is an equivalence&emsp;â‰¡&emsp;<em>âˆ€ x, y â€¢&emsp;x ã€”Îã€• y &#x2000;â‰¡&#x2000; (âˆ€ z â€¢ x ã€”Îã€• z &#8195;â‰¡&#8195; y ã€”Îã€• z)</em><br><hr><br>Equivalence relations coincide with partitions.">Equivalence</abbr> <abbr class="tooltip" title="A <em>preorder</em> models the notion of â€˜inclusionâ€™ or â€˜at mostâ€™ or â€˜beforeâ€™ or<br>â€˜predecessor ofâ€™; and so requires: <em>Everything is included in itself and<br>inclusion is transitive.</em><br><br>&emsp;<EM>R</EM> is a preorder<br>â‰¡ <EM>R</EM> is transitive and reflexive<br>â‰¡ <em>R â¨¾ R âŠ† R &#8195;âˆ§&#8195; Id âŠ† R</em><br>â‰¡ <em>R â¨¾ R = R &#8195;âˆ§&#8195; Id âŠ† R</em><br>â‰¡ <EM>R â•± R = R</EM>&emsp;---â€œindirect inclusion from aboveâ€<br>â‰¡ <EM>R â•² R = R</EM>&emsp;---â€œindirect inclusion from belowâ€<br><br>Where <em>â¨¾, âŠ¤, âŠ¥, Id, Ë˜, âˆ¼</em> are relation composition, the universal relation, the<br>empty relation, the identity relation, relation converse (transpose), and complement.<br><br>If it is additionally <em>antisymmetric</em>, one says we have an <strong>order</strong>.<br>- The relation <EM>R âˆ© RË˜</EM> is the greatest equivalence contained in a preorder <EM>R</EM>.<br><br>&emsp;Indeed, it's clearly symmetric and reflexive, and transitive since â€˜â¨¾â€™<br>&emsp;sub-distributes over â€˜âˆ©â€™ and <em>R</em> and <em>RË˜</em> are transitive. Then, for any<br>&emsp;equivalence <em>Î âŠ† R</em>, we have <em>Î = Î Ë˜ âŠ† R Ë˜</em> and so <em>Î âŠ† R âˆ© RË˜</em>.<br><br>Instead of reflexivity, if we have irreflexivity we get <strong>strict order</strong>:<br>&emsp;<EM>R</EM> is a strict order<br>â‰¡ <EM>R</EM> is transitive and irreflexive<br>â‰¡ <em>R â¨¾ R âŠ† R âŠ† âˆ¼Id</em><br>â‰¡ <EM>R â¨¾ R âŠ† R &#8195;âˆ§&#8195; RË˜ âŠ† âˆ¼ R</EM><br>â‰¡ <EM>R â¨¾ R âŠ† R &#8195;âˆ§&#8195; R âˆ© RË˜ âŠ† âŠ¥</EM><br>â‰¡ <EM>R</EM> is transitive and asymmetric<br><br>( <em>Warning!</em> A â€œstrict orderâ€ is not an order that is somehow strict. )<br><br>Orders and strict orders come in pairs: Every order <EM>R</EM> induces a strict order<br><em>R âˆ© âˆ¼Id</em>; conversely, every strict order <EM>R</EM> gives rise to an order <em>R âˆª<br>Id</em>. As such, it is customary to denote order relations by symbols such as â‰¤,<br>âŠ†. â‰¼, âŠ‘ and their associated strict orders by related symbols <, âŠ‚, â‰º, âŠ,<br>respectively, with *lack the horizontal line â€˜â”€â€™ below the symbol to indicate<br>irreflexivity ---i.e., the line is a suggestive reminder of equality.<br><br>When letters are used to denote orders, one may see <em>E</em> for an order since it is<br>reminiscent of â‰¤ and âŠ†, and may see <em>C</em> for a strict order since it is reminiscent<br>of < and âŠ‚.<br><br>Using â€˜â‰¤â€™ for <em>an arbitrary order</em> is not ideal since readers may confuse it with<br>the familiar <em>linear</em> orders for numbers.">Preorder</abbr> <abbr class="tooltip" title="/The relationship is mutually exclusive.<em><br><hr><br><br>A relation <EM>R : V â†’ V</EM> can be visualised as a drawing: A dot for each element<br><em>x</em> of <EM>V</EM>, and a directed line <em>x âŸ¶ y</em> between two points exactly when <em>x ã€”Rã€•<br>y</em>.&emsp;That is relations are </em>simple graphs/; one refers to the directed lines as<br><em>edges</em> and the dots as <em>nodes</em>.<br><br>As a simple graph, asymmetric means: <em>There's at most 1 edge (regardless of<br>direction) relating any 2 nodes</em>.<br><hr><br>&emsp; <EM>R</EM> is asymmetric<br>â‰¡&emsp;<em>âˆ€ x, y â€¢ x ã€”Rã€• y&emsp;â‡’&emsp;Â¬ y ã€”Rã€• x</em><br>â‰¡&emsp;<EM>R âˆ© R Ë˜ âŠ† âŠ¥</EM><br>â‰¡&emsp;<EM>R Ë˜ âŠ† âˆ¼ R</EM><br><br>Where <em>â¨¾, âŠ¤, âŠ¥, Id, Ë˜, âˆ¼</em> are relation composition, the universal relation, the<br>empty relation, the identity relation, relation converse (transpose), and complement.<br><br>Asymmetrics are irreflexive ---just pick <em>x = y</em> in the above âˆ€-formulation ;-)<br><hr><br><br>Interestingly, every homogeneous relation <em>R</em> may be <em>partitioned</em> into an<br>asymmetric part <EM>A = R âˆ© âˆ¼RË˜</EM> and a symmetric part <EM>S = R âˆ© RË˜</EM><br>---i.e., <EM>R = A âˆª S</EM> and <EM>A âˆ© S = âŠ¥</EM> where âŠ¥ is the empty relation.">Asymmetric</abbr> <abbr class="tooltip" title="/Different elements cannot be mutually related; i.e.,<br>Mutually related items are necessarily indistinguishable.<em><br><br>Such relations allow us to prove equality between two elements;<br>we have only to show that the relationship holds in both directions.<br>&emsp;* E.g, one often shows two sets are equal by using the antisymmetry of â€˜âŠ†â€™.<br><hr><br><br>A relation <EM>R : V â†’ V</EM> can be visualised as a drawing: A dot for each element<br><em>x</em> of <EM>V</EM>, and a directed line <em>x âŸ¶ y</em> between two points exactly when <em>x ã€”Rã€•<br>y</em>.&emsp;That is relations are </em>simple graphs/; one refers to the directed lines as<br><em>edges</em> and the dots as <em>nodes</em>.<br><br>As a simple graph, antisymmetry means <em>Mutually related nodes are necessarily self-loops</em>.<br><hr><br>&emsp; <EM>R</EM> is antisymmetric<br>â‰¡&emsp;<em>âˆ€ x, y â€¢ x ã€”Rã€• y&emsp;âˆ§&emsp;y ã€” Rã€• x â‡’ x = y</em><br>â‰¡&emsp;<em>âˆ€ x, y â€¢&emsp;x â‰  y&emsp;â‡’&emsp;Â¬ (x ã€”Rã€• y&emsp;âˆ§&emsp;y ã€” Rã€• x)</em><br>â‰¡&emsp;<em>âˆ€ x, y â€¢&emsp;x â‰  y&emsp;â‡’&emsp;x ã€”RÌ¸ã€• y&emsp;âˆ¨&emsp;y ã€” RÌ¸ã€• x</em><br>â‰¡&emsp;<em>R âˆ© R Ë˜ âŠ† Id</em><br>â‰¡&emsp;<em>R Ë˜ âŠ† âˆ¼ R âˆª Id</em><br>â‰¡&emsp;<em>R â•³ R = Id</em>&emsp;---â€˜â•³â€™ is symmetric quotient<br><br>Where <em>â¨¾, âŠ¤, âŠ¥, Id, Ë˜, âˆ¼</em> are relation composition, the universal relation, the<br>empty relation, the identity relation, relation converse (transpose), and complement.<br><br>( As a simple graph, an antisymmetric relation has <em>at most</em> one arrow between<br>any two different nodes. )">Antisymmetric</abbr> <abbr class="tooltip" title="/The relationship is mutual; if one thing is related to the other, then the other<br>is also related to the first.<em><br><br>&emsp; <EM>R</EM> is symmetric<br>â‰¡&emsp;If </em>x/ is related to <em>y</em>, then <em>y</em> is also related to <em>x</em>.<br>â‰¡&emsp;<em>âˆ€ x, y â€¢ x ã€”Rã€• y â‡’ y ã€” Rã€• x</em><br>â‰¡&emsp;<EM>R Ë˜ âŠ† R</EM><br>â‰¡&emsp;<EM>R âˆ© RË˜ âŠ† R</EM><br>â‰¡&emsp;<EM>R Ë˜ = R</EM><br><br>Where <em>â¨¾, âŠ¤, âŠ¥, Id, Ë˜, âˆ¼</em> are relation composition, the universal relation, the<br>empty relation, the identity relation, relation converse (transpose), and complement.<br><hr><br><br>A relation <EM>R : V â†’ V</EM> can be visualised as a drawing: A dot for each element<br><em>x</em> of <EM>V</EM>, and a directed line <em>x âŸ¶ y</em> between two points exactly when <em>x ã€”Rã€•<br>y</em>.&emsp;That is relations are <em>simple graphs</em>; one refers to the directed lines as<br><em>edges</em> and the dots as <em>nodes</em>.<br><br>As a simple graph, symmetry means the graphs is <em>undirected</em>.<br><br>That is, as graphs, symmetric relations contains either exactly two arrows ---in<br>opposite directions--- between any two elements or none at all.&emsp;As such, for<br>clarity, one prefers â€œsqueezing any two arrows in opposite directionsâ€ into one<br>â€˜undirectedâ€™ line and so obtains <strong>undirected graphs</strong>.<br>- Undirected edges represent pairs of arrows pointing in opposite directions.<br><br>&emsp;Coreflexives are symmetric: <em>R âŠ† Id â‡’ R Ë˜ = R</em>.<br><hr><br><br>Interestingly, every homogeneous relation <em>R</em> may be <em>partitioned</em> into an<br>asymmetric part <EM>A = R âˆ© âˆ¼RË˜</EM> and a symmetric part <EM>S = R âˆ© RË˜</EM><br>---i.e., <EM>R = A âˆª S</EM> and <EM>A âˆ© S = âŠ¥</EM> where âŠ¥ is the empty relation.">Symmetric</abbr> <abbr class="tooltip" title="A relation _âŠ‘_ is <em>transitive</em> when it satisfies <em>a âŠ‘ b Â âˆ§Â  b âŠ‘ c Â â‡’Â  a âŠ‘ c</em>;<br>i.e., <em>a âŠ‘ b âŠ‘ c Â â‡’Â a âŠ‘ c</em> ---that is, â€œwe can chain âŠ‘â€ so that from a proof of <em>a<br>âŠ‘ b âŠ‘ c</em> we can get from the first to the final part and so have a proof of<br><em>a âŠ‘ c</em>.<br><br>Loosely put, whenever <em>a</em> and <em>c</em> have a common relative then they are themselves<br>related.<br><hr><br><br>A relation <EM>R : V â†’ V</EM> can be visualised as a drawing: A dot for each element<br><em>x</em> of <EM>V</EM>, and a directed line <em>x âŸ¶ y</em> between two points exactly when <em>x ã€”Rã€•<br>y</em>.&emsp;That is relations are <em>simple graphs</em>; one refers to the directed lines as<br><em>edges</em> and the dots as <em>nodes</em>.<br><br>As a simple graph, transitivity means <em>paths can always be shortened (but<br>nonempty).</em><br><br><hr><br><br>By the shunting rule, transitivity can be read as a <strong>â€˜monotonicityâ€™</strong> property for<br>the operation that turns a value <em>x</em> into the proposition <em>a âŠ‘ x</em>; this maps ordered<br>relationships <em>b âŠ‘ c</em> to ordered propositions <em>a âŠ‘ b â‡’ a âŠ‘ c</em>.<br><br>Likewise, transitivity can be read as an â€˜<strong>antitonicity</strong>â€™ property for the<br>operation mapping a value <em>x</em> to the proposition <em>x âŠ‘ c</em>; this maps ordered<br>relationships <em>a âŠ‘ b</em> to ordered propositions <em>b âŠ‘ c â‡’ a âŠ‘ c</em>.<br><br><hr><br><br>&emsp; Relation <em>R</em> is transitive<br>â‰¡&emsp;<em>Things related to things that are related, are themselves related.</em><br>â‰¡&emsp;Whenever <em>x</em> is related to <em>y</em> and <em>y</em> is related to <em>z</em>, then also <em>x</em> will<br>&emsp; be related to <em>z</em><br>â‰¡&emsp;<em>âˆ€ x, y, z â€¢&emsp;x ã€” R ã€• y ã€”R ã€• z&emsp;â‡’&emsp;x ã€”Rã€• z</em><br>â‰¡&emsp;<EM>R â¨¾ R âŠ† R</EM><br><br>Where <em>â¨¾, âŠ¤, âŠ¥, Id, Ë˜, âˆ¼</em> are relation composition, the universal relation, the<br>empty relation, the identity relation, relation converse (transpose), and complement.<br><br><hr><br><br>A transitive relation is irreflexive precisely when it is asymmetric.">Transitive</abbr> <abbr class="tooltip" title="/Elements are related to themselves/<br><hr><br>A relation <EM>R : V â†’ V</EM> can be visualised as a drawing: A dot for each element<br><em>x</em> of <EM>V</EM>, and a directed line <em>x âŸ¶ y</em> between two points exactly when <em>x ã€”Rã€•<br>y</em>.&emsp;That is relations are <em>simple graphs</em>; one refers to the directed lines as<br><em>edges</em> and the dots as <em>nodes</em>.<br><br>As a simple graph, reflexivity means <em>there is loop â€œ âŸ³ â€ at each node.</em><br><hr><br><br>&emsp; <em>R</em> is reflexive exactly when <em>everything is related to itself</em>.<br>â‰¡&emsp;<em>âˆ€ x â€¢ x ã€”Rã€• x</em><br>â‰¡&emsp;<em>Id âŠ† R</em><br><br>Where <em>â¨¾, âŠ¤, âŠ¥, Id, Ë˜, âˆ¼</em> are relation composition, the universal relation, the<br>empty relation, the identity relation, relation converse (transpose), and complement.">Reflexive</abbr> <abbr class="tooltip" title="An operation _âŠ•_ is <em>commutative</em> or <em>symmetric</em> if it satisfies <em>x âŠ• y = y âŠ• x</em>.<br><br>This property indicates (semantically) that the value of an âŠ•-expression doesn't<br>depend on the order of its arguments and (syntactically) we may swap their order<br>when manipulating âŠ•-expressions.">Commutative</abbr> <abbr class="tooltip" title="An operation âŠ— distributes over âŠ• when they satisfy<br>â€œleft-distributivityâ€ <em>x âŠ— (y âŠ• z) = (x âŠ— y) âŠ• (x âŠ— y)</em><br>and<br>â€œright-distributivityâ€ <em>(y âŠ• z) âŠ— x = (y âŠ— x) âŠ• (z âŠ— x)</em>.<br><br>When âŠ• = âŠ—, one says that the operation is â€œself-distributiveâ€.<br><br>Distributivity can be viewed in two ways, much like distributivity of<br>multiplication Ã— over addition +. Replacing the left side by the right side<br>could be called â€œmultiplying outâ€; replacing the right side by the left side,<br>â€œfactoringâ€.">Distributive</abbr> <abbr class="tooltip" title="An operation _âŠ•_ has identity ğ‘° when it satisfies <em>ğ‘° âŠ• x = x = x âŠ• ğ‘°</em>.<br><br>If it satisfies only the first equation, <em>ğ‘° âŠ• x = x</em>, one says<br>that â€œğ‘° is a left-identity for âŠ•â€. If it satisfies only the second<br>equation, <em>x âŠ• ğ‘° = x</em>, one says that â€œğ‘° is a right-identity for âŠ•â€.<br><br>For example, implication only has a left identity, <em>(false â‡’ x) = x</em>, and<br>subtraction only has a right identity, <em>(x - 0) = x</em>.<br><br>An identity implies that occurrences of â€œâŠ• ğ‘°â€ and â€œğ‘° âŠ•â€ in an expression are<br>redundant. Thus, <em>x âŠ• ğ‘°</em> may be replaced by <em>x</em> in any expression without<br>changing the value of the expression. Therefore, we usually eliminate such<br>occurrences unless something encourages us to leave them in.">Identity</abbr> <abbr class="tooltip" title="An operation _âŠ•_ is associative when it satisfies <em>(p âŠ• q) âŠ• r = p âŠ• (q âŠ• r)</em>.<br><br>Associativity allows us to be informal and insert or delete pairs of<br>parentheses in sequences of âŠ•'s, just as we do with sequences of<br>additions ---e.g., <em>a + b + c + d</em> is equivalent to <em>a + (b + c) + d</em>.<br><br>Hence, we can write <em>p âŠ• q âŠ• r</em> instead of <em>(p âŠ• q) âŠ• r</em> or <em>p âŠ• (q âŠ• r)</em>.<br><br>When an operation is associative, it is best to avoid â€œmaking a choiceâ€ of how<br>sequences of âŠ• should be read, by using parentheses ---unless to make things<br>clear or explicit for manipulation.<br><br><hr><br><br>More generally, for any two operations _âŠ•_ and _âŠ_, the â€œ(left to right) mutual<br>associativity of âŠ• and âŠâ€ is the property <em>(x âŠ• y) âŠ z = x âŠ• (y âŠ z)</em>. It allows<br>us to omit parentheses in mixed sequences of âŠ• and âŠ. For instance, addition and<br>subtraction are (left to right) mutually associative.">Associative</abbr> <abbr class="tooltip" title="A theory of typed&emsp;composition; e.g., typed monoids.">Category Theory</abbr> <abbr class="tooltip" title="Natural transformations are essentially polymorphic functions that make <em>no</em><br> choices according to the input type; e.g., =reverse : List Ï„ â†’ List Ï„= makes no<br> choices depending on the type <code>Ï„</code>.">Natural Transformation</abbr> <abbr class="tooltip" title="There are two ways to read this phrase.<br><br> Algorithmic-problem solving is about solving problems that<br> involve the construction of an algorithm for their solution.<br><br> Algorithmic problem-solving is about problem solving in general,<br> using the principles of correct-by-construction algorithm-design.">Algorithmic Problem Solving</abbr> <abbr class="tooltip" title="Problems may be formulated and solved using, possibly implicitly, the<br> construction of correct programs:<br><br>&emsp;&emsp; <em>â€œfor all x satisfying R(x), there is a y such that G(x,y) is trueâ€</em><br> â‰ˆ	<em>âˆ€ x â€¢ R x â‡’ âˆƒ y â€¢ G x y</em><br> â‰ˆ	<em>R {ğ‘º} G for some program ğ‘º with inputs x and outputs y</em><br><br> This is known as a <em>constructive proof</em> since we have an algorithm ğ‘º that actually<br> shows how to find a particular <em>y</em> to solve the problem, for any given x. In<br> contrast, non-constructive proofs usually involving some form of counting<br> followed by a phrase â€œthere is at least one such <em>y</em> â€¦â€, without actually<br> indicating <em>how</em> to find it!<br><br> The <em>â€œR {ğ‘º} Gâ€</em> is known as a â€˜Hoare tripleâ€™ and it expresses â€œwhen begun in a<br> state satisfying <em>R</em>, program ğ‘º will terminate in a state satisfying <em>G</em>.â€<br><br> <hr><br><br> + Proving â‰ˆ Programming<br> + Logic&emsp; â‰ˆ Trees (algebraic data types, ğ’²-types)<br> + Rules&emsp; â‰ˆ Constructors<br> + Proof&emsp; â‰ˆ An application of constructors<br> + Axiom&emsp; â‰ˆ A constructor with no arguments">Proving_is_Programming</abbr> <abbr class="tooltip" title="A specification is an equation of a certain shape.<br>&emsp;<em>Programming</em> is the activity of solving a specification<br>&emsp;for its unknown. Its unknown is called a <em>program</em>.<br><br>&emsp;See also â€œProgrammingâ€.">Specification</abbr> <abbr class="tooltip" title="Programming is solving the equation <em>R â‡’[C] G</em> in the unknown <em>C</em>; i.e., it is the<br> activity of finding a â€˜recipeâ€™ that satisfies a given specification. Sometimes<br> we may write <em>R â‡’[?] G</em> and solve for â€˜?â€™. Programming is a goal-directed activity: From a specification, a program is found by examining the shape of its postcondition.">Programming</abbr> <abbr class="tooltip" title="A story whose events have smooth transitions connecting them.<br><br># A proof wherein each step is connected to the next step by an explicit<br># justification.<br><br>This is a â€˜linearâ€™ proof format; also known as <em>equational style</em> or <em>calculational<br>proof</em>. This corresponds to the â€˜high-school styleâ€™ of writing a sequence of<br>equations, one on each line, along with hints/explanations of how each line was<br>reached from the previous line. ( This is similar to <strong>programming</strong> which<br>encourages placing <em>comments</em> to <em>communicate</em> what's going on to future readers. )<br><br>The structure of equational proofs allows implicit use of infernece rules<br>Leibniz, Transitvitity & Symmetry & Reflexivity of equality, and<br>Substitution. In contrast, the structure of proof trees is no help in this<br>regard, and so all uses of inference rules must be mentioned explicitly.<br><br>For comparison with other proof notations see Equational Propositional Logic (http://www.cse.yorku.ca/~logicE/misc/logicE_intro.pdf).<br><br><hr><br><br>We advocate <em>calculational proofs</em> in which reasoning is goal directed and<br>justified by simple axiomatic laws that can be checked syntactically rather than<br>semantically. ---<em>Program Construction</em> by Roland Backhouse<br><br><hr><br><br>Calculational proofs introduce notation and recall theorems as needed, thereby<br>making each step of the argument easy to verify and follow. Thus, such arguments<br>are more accessible to readers unfamiliar with the problem domain.<br><br><hr><br><br>The use of a formal approach let us keep track of when our statements are<br>equivalent (â€œ=â€) rather than being weakened (â€œâ‡’â€). That is, the use of English<br>to express the connection between steps is usually presented naturally using â€œif<br>this, then thatâ€ statements ---i.e., implication--- rather than stronger notion<br>of equality.">Calculational Proof</abbr> <abbr class="tooltip" title="<strong>Syntax</strong> refers to the structure of expressions, or the rules for putting symbols<br>together to form an expression. <strong>Semantics</strong> refers to the meaning of expressions<br>or how they are evaluated.<br><br>Abstractions express something shared by their instances, such as the kinds of<br>operations one can perform. However, abstractions don't, by themselves, â€œmeanâ€<br>anything! E.g., for Haskell, the <code>Monad</code> type class does not mean anything, but<br>for the <code>Maybe</code> implementation it means short-circuit sequencing and for the <code>List</code><br>implementation it means (possibly nested) iteration.<br>Abstractions for operations are also known as â€œdesign patternsâ€.<br>( With judicious use of Yoneda, things always denote/mean certain actions. )<br><hr><br><br>An expression can contain variables, and evaluating such an expression requires<br>knowing what values to use for these variables; i.e., a <strong>state</strong>: A list of<br>variables with associated values. E.g., evaluation of <em>x - y + 2</em> in the state<br>consisting of <em>(x, 5)</em> and <em>(y, 6)</em> is performed by replacing <em>x</em> and <em>y</em> by<br>their values to yield <em>5 - 6 + 2</em> and then evaluating that to yield <em>1</em>.<br><br>A Boolean expression <EM>P</EM> is <strong>satisfied</strong> in a state if its value is <em>true</em> in that<br>state; <EM>P</EM> is <strong>satisfiable</strong> if there is a state in which it is satisfied; and <EM>P</EM><br>is <strong>valid</strong> (or is a <strong>tautology</strong>) if it is satisfied in every state.<br><hr><br><br>Often operations are defined by how they are evaluated (<strong>operationally</strong>), we can<br>take the alternative route of defining operations by how they can be manipulated<br>(<strong>axiomatically</strong>); i.e., by what properties they satisfy.<br><br>For example, evaluation of the expression <EM>X = Y</EM> in a state yields the value<br><em>true</em> if expressions <EM>X</EM> and <EM>Y</EM> have the same value and yields <em>false</em> if they<br>have different values.&emsp;This characterisation of equality is in terms of<br>expression <em>evaluation</em>.&emsp;For <em>reasoning about expressions</em>, a more useful<br>characterisation would be a set of <em>laws</em> that can be used to show that two<br>expressions are equal, <strong>without</strong> calculating their values.<br>--- c.f., static analysis versues running a program.<br><br>For example, you know that <em>x = y</em> equals <em>y = x</em>, regardless of the values of<br><em>x</em> and <em>y</em>.&emsp;A collection of such laws can be regarded as a definition of<br>equality, <strong>provided</strong> two expressions have the same value in all states precisely<br>when one expression can be translated into the other according to the laws.<br><br>Usually, in <em>a</em> logic, theorems correspond to expressions that are true in all<br>states.<br><hr><br><br>That is, instead of defining expressions by how they are evaluated, we may<br>define expressions in terms of how they can be manipulated ---c.f., a calculus.<br><br>For instance, we may define basic manipulative properties of operators ---i.e.,<br><em>axioms</em>--- by considering how the operators behave operationally on particular<br>expressions. That is, one may use an operational, intuitive, approach to obtain<br>an axiomatic specification (characterisation, interface) of the desired<br>properties.<br><br>More concretely, since <em>(p â‰¡ q) â‰¡ r</em> and <em>p â‰¡ (q â‰¡ r)</em> evaluate to<br>the same value for any choice of values for <em>p, q, r</em>, we may insist that a part<br>of the definition of equivalence is that it be an associative operation.<br><br>Sometimes a single axiom is not enough to â€˜pin downâ€™ a unique operator ---i.e.,<br>to ensure we actually have a well-defined operation--- and other times this is<br>cleanly possible; e.g., given an ordering â€˜â‰¤â€™(â€˜â‡’, âŠ†, âŠ‘â€™) we can define minima<br>â€˜â†“â€™ (â€˜âˆ§, âˆ©, âŠ“â€™) by the axiom: â€œx â†“ y is the greatest lower boundâ€;<br>i.e., <em>z â‰¤ x â†“ y &#x2000;â‰¡&#x2000; z â‰¤ x &#8194;âˆ§&#8194; z â‰¤ y</em>.">Semantics</abbr> <abbr class="tooltip" title="A <em>calculus</em> is a method or process of reasoning by calculation<br>with symbols. A <em>propositional calculus</em> is a method of calculating with Boolean<br>(or propositional) expressions.<br><br><hr><br><br>Calculus: Formalised reasoning through calculation.<br><br>â€˜Hand wavyâ€™ English arguments tend to favour case analysis â€”considering what<br>could happen in each possible scenarioâ€” which increases exponentially with each<br>variable; in contrast, equality-based calculation is much simpler since it<br>delegates intricate case analysis into codified algebraic laws.">Calculus</abbr> <abbr class="tooltip" title="A <em>theorem</em> in the technical sense is an expression derived<br>from axioms using inference rules.<br><br>A <em>metatheorem</em> is a general <strong>statement</strong> about a logic that<br>one argues to be <strong>true</strong>.<br><br>For instance, â€œany two theorems are equivalentâ€ is a statement that speaks about<br>expressions which happen to be theorems. A logic may not have the linguistic<br>capability to speak of its own expressions and so the statement may not be<br>expressible as an expression <strong>within</strong> the logic ---and so cannot be a theorem of<br>the logic.<br><br>For instance, the logic ğ’‘ğ‘ has expressions formed from the symbols â€œğ’‘â€, â€œğ’’â€, and<br>â€œ-â€ (dash). It has the axiom schema <em>xğ’‘-ğ’’x-</em> and the rule â€œIf <em>xğ’‘yğ’’z</em> is a theorem<br>then so is <em>x-ğ’‘y-ğ’’z-</em>â€. Notice that <em>x, y, z</em> are <em>any</em> strings of dashes;<br>the language of this logic does not have variables and so cannot even speak<br>of its own expressions, let alone its own theorems!<br><br>[Informal] theorems about [technical, logic-specific] theorems are thus termed<br>â€˜metatheoremsâ€™.">Metatheorem</abbr> <abbr class="tooltip" title="A <em>theorem</em> is a syntactic object, a string of symbols with a particular property.<br><br>A <em>theorem</em> of a calculus is either an axiom or the conclusion of an inference<br>rule whose premises are theorems.<br><br>Different axioms could lead to the same set of theorems, and many texts use<br>different axioms.<br><br><hr><br><br>A â€œtheoremâ€ is a syntactic concept: Can we play the game of moving symbols to<br>get this? Not â€œis the meaning of this trueâ€!&emsp;â€˜Semantic conceptsâ€™ rely on<br>â€˜statesâ€™, assignments of values to variables so that we can â€˜evaluate, simplifyâ€™<br>statements to deduce if they are true.<br><br>Syntax is like static analysis; semantics is like actually running the program<br>(on some, or all possible inputs).<br><br><hr><br><br>A <strong>meta-theorem</strong> is a general statement about our logic that we prove to be<br>true. That is, if ğ‘¬ is collection of rules that allows us to find truths, then a<br><em>theorem</em> is a truth found using those rules; whereas a meta-theorem/ is property<br>of ğ‘¬ itself, such as what theorems it can have.&emsp;That is, theorems are _in_ ğ‘¬ and<br>meta-theorems are _about_ ğ‘¬.&emsp;For example, here is a meta-theorem that the<br>equational logic ğ‘¬ has (as do many other theories, such as lattices): An<br><em>equational</em> theorem is true precisely when its â€˜dualâ€™ is true. Such metatheorems<br>can be helpful to discover new theorems.<br><br># A meta-theorem is a theorem about theorems.">Theorem</abbr> <abbr class="tooltip" title="A <em>logic</em> is a formal system of reasoning...<br><br>A <em>logic</em> is a set of symbols along with a set of <em>formulas</em> formed from the<br>symbols, and a set of <em>inference rules</em> which allow formulas to be derived from<br>other formulas. (The formulas may or may not include a notion of variable.)<br><br>Logics are purely syntactic objects; an <em>inference rule</em> is a syntactic mechanism<br>for deriving â€œtruthsâ€ or â€œtheoremsâ€.<br><br>In general, proofs are evidence of truth of a claim; by demonstrating that the<br>claim follows from some <em>obvious truth</em> using rules of reasoning that <em>obviously<br>preserve truth.</em>">Logic</abbr> <abbr class="tooltip" title="Formally, a â€œproofâ€ is obtained by applying a number of â€œrulesâ€ to known results<br>to obtain new results; a â€œtheoremâ€ is the conclusion of a â€œproofâ€.&emsp;An â€œaxiomâ€<br>is a rule that does not need to be applied to any existing results: It's just a<br>known result.<br><br>That is, a <strong>rule</strong> <EM>R</EM> is a tuple <EM>Pâ‚, â€¦, Pâ‚™, C</EM> that is thought of as â€˜taking<br><strong>premises</strong> (instances of known results) <EM>Páµ¢</EM>â€™ and acting as a â€˜natural,<br>reasonable justificationâ€™ to obtain <strong>conclusion</strong> <EM>C</EM>.&emsp;A <strong>proof system</strong> is a<br>collection of rules. At first sight, this all sounds very abstract and rather<br>useless, however it is a <em>game</em>: <strong>Starting from rules, what can you obtain?</strong> Some<br>games can be very fun! Another way to see these ideas is from the view of<br>programming:<br><br>+ Proving â‰ˆ Programming<br>+ Logic&emsp; â‰ˆ Trees (algebraic data types, ğ’²-types)<br>+ Rules&emsp; â‰ˆ Constructors<br>+ Proof&emsp; â‰ˆ An application of constructors<br>+ Axiom&emsp; â‰ˆ A constructor with no arguments<br><br>Just as in elementary school one sees addition â€˜+â€™ as a fraction with the<br>arguments above the horizontal line and their sum below the line, so too is that<br>notation reused for inference rules: Premises are above the fraction's bar and<br>the conclusion is below.<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 12<br>Pâ‚, Pâ‚‚, â€¦, Pn&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;+&emsp;7<br><hr>R&emsp;&emsp; versues&emsp;&emsp; ----<br>&emsp;&emsp;&emsp;C&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;19<br><br>Just as there are meta-variables and meta-theorems, there is â€˜meta-syntaxâ€™:<br>- The use of a fraction to delimit premises from conclusion is a form of â€˜implicationâ€™.<br>- The use of a comma, or white space, to separate premises is a form of â€˜conjunctionâ€™.<br><br>If our expressions actually have an implication and conjunction operation, then<br>inference rule above can be presented as an axiom <EM>Pâ‚ &#8194;âˆ§&#8194; â‹¯ &#8194;âˆ§&#8194; Pâ‚™ &#8194;â‡’&#8194; C</EM>.<br><br>The inference rule says â€œif the <EM>Páµ¢</EM> are all valid, i.e., true in <em>all states</em>,<br>then so is <EM>C</EM>â€; the axiom, on the other hand, says â€œif the <EM>Páµ¢</EM> are true in <em>a<br>state</em>, then <EM>C</EM> is true in <em>that state</em>.â€ Thus the rule and the axiom are not<br>quite the same.<br><br>Moreover, the rule is not a Boolean expression.&emsp;Rules are thus more general,<br>allowing us to construct systems of reasoning that have no concrete notions of<br>â€˜truthâ€™ ---e.g., the above arithmetic rule says from the things above the<br>fraction bar, using the operation â€˜+â€™, we <em>can get</em> the thing below the bar, but<br>that thing (19) is not â€˜trueâ€™ as we may think of conventional truth.<br><br>Finally, the rule asserts that <EM>C</EM> follows from <EM>Pâ‚, â€¦, Pâ‚™</EM>.&emsp;The formula <em>Pâ‚<br>&#8194;âˆ§&#8194; â‹¯ &#8194;âˆ§&#8194; Pâ‚™ &#8194;â‡’&#8194; C</em>, on the other hand, is an expression (but it need not<br>be a theorem).<br><br>A â€œtheoremâ€ is a syntactic concept: Can we play the game of moving symbols to<br>get this? Not â€œis the meaning of this trueâ€!&emsp;â€˜Semantic conceptsâ€™ rely on<br>â€˜statesâ€™, assignments of values to variables so that we can â€˜evaluate, simplifyâ€™<br>statements to deduce if they are true.<br><br>Syntax is like static analysis; semantics is like actually running the program<br>(on some, or all possible inputs).<br><br><hr><br><br>One reads/writes a <em>natural deduction proof (tree)</em> from the very <strong>bottom</strong>: Each<br>line is an application of a rule of reasoning, whose assumptions are above the<br>line; so read/written upward.&emsp;The <strong>benefit</strong> of this approach is that <strong>rules guide<br>proof construction</strong>; i.e., it is goal-directed.<br><br>However the <strong>downsides are numerous</strong>:<br>- So much horizontal space is needed even for simple proofs.<br>- One has to <strong>repeat</strong> common subexpressions; e.g., when using transitivity of equality.<br>- For comparison with other proof notations, such as Hilbert style,<br>&emsp;see Prolog (http://www.cse.yorku.ca/~logicE/misc/logicE_intro.pdf][Equational Propositional Logic]].<br><br>&emsp;This is more â€˜linearâ€™ proof format; also known as <em>equational style</em> or<br>&emsp;<em>calculational proof</em>. This corresponds to the â€˜high-school styleâ€™ of writing a<br>&emsp;sequence of equations, one on each line, along with hints/explanations of how<br>&emsp;each line was reached from the previous line.<br><br><hr><br><br>Finally, an inference rule says that it is possible to start with the givens<br><EM>Páµ¢</EM> and obtain as result <EM>C</EM>.&emsp;The idea to use <strong>inference rules as computation</strong><br>is witnessed by the [[https://alhassy.github.io/PrologCheatSheet/CheatSheet.pdf) programming language.">Inference_Rule</abbr> <abbr class="tooltip" title="The <strong>(simultaneous textual) Substitution operation</strong> <em>E[\vec x â‰” \vec F]</em> replaces<br>all variables <em>\vec x</em> with parenthesised expressions <em>\vec F</em> in an expression<br><EM>E</EM>. In particular, <em>E[x â‰” F]</em> is just <EM>E</EM> but with all occurrences of <em>x</em><br>replaced by <em>â€œ(F)â€</em>. This is the â€œfind-and-replaceâ€ utility you use on your<br>computers.<br><br>Textual substitution on expressions is known as â€œgraftingâ€ on trees: Evaluate<br><em>E[x â‰” F]</em> by going down the tree <EM>E</EM> and finding all the â€˜leavesâ€™ labelled <em>x</em>,<br>cut them out and replace them with the new trees <EM>F</EM>.<br><br>Since expressions are either variables of functions applications,<br>substitution can be defined inductively/recursively by the following two clauses:<br><br>+ <em>y[x â‰” F]&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; =&emsp;ifÂ  x = yÂ  thenÂ  F Â elseÂ  y Â fi</em><br>+ <em>f(tâ‚, â€¦, tâ‚™)[x â‰” F]&emsp;=&emsp;f(tâ‚â€², â€¦, tâ‚™â€²)&emsp;Â whereÂ  táµ¢â€² = táµ¢[x â‰” F]</em><br><br><hr><br><br>Sequential â‰  Simultaneous:<br>&emsp;<em>(x + 2 Â· y)[x â‰” y][y â‰” x]&emsp;â‰ &emsp;(x + 2 Â· y)[x, y â‰” y, x]</em><br><br>Python (https://alhassy.github.io/PythonCheatSheet/CheatSheet.pdf), for example, has simultaneous <em>assignment</em>;<br>e.g., <code>x, y = y, x</code> is used to swap the value of two variables.<br><br><hr><br><br>A <em>function</em> <em>f</em> is a rule for computing a value from another value.<br><br>If we define <em>f&#8194; x = E</em> using an expression, then <em>function application</em> can be<br>defined using textual substitution: <em>f &#8194; X = E[x â‰” X]</em>. That is, expressions<br>can be considered functions of their variables ---but it is still expressions<br>that are the primitive idea, the building blocks.">Textual_Substitution</abbr> <abbr class="tooltip" title="How we prove a theorem <em>P&#8194; n</em> ranging over natural numbers <em>n</em>?<br><br>For instance, suppose the property <EM>P</EM> is that using only 3 and 5 dollar bills,<br>any amount of money that is at-least 8 dollars can be formed.<br><br>Since there are an infinite number of natural numbers, it is not possibly to<br>verify <em>P&#8194; n</em> is true by <em>evaluating</em> <em>P&#8194; n</em> at each natural number <em>n</em>.<br><br><strong>Knocking over dominos is induction:</strong><br>The natural numbers are like an infinite number of dominoes ---i.e., standing<br>tiles one after the other, in any arrangement. Can all dominoes be knocked over?<br>That is, if we construe <em>P&#8194; n</em> to mean â€œthe <em>n</em>-th domino can be knocked overâ€,<br>then the question is â€œis <em>âˆ€ n â€¢ P&#8194; n</em> trueâ€. Then, clearly if we can knock over<br>the first domino, <EM>P&#8194; 0</EM>, and if when a domino is knocked over then it also<br>knocks over the next domino, <em>P&#8194; n â‡’ P&#8194; (n + 1)</em>, then â€˜clearlyâ€™ all dominoes<br>will be knocked over. This â€˜basic observationâ€™ is known as <em>induction</em>.<br><br><strong>Climbing a ladder is induction:</strong><br>The natural numbers are like an infinite ladder ascending to heaven.&emsp;Can we<br>reach every step, rung, on the ladder?&emsp;That is, if we construe <em>P&#8194; n</em> to mean<br>â€œthe <em>n</em>-th rung is reachableâ€, then the question is â€œis <em>âˆ€ n â€¢ P&#8194; n</em><br>trueâ€. Then, clearly if we can reach the first rung, <EM>P&#8194; 0</EM>, and whenever we<br>climb to a rung then we can reach up and grab the next rung, <em>P&#8194; n â‡’ P&#8194; (n +<br>1)</em>, then â€˜clearlyâ€™ all rungs of the ladder can be reached. This â€˜basic<br>observationâ€™ is known as <em>induction</em>.<br><br><strong>Constant functions are induction:</strong><br>A predicate <EM>P : â„• â†’ ğ”¹</EM> is a function. When is such a function constantly the<br>value <em>\true</em>? That is, when is <em>âˆ€ n â€¢ P&#8194; n = \true</em>?&emsp;Clearly, if <EM>P</EM> starts<br>off being <em>\true</em> ---i.e., <em>P 0</em>--- and it preserves truth at every step ---i.e.,<br><em>P n â‡’ P (n + 1)</em>--- then <em>P n</em> will be true for any choice of <em>n</em>.<br><br>That is, if we consider <em>(â„•, â‰¤)</em> and <em>(ğ”¹, â‡’)</em> as ordered sets and <EM>P</EM> starts at<br>the â€˜topâ€™ of ğ”¹ ---i.e., <em>P 0 = true</em>--- and it is ascending ---i.e., <em>P n â‡’ P (n +<br>1)</em>--- and so â€˜never goes downâ€™, then clearly it must stay constantly at the top<br>value of ğ”¹. This â€˜basic observationâ€™ is known as <em>induction</em>.<br><br><br>âŸ¦ For the money problem, we need to start somewhere else besides 0. âŸ§<br><br><strong>Principle of (â€œWeakâ€) Mathematical Induction:</strong><br>To show that a property <EM>P</EM> is true for all natural numbers starting with some<br>number <em>n_0</em>, show the following two properties:<br>+ Base case :: Show that <em>P&#8194; nâ‚€</em> is true.<br>+ Inductive Step :: Show that whenever (the <strong>inductive hypothesis</strong>) <em>n</em> is a<br>&emsp;natural number that such that <em>n â‰¥ nâ‚€</em> and <em>P&#8194; n</em> is true, then <em>P&#8194; (n + 1)</em><br>&emsp;is also true.<br><br>âŸ¦ For the money problem, we need to be able to use the fact that to prove<br><em>P&#8194;(n + 1)</em> we must have already proven <EM>P</EM> for all smaller values. âŸ§<br><br><strong>Principle of (â€œStrongâ€) Mathematical Induction</strong>:<br>To show that a property <EM>P</EM> is true for all natural numbers starting with some<br>number <em>n_0</em>, show the following two properties:<br>+ Base case :: Show that <em>P&#8194; nâ‚€</em> is true.<br>+ Inductive Step :: Show that whenever (the <strong>inductive hypothesis</strong>) <em>n</em> is a<br>&emsp;natural number that such that <em>n â‰¥ nâ‚€</em> and <em>P&#8194; n_0, P&#8194; (n_0 + 1), P&#8194; (n_0 +<br>&emsp;2), â€¦, P&#8194; n</em> are true, then <em>P&#8194; (n + 1)</em> is also true.<br><br>âŸ¦ The â€˜strengthâ€™ of these principles refers to the strength of the inductive<br>hypothesis. The principles are provably equivalent. âŸ§<br><br># (It is also a way to say that â„• has non-empty meets.)<br><strong>The Least Number Principle (LNP) ---Another way to see induction:</strong><br>Every non-empty subset of the natural numbers must have a least element,<br>â€˜obviouslyâ€™. This is (strong) induction.<br># Possibly infinite!<br><br>Application of LNP to showing that algorithms terminate:<br>In particular, every decreasing non-negative sequence of integers<br><em>râ‚€ > râ‚ > râ‚‚ > â‹¯</em> must terminate.<br>#+end_box">Induction</abbr> <abbr class="tooltip" title="An <em>expression</em> is either a â€˜variableâ€™ or a â€˜function applicationâ€™; i.e., the name<br>of a function along with a number of existing expressions.<br><br> Expr ::= Constant&emsp;&emsp;-- E.g., 1 or â€œappleâ€<br>&emsp;&emsp;&emsp;|&emsp;Variable&emsp;&emsp;-- E.g., x or apple (no quotes!)<br>&emsp;&emsp;&emsp;|&emsp;Application -- E.g., f(xâ‚, xâ‚‚, â€¦, xâ‚™)<br><br>( One reads â€˜:=â€™ as <em>becomes</em> and so the addition of an extra colon results in a<br>â€˜stutterâ€™: One reads â€˜âˆ·=â€™ as <em>be-becomes</em>. The symbol â€˜|â€™ is read <em>or</em>. )<br><br>Notice that a constant is really just an application with <em>n</em> being <em>0</em> arguments<br>and so the first line in the definition above could be omitted.<br><br><hr><br><br>In a sense, an expression is like a sentence with the variables acting as<br>pronouns and the function applications acting as verb clauses and the argument<br>to the application are the participants in the action of the verbal clause.<br><br>A <strong>variable of type Ï„</strong> is a <em>name</em> denoting a yet unknown <em>value</em> of type Ï„;<br>i.e., â€œit is a pronoun (nickname) referring to a person in the collection of people Ï„â€.<br>E.g., to say <em>x</em> is an integer variable means that we may treat it<br>as if it were a number whose precise value is unknown.<br>Then, if we let =Expr Ï„= refer to the expressions denoting <em>values</em> of type Ï„;<br>then a <strong>meta-variable</strong> is simply a normal variable of type =Expr Ï„=.<br><br>That is, when we write phrases like =â€œLet E be an expressionâ€=, then the <em>name</em> <EM>E</EM><br>varies and so is a variable, but it is an expression and so may consist of a<br>function application or a variable. <strong>That is, <EM>E</EM> is a variable that may stand<br>for variables.</strong> This layered inception is resolved by referring to <EM>E</EM> as not<br>just any normal variable, but instead as a <strong>meta-variable</strong>: A variable capable of<br>referring to other (simpler) variables.<br><br><hr><br><br>Expressions, as defined above, are also known as <em>abstract syntax trees</em> (AST) or<br><em>prefix notation</em>. Then <em>textual substitution</em> is known as â€˜grafting treesâ€™ (a<br>monadic bind).<br><br>Their use can be clunky, such as by requiring many parentheses and implicitly<br>forcing a syntactic distinction between equivalent expressions; e.g.,<br><em>gcd(m,gcd(n,p))</em> and <em>gcd(gcd(m,n),p)</em> look difference even though <em>gcd</em> is<br>associative.<br><br>As such, one can declare <em>precedence levels</em> ---a.k.a. <em>binding power</em>--- to reduce<br>parentheses, one can declare fixity ---i.e., have arguments around operation<br>names---, and, finally, one can declare association ---whether sequential<br>instances of an operation should be read with implicit parenthesis to the right<br>or the to the left--- to reduce syntactic differences.&emsp;The resulting expression<br>are now known to be in a <em>concrete syntax</em> ---i.e., in a syntactic shape that is<br>more concrete.<br><br>That is, the <strong>conventions</strong> on how a <em>string</em> should be parsed as a <em>tree</em> are known as a<br><strong>precedence, fixity, and associativity rules.</strong><br><br>Similarly, not for operators but one treats <em>relations</em> <strong>conjunctionally</strong> to reduce<br>the number of â€˜andâ€™(âˆ§) symbols; e.g. <em>x â‰¤ y + 2 = z &#x2000;â‰¡&#x2000; x â‰¤ (y + 2) &#8194;âˆ§&#8194; (y + 2) = z</em>.<br>This is very useful to avoid repeating lengthy common expressions, such as <em>y + 2</em>.">Expression</abbr> <abbr class="tooltip" title="A <em>(Partial, resp. Total) Graph</em> <em>G = (V, E, src, tgt)</em> consists of<br>&emsp; + <EM>V</EM>, a set of â€œpoints, nodes, verticesâ€<br>&emsp; + <EM>E</EM>, a set of â€œarcs, edgesâ€<br>&emsp; + <em>src, tgt : E â†” V</em>, a pair of <em>partial (resp. total)</em> functions.<br><br>âŸ¦ Tersely put, in any category, a <em>graph</em> is a parallel pair of morphisms. âŸ§<br><br><em>Edge parallelism</em> is the relation <em>Î = src â¨¾ src Ë˜ âˆ© tgt â¨¾ tgtË˜</em>; two arcs are<br>related when they have the same starting point and the same ending point, which<br>both exist. Joyously, the name â€˜Îâ€™ is a neat reminder of the concept:<br>The name is three parallel lines, for the concept of edge(line) parallelism.<br><br>+ A graph is <em>total</em> exactly when <em>Id âŠ† Î</em>; and so Î is an equivalence.<br>+ A graph has <em>no parallel arrows</em> exactly when <em>Î âŠ† Id</em>.<br>+ A graph is <em>simple</em> exactly when <em>Î = Id</em>.<br><br>The <em>associated relation</em> is the relation <em>_âŸ¶_ = src Ë˜ â¨¾ tgt</em> that relates two nodes<br>when the first is the source of some edge that happens to have the second point<br>as its target. One uses the associated relation to study properties not<br>involving partial or parallel arrows. One writes <em>âŸµ</em> for <em>âŸ¶Ë˜</em>;<br>one writes âŸ¶â‹† for the <em>reachability</em> relation.<br><br>+ Node <em>y</em> is <em>reachable via a non-empty path</em> from node <em>x</em> exactly when <em>x âŸ¶âº y</em>.<br>&emsp;- Node <em>x</em> lies on a cycle exactly when <em>x âŸ¶âº x</em>.<br>&emsp;- A graph is <em>DAG, acylic, circuit-free,</em> exactly when <em>âŸ¶âº âŠ† âˆ¼Id</em>; i.e., <em>âŸ¶âº âˆ© Id = âŠ¥</em>.<br>&emsp;- An acyclic graph is a (<em>directed) forest</em> exactly when âŸ¶ is injective; i.e.,<br>&emsp;&emsp;every node has at most one predecessor; i.e., <em>âŸ¶ â¨¾ âŸµ âŠ† Id</em>.<br>+ A node <em>r</em> is a <em>root</em> exactly when every node is reachable from it; i.e., <em>{r} Ã— V âŠ† âŸ¶â‹†;</em><br>&emsp;i.e., <em>ğ•ƒ r â¨¾ âŸ¶â‹† = âŠ¤</em> where <em>ğ•ƒ r</em> is defined by <em>ğ•ƒ r = (â„ r)Ë˜</em> and <em>x ã€”â„ rã€• y &#8195;â‰¡&#8195; x = r</em>.<br>&emsp;- <em>xã€”ğ•ƒ r â¨¾ Rã€• y &#8195;â‰¡&#8195; rã€”Rã€• y</em> and <em>x ã€”R â¨¾ â„ rã€• y &#8195;â‰¡&#8195; x ã€”Rã€• r</em><br>&emsp;- A <em>tree</em> is a forest with a root.<br>+ A graph is <em>loop free</em> exactly when <em>âŸ¶ âŠ† âˆ¼Id</em>.<br>+ A graph is <em>strongly connected</em> exactly when <em>âŸ¶â‹† = âŠ¤</em>; i.e., <em>âˆ¼Id âŠ† âŸ¶âº</em>;<br>&emsp;i.e., every point is reachable from any <em>other</em> point; i.e., <em>âˆ¼Id âŠ† âŸ¶ âˆ© âŸµË˜</em>;<br>&emsp;i.e., any two distinct points lie on an undirected circuit.<br>&emsp;- The equivalence classes of <em>âŸ¶â‹† âˆ© âŸµâ‹†</em> are the <em>strongly connected components</em>.<br>+ <em>Terminalâˆ£sinks</em> are nodes from which it is <em>not</em> possible to proceed <em>any</em> further;<br>&emsp;i.e., terminals have no successors; the domain of <em>âˆ¼(âŸ¶ â¨¾ âŠ¤)</em> is all terminals.<br>+ <em>Initialâˆ£sources</em> are nodes from which it is <em>not</em> possible to proceed backward;<br>&emsp;i.e., initials have no predecessors; the domain of <em>âˆ¼(âŸµ â¨¾ âŠ¤)</em> is all initials.">Graph</abbr> <abbr class="tooltip" title="Language (Native Name) â€œHelloâ€<br>1. Amharic (áŠ áˆ›áˆ­áŠ›)	áˆ áˆ‹áˆ<br>2. Arabic (Ø§Ù„Ø¹Ø±Ø¨ÙŠÙ‘Ø©)	Ø§Ù„Ø³Ù‘Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ…<br>3. Armenian (Õ°Õ¡ÕµÕ¥Ö€Õ¥Õ¶)	Ô²Õ¡Ö€Ö‡ Õ±Õ¥Õ¦<br>4. Bengali (à¦¬à¦¾à¦‚à¦²à¦¾)	à¦¨à¦®à¦¸à§à¦•à¦¾à¦°<br>5. Braille	â “â ‘â ‡â ‡â •<br>6. Burmese (á€™á€¼á€”á€ºá€™á€¬)	á€™á€„á€ºá€¹á€‚á€œá€¬á€•á€«<br>7. C	printf (''Hello, world!\n'');<br>8. Cherokee (á£á³á© á¦á¬á‚á¯áá—)	á£áá² â•± áá²<br>9. Comanche â•±kÉ™ËˆmÃ¦ntÊƒiËâ•±	Haa marÊ‰Ìawe<br>10. Cree (á“€á¦áƒá”­ááá£)	á‘•á“‚á“¯ â•± á™á’‹á”®<br>11. Czech (ÄeÅ¡tina)	DobrÃ½ den<br>12. Danish (dansk)	Hej â•± Goddag â•± HallÃ¸j<br>13. Dutch (Nederlands)	Hallo â•± Dag<br>14. Efik&emsp;â•±ËˆÉ›fÉªkâ•±	MÉ”kÉ”m<br>15. Emacs	emacs --no-splash -f view-hello-file<br>16. Emoji	ğŸ‘‹<br>17. English â•±ËˆÉªÅ‹É¡lÉªÊƒâ•±	Hello<br>18. Esperanto	Saluton (EÄ¥oÅanÄo Ä‰iuÄµaÅ­de)<br>19. Estonian (eesti keel)	Tere pÃ¤evast â•± Tere Ãµhtust<br>20. Finnish (suomi)	Hei â•± HyvÃ¤Ã¤ pÃ¤ivÃ¤Ã¤<br>21. French (franÃ§ais)	Bonjour â•± Salut<br>22. Georgian (áƒ¥áƒáƒ áƒ—áƒ£áƒšáƒ˜)	áƒ’áƒáƒ›áƒáƒ áƒ¯áƒáƒ‘áƒ<br>23. German (Deutsch)	Guten Tag â•± GrÃ¼ÃŸ Gott<br>24. Greek (ÎµÎ»Î»Î·Î½Î¹ÎºÎ¬)	Î“ÎµÎ¹Î¬ ÏƒÎ±Ï‚<br>25. Greek, ancient (á¼‘Î»Î»Î·Î½Î¹ÎºÎ®)	ÎŸá½–Î»Î­ Ï„Îµ ÎºÎ±á½¶ Î¼Î­Î³Î± Ï‡Î±á¿–ÏÎµ<br>26. Gujarati (àª—à«àªœàª°àª¾àª¤à«€)	àª¨àª®àª¸à«àª¤à«‡<br>27. Hebrew (×¢Ö´×‘Ö°×¨Ö´×™×ª)	×©Ö¸××œ×•Ö¹×<br>28. Hungarian (magyar)	SzÃ©p jÃ³ napot!<br>29. Hindi (à¤¹à¤¿à¤‚à¤¦à¥€)	à¤¨à¤®à¤¸à¥à¤¤à¥‡ â•± à¤¨à¤®à¤¸à¥à¤•à¤¾à¤° à¥¤<br>30. Inuktitut (áƒá“„á’ƒá‘á‘á‘¦)	áŠáƒ<br>31. Italian (italiano)	Ciao â•± Buon giorno<br>32. Javanese (Jawa)	System.out.println(''Sugeng siang!'');<br>33. Kannada (à²•à²¨à³à²¨à²¡)	à²¨à²®à²¸à³à²•à²¾à²°<br>34. Khmer (á—á¶áŸá¶ááŸ’á˜áŸ‚áš)	á‡áŸ†ášá¶á”áŸá½áš<br>35. Lao (àºàº²àºªàº²àº¥àº²àº§)	àºªàº°àºšàº²àºàº”àºµ â•± àº‚à»à»ƒàº«à»‰à»‚àºŠàºàº”àºµ<br>36. Malayalam (à´®à´²à´¯à´¾à´³à´‚)	à´¨à´®à´¸àµà´•à´¾à´°à´‚<br>37. Maldivian (Ş‹Ş¨ŞˆŞ¬Ş€Ş¨)	Ş‡Ş¦Ş‡Ş°ŞŞ¦ŞŞ§Ş‰Şª Ş¢Ş¦ŞŞ¦Ş‡Ş¨Ş†ŞªŞ‰Ş° â•± Ş†Ş¨Ş€Ş¨Ş‚Ş¬Ş€Ş°ØŸ<br>38. Maltese (il-Malti)	BonÄ¡u â•± SaÄ§Ä§a<br>39. Mathematics	âˆ€ p âˆˆ world â€¢ hello p&emsp;â–¡<br>40. Mongolian (Ğ¼Ğ¾Ğ½Ğ³Ğ¾Ğ» Ñ…ÑĞ»)	Ğ¡Ğ°Ğ¹Ğ½ Ğ±Ğ°Ğ¹Ğ½Ğ° ÑƒÑƒ?<br>41. Norwegian (norsk)	Hei â•± God dag<br>42. Oriya (à¬“à­œà¬¿à¬†)	à¬¶à­à¬£à¬¿à¬¬à­‡<br>43. Polish&emsp;(jÄ™zyk polski)	DzieÅ„ dobry! â•± CzeÅ›Ä‡!<br>44. Russian (Ñ€ÑƒÑÑĞºĞ¸Ğ¹)	Ğ—Ğ´Ñ€Ğ°ÌĞ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ!<br>45. Sinhala (à·ƒà·’à¶‚à·„à¶½)	à¶†à¶ºà·”à¶¶à·à·€à¶±à·Š<br>46. Slovak (slovenÄina)	DobrÃ½ deÅˆ<br>47. Slovenian (slovenÅ¡Äina)	Pozdravljeni!<br>48. Spanish (espaÃ±ol)	Â¡Hola!<br>49. Swedish (svenska)	Hej â•± Goddag â•± HallÃ¥<br>50. Tamil (à®¤à®®à®¿à®´à¯)	à®µà®£à®•à¯à®•à®®à¯<br>51. Telugu (à°¤à±†à°²à±à°—à±)	à°¨à°®à°¸à±à°•à°¾à°°à°‚<br>52. TaiViet (êªêª«êª±êª£ êª¼êª•)	êª…êª°êª™ê«‚ êª¨êª®ê«‚ êªêª«êª± â•± êª…êª½ êª¨êª· êªêª«êª±<br>53. Thai (à¸ à¸²à¸©à¸²à¹„à¸—à¸¢)	à¸ªà¸§à¸±à¸ªà¸”à¸µà¸„à¸£à¸±à¸š â•± à¸ªà¸§à¸±à¸ªà¸”à¸µà¸„à¹ˆà¸°<br>54. Tibetan (à½–à½¼à½‘à¼‹à½¦à¾à½‘à¼‹)	à½–à½€à¾²à¼‹à½¤à½²à½¦à¼‹à½–à½‘à½ºà¼‹à½£à½ºà½‚à½¦à¼<br>55. Tigrigna (á‰µáŒáˆ­áŠ›)	áˆ°áˆ‹áˆ›á‰µ<br>56. Turkish (TÃ¼rkÃ§e)	Merhaba<br>57. Ukrainian (ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ°)	Ğ’Ñ–Ñ‚Ğ°Ñ<br>58. Vietnamese (tiáº¿ng Viá»‡t)	ChÃ o báº¡n<br>59. Japanese (æ—¥æœ¬èª)	ã“ã‚“ã«ã¡ã¯ â•± ï½ºï¾ï¾†ï¾ï¾Š<br>60. Chinese (ä¸­æ–‡,æ™®é€šè¯,æ±‰è¯­)	ä½ å¥½<br>61. Cantonese (ç²µèª,å»£æ±è©±)	æ—©æ™¨, ä½ å¥½<br>62. Korean (í•œê¸€)	ì•ˆë…•í•˜ì„¸ìš” â•± ì•ˆë…•í•˜ì‹­ë‹ˆê¹Œ<br><hr><br>This list was generated by pressing <code>C-h h</code> in Emacs, <code>view-hello-file</code>.">Hello</abbr> <abbr class="tooltip" title="">temp</abbr> <abbr class="tooltip" title="zsh:1: command not found: wn<br>">Hussain</abbr> <abbr class="tooltip" title="zsh:1: command not found: wn<br>">family</abbr> <abbr class="tooltip" title="Thread FORMS elements as the first argument of their successor.<br>Example:<br>&emsp;&emsp;(thread-first<br>&emsp;&emsp;&emsp;5<br>&emsp;&emsp;&emsp;(+ 20)<br>&emsp;&emsp;&emsp;(<em> 25)<br>&emsp;&emsp;&emsp;-<br>&emsp;&emsp;&emsp;(+ 40))<br>Is equivalent to:<br>&emsp;&emsp;(+ (- (</em> (+ 5 20) 25)) 40)<br>Note how the single â€˜-â€™ got converted into a list before<br>threading.<br><br>(fn &rest FORMS)">thread-first</abbr> <abbr class="tooltip" title="Show an OctoIcon: home, link, mail, report, tag, clock">o-link/octoicon</abbr> <abbr class="tooltip" title="Call FUNCTION with our remaining args, using our last arg as list of args.<br>Then return the value FUNCTION returns.<br>With a single argument, call the argumentâ€™s first element using the<br>other elements as args.<br>Thus, (apply '+ 1 2 '(3 4)) returns 10.<br><br>(fn FUNCTION &rest ARGUMENTS)">apply</abbr> <abbr class="tooltip" title="zsh:1: command not found: wn<br>">test</abbr>
</p>
</div>
</div>

<div id="outline-container-org60b7244" class="outline-2">
<h2 id="org60b7244"><span class="section-number-2">2.</span> å„ç§é“¾æ¥</h2>
<div class="outline-text-2" id="text-2">
<p>
<kbd style="">xboldcolor</kbd>  <code>*&lt;pink: super neato stuff&gt;*</code> -&gt; <b><span style="color:pink;"> super neato stuff</span></b>
</p>

<p>
<kbd style="">xlinkhere</kbd> æœ¬åœ°é”šç‚¹: <a class="anchor" aria-hidden="true" id="test-link-here-links" href="#test-link-here-links"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16
   16" width="16" height="16"><path fill-rule="evenodd"
   d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69
   3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10
   5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0
   2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5
   0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55
   13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> ç‚¹å‡»åæ³¨æ„ URL <code>#</code> åé¢
å†…å®¹çš„å˜åŒ–ã€‚
</p>

<p>
<kbd style="">xicon</kbd> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M16 9l-3-3V2h-2v2L8 1 0 9h2l1 5c0 .55.45 1 1 1h8c.55 0 1-.45 1-1l1-5h2zm-4 5H9v-4H7v4H4L2.81 7.69 8 2.5l5.19 5.19L12 14z"></path></svg> ä¼šæ˜¾ç¤ºä¸€ä¸ªä¸»é¡µ Icon <abbr class="tooltip" title="Show an OctoIcon: home, link, mail, report, tag, clock">o-link/octoicon</abbr> ã€‚
</p>

<p>
<kbd style="">xbadge</kbd> <code>&lt;badge: Emacs | is awesome | blue |
https://www.google.com/search?q=hello%20world | gnu-emacs&gt;</code> å¯¼å‡ºæˆ <a href="https://www.google.com/search?q=hello%20world"><img src="https://img.shields.io/badge/Emacs-is%20awesome-blue?logo=gnu-emacs"></a>
</p>

<p>
<abbr class="tooltip" title="Thread FORMS elements as the first argument of their successor.<br>Example:<br>&emsp;&emsp;(thread-first<br>&emsp;&emsp;&emsp;5<br>&emsp;&emsp;&emsp;(+ 20)<br>&emsp;&emsp;&emsp;(<em> 25)<br>&emsp;&emsp;&emsp;-<br>&emsp;&emsp;&emsp;(+ 40))<br>Is equivalent to:<br>&emsp;&emsp;(+ (- (</em> (+ 5 20) 25)) 40)<br>Note how the single â€˜-â€™ got converted into a list before<br>threading.<br><br>(fn &rest FORMS)">thread-first</abbr> Lisp å‡½æ•°å®šä¹‰
</p>

<p>
<abbr class="tooltip" title="zsh:1: command not found: wn<br>">family</abbr> English å«ä¹‰
</p>

<p>
<abbr class="tooltip" title="Hussein ibn Ali is the grandson of Prophet Muhammad, who is known to have<br>declared <strong>â€œHussain is from me and I am from Hussain; God loves whoever loves Hussain.â€</strong><br><br>He is honoured as â€œThe Chief of Martyrsâ€ for his selfless stand for social justice<br>against Yazid, the corrupt 7áµ—Ê° caliph. The Karbala Massacre is commemorated annually<br>in the first Islamic month, Muharram, as a reminder to stand against oppression and tyranny;<br>Jesus Christ, son of Mary, makes an indirect appearance in the story.<br><br>A terse summary of the chain of events leading to the massacre may be found at<br>https://www.al-islam.org/articles/karbala-chain-events.<br><br>An elegant English recitation recounting the Karbala Massacre may be found at<br>https://youtu.be/2i9Y3Km6h08 ---â€œArbaeen Maqtal - Sheikh Hamam Nassereddine - 1439â€.<br><hr><br> <strong>Charles Dickens:</strong> <em>â€œIf Hussain had fought to quench his worldly desires...then I</em><br><em>do not understand why his sister, wife, and children accompanied him. It stands<br>to reason therefore, that he sacrificed purely for Islam.â€</em><br><br><strong>Gandhi:</strong> <em>â€œI learned from Hussain how to achieve victory while being oppressed.â€</em><br><br><strong>Thomas Carlyle:</strong> <em>â€œThe victory of Hussein, despite his minority, marvels me.â€</em><br><br><strong>Thomas Masaryk:</strong> <em>â€œAlthough our clergies also move us while describing the<br>Christ's sufferings, but the zeal and zest that is found in the followers of</em><br><em>Hussain will not be found in the followers of Christ. And it seems that the<br>suffering of Christ against the suffering of Hussain is like a blade of straw</em> <em>in<br>front of a huge mountain.â€</em>">Hussain</abbr> ä¸ªäººæ–‡æ¡£æè¿°
</p>
</div>
</div>

<div id="outline-container-orgd19b976" class="outline-2">
<h2 id="orgd19b976"><span class="section-number-2">3.</span> link here head</h2>
<div class="outline-text-2" id="text-3">
<p>
<span id="test-link-here-links"></span>
</p>

<p>
<img src="https://img.shields.io/badge/Thanks-for_reading-nil?logo=nil">
<a href="https://twitter.com/intent/tweet?text=This looks super neat (â€¢Ì€á´—â€¢Ì)Ùˆ::&url=https://github.com/gcclll/blog.cheng92.com"><img src="https://img.shields.io/twitter/url?url=https://github.com/gcclll/blog.cheng92.com"></a>
<a href="https://www.cheng92.com"><img src="https://img.shields.io/badge/-buy_me_a_coffee-gray?logo=buy-me-a-coffee"></a>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Zhicheng Lee</p>
<p class="date">Created: 2022-02-22 Tue 11:07</p>
</div>
</body>
</html>
