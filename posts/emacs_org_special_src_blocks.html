<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-02-22 Tue 11:07 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>emacs org-special-src-blocks</title>
<meta name="author" content="Zhicheng Lee" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
</style>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>

        <style>
        /* From: https://endlessparentheses.com/public/css/endless.css */
        /* See also: https://meta.superuser.com/questions/4788/css-for-the-new-kbd-style */
        kbd
        {
          -moz-border-radius: 6px;
          -moz-box-shadow: 0 1px 0 rgba(0,0,0,0.2),0 0 0 2px #fff inset;
          -webkit-border-radius: 6px;
          -webkit-box-shadow: 0 1px 0 rgba(0,0,0,0.2),0 0 0 2px #fff inset;
          background-color: #f7f7f7;
          border: 1px solid #ccc;
          border-radius: 6px;
          box-shadow: 0 1px 0 rgba(0,0,0,0.2),0 0 0 2px #fff inset;
          color: #333;
          display: inline-block;
          font-family: 'Droid Sans Mono', monospace;
          font-size: 80%;
          font-weight: normal;
          line-height: inherit;
          margin: 0 .1em;
          padding: .08em .4em;
          text-shadow: 0 1px 0 #fff;
          word-spacing: -4px;
        
          box-shadow: 2px 2px 2px #222; /* MA: An extra I've added. */
        }
        </style>
        <link rel="stylesheet" type="text/css" href="https://alhassy.github.io/org-special-block-extras/tooltipster/dist/css/tooltipster.bundle.min.css"/>
        
        <link rel="stylesheet" type="text/css" href="https://alhassy.github.io/org-special-block-extras/tooltipster/dist/css/plugins/tooltipster/sideTip/themes/tooltipster-sideTip-punk.min.css" />
        
        <script type="text/javascript">
            if (typeof jQuery == 'undefined') {
                document.write(unescape('%3Cscript src="https://code.jquery.com/jquery-1.10.0.min.js"%3E%3C/script%3E'));
            }
        </script>
        
         <script type="text/javascript"            src="https://alhassy.github.io/org-special-block-extras/tooltipster/dist/js/tooltipster.bundle.min.js"></script>
        
          <script>
                 $(document).ready(function() {
                     $('.tooltip').tooltipster({
                         theme: 'tooltipster-punk',
                         contentAsHTML: true,
                         animation: 'grow',
                         delay: [100,500],
                         // trigger: 'click'
                         trigger: 'custom',
                         triggerOpen: {
                             mouseenter: true
                         },
                         triggerClose: {
                             originClick: true,
                             scroll: true
                         }
         });
                 });
             </script>
        
        <style>
           abbr {color: red;}
        
           .tooltip { border-bottom: 1px dotted #000;
                      color:red;
                      text-decoration: none;}
        </style>
</head>
<body>
<div id="content" class="content">
<h1 class="title">emacs org-special-src-blocks</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org523d563">1. Minimal working example</a></li>
<li><a href="#org60b7244">2. 各种链接</a></li>
<li><a href="#orgd19b976">3. link here head</a></li>
</ul>
</div>
</div>
<p>
<a href="/"><img src="https://img.shields.io/badge/GCCLL-Homepage-green?logo=gnu-emacs"></a>
</p>

<p>
Examples: 或 <a href="https://alhassy.github.io/org-special-block-extras/">org-special-block-extras</a>
</p>

<div id="outline-container-org523d563" class="outline-2">
<h2 id="org523d563"><span class="section-number-2">1.</span> Minimal working example</h2>
<div class="outline-text-2" id="text-1">
<div style="column-rule-style: none;column-count: 2;">
<p>
<span style="color:orange;">Are you excited to learn some Lisp?</span> <span style="color:blue;">Yes!</span>
</p>

<p>
Pop-quiz: How does <abbr class="tooltip" title="Call FUNCTION with our remaining args, using our last arg as list of args.<br>Then return the value FUNCTION returns.<br>With a single argument, call the argument’s first element using the<br>other elements as args.<br>Thus, (apply '+ 1 2 '(3 4)) returns 10.<br><br>(fn FUNCTION &rest ARGUMENTS)">apply</abbr> work?
</p>

</div>

<details class="code-details"
                 style ="padding: 1em;
                          background-color: #e5f5e5;
                          /* background-color: pink; */
                          border-radius: 15px;
                          color: hsl(157 75%);
                          font-size: 0.9em;
                          box-shadow: 0.05em 0.1em 5px 0.01em  #00000057;">
                  <summary>
                    <strong>
                      <font face="Courier" size="3" color="green">
                         Answer
                      </font>
                    </strong>
                  </summary>
<p>
<a class="anchor" aria-hidden="true" id="solution" href="#solution"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16
   16" width="16" height="16"><path fill-rule="evenodd"
   d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69
   3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10
   5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0
   2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5
   0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55
   13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>
Syntactically, <code>(apply f '(x0 ... xN)) = (f x0 ... xN)</code>.
</p>

<p>
<p style="color: black;"><span style="border-width:1px;border-style:solid;padding:5px"><strong>[Musa:</strong></span> Ain&rsquo;t that cool?  <span style="border-width:1px;border-style:solid;padding:5px"><strong>]</strong></span></p>
</p>

<style> #g215 {color: aqua; background-color:aqua;}
       #g215:hover {color: black; background-color:white;} </style>
<p>
That is, <span style="color:magenta;">we can <span id="g215"> apply </span> a function to a list of arguments!</span>
</p>





</details>

<br>
<div style="padding: 1em; background-color: #CCFFCC;border-radius: 15px; font-size: 0.9em; box-shadow: 0.05em 0.1em 5px 0.01em #00000057;"><h3></h3>
<p>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M0 2a1 1 0 011-1h14a1 1 0 011 1v9a1 1 0 01-1 1H7l-4 4v-4H1a1 1 0 01-1-1V2zm1 0h14v9H6.5L4 13.5V11H1V2zm6 6h2v2H7V8zm0-5h2v4H7V3z"></path></svg> Note that <abbr class="tooltip" style="border: none; text-decoration: none;" title="C-x C-e ∷ eros-eval-last-sexp<br>Wrapper for ‘eval-last-sexp’ that overlays results.<br><br>(fn EVAL-LAST-SEXP-ARG-INTERNAL)"><kbd style="border-color: red">C-x C-e</kbd></abbr> evaluates a Lisp form!
</p>

</div>

<p>
<abbr class="tooltip" title="This property generalises injectivity, univalence, and equivalence...<br><br>Recall,<br>- Univalent: Every source value <em>x</em> is associated <strong>at most one</strong> target value <em>y</em>.<br>&emsp;&emsp;+ I.e., if <em>x</em> goes to <em>y</em> and <em>y′</em> then <em>y = y′</em>.<br>&emsp;&emsp;+ I.e., <em>∀ x, y′, y •&#x2000;&emsp;x 〔R〕 y&emsp;〔R˘〕 x 〔R〕 y′ &#8195;⇒&#8195; y 〔Id〕 y′</em><br>- Injective: Every source value <em>y</em> is associated <strong>at most</strong> one source value <em>x</em>.<br>&emsp;&emsp;+ I.e., if <em>y</em> comes from <em>x</em> and <em>x′</em> then <em>x = x′</em>.<br>&emsp;&emsp;+ I.e., <em>∀ x, x′, y •&#x2000;&emsp;x 〔R〕 y&emsp;〔R˘〕 x′ 〔R〕 y &#8195;⇒&#8195; x 〔Id〕 x′</em><br>- Equivalence: Any given equivalence classes are either identical or disjoint.<br>&emsp;&emsp;&emsp;# + I.e., <em>∀ x, y •&#x2000;&emsp;x 〔R〕 y&emsp;〔R˘〕 x 〔R〕 y′ &#8195;⇒&#8195; x 〔R〕 y′</em><br>&emsp;&emsp;+ Moreover, it is a <em>homogenous</em> relation.<br><br> Now, a <em>possibly heterogenous</em> relation <em>R</em> is <em>difunctional</em> exactly when<br> <em>∀ x, x′, y′, y •&#x2000;&emsp;x 〔R〕 y&emsp;〔R˘〕 x′ 〔R〕 y′ &#8195;⇒&#8195; x 〔R〕 y′</em>.<br> That is, <EM>R ⨾ R ˘ ⨾ R ⊆ R</EM>; in-fact we have equality <EM>R ⨾ R ˘ ⨾ R = R</EM>.<br> Using Schröder, this amounts to <EM>R ⨾ ∼R ˘ ⨾ R &#8195;⊆&#8195; ∼R</EM>.<br><br> Clearly, converse preserves difunctionality.<br><br> For difunctional <em>R</em>,<br> 1. <em>R ⨾ (Q ∩ R˘ ⨾ S) = R ⨾ Q ∩ R ⨾ R˘ ⨾ S</em><br> 2. <EM>R ⨾ ∼(R ˘ ⨾ Q) &#8195;=&#8195; R ⨾ ⊤ ∩ ∼(R ⨾ R˘ Q)</EM><br> 3. <em>∼(R ⨾ R ˘ ⨾ Q) &#8195;=&#8195; R ⨾ ∼(R˘ ⨾ Q) ∪ ∼(R ⨾ ⊤)</em><br> 4. <EM>R ⨾ ∼(R ˘ ⨾ Q) &#8195;=&#8195; ∼(R ⨾ R˘ Q)</EM>, if <em>R</em> is also total.<br><br>Where <em>⨾, ⊤, ⊥, Id, ˘, ∼</em> are relation composition, the universal relation, the<br>empty relation, the identity relation, relation converse (transpose), and complement.<br><hr><br>The equivalence target-saturation of a univalent relation is difunctional; i.e.,<br>if <em>R</em> is univalent and Ξ is an equivalence, then <EM>R ⨾ Ξ</EM> is difunctional.">Difunctional</abbr> <abbr class="tooltip" title="An <strong>iso</strong> is a bijective mapping, also known as a <strong>permutation.</strong><br><br>An isomorphism is a non-lossy protocol associating inputs to outputs.<br><hr><br>A relation <EM>R : V → V</EM> can be visualised as a drawing: A dot for each element<br><em>x</em> of <EM>V</EM>, and a directed line <em>x ⟶ y</em> between two points exactly when <em>x 〔R〕<br>y</em>. That is relations are <em>simple graphs</em>; one refers to the directed lines<br>as <em>edges</em> and the dots as <em>nodes</em>.<br><br>As a simple graph, an iso is a <em>bunch of circles</em>: Any number of cycles, such that<br>every node lies on exactly one.<br><hr><br>If relation <EM>R</EM> is finite, then<br><em>R ⨾ R ˘ = Id &#x2000;≡&#x2000;&emsp;(∃ m • Rᵐ = Id ∧ Rᵐ⁻¹ = R ˘)</em><br><br>Where <em>⨾, ⊤, ⊥, Id, ˘, ∼</em> are relation composition, the universal relation, the<br>empty relation, the identity relation, relation converse (transpose), and complement.">Iso</abbr> <abbr class="tooltip" title="<strong>Bijective:</strong> <em>Every source value y is associated <strong>exactly one</strong> source value x.</em><br><br>&emsp; <EM>R</EM> is bijective<br>≡&emsp;<EM>R</EM> is injective and surjective<br><hr><br>A relation <EM>R : V → V</EM> can be visualised as a drawing: A dot for each element<br><em>x</em> of <EM>V</EM>, and a directed line <em>x ⟶ y</em> between two points exactly when <em>x 〔R〕<br>y</em>. That is relations are <em>simple graphs</em>; one refers to the directed lines<br>as <em>edges</em> and the dots as <em>nodes</em>.<br><br>As a simple graph, bijectivity means: <em>Every node has exactly one outgoing edge</em>.">Bijective</abbr> <abbr class="tooltip" title="<strong>Injective:</strong> <em>Every source value y is associated <strong>at most</strong> one source value x.</em><br><hr><br>A relation <EM>R : V → V</EM> can be visualised as a drawing: A dot for each element<br><em>x</em> of <EM>V</EM>, and a directed line <em>x ⟶ y</em> between two points exactly when <em>x 〔R〕<br>y</em>. That is relations are <em>simple graphs</em>; one refers to the directed lines<br>as <em>edges</em> and the dots as <em>nodes</em>.<br><br>As a simple graph, injective means: <em>Every node has at most one incoming edge.</em><br><hr><br>&emsp; <EM>R</EM> is injective<br>≡&emsp;<EM>R˘</EM> is univalent<br>≡&emsp;<em>R&emsp;⨾ R ˘ ⊆ Id</em><br>≡&emsp;<em>∼ Id ⨾ R &#8195;⊆&#8195; ∼ R</em><br><br>Where <em>⨾, ⊤, ⊥, Id, ˘, ∼</em> are relation composition, the universal relation, the<br>empty relation, the identity relation, relation converse (transpose), and complement.">Injective</abbr> <abbr class="tooltip" title="<strong>Surjective:</strong> <em>Every source value y is associated <strong>at least</strong> one source value x.</em><br><hr><br>A relation <EM>R : V → V</EM> can be visualised as a drawing: A dot for each element<br><em>x</em> of <EM>V</EM>, and a directed line <em>x ⟶ y</em> between two points exactly when <em>x 〔R〕<br>y</em>. That is relations are <em>simple graphs</em>; one refers to the directed lines<br>as <em>edges</em> and the dots as <em>nodes</em>.<br><br>As a simple graph, surjectivity means: <em>Every node has at least one incoming edge.</em><br><hr><br>&emsp; <EM>R</EM> is surjective<br>≡&emsp;<EM>R˘</EM> is total<br>≡&emsp;<em>⊤ ⨾ R = ⊤</em><br>≡&emsp;<em>Id ⊆ R ˘ ⨾ R</em><br>≡&emsp;<em>∼ R &#8195;⊆&#8195; ∼ Id ⨾ R</em><br>≡&emsp;<em>∀ S • R ⨾ S = ⊥ ≡ S = ⊥</em><br><br>Where <em>⨾, ⊤, ⊥, Id, ˘, ∼</em> are relation composition, the universal relation, the<br>empty relation, the identity relation, relation converse (transpose), and complement.">Surjective</abbr> <abbr class="tooltip" title="<strong>Map (totally defined function):</strong> <em>Every source value x is associated <strong>exactly one</strong><br>target value y.</em><br><hr><br>A relation <EM>R : V → V</EM> can be visualised as a drawing: A dot for each element<br><em>x</em> of <EM>V</EM>, and a directed line <em>x ⟶ y</em> between two points exactly when <em>x 〔R〕<br>y</em>. That is relations are <em>simple graphs</em>; one refers to the directed lines<br>as <em>edges</em> and the dots as <em>nodes</em>.<br><br>As a simple relation, being a mapping means: <em>Every node has exactly one outgoing edge.</em><br><hr><br>&emsp; <EM>F</EM> is a map<br>≡&emsp;<EM>F</EM> is total and univalent<br>≡&emsp;<em>F ⨾ ∼ Id &#8195;=&#8195; ∼ F</em><br>≡&emsp;<em>∀ S • F ⨾ ∼ S &#8195;=&#8195; ∼ (F ⨾ S)</em><br><br>Where <em>⨾, ⊤, ⊥, Id, ˘, ∼</em> are relation composition, the universal relation, the<br>empty relation, the identity relation, relation converse (transpose), and complement.<br><hr><br>The final rule says <em>the preimage of the complement is the complement of the<br>preimage</em>; or, using conventional direct image notation, <em>f⁻¹(∼ A) &#8195;=&#8195; ∼<br>f⁻¹(A)</em>.<br><br>In conventional direct image notation, this amount to a Galois connection: <em>A ⊆<br>f⁻¹(B) &#x2000;≡&#x2000; f(A) ⊆ B</em>.<br><br>A mapping is so very close to being invertible since mappings <EM>F</EM> always<br>satisfy: <em>F ˘ ⨾ F ⊆ Id</em> and <em>Id ⊆ F ⨾ F˘</em>.<br><br>Shunting rule:* If <EM>F</EM> is a map, then <em>R ⊆ S ⨾ F ˘ &#x2000;≡&#x2000; R ⨾ F ⊆ S</em>.<br><br>More generally, given an equivalence Ξ, if relation <em>F</em> is total and Ξ-univalent<br>---i.e., <em>F˘ ⨾ F ⊆ Ξ</em>--- and if <em>S</em> is Ξ-target-saturated ---i.e., <em>S ⨾ Ξ = S</em>---<br>then <em>R ⊆ S ⨾ F ˘ &#x2000;≡&#x2000; R ⨾ F ⊆ S</em>.">Map</abbr> <abbr class="tooltip" title="<strong>Total:</strong> <em>Every source value x is associated <strong>at least one</strong> target value y.</em><br><hr><br>A relation <EM>R : V → V</EM> can be visualised as a drawing: A dot for each element<br><em>x</em> of <EM>V</EM>, and a directed line <em>x ⟶ y</em> between two points exactly when <em>x 〔R〕<br>y</em>. That is relations are <em>simple graphs</em>; one refers to the directed lines<br>as <em>edges</em> and the dots as <em>nodes</em>.<br><br>As a simple graph, totality means: <em>Every node has at least one outgoing edge</em>.<br><br>&emsp; <EM>R</EM> is total<br>≡&emsp;<em>∀ x • ∃ y • x 〔 R 〕 y</em><br>≡&emsp;<em>⊤ = R ⨾ ⊤</em> (“defined everywhere”)<br>≡&emsp;<em>⊥ = ∼ (R ⨾ ⊤)</em><br>≡&emsp;<em>Id ⊆ R ⨾ R ˘</em><br>≡&emsp;<em>∼ R &#8195;⊆&#8195; R ⨾ ∼ Id</em><br>≡&emsp;<em>∀ S • ∼ (R ⨾ S) &#8195;⊆&#8195; R ⨾ ∼ S</em><br>≡&emsp;<em>∀ Q • Q ⨾ R = ⊥ ≡ Q = ⊥</em><br><br>Where <em>⨾, ⊤, ⊥, Id, ˘, ∼</em> are relation composition, the universal relation, the<br>empty relation, the identity relation, relation converse (transpose), and complement.<br><hr><br>The formula <em>∼ R &#8195;⊆&#8195; R ⨾ ∼ Id</em> reads “If <em>x</em> is not <em>R</em>-related to y, then <em>x</em> is <em>R</em><br>related to some element different from <em>y</em>.”&emsp;It continues to hold when we replace<br>the identity by an arbitrary relation.<br><br>The final formula says that <EM>R</EM> is post-annihilated by the empty relation only.<br><br>Note: <em>∼(R ⨾ ⊤) = ⊤ &#8195;≡&#8195; R = ⊥</em>, for any <EM>R</EM>; i.e., <em>the complement of a<br>relation's domain is everything precisely when the relation is empty.</em>">Total</abbr> <abbr class="tooltip" title="<strong>Univalent (partially defined function):</strong> <em>Equal elements are related to equal<br>elements; i.e., an element cannot be related to two different elements.</em><br><br><em>That is, every source value x is associated <strong>at most one</strong> target value y.</em><br><hr><br>A relation <EM>R : V → V</EM> can be visualised as a drawing: A dot for each element<br><em>x</em> of <EM>V</EM>, and a directed line <em>x ⟶ y</em> between two points exactly when <em>x 〔R〕<br>y</em>. That is relations are <em>simple graphs</em>; one refers to the directed lines<br>as <em>edges</em> and the dots as <em>nodes</em>.<br><br>As a simple graph, univalence means: <em>Any arcs from the same source actually coincide.</em><br>That is, <em>Every node has at most one outgoing edge.</em><br><hr><br>&emsp; <EM>R</EM> is univalent<br>≡&emsp;<em>∀ x, y, y′&emsp;• x 〔 R 〕 y ∧ x 〔R〕 y′&emsp;⇒ y = y′</em><br>≡&emsp;<em>R ˘ ⨾ R&emsp;⊆ Id</em><br>≡&emsp;<em>R ⨾ ∼ Id &#8195;⊆&#8195; ∼ R</em><br>≡&emsp;<em>∀ S • R ⨾ ∼ S &#8195;⊆&#8195; ∼ (R ⨾ S)</em><br>≡&emsp;<em>∀ S • R ⨾ ∼ S = R ⨾ ⊤ ∩ ∼(R ⨾ S)</em><br>≡&emsp;<em>∀ Q, S •&emsp;R ⨾ (Q ∩ S) = R ⨾ Q ∩ R ⨾ S</em>&emsp; ---c.f., ⨾ sub-distributes over ∩<br>≡&emsp;<em>∀ Q, S • Q⨾R ∩ S = (Q ∩ S ⨾ R˘)⨾R</em>&emsp;&emsp;&emsp; ---c.f., the Dedekind rule<br><br>Where <em>⨾, ⊤, ⊥, Id, ˘, ∼</em> are relation composition, the universal relation, the<br>empty relation, the identity relation, relation converse (transpose), and complement.<br><hr><br>The formula <em>R ⨾ ∼ Id &#8195;⊆ ∼ R</em> reads “If <em>x</em> is <em>R</em>-related to a value different<br>from <em>y</em>, then it is not <em>R</em>-related to <em>y</em>.”&emsp;It continues to hold when we replace<br>the identity by an arbitrary relation.<br><br>The 5th row reads, <em>the preimage of the complement is the same as the complement<br>of the preimage intersected with the domain</em>.&emsp;In fact, for univalent <EM>R</EM>, we<br>also have <em>∼(R ⨾ S) = R ⨾ ∼ S ∪ ∼(R ⨾ ⊤)</em>; e.g., the people who do “not (own an<br>Audi car)” are exactly the people who “(own a non-Audi car) or do not(own any<br>car)” ---assuming a person can own at most one car.<br><br>For a map <em>f</em>, the 6th row becomes: <em>f(A ∩ B) &#8195;=&#8195; f(A) ∩ f(B)</em>, using<br>conventional direct image notation; i.e., for a function, <em>the preimage of an<br>intersection is the intersection of preimages</em>.<br><br>Likewise, for a map <em>f</em>, we have <em>the intersection of <EM>B</EM> with a function's image<br>is the same as the image of an intersection involving the preimage of <EM>B</EM></em>; i.e.,<br><em>f(A) ∩ B = f(A ∩ f^{-1}(B))</em>.">Univalent</abbr> <abbr class="tooltip" title="/Any two different members are related/; (the associated graph can be drawn<br>similar to a line).<br><br>( In graph terminology, semilinear is also referred to as <em>complete</em>; e.g., <em>“the<br>complete graph on n nodes”</em> refers to <em>⊤ ∩ ∼Id : 1..n ↔ 1..n</em>. )<br><br>&emsp; <EM>R</EM> is semilinear<br>≡&emsp;<em>∀ x, y • x ≠ y&emsp;⇒&emsp;x 〔R〕 y&emsp;∨&emsp;y 〔R〕 x</em><br>≡&emsp;<em>∼Id ⊆ R ∪ R ˘</em><br>≡&emsp;<em>∼ R ⊆ R ˘ ∪ Id</em><br>≡&emsp;<em>∼ R</em> is antisymmetric<br><br>Where <em>⨾, ⊤, ⊥, Id, ˘, ∼</em> are relation composition, the universal relation, the<br>empty relation, the identity relation, relation converse (transpose), and complement.<br><br>A relation without incomparable elements is semilinear.<br><br>A semilinear and asymmetric relation <EM>R</EM> is known as a <em>tournament</em> since it<br>models the win-loss situation of a typical sports tournament: Semilinearity and<br>asymmetry ensure teams do not play against themselves and that there is no draw<br>---i.e., there must be a winner. A tournament <em>R</em> is characterised by <em>R ∪ R˘ =<br>∼Id</em>.">Semilinear</abbr> <abbr class="tooltip" title="/Any two (possibly identical) members are related/; (the associated<br>graph can be drawn <em>similar</em> to a line; i.e., the nodes can be arranged in a<br>sequence).<br><br>( In graph terminology, linear is also referred to as <em>strongly complete</em>. )<br><br>( Sometimes a linear <em>order</em> is called a <em>complete order</em>. )<br><br>&emsp; <EM>R</EM> is linear<br>≡&emsp;<em>∀ x, y • x 〔R〕 y&emsp;∨&emsp;y 〔R〕 x</em><br>≡&emsp;<em>⊤ ⊆ R ∪ R ˘</em><br>≡&emsp;<em>∼ R ⊆ R ˘</em><br>≡&emsp;<em>∼ R</em> is asymmetric<br><br>Where <em>⨾, ⊤, ⊥, Id, ˘, ∼</em> are relation composition, the universal relation, the<br>empty relation, the identity relation, relation converse (transpose), and complement.<br><hr><br>A linear <em>order</em> corresponds to a full upper triangular matrix, <em>after</em> suitably<br>arranging rows and columns. A linear (pre)-<em>order</em> has no (distinct) incomparable<br>elements.<br><br>Any linear ordering <em>E</em>, with associated strict order <em>C</em>, satisfies <EM>C˘ = ∼E</EM>;<br>i.e., any linear order ‘⊑’ satisfies <em>∀ x, y •&#x2000; ¬ (x ⊑ y) &#8195;≡&#8195; y ⊏ x</em>.<br><br>Likewise, for liner order, we have <em>transitivity E⨾C⨾E = C</em> and <em>weakening C ⊆ E</em>;<br>i.e., <em>a ⊑ b ⊏ c ⊑ d &#8195;⇒&#8195; a ⊏ d &#x2000;&#8195; and&#8195; &#x2000; x ⊏ y &#8195;⇒&#8195; x ⊑ y</em>.<br><br>Every order <em>E</em> can be extended to a linear order <em>E′</em>; i.e., <em>E ⊆ E′</em>.&emsp;For the<br>finite case this is known as <em>topological sort</em>, and for the infinite case this is<br>known as the <em>Szpilrajn extension</em>.<br><br>- For the finite case, the <em>idea</em> is as follows: If <em>E</em> is not linear, then there<br>&emsp;are two incomparable elements <em>x, y</em> (i.e., outside <em>E ∪ E˘</em>), so we may define<br>&emsp;<em>an</em> ordering <em>E₁ ≔ E ∪ {(x, y)}</em>. We iterate this process and <em>Eₙ</em> will<br>&emsp;eventually become linear.<br><br>&emsp;This process maintains “the order <em>E</em>, less the incomparable elements, is<br>&emsp;linear” invariant throughout. Since each step reduces the number of<br>&emsp;incomparable elements, it must terminate, and the invariant then ensures the<br>&emsp;resulting order is linear. (•̀ᴗ•́)و">Linear</abbr> <abbr class="tooltip" title="An <em>equivalence</em> models the notion of ‘similarity’; <em>Everything is similar to<br>itself, being similar is a mutual relationship, and it is transitive</em>.<br><br>&emsp; <EM>R</EM> is an equivalence<br>≡&emsp;<EM>R</EM> is a symmetric preorder<br>≡&emsp;<EM>R</EM> is transitive and reflexive and symmetric<br>≡&emsp;<em>R ⨾ R ⊆ R &#8195;∧&#8195; Id ⊆ R ⊆ R˘</em><br>≡&emsp;<em>R ⨾ R = R = R˘ &#8195;∧&#8195; Id ⊆ R</em><br>≡&emsp;<em>R ⨾ R ˘ ⊆ R &#8195;∧&#8195; Id ⊆ R</em><br><br>Where <em>⨾, ⊤, ⊥, Id, ˘, ∼</em> are relation composition, the universal relation, the<br>empty relation, the identity relation, relation converse (transpose), and complement.<br><hr><br>For example, “2 + 3” and “5” are clearly <strong>not the same</strong>”: The first is a string<br>of 3 symbols, whereas the latter is a string of a single symbol.&emsp;However, they<br>are <strong>equivalent</strong> when we evaluate them and so we want to pretend they are the<br>same, not by using equality, but by using an equivalence relation.&emsp;( This<br>equivalence relation is obtained using transitive closure as <em>(R ⨾ R)^*</em> where<br><EM>R</EM> is the evaluation, reduction relation. )<br><br>In general, “sharing the same feature 𝒇” is an equivalence relation.<br>That is, if <em>f : A → B</em> is a function, then ∼ is an equivalence relation<br>defined by <em>a₁ ∼&emsp;a₂ &#x2000;≡&#x2000; f(a₁) &#8195;=&#8195; f(a₂)</em>.<br><hr><br>Characterising Equivalences with “Indirect Equivalence”:<br>Ξ is an equivalence&emsp;≡&emsp;<em>∀ x, y •&emsp;x 〔Ξ〕 y &#x2000;≡&#x2000; (∀ z • x 〔Ξ〕 z &#8195;≡&#8195; y 〔Ξ〕 z)</em><br><hr><br>Equivalence relations coincide with partitions.">Equivalence</abbr> <abbr class="tooltip" title="A <em>preorder</em> models the notion of ‘inclusion’ or ‘at most’ or ‘before’ or<br>‘predecessor of’; and so requires: <em>Everything is included in itself and<br>inclusion is transitive.</em><br><br>&emsp;<EM>R</EM> is a preorder<br>≡ <EM>R</EM> is transitive and reflexive<br>≡ <em>R ⨾ R ⊆ R &#8195;∧&#8195; Id ⊆ R</em><br>≡ <em>R ⨾ R = R &#8195;∧&#8195; Id ⊆ R</em><br>≡ <EM>R ╱ R = R</EM>&emsp;---“indirect inclusion from above”<br>≡ <EM>R ╲ R = R</EM>&emsp;---“indirect inclusion from below”<br><br>Where <em>⨾, ⊤, ⊥, Id, ˘, ∼</em> are relation composition, the universal relation, the<br>empty relation, the identity relation, relation converse (transpose), and complement.<br><br>If it is additionally <em>antisymmetric</em>, one says we have an <strong>order</strong>.<br>- The relation <EM>R ∩ R˘</EM> is the greatest equivalence contained in a preorder <EM>R</EM>.<br><br>&emsp;Indeed, it's clearly symmetric and reflexive, and transitive since ‘⨾’<br>&emsp;sub-distributes over ‘∩’ and <em>R</em> and <em>R˘</em> are transitive. Then, for any<br>&emsp;equivalence <em>Ξ ⊆ R</em>, we have <em>Ξ = Ξ ˘ ⊆ R ˘</em> and so <em>Ξ ⊆ R ∩ R˘</em>.<br><br>Instead of reflexivity, if we have irreflexivity we get <strong>strict order</strong>:<br>&emsp;<EM>R</EM> is a strict order<br>≡ <EM>R</EM> is transitive and irreflexive<br>≡ <em>R ⨾ R ⊆ R ⊆ ∼Id</em><br>≡ <EM>R ⨾ R ⊆ R &#8195;∧&#8195; R˘ ⊆ ∼ R</EM><br>≡ <EM>R ⨾ R ⊆ R &#8195;∧&#8195; R ∩ R˘ ⊆ ⊥</EM><br>≡ <EM>R</EM> is transitive and asymmetric<br><br>( <em>Warning!</em> A “strict order” is not an order that is somehow strict. )<br><br>Orders and strict orders come in pairs: Every order <EM>R</EM> induces a strict order<br><em>R ∩ ∼Id</em>; conversely, every strict order <EM>R</EM> gives rise to an order <em>R ∪<br>Id</em>. As such, it is customary to denote order relations by symbols such as ≤,<br>⊆. ≼, ⊑ and their associated strict orders by related symbols <, ⊂, ≺, ⊏,<br>respectively, with *lack the horizontal line ‘─’ below the symbol to indicate<br>irreflexivity ---i.e., the line is a suggestive reminder of equality.<br><br>When letters are used to denote orders, one may see <em>E</em> for an order since it is<br>reminiscent of ≤ and ⊆, and may see <em>C</em> for a strict order since it is reminiscent<br>of < and ⊂.<br><br>Using ‘≤’ for <em>an arbitrary order</em> is not ideal since readers may confuse it with<br>the familiar <em>linear</em> orders for numbers.">Preorder</abbr> <abbr class="tooltip" title="/The relationship is mutually exclusive.<em><br><hr><br><br>A relation <EM>R : V → V</EM> can be visualised as a drawing: A dot for each element<br><em>x</em> of <EM>V</EM>, and a directed line <em>x ⟶ y</em> between two points exactly when <em>x 〔R〕<br>y</em>.&emsp;That is relations are </em>simple graphs/; one refers to the directed lines as<br><em>edges</em> and the dots as <em>nodes</em>.<br><br>As a simple graph, asymmetric means: <em>There's at most 1 edge (regardless of<br>direction) relating any 2 nodes</em>.<br><hr><br>&emsp; <EM>R</EM> is asymmetric<br>≡&emsp;<em>∀ x, y • x 〔R〕 y&emsp;⇒&emsp;¬ y 〔R〕 x</em><br>≡&emsp;<EM>R ∩ R ˘ ⊆ ⊥</EM><br>≡&emsp;<EM>R ˘ ⊆ ∼ R</EM><br><br>Where <em>⨾, ⊤, ⊥, Id, ˘, ∼</em> are relation composition, the universal relation, the<br>empty relation, the identity relation, relation converse (transpose), and complement.<br><br>Asymmetrics are irreflexive ---just pick <em>x = y</em> in the above ∀-formulation ;-)<br><hr><br><br>Interestingly, every homogeneous relation <em>R</em> may be <em>partitioned</em> into an<br>asymmetric part <EM>A = R ∩ ∼R˘</EM> and a symmetric part <EM>S = R ∩ R˘</EM><br>---i.e., <EM>R = A ∪ S</EM> and <EM>A ∩ S = ⊥</EM> where ⊥ is the empty relation.">Asymmetric</abbr> <abbr class="tooltip" title="/Different elements cannot be mutually related; i.e.,<br>Mutually related items are necessarily indistinguishable.<em><br><br>Such relations allow us to prove equality between two elements;<br>we have only to show that the relationship holds in both directions.<br>&emsp;* E.g, one often shows two sets are equal by using the antisymmetry of ‘⊆’.<br><hr><br><br>A relation <EM>R : V → V</EM> can be visualised as a drawing: A dot for each element<br><em>x</em> of <EM>V</EM>, and a directed line <em>x ⟶ y</em> between two points exactly when <em>x 〔R〕<br>y</em>.&emsp;That is relations are </em>simple graphs/; one refers to the directed lines as<br><em>edges</em> and the dots as <em>nodes</em>.<br><br>As a simple graph, antisymmetry means <em>Mutually related nodes are necessarily self-loops</em>.<br><hr><br>&emsp; <EM>R</EM> is antisymmetric<br>≡&emsp;<em>∀ x, y • x 〔R〕 y&emsp;∧&emsp;y 〔 R〕 x ⇒ x = y</em><br>≡&emsp;<em>∀ x, y •&emsp;x ≠ y&emsp;⇒&emsp;¬ (x 〔R〕 y&emsp;∧&emsp;y 〔 R〕 x)</em><br>≡&emsp;<em>∀ x, y •&emsp;x ≠ y&emsp;⇒&emsp;x 〔R̸〕 y&emsp;∨&emsp;y 〔 R̸〕 x</em><br>≡&emsp;<em>R ∩ R ˘ ⊆ Id</em><br>≡&emsp;<em>R ˘ ⊆ ∼ R ∪ Id</em><br>≡&emsp;<em>R ╳ R = Id</em>&emsp;---‘╳’ is symmetric quotient<br><br>Where <em>⨾, ⊤, ⊥, Id, ˘, ∼</em> are relation composition, the universal relation, the<br>empty relation, the identity relation, relation converse (transpose), and complement.<br><br>( As a simple graph, an antisymmetric relation has <em>at most</em> one arrow between<br>any two different nodes. )">Antisymmetric</abbr> <abbr class="tooltip" title="/The relationship is mutual; if one thing is related to the other, then the other<br>is also related to the first.<em><br><br>&emsp; <EM>R</EM> is symmetric<br>≡&emsp;If </em>x/ is related to <em>y</em>, then <em>y</em> is also related to <em>x</em>.<br>≡&emsp;<em>∀ x, y • x 〔R〕 y ⇒ y 〔 R〕 x</em><br>≡&emsp;<EM>R ˘ ⊆ R</EM><br>≡&emsp;<EM>R ∩ R˘ ⊆ R</EM><br>≡&emsp;<EM>R ˘ = R</EM><br><br>Where <em>⨾, ⊤, ⊥, Id, ˘, ∼</em> are relation composition, the universal relation, the<br>empty relation, the identity relation, relation converse (transpose), and complement.<br><hr><br><br>A relation <EM>R : V → V</EM> can be visualised as a drawing: A dot for each element<br><em>x</em> of <EM>V</EM>, and a directed line <em>x ⟶ y</em> between two points exactly when <em>x 〔R〕<br>y</em>.&emsp;That is relations are <em>simple graphs</em>; one refers to the directed lines as<br><em>edges</em> and the dots as <em>nodes</em>.<br><br>As a simple graph, symmetry means the graphs is <em>undirected</em>.<br><br>That is, as graphs, symmetric relations contains either exactly two arrows ---in<br>opposite directions--- between any two elements or none at all.&emsp;As such, for<br>clarity, one prefers “squeezing any two arrows in opposite directions” into one<br>‘undirected’ line and so obtains <strong>undirected graphs</strong>.<br>- Undirected edges represent pairs of arrows pointing in opposite directions.<br><br>&emsp;Coreflexives are symmetric: <em>R ⊆ Id ⇒ R ˘ = R</em>.<br><hr><br><br>Interestingly, every homogeneous relation <em>R</em> may be <em>partitioned</em> into an<br>asymmetric part <EM>A = R ∩ ∼R˘</EM> and a symmetric part <EM>S = R ∩ R˘</EM><br>---i.e., <EM>R = A ∪ S</EM> and <EM>A ∩ S = ⊥</EM> where ⊥ is the empty relation.">Symmetric</abbr> <abbr class="tooltip" title="A relation _⊑_ is <em>transitive</em> when it satisfies <em>a ⊑ b  ∧  b ⊑ c  ⇒  a ⊑ c</em>;<br>i.e., <em>a ⊑ b ⊑ c  ⇒ a ⊑ c</em> ---that is, “we can chain ⊑” so that from a proof of <em>a<br>⊑ b ⊑ c</em> we can get from the first to the final part and so have a proof of<br><em>a ⊑ c</em>.<br><br>Loosely put, whenever <em>a</em> and <em>c</em> have a common relative then they are themselves<br>related.<br><hr><br><br>A relation <EM>R : V → V</EM> can be visualised as a drawing: A dot for each element<br><em>x</em> of <EM>V</EM>, and a directed line <em>x ⟶ y</em> between two points exactly when <em>x 〔R〕<br>y</em>.&emsp;That is relations are <em>simple graphs</em>; one refers to the directed lines as<br><em>edges</em> and the dots as <em>nodes</em>.<br><br>As a simple graph, transitivity means <em>paths can always be shortened (but<br>nonempty).</em><br><br><hr><br><br>By the shunting rule, transitivity can be read as a <strong>‘monotonicity’</strong> property for<br>the operation that turns a value <em>x</em> into the proposition <em>a ⊑ x</em>; this maps ordered<br>relationships <em>b ⊑ c</em> to ordered propositions <em>a ⊑ b ⇒ a ⊑ c</em>.<br><br>Likewise, transitivity can be read as an ‘<strong>antitonicity</strong>’ property for the<br>operation mapping a value <em>x</em> to the proposition <em>x ⊑ c</em>; this maps ordered<br>relationships <em>a ⊑ b</em> to ordered propositions <em>b ⊑ c ⇒ a ⊑ c</em>.<br><br><hr><br><br>&emsp; Relation <em>R</em> is transitive<br>≡&emsp;<em>Things related to things that are related, are themselves related.</em><br>≡&emsp;Whenever <em>x</em> is related to <em>y</em> and <em>y</em> is related to <em>z</em>, then also <em>x</em> will<br>&emsp; be related to <em>z</em><br>≡&emsp;<em>∀ x, y, z •&emsp;x 〔 R 〕 y 〔R 〕 z&emsp;⇒&emsp;x 〔R〕 z</em><br>≡&emsp;<EM>R ⨾ R ⊆ R</EM><br><br>Where <em>⨾, ⊤, ⊥, Id, ˘, ∼</em> are relation composition, the universal relation, the<br>empty relation, the identity relation, relation converse (transpose), and complement.<br><br><hr><br><br>A transitive relation is irreflexive precisely when it is asymmetric.">Transitive</abbr> <abbr class="tooltip" title="/Elements are related to themselves/<br><hr><br>A relation <EM>R : V → V</EM> can be visualised as a drawing: A dot for each element<br><em>x</em> of <EM>V</EM>, and a directed line <em>x ⟶ y</em> between two points exactly when <em>x 〔R〕<br>y</em>.&emsp;That is relations are <em>simple graphs</em>; one refers to the directed lines as<br><em>edges</em> and the dots as <em>nodes</em>.<br><br>As a simple graph, reflexivity means <em>there is loop “ ⟳ ” at each node.</em><br><hr><br><br>&emsp; <em>R</em> is reflexive exactly when <em>everything is related to itself</em>.<br>≡&emsp;<em>∀ x • x 〔R〕 x</em><br>≡&emsp;<em>Id ⊆ R</em><br><br>Where <em>⨾, ⊤, ⊥, Id, ˘, ∼</em> are relation composition, the universal relation, the<br>empty relation, the identity relation, relation converse (transpose), and complement.">Reflexive</abbr> <abbr class="tooltip" title="An operation _⊕_ is <em>commutative</em> or <em>symmetric</em> if it satisfies <em>x ⊕ y = y ⊕ x</em>.<br><br>This property indicates (semantically) that the value of an ⊕-expression doesn't<br>depend on the order of its arguments and (syntactically) we may swap their order<br>when manipulating ⊕-expressions.">Commutative</abbr> <abbr class="tooltip" title="An operation ⊗ distributes over ⊕ when they satisfy<br>“left-distributivity” <em>x ⊗ (y ⊕ z) = (x ⊗ y) ⊕ (x ⊗ y)</em><br>and<br>“right-distributivity” <em>(y ⊕ z) ⊗ x = (y ⊗ x) ⊕ (z ⊗ x)</em>.<br><br>When ⊕ = ⊗, one says that the operation is “self-distributive”.<br><br>Distributivity can be viewed in two ways, much like distributivity of<br>multiplication × over addition +. Replacing the left side by the right side<br>could be called “multiplying out”; replacing the right side by the left side,<br>“factoring”.">Distributive</abbr> <abbr class="tooltip" title="An operation _⊕_ has identity 𝑰 when it satisfies <em>𝑰 ⊕ x = x = x ⊕ 𝑰</em>.<br><br>If it satisfies only the first equation, <em>𝑰 ⊕ x = x</em>, one says<br>that “𝑰 is a left-identity for ⊕”. If it satisfies only the second<br>equation, <em>x ⊕ 𝑰 = x</em>, one says that “𝑰 is a right-identity for ⊕”.<br><br>For example, implication only has a left identity, <em>(false ⇒ x) = x</em>, and<br>subtraction only has a right identity, <em>(x - 0) = x</em>.<br><br>An identity implies that occurrences of “⊕ 𝑰” and “𝑰 ⊕” in an expression are<br>redundant. Thus, <em>x ⊕ 𝑰</em> may be replaced by <em>x</em> in any expression without<br>changing the value of the expression. Therefore, we usually eliminate such<br>occurrences unless something encourages us to leave them in.">Identity</abbr> <abbr class="tooltip" title="An operation _⊕_ is associative when it satisfies <em>(p ⊕ q) ⊕ r = p ⊕ (q ⊕ r)</em>.<br><br>Associativity allows us to be informal and insert or delete pairs of<br>parentheses in sequences of ⊕'s, just as we do with sequences of<br>additions ---e.g., <em>a + b + c + d</em> is equivalent to <em>a + (b + c) + d</em>.<br><br>Hence, we can write <em>p ⊕ q ⊕ r</em> instead of <em>(p ⊕ q) ⊕ r</em> or <em>p ⊕ (q ⊕ r)</em>.<br><br>When an operation is associative, it is best to avoid “making a choice” of how<br>sequences of ⊕ should be read, by using parentheses ---unless to make things<br>clear or explicit for manipulation.<br><br><hr><br><br>More generally, for any two operations _⊕_ and _⊞_, the “(left to right) mutual<br>associativity of ⊕ and ⊞” is the property <em>(x ⊕ y) ⊞ z = x ⊕ (y ⊞ z)</em>. It allows<br>us to omit parentheses in mixed sequences of ⊕ and ⊞. For instance, addition and<br>subtraction are (left to right) mutually associative.">Associative</abbr> <abbr class="tooltip" title="A theory of typed&emsp;composition; e.g., typed monoids.">Category Theory</abbr> <abbr class="tooltip" title="Natural transformations are essentially polymorphic functions that make <em>no</em><br> choices according to the input type; e.g., =reverse : List τ → List τ= makes no<br> choices depending on the type <code>τ</code>.">Natural Transformation</abbr> <abbr class="tooltip" title="There are two ways to read this phrase.<br><br> Algorithmic-problem solving is about solving problems that<br> involve the construction of an algorithm for their solution.<br><br> Algorithmic problem-solving is about problem solving in general,<br> using the principles of correct-by-construction algorithm-design.">Algorithmic Problem Solving</abbr> <abbr class="tooltip" title="Problems may be formulated and solved using, possibly implicitly, the<br> construction of correct programs:<br><br>&emsp;&emsp; <em>“for all x satisfying R(x), there is a y such that G(x,y) is true”</em><br> ≈	<em>∀ x • R x ⇒ ∃ y • G x y</em><br> ≈	<em>R {𝑺} G for some program 𝑺 with inputs x and outputs y</em><br><br> This is known as a <em>constructive proof</em> since we have an algorithm 𝑺 that actually<br> shows how to find a particular <em>y</em> to solve the problem, for any given x. In<br> contrast, non-constructive proofs usually involving some form of counting<br> followed by a phrase “there is at least one such <em>y</em> …”, without actually<br> indicating <em>how</em> to find it!<br><br> The <em>“R {𝑺} G”</em> is known as a ‘Hoare triple’ and it expresses “when begun in a<br> state satisfying <em>R</em>, program 𝑺 will terminate in a state satisfying <em>G</em>.”<br><br> <hr><br><br> + Proving ≈ Programming<br> + Logic&emsp; ≈ Trees (algebraic data types, 𝒲-types)<br> + Rules&emsp; ≈ Constructors<br> + Proof&emsp; ≈ An application of constructors<br> + Axiom&emsp; ≈ A constructor with no arguments">Proving_is_Programming</abbr> <abbr class="tooltip" title="A specification is an equation of a certain shape.<br>&emsp;<em>Programming</em> is the activity of solving a specification<br>&emsp;for its unknown. Its unknown is called a <em>program</em>.<br><br>&emsp;See also “Programming”.">Specification</abbr> <abbr class="tooltip" title="Programming is solving the equation <em>R ⇒[C] G</em> in the unknown <em>C</em>; i.e., it is the<br> activity of finding a ‘recipe’ that satisfies a given specification. Sometimes<br> we may write <em>R ⇒[?] G</em> and solve for ‘?’. Programming is a goal-directed activity: From a specification, a program is found by examining the shape of its postcondition.">Programming</abbr> <abbr class="tooltip" title="A story whose events have smooth transitions connecting them.<br><br># A proof wherein each step is connected to the next step by an explicit<br># justification.<br><br>This is a ‘linear’ proof format; also known as <em>equational style</em> or <em>calculational<br>proof</em>. This corresponds to the ‘high-school style’ of writing a sequence of<br>equations, one on each line, along with hints/explanations of how each line was<br>reached from the previous line. ( This is similar to <strong>programming</strong> which<br>encourages placing <em>comments</em> to <em>communicate</em> what's going on to future readers. )<br><br>The structure of equational proofs allows implicit use of infernece rules<br>Leibniz, Transitvitity & Symmetry & Reflexivity of equality, and<br>Substitution. In contrast, the structure of proof trees is no help in this<br>regard, and so all uses of inference rules must be mentioned explicitly.<br><br>For comparison with other proof notations see Equational Propositional Logic (http://www.cse.yorku.ca/~logicE/misc/logicE_intro.pdf).<br><br><hr><br><br>We advocate <em>calculational proofs</em> in which reasoning is goal directed and<br>justified by simple axiomatic laws that can be checked syntactically rather than<br>semantically. ---<em>Program Construction</em> by Roland Backhouse<br><br><hr><br><br>Calculational proofs introduce notation and recall theorems as needed, thereby<br>making each step of the argument easy to verify and follow. Thus, such arguments<br>are more accessible to readers unfamiliar with the problem domain.<br><br><hr><br><br>The use of a formal approach let us keep track of when our statements are<br>equivalent (“=”) rather than being weakened (“⇒”). That is, the use of English<br>to express the connection between steps is usually presented naturally using “if<br>this, then that” statements ---i.e., implication--- rather than stronger notion<br>of equality.">Calculational Proof</abbr> <abbr class="tooltip" title="<strong>Syntax</strong> refers to the structure of expressions, or the rules for putting symbols<br>together to form an expression. <strong>Semantics</strong> refers to the meaning of expressions<br>or how they are evaluated.<br><br>Abstractions express something shared by their instances, such as the kinds of<br>operations one can perform. However, abstractions don't, by themselves, “mean”<br>anything! E.g., for Haskell, the <code>Monad</code> type class does not mean anything, but<br>for the <code>Maybe</code> implementation it means short-circuit sequencing and for the <code>List</code><br>implementation it means (possibly nested) iteration.<br>Abstractions for operations are also known as “design patterns”.<br>( With judicious use of Yoneda, things always denote/mean certain actions. )<br><hr><br><br>An expression can contain variables, and evaluating such an expression requires<br>knowing what values to use for these variables; i.e., a <strong>state</strong>: A list of<br>variables with associated values. E.g., evaluation of <em>x - y + 2</em> in the state<br>consisting of <em>(x, 5)</em> and <em>(y, 6)</em> is performed by replacing <em>x</em> and <em>y</em> by<br>their values to yield <em>5 - 6 + 2</em> and then evaluating that to yield <em>1</em>.<br><br>A Boolean expression <EM>P</EM> is <strong>satisfied</strong> in a state if its value is <em>true</em> in that<br>state; <EM>P</EM> is <strong>satisfiable</strong> if there is a state in which it is satisfied; and <EM>P</EM><br>is <strong>valid</strong> (or is a <strong>tautology</strong>) if it is satisfied in every state.<br><hr><br><br>Often operations are defined by how they are evaluated (<strong>operationally</strong>), we can<br>take the alternative route of defining operations by how they can be manipulated<br>(<strong>axiomatically</strong>); i.e., by what properties they satisfy.<br><br>For example, evaluation of the expression <EM>X = Y</EM> in a state yields the value<br><em>true</em> if expressions <EM>X</EM> and <EM>Y</EM> have the same value and yields <em>false</em> if they<br>have different values.&emsp;This characterisation of equality is in terms of<br>expression <em>evaluation</em>.&emsp;For <em>reasoning about expressions</em>, a more useful<br>characterisation would be a set of <em>laws</em> that can be used to show that two<br>expressions are equal, <strong>without</strong> calculating their values.<br>--- c.f., static analysis versues running a program.<br><br>For example, you know that <em>x = y</em> equals <em>y = x</em>, regardless of the values of<br><em>x</em> and <em>y</em>.&emsp;A collection of such laws can be regarded as a definition of<br>equality, <strong>provided</strong> two expressions have the same value in all states precisely<br>when one expression can be translated into the other according to the laws.<br><br>Usually, in <em>a</em> logic, theorems correspond to expressions that are true in all<br>states.<br><hr><br><br>That is, instead of defining expressions by how they are evaluated, we may<br>define expressions in terms of how they can be manipulated ---c.f., a calculus.<br><br>For instance, we may define basic manipulative properties of operators ---i.e.,<br><em>axioms</em>--- by considering how the operators behave operationally on particular<br>expressions. That is, one may use an operational, intuitive, approach to obtain<br>an axiomatic specification (characterisation, interface) of the desired<br>properties.<br><br>More concretely, since <em>(p ≡ q) ≡ r</em> and <em>p ≡ (q ≡ r)</em> evaluate to<br>the same value for any choice of values for <em>p, q, r</em>, we may insist that a part<br>of the definition of equivalence is that it be an associative operation.<br><br>Sometimes a single axiom is not enough to ‘pin down’ a unique operator ---i.e.,<br>to ensure we actually have a well-defined operation--- and other times this is<br>cleanly possible; e.g., given an ordering ‘≤’(‘⇒, ⊆, ⊑’) we can define minima<br>‘↓’ (‘∧, ∩, ⊓’) by the axiom: “x ↓ y is the greatest lower bound”;<br>i.e., <em>z ≤ x ↓ y &#x2000;≡&#x2000; z ≤ x &#8194;∧&#8194; z ≤ y</em>.">Semantics</abbr> <abbr class="tooltip" title="A <em>calculus</em> is a method or process of reasoning by calculation<br>with symbols. A <em>propositional calculus</em> is a method of calculating with Boolean<br>(or propositional) expressions.<br><br><hr><br><br>Calculus: Formalised reasoning through calculation.<br><br>‘Hand wavy’ English arguments tend to favour case analysis —considering what<br>could happen in each possible scenario— which increases exponentially with each<br>variable; in contrast, equality-based calculation is much simpler since it<br>delegates intricate case analysis into codified algebraic laws.">Calculus</abbr> <abbr class="tooltip" title="A <em>theorem</em> in the technical sense is an expression derived<br>from axioms using inference rules.<br><br>A <em>metatheorem</em> is a general <strong>statement</strong> about a logic that<br>one argues to be <strong>true</strong>.<br><br>For instance, “any two theorems are equivalent” is a statement that speaks about<br>expressions which happen to be theorems. A logic may not have the linguistic<br>capability to speak of its own expressions and so the statement may not be<br>expressible as an expression <strong>within</strong> the logic ---and so cannot be a theorem of<br>the logic.<br><br>For instance, the logic 𝒑𝑞 has expressions formed from the symbols “𝒑”, “𝒒”, and<br>“-” (dash). It has the axiom schema <em>x𝒑-𝒒x-</em> and the rule “If <em>x𝒑y𝒒z</em> is a theorem<br>then so is <em>x-𝒑y-𝒒z-</em>”. Notice that <em>x, y, z</em> are <em>any</em> strings of dashes;<br>the language of this logic does not have variables and so cannot even speak<br>of its own expressions, let alone its own theorems!<br><br>[Informal] theorems about [technical, logic-specific] theorems are thus termed<br>‘metatheorems’.">Metatheorem</abbr> <abbr class="tooltip" title="A <em>theorem</em> is a syntactic object, a string of symbols with a particular property.<br><br>A <em>theorem</em> of a calculus is either an axiom or the conclusion of an inference<br>rule whose premises are theorems.<br><br>Different axioms could lead to the same set of theorems, and many texts use<br>different axioms.<br><br><hr><br><br>A “theorem” is a syntactic concept: Can we play the game of moving symbols to<br>get this? Not “is the meaning of this true”!&emsp;‘Semantic concepts’ rely on<br>‘states’, assignments of values to variables so that we can ‘evaluate, simplify’<br>statements to deduce if they are true.<br><br>Syntax is like static analysis; semantics is like actually running the program<br>(on some, or all possible inputs).<br><br><hr><br><br>A <strong>meta-theorem</strong> is a general statement about our logic that we prove to be<br>true. That is, if 𝑬 is collection of rules that allows us to find truths, then a<br><em>theorem</em> is a truth found using those rules; whereas a meta-theorem/ is property<br>of 𝑬 itself, such as what theorems it can have.&emsp;That is, theorems are _in_ 𝑬 and<br>meta-theorems are _about_ 𝑬.&emsp;For example, here is a meta-theorem that the<br>equational logic 𝑬 has (as do many other theories, such as lattices): An<br><em>equational</em> theorem is true precisely when its ‘dual’ is true. Such metatheorems<br>can be helpful to discover new theorems.<br><br># A meta-theorem is a theorem about theorems.">Theorem</abbr> <abbr class="tooltip" title="A <em>logic</em> is a formal system of reasoning...<br><br>A <em>logic</em> is a set of symbols along with a set of <em>formulas</em> formed from the<br>symbols, and a set of <em>inference rules</em> which allow formulas to be derived from<br>other formulas. (The formulas may or may not include a notion of variable.)<br><br>Logics are purely syntactic objects; an <em>inference rule</em> is a syntactic mechanism<br>for deriving “truths” or “theorems”.<br><br>In general, proofs are evidence of truth of a claim; by demonstrating that the<br>claim follows from some <em>obvious truth</em> using rules of reasoning that <em>obviously<br>preserve truth.</em>">Logic</abbr> <abbr class="tooltip" title="Formally, a “proof” is obtained by applying a number of “rules” to known results<br>to obtain new results; a “theorem” is the conclusion of a “proof”.&emsp;An “axiom”<br>is a rule that does not need to be applied to any existing results: It's just a<br>known result.<br><br>That is, a <strong>rule</strong> <EM>R</EM> is a tuple <EM>P₁, …, Pₙ, C</EM> that is thought of as ‘taking<br><strong>premises</strong> (instances of known results) <EM>Pᵢ</EM>’ and acting as a ‘natural,<br>reasonable justification’ to obtain <strong>conclusion</strong> <EM>C</EM>.&emsp;A <strong>proof system</strong> is a<br>collection of rules. At first sight, this all sounds very abstract and rather<br>useless, however it is a <em>game</em>: <strong>Starting from rules, what can you obtain?</strong> Some<br>games can be very fun! Another way to see these ideas is from the view of<br>programming:<br><br>+ Proving ≈ Programming<br>+ Logic&emsp; ≈ Trees (algebraic data types, 𝒲-types)<br>+ Rules&emsp; ≈ Constructors<br>+ Proof&emsp; ≈ An application of constructors<br>+ Axiom&emsp; ≈ A constructor with no arguments<br><br>Just as in elementary school one sees addition ‘+’ as a fraction with the<br>arguments above the horizontal line and their sum below the line, so too is that<br>notation reused for inference rules: Premises are above the fraction's bar and<br>the conclusion is below.<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 12<br>P₁, P₂, …, Pn&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;+&emsp;7<br><hr>R&emsp;&emsp; versues&emsp;&emsp; ----<br>&emsp;&emsp;&emsp;C&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;19<br><br>Just as there are meta-variables and meta-theorems, there is ‘meta-syntax’:<br>- The use of a fraction to delimit premises from conclusion is a form of ‘implication’.<br>- The use of a comma, or white space, to separate premises is a form of ‘conjunction’.<br><br>If our expressions actually have an implication and conjunction operation, then<br>inference rule above can be presented as an axiom <EM>P₁ &#8194;∧&#8194; ⋯ &#8194;∧&#8194; Pₙ &#8194;⇒&#8194; C</EM>.<br><br>The inference rule says “if the <EM>Pᵢ</EM> are all valid, i.e., true in <em>all states</em>,<br>then so is <EM>C</EM>”; the axiom, on the other hand, says “if the <EM>Pᵢ</EM> are true in <em>a<br>state</em>, then <EM>C</EM> is true in <em>that state</em>.” Thus the rule and the axiom are not<br>quite the same.<br><br>Moreover, the rule is not a Boolean expression.&emsp;Rules are thus more general,<br>allowing us to construct systems of reasoning that have no concrete notions of<br>‘truth’ ---e.g., the above arithmetic rule says from the things above the<br>fraction bar, using the operation ‘+’, we <em>can get</em> the thing below the bar, but<br>that thing (19) is not ‘true’ as we may think of conventional truth.<br><br>Finally, the rule asserts that <EM>C</EM> follows from <EM>P₁, …, Pₙ</EM>.&emsp;The formula <em>P₁<br>&#8194;∧&#8194; ⋯ &#8194;∧&#8194; Pₙ &#8194;⇒&#8194; C</em>, on the other hand, is an expression (but it need not<br>be a theorem).<br><br>A “theorem” is a syntactic concept: Can we play the game of moving symbols to<br>get this? Not “is the meaning of this true”!&emsp;‘Semantic concepts’ rely on<br>‘states’, assignments of values to variables so that we can ‘evaluate, simplify’<br>statements to deduce if they are true.<br><br>Syntax is like static analysis; semantics is like actually running the program<br>(on some, or all possible inputs).<br><br><hr><br><br>One reads/writes a <em>natural deduction proof (tree)</em> from the very <strong>bottom</strong>: Each<br>line is an application of a rule of reasoning, whose assumptions are above the<br>line; so read/written upward.&emsp;The <strong>benefit</strong> of this approach is that <strong>rules guide<br>proof construction</strong>; i.e., it is goal-directed.<br><br>However the <strong>downsides are numerous</strong>:<br>- So much horizontal space is needed even for simple proofs.<br>- One has to <strong>repeat</strong> common subexpressions; e.g., when using transitivity of equality.<br>- For comparison with other proof notations, such as Hilbert style,<br>&emsp;see Prolog (http://www.cse.yorku.ca/~logicE/misc/logicE_intro.pdf][Equational Propositional Logic]].<br><br>&emsp;This is more ‘linear’ proof format; also known as <em>equational style</em> or<br>&emsp;<em>calculational proof</em>. This corresponds to the ‘high-school style’ of writing a<br>&emsp;sequence of equations, one on each line, along with hints/explanations of how<br>&emsp;each line was reached from the previous line.<br><br><hr><br><br>Finally, an inference rule says that it is possible to start with the givens<br><EM>Pᵢ</EM> and obtain as result <EM>C</EM>.&emsp;The idea to use <strong>inference rules as computation</strong><br>is witnessed by the [[https://alhassy.github.io/PrologCheatSheet/CheatSheet.pdf) programming language.">Inference_Rule</abbr> <abbr class="tooltip" title="The <strong>(simultaneous textual) Substitution operation</strong> <em>E[\vec x ≔ \vec F]</em> replaces<br>all variables <em>\vec x</em> with parenthesised expressions <em>\vec F</em> in an expression<br><EM>E</EM>. In particular, <em>E[x ≔ F]</em> is just <EM>E</EM> but with all occurrences of <em>x</em><br>replaced by <em>“(F)”</em>. This is the “find-and-replace” utility you use on your<br>computers.<br><br>Textual substitution on expressions is known as “grafting” on trees: Evaluate<br><em>E[x ≔ F]</em> by going down the tree <EM>E</EM> and finding all the ‘leaves’ labelled <em>x</em>,<br>cut them out and replace them with the new trees <EM>F</EM>.<br><br>Since expressions are either variables of functions applications,<br>substitution can be defined inductively/recursively by the following two clauses:<br><br>+ <em>y[x ≔ F]&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; =&emsp;if  x = y  then  F  else  y  fi</em><br>+ <em>f(t₁, …, tₙ)[x ≔ F]&emsp;=&emsp;f(t₁′, …, tₙ′)&emsp; where  tᵢ′ = tᵢ[x ≔ F]</em><br><br><hr><br><br>Sequential ≠ Simultaneous:<br>&emsp;<em>(x + 2 · y)[x ≔ y][y ≔ x]&emsp;≠&emsp;(x + 2 · y)[x, y ≔ y, x]</em><br><br>Python (https://alhassy.github.io/PythonCheatSheet/CheatSheet.pdf), for example, has simultaneous <em>assignment</em>;<br>e.g., <code>x, y = y, x</code> is used to swap the value of two variables.<br><br><hr><br><br>A <em>function</em> <em>f</em> is a rule for computing a value from another value.<br><br>If we define <em>f&#8194; x = E</em> using an expression, then <em>function application</em> can be<br>defined using textual substitution: <em>f &#8194; X = E[x ≔ X]</em>. That is, expressions<br>can be considered functions of their variables ---but it is still expressions<br>that are the primitive idea, the building blocks.">Textual_Substitution</abbr> <abbr class="tooltip" title="How we prove a theorem <em>P&#8194; n</em> ranging over natural numbers <em>n</em>?<br><br>For instance, suppose the property <EM>P</EM> is that using only 3 and 5 dollar bills,<br>any amount of money that is at-least 8 dollars can be formed.<br><br>Since there are an infinite number of natural numbers, it is not possibly to<br>verify <em>P&#8194; n</em> is true by <em>evaluating</em> <em>P&#8194; n</em> at each natural number <em>n</em>.<br><br><strong>Knocking over dominos is induction:</strong><br>The natural numbers are like an infinite number of dominoes ---i.e., standing<br>tiles one after the other, in any arrangement. Can all dominoes be knocked over?<br>That is, if we construe <em>P&#8194; n</em> to mean “the <em>n</em>-th domino can be knocked over”,<br>then the question is “is <em>∀ n • P&#8194; n</em> true”. Then, clearly if we can knock over<br>the first domino, <EM>P&#8194; 0</EM>, and if when a domino is knocked over then it also<br>knocks over the next domino, <em>P&#8194; n ⇒ P&#8194; (n + 1)</em>, then ‘clearly’ all dominoes<br>will be knocked over. This ‘basic observation’ is known as <em>induction</em>.<br><br><strong>Climbing a ladder is induction:</strong><br>The natural numbers are like an infinite ladder ascending to heaven.&emsp;Can we<br>reach every step, rung, on the ladder?&emsp;That is, if we construe <em>P&#8194; n</em> to mean<br>“the <em>n</em>-th rung is reachable”, then the question is “is <em>∀ n • P&#8194; n</em><br>true”. Then, clearly if we can reach the first rung, <EM>P&#8194; 0</EM>, and whenever we<br>climb to a rung then we can reach up and grab the next rung, <em>P&#8194; n ⇒ P&#8194; (n +<br>1)</em>, then ‘clearly’ all rungs of the ladder can be reached. This ‘basic<br>observation’ is known as <em>induction</em>.<br><br><strong>Constant functions are induction:</strong><br>A predicate <EM>P : ℕ → 𝔹</EM> is a function. When is such a function constantly the<br>value <em>\true</em>? That is, when is <em>∀ n • P&#8194; n = \true</em>?&emsp;Clearly, if <EM>P</EM> starts<br>off being <em>\true</em> ---i.e., <em>P 0</em>--- and it preserves truth at every step ---i.e.,<br><em>P n ⇒ P (n + 1)</em>--- then <em>P n</em> will be true for any choice of <em>n</em>.<br><br>That is, if we consider <em>(ℕ, ≤)</em> and <em>(𝔹, ⇒)</em> as ordered sets and <EM>P</EM> starts at<br>the ‘top’ of 𝔹 ---i.e., <em>P 0 = true</em>--- and it is ascending ---i.e., <em>P n ⇒ P (n +<br>1)</em>--- and so ‘never goes down’, then clearly it must stay constantly at the top<br>value of 𝔹. This ‘basic observation’ is known as <em>induction</em>.<br><br><br>⟦ For the money problem, we need to start somewhere else besides 0. ⟧<br><br><strong>Principle of (“Weak”) Mathematical Induction:</strong><br>To show that a property <EM>P</EM> is true for all natural numbers starting with some<br>number <em>n_0</em>, show the following two properties:<br>+ Base case :: Show that <em>P&#8194; n₀</em> is true.<br>+ Inductive Step :: Show that whenever (the <strong>inductive hypothesis</strong>) <em>n</em> is a<br>&emsp;natural number that such that <em>n ≥ n₀</em> and <em>P&#8194; n</em> is true, then <em>P&#8194; (n + 1)</em><br>&emsp;is also true.<br><br>⟦ For the money problem, we need to be able to use the fact that to prove<br><em>P&#8194;(n + 1)</em> we must have already proven <EM>P</EM> for all smaller values. ⟧<br><br><strong>Principle of (“Strong”) Mathematical Induction</strong>:<br>To show that a property <EM>P</EM> is true for all natural numbers starting with some<br>number <em>n_0</em>, show the following two properties:<br>+ Base case :: Show that <em>P&#8194; n₀</em> is true.<br>+ Inductive Step :: Show that whenever (the <strong>inductive hypothesis</strong>) <em>n</em> is a<br>&emsp;natural number that such that <em>n ≥ n₀</em> and <em>P&#8194; n_0, P&#8194; (n_0 + 1), P&#8194; (n_0 +<br>&emsp;2), …, P&#8194; n</em> are true, then <em>P&#8194; (n + 1)</em> is also true.<br><br>⟦ The ‘strength’ of these principles refers to the strength of the inductive<br>hypothesis. The principles are provably equivalent. ⟧<br><br># (It is also a way to say that ℕ has non-empty meets.)<br><strong>The Least Number Principle (LNP) ---Another way to see induction:</strong><br>Every non-empty subset of the natural numbers must have a least element,<br>‘obviously’. This is (strong) induction.<br># Possibly infinite!<br><br>Application of LNP to showing that algorithms terminate:<br>In particular, every decreasing non-negative sequence of integers<br><em>r₀ > r₁ > r₂ > ⋯</em> must terminate.<br>#+end_box">Induction</abbr> <abbr class="tooltip" title="An <em>expression</em> is either a ‘variable’ or a ‘function application’; i.e., the name<br>of a function along with a number of existing expressions.<br><br> Expr ::= Constant&emsp;&emsp;-- E.g., 1 or “apple”<br>&emsp;&emsp;&emsp;|&emsp;Variable&emsp;&emsp;-- E.g., x or apple (no quotes!)<br>&emsp;&emsp;&emsp;|&emsp;Application -- E.g., f(x₁, x₂, …, xₙ)<br><br>( One reads ‘:=’ as <em>becomes</em> and so the addition of an extra colon results in a<br>‘stutter’: One reads ‘∷=’ as <em>be-becomes</em>. The symbol ‘|’ is read <em>or</em>. )<br><br>Notice that a constant is really just an application with <em>n</em> being <em>0</em> arguments<br>and so the first line in the definition above could be omitted.<br><br><hr><br><br>In a sense, an expression is like a sentence with the variables acting as<br>pronouns and the function applications acting as verb clauses and the argument<br>to the application are the participants in the action of the verbal clause.<br><br>A <strong>variable of type τ</strong> is a <em>name</em> denoting a yet unknown <em>value</em> of type τ;<br>i.e., “it is a pronoun (nickname) referring to a person in the collection of people τ”.<br>E.g., to say <em>x</em> is an integer variable means that we may treat it<br>as if it were a number whose precise value is unknown.<br>Then, if we let =Expr τ= refer to the expressions denoting <em>values</em> of type τ;<br>then a <strong>meta-variable</strong> is simply a normal variable of type =Expr τ=.<br><br>That is, when we write phrases like =“Let E be an expression”=, then the <em>name</em> <EM>E</EM><br>varies and so is a variable, but it is an expression and so may consist of a<br>function application or a variable. <strong>That is, <EM>E</EM> is a variable that may stand<br>for variables.</strong> This layered inception is resolved by referring to <EM>E</EM> as not<br>just any normal variable, but instead as a <strong>meta-variable</strong>: A variable capable of<br>referring to other (simpler) variables.<br><br><hr><br><br>Expressions, as defined above, are also known as <em>abstract syntax trees</em> (AST) or<br><em>prefix notation</em>. Then <em>textual substitution</em> is known as ‘grafting trees’ (a<br>monadic bind).<br><br>Their use can be clunky, such as by requiring many parentheses and implicitly<br>forcing a syntactic distinction between equivalent expressions; e.g.,<br><em>gcd(m,gcd(n,p))</em> and <em>gcd(gcd(m,n),p)</em> look difference even though <em>gcd</em> is<br>associative.<br><br>As such, one can declare <em>precedence levels</em> ---a.k.a. <em>binding power</em>--- to reduce<br>parentheses, one can declare fixity ---i.e., have arguments around operation<br>names---, and, finally, one can declare association ---whether sequential<br>instances of an operation should be read with implicit parenthesis to the right<br>or the to the left--- to reduce syntactic differences.&emsp;The resulting expression<br>are now known to be in a <em>concrete syntax</em> ---i.e., in a syntactic shape that is<br>more concrete.<br><br>That is, the <strong>conventions</strong> on how a <em>string</em> should be parsed as a <em>tree</em> are known as a<br><strong>precedence, fixity, and associativity rules.</strong><br><br>Similarly, not for operators but one treats <em>relations</em> <strong>conjunctionally</strong> to reduce<br>the number of ‘and’(∧) symbols; e.g. <em>x ≤ y + 2 = z &#x2000;≡&#x2000; x ≤ (y + 2) &#8194;∧&#8194; (y + 2) = z</em>.<br>This is very useful to avoid repeating lengthy common expressions, such as <em>y + 2</em>.">Expression</abbr> <abbr class="tooltip" title="A <em>(Partial, resp. Total) Graph</em> <em>G = (V, E, src, tgt)</em> consists of<br>&emsp; + <EM>V</EM>, a set of “points, nodes, vertices”<br>&emsp; + <EM>E</EM>, a set of “arcs, edges”<br>&emsp; + <em>src, tgt : E ↔ V</em>, a pair of <em>partial (resp. total)</em> functions.<br><br>⟦ Tersely put, in any category, a <em>graph</em> is a parallel pair of morphisms. ⟧<br><br><em>Edge parallelism</em> is the relation <em>Ξ = src ⨾ src ˘ ∩ tgt ⨾ tgt˘</em>; two arcs are<br>related when they have the same starting point and the same ending point, which<br>both exist. Joyously, the name ‘Ξ’ is a neat reminder of the concept:<br>The name is three parallel lines, for the concept of edge(line) parallelism.<br><br>+ A graph is <em>total</em> exactly when <em>Id ⊆ Ξ</em>; and so Ξ is an equivalence.<br>+ A graph has <em>no parallel arrows</em> exactly when <em>Ξ ⊆ Id</em>.<br>+ A graph is <em>simple</em> exactly when <em>Ξ = Id</em>.<br><br>The <em>associated relation</em> is the relation <em>_⟶_ = src ˘ ⨾ tgt</em> that relates two nodes<br>when the first is the source of some edge that happens to have the second point<br>as its target. One uses the associated relation to study properties not<br>involving partial or parallel arrows. One writes <em>⟵</em> for <em>⟶˘</em>;<br>one writes ⟶⋆ for the <em>reachability</em> relation.<br><br>+ Node <em>y</em> is <em>reachable via a non-empty path</em> from node <em>x</em> exactly when <em>x ⟶⁺ y</em>.<br>&emsp;- Node <em>x</em> lies on a cycle exactly when <em>x ⟶⁺ x</em>.<br>&emsp;- A graph is <em>DAG, acylic, circuit-free,</em> exactly when <em>⟶⁺ ⊆ ∼Id</em>; i.e., <em>⟶⁺ ∩ Id = ⊥</em>.<br>&emsp;- An acyclic graph is a (<em>directed) forest</em> exactly when ⟶ is injective; i.e.,<br>&emsp;&emsp;every node has at most one predecessor; i.e., <em>⟶ ⨾ ⟵ ⊆ Id</em>.<br>+ A node <em>r</em> is a <em>root</em> exactly when every node is reachable from it; i.e., <em>{r} × V ⊆ ⟶⋆;</em><br>&emsp;i.e., <em>𝕃 r ⨾ ⟶⋆ = ⊤</em> where <em>𝕃 r</em> is defined by <em>𝕃 r = (ℝ r)˘</em> and <em>x 〔ℝ r〕 y &#8195;≡&#8195; x = r</em>.<br>&emsp;- <em>x〔𝕃 r ⨾ R〕 y &#8195;≡&#8195; r〔R〕 y</em> and <em>x 〔R ⨾ ℝ r〕 y &#8195;≡&#8195; x 〔R〕 r</em><br>&emsp;- A <em>tree</em> is a forest with a root.<br>+ A graph is <em>loop free</em> exactly when <em>⟶ ⊆ ∼Id</em>.<br>+ A graph is <em>strongly connected</em> exactly when <em>⟶⋆ = ⊤</em>; i.e., <em>∼Id ⊆ ⟶⁺</em>;<br>&emsp;i.e., every point is reachable from any <em>other</em> point; i.e., <em>∼Id ⊆ ⟶ ∩ ⟵˘</em>;<br>&emsp;i.e., any two distinct points lie on an undirected circuit.<br>&emsp;- The equivalence classes of <em>⟶⋆ ∩ ⟵⋆</em> are the <em>strongly connected components</em>.<br>+ <em>Terminal∣sinks</em> are nodes from which it is <em>not</em> possible to proceed <em>any</em> further;<br>&emsp;i.e., terminals have no successors; the domain of <em>∼(⟶ ⨾ ⊤)</em> is all terminals.<br>+ <em>Initial∣sources</em> are nodes from which it is <em>not</em> possible to proceed backward;<br>&emsp;i.e., initials have no predecessors; the domain of <em>∼(⟵ ⨾ ⊤)</em> is all initials.">Graph</abbr> <abbr class="tooltip" title="Language (Native Name) “Hello”<br>1. Amharic (አማርኛ)	ሠላም<br>2. Arabic (العربيّة)	السّلام عليكم<br>3. Armenian (հայերեն)	Բարև ձեզ<br>4. Bengali (বাংলা)	নমস্কার<br>5. Braille	⠓⠑⠇⠇⠕<br>6. Burmese (မြန်မာ)	မင်္ဂလာပါ<br>7. C	printf (''Hello, world!\n'');<br>8. Cherokee (ᏣᎳᎩ ᎦᏬᏂᎯᏍᏗ)	ᎣᏏᏲ ╱ ᏏᏲ<br>9. Comanche ╱kəˈmæntʃiː╱	Haa marʉ́awe<br>10. Cree (ᓀᐦᐃᔭᐍᐏᐣ)	ᑕᓂᓯ ╱ ᐙᒋᔮ<br>11. Czech (čeština)	Dobrý den<br>12. Danish (dansk)	Hej ╱ Goddag ╱ Halløj<br>13. Dutch (Nederlands)	Hallo ╱ Dag<br>14. Efik&emsp;╱ˈɛfɪk╱	Mɔkɔm<br>15. Emacs	emacs --no-splash -f view-hello-file<br>16. Emoji	👋<br>17. English ╱ˈɪŋɡlɪʃ╱	Hello<br>18. Esperanto	Saluton (Eĥoŝanĝo ĉiuĵaŭde)<br>19. Estonian (eesti keel)	Tere päevast ╱ Tere õhtust<br>20. Finnish (suomi)	Hei ╱ Hyvää päivää<br>21. French (français)	Bonjour ╱ Salut<br>22. Georgian (ქართული)	გამარჯობა<br>23. German (Deutsch)	Guten Tag ╱ Grüß Gott<br>24. Greek (ελληνικά)	Γειά σας<br>25. Greek, ancient (ἑλληνική)	Οὖλέ τε καὶ μέγα χαῖρε<br>26. Gujarati (ગુજરાતી)	નમસ્તે<br>27. Hebrew (עִבְרִית)	שָׁלוֹם<br>28. Hungarian (magyar)	Szép jó napot!<br>29. Hindi (हिंदी)	नमस्ते ╱ नमस्कार ।<br>30. Inuktitut (ᐃᓄᒃᑎᑐᑦ)	ᐊᐃ<br>31. Italian (italiano)	Ciao ╱ Buon giorno<br>32. Javanese (Jawa)	System.out.println(''Sugeng siang!'');<br>33. Kannada (ಕನ್ನಡ)	ನಮಸ್ಕಾರ<br>34. Khmer (ភាសាខ្មែរ)	ជំរាបសួរ<br>35. Lao (ພາສາລາວ)	ສະບາຍດີ ╱ ຂໍໃຫ້ໂຊກດີ<br>36. Malayalam (മലയാളം)	നമസ്കാരം<br>37. Maldivian (ދިވެހި)	އައްސަލާމު ޢަލައިކުމް ╱ ކިހިނެހް؟<br>38. Maltese (il-Malti)	Bonġu ╱ Saħħa<br>39. Mathematics	∀ p ∈ world • hello p&emsp;□<br>40. Mongolian (монгол хэл)	Сайн байна уу?<br>41. Norwegian (norsk)	Hei ╱ God dag<br>42. Oriya (ଓଡ଼ିଆ)	ଶୁଣିବେ<br>43. Polish&emsp;(język polski)	Dzień dobry! ╱ Cześć!<br>44. Russian (русский)	Здра́вствуйте!<br>45. Sinhala (සිංහල)	ආයුබෝවන්<br>46. Slovak (slovenčina)	Dobrý deň<br>47. Slovenian (slovenščina)	Pozdravljeni!<br>48. Spanish (español)	¡Hola!<br>49. Swedish (svenska)	Hej ╱ Goddag ╱ Hallå<br>50. Tamil (தமிழ்)	வணக்கம்<br>51. Telugu (తెలుగు)	నమస్కారం<br>52. TaiViet (ꪁꪫꪱꪣ ꪼꪕ)	ꪅꪰꪙꫂ ꪨꪮꫂ ꪁꪫꪱ ╱ ꪅꪽ ꪨꪷ ꪁꪫꪱ<br>53. Thai (ภาษาไทย)	สวัสดีครับ ╱ สวัสดีค่ะ<br>54. Tibetan (བོད་སྐད་)	བཀྲ་ཤིས་བདེ་ལེགས༎<br>55. Tigrigna (ትግርኛ)	ሰላማት<br>56. Turkish (Türkçe)	Merhaba<br>57. Ukrainian (українська)	Вітаю<br>58. Vietnamese (tiếng Việt)	Chào bạn<br>59. Japanese (日本語)	こんにちは ╱ ｺﾝﾆﾁﾊ<br>60. Chinese (中文,普通话,汉语)	你好<br>61. Cantonese (粵語,廣東話)	早晨, 你好<br>62. Korean (한글)	안녕하세요 ╱ 안녕하십니까<br><hr><br>This list was generated by pressing <code>C-h h</code> in Emacs, <code>view-hello-file</code>.">Hello</abbr> <abbr class="tooltip" title="">temp</abbr> <abbr class="tooltip" title="zsh:1: command not found: wn<br>">Hussain</abbr> <abbr class="tooltip" title="zsh:1: command not found: wn<br>">family</abbr> <abbr class="tooltip" title="Thread FORMS elements as the first argument of their successor.<br>Example:<br>&emsp;&emsp;(thread-first<br>&emsp;&emsp;&emsp;5<br>&emsp;&emsp;&emsp;(+ 20)<br>&emsp;&emsp;&emsp;(<em> 25)<br>&emsp;&emsp;&emsp;-<br>&emsp;&emsp;&emsp;(+ 40))<br>Is equivalent to:<br>&emsp;&emsp;(+ (- (</em> (+ 5 20) 25)) 40)<br>Note how the single ‘-’ got converted into a list before<br>threading.<br><br>(fn &rest FORMS)">thread-first</abbr> <abbr class="tooltip" title="Show an OctoIcon: home, link, mail, report, tag, clock">o-link/octoicon</abbr> <abbr class="tooltip" title="Call FUNCTION with our remaining args, using our last arg as list of args.<br>Then return the value FUNCTION returns.<br>With a single argument, call the argument’s first element using the<br>other elements as args.<br>Thus, (apply '+ 1 2 '(3 4)) returns 10.<br><br>(fn FUNCTION &rest ARGUMENTS)">apply</abbr> <abbr class="tooltip" title="zsh:1: command not found: wn<br>">test</abbr>
</p>
</div>
</div>

<div id="outline-container-org60b7244" class="outline-2">
<h2 id="org60b7244"><span class="section-number-2">2.</span> 各种链接</h2>
<div class="outline-text-2" id="text-2">
<p>
<kbd style="">xboldcolor</kbd>  <code>*&lt;pink: super neato stuff&gt;*</code> -&gt; <b><span style="color:pink;"> super neato stuff</span></b>
</p>

<p>
<kbd style="">xlinkhere</kbd> 本地锚点: <a class="anchor" aria-hidden="true" id="test-link-here-links" href="#test-link-here-links"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16
   16" width="16" height="16"><path fill-rule="evenodd"
   d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69
   3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10
   5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0
   2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5
   0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55
   13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> 点击后注意 URL <code>#</code> 后面
内容的变化。
</p>

<p>
<kbd style="">xicon</kbd> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M16 9l-3-3V2h-2v2L8 1 0 9h2l1 5c0 .55.45 1 1 1h8c.55 0 1-.45 1-1l1-5h2zm-4 5H9v-4H7v4H4L2.81 7.69 8 2.5l5.19 5.19L12 14z"></path></svg> 会显示一个主页 Icon <abbr class="tooltip" title="Show an OctoIcon: home, link, mail, report, tag, clock">o-link/octoicon</abbr> 。
</p>

<p>
<kbd style="">xbadge</kbd> <code>&lt;badge: Emacs | is awesome | blue |
https://www.google.com/search?q=hello%20world | gnu-emacs&gt;</code> 导出成 <a href="https://www.google.com/search?q=hello%20world"><img src="https://img.shields.io/badge/Emacs-is%20awesome-blue?logo=gnu-emacs"></a>
</p>

<p>
<abbr class="tooltip" title="Thread FORMS elements as the first argument of their successor.<br>Example:<br>&emsp;&emsp;(thread-first<br>&emsp;&emsp;&emsp;5<br>&emsp;&emsp;&emsp;(+ 20)<br>&emsp;&emsp;&emsp;(<em> 25)<br>&emsp;&emsp;&emsp;-<br>&emsp;&emsp;&emsp;(+ 40))<br>Is equivalent to:<br>&emsp;&emsp;(+ (- (</em> (+ 5 20) 25)) 40)<br>Note how the single ‘-’ got converted into a list before<br>threading.<br><br>(fn &rest FORMS)">thread-first</abbr> Lisp 函数定义
</p>

<p>
<abbr class="tooltip" title="zsh:1: command not found: wn<br>">family</abbr> English 含义
</p>

<p>
<abbr class="tooltip" title="Hussein ibn Ali is the grandson of Prophet Muhammad, who is known to have<br>declared <strong>“Hussain is from me and I am from Hussain; God loves whoever loves Hussain.”</strong><br><br>He is honoured as “The Chief of Martyrs” for his selfless stand for social justice<br>against Yazid, the corrupt 7ᵗʰ caliph. The Karbala Massacre is commemorated annually<br>in the first Islamic month, Muharram, as a reminder to stand against oppression and tyranny;<br>Jesus Christ, son of Mary, makes an indirect appearance in the story.<br><br>A terse summary of the chain of events leading to the massacre may be found at<br>https://www.al-islam.org/articles/karbala-chain-events.<br><br>An elegant English recitation recounting the Karbala Massacre may be found at<br>https://youtu.be/2i9Y3Km6h08 ---“Arbaeen Maqtal - Sheikh Hamam Nassereddine - 1439”.<br><hr><br> <strong>Charles Dickens:</strong> <em>“If Hussain had fought to quench his worldly desires...then I</em><br><em>do not understand why his sister, wife, and children accompanied him. It stands<br>to reason therefore, that he sacrificed purely for Islam.”</em><br><br><strong>Gandhi:</strong> <em>“I learned from Hussain how to achieve victory while being oppressed.”</em><br><br><strong>Thomas Carlyle:</strong> <em>“The victory of Hussein, despite his minority, marvels me.”</em><br><br><strong>Thomas Masaryk:</strong> <em>“Although our clergies also move us while describing the<br>Christ's sufferings, but the zeal and zest that is found in the followers of</em><br><em>Hussain will not be found in the followers of Christ. And it seems that the<br>suffering of Christ against the suffering of Hussain is like a blade of straw</em> <em>in<br>front of a huge mountain.”</em>">Hussain</abbr> 个人文档描述
</p>
</div>
</div>

<div id="outline-container-orgd19b976" class="outline-2">
<h2 id="orgd19b976"><span class="section-number-2">3.</span> link here head</h2>
<div class="outline-text-2" id="text-3">
<p>
<span id="test-link-here-links"></span>
</p>

<p>
<img src="https://img.shields.io/badge/Thanks-for_reading-nil?logo=nil">
<a href="https://twitter.com/intent/tweet?text=This looks super neat (•̀ᴗ•́)و::&url=https://github.com/gcclll/blog.cheng92.com"><img src="https://img.shields.io/twitter/url?url=https://github.com/gcclll/blog.cheng92.com"></a>
<a href="https://www.cheng92.com"><img src="https://img.shields.io/badge/-buy_me_a_coffee-gray?logo=buy-me-a-coffee"></a>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Zhicheng Lee</p>
<p class="date">Created: 2022-02-22 Tue 11:07</p>
</div>
</body>
</html>
