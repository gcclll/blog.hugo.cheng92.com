<!DOCTYPE html>
<html lang="en">
<head>
  <!-- 2022-05-05 Thu 16:39 -->
  <meta charset="utf-8">
  <meta name="viewport" content=
  "width=device-width, initial-scale=1">
  <title>build your own vue compiler-sfc</title>
  <meta name="author" content="Zhicheng Lee">
  <meta name="generator" content="Org Mode">
  <style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  </style>
  <link rel="stylesheet" type="text/css" href=
  "/assets/css/htmlize.css">
  <link rel="stylesheet" type="text/css" href=
  "/assets/css/readtheorg.css">
  <link rel="stylesheet" type="text/css" href=
  "/assets/css/global.css">
  <link rel="stylesheet" type="text/css" href=
  "/assets/css/element-plus.css">
  <link rel="icon" type="image/png" sizes="48x48" href=
  "/favicon.ico">
  <script type="text/javascript" src=
  "/assets/js/jquery.min.js"></script>
  <script type="text/javascript" src=
  "/assets/js/jquery.stickytableheaders.min.js"></script>
  <script type="text/javascript" src=
  "/assets/js/bootstrap.min.js"></script>
  <script type="text/javascript" src=
  "/assets/js/lodash.min.js"></script>
  <script type="text/javascript" src=
  "/assets/js/readtheorg.js"></script>
  <link rel="stylesheet" href="/assets/js/fancybox/fancybox.css"
  type="text/css" media="screen">
  <script type="text/javascript" src=
  "/assets/js/fancybox/fancybox.umd.js"></script>
  <script type="text/javascript" src=
  "/assets/js/mobile-detect.min.js"></script>
  <script type="text/javascript" src=
  "/assets/js/Valine.min.js"></script>
  <script type="text/javascript" src="/assets/js/vue.js"></script>
  <script type="text/javascript" src=
  "/assets/js/element-plus.js"></script>
  <script type="text/javascript" src=
  "/assets/js/dist/stats.js"></script>
  <script type="text/javascript" src=
  "/assets/js/dist/apps.js"></script>
  <script type="text/javascript" src=
  "/assets/js/dist/global.js"></script>
  <meta name="category" content="vue">
  <meta name="tags" content="compiler-sfc">
  <meta name="createdAt" content="2022-04-28 16:19:09">
  <style>
        /* From: https://endlessparentheses.com/public/css/endless.css */
        /* See also: https://meta.superuser.com/questions/4788/css-for-the-new-kbd-style */
        kbd
        {
          -moz-border-radius: 6px;
          -moz-box-shadow: 0 1px 0 rgba(0,0,0,0.2),0 0 0 2px #fff inset;
          -webkit-border-radius: 6px;
          -webkit-box-shadow: 0 1px 0 rgba(0,0,0,0.2),0 0 0 2px #fff inset;
          background-color: #f7f7f7;
          border: 1px solid #ccc;
          border-radius: 6px;
          box-shadow: 0 1px 0 rgba(0,0,0,0.2),0 0 0 2px #fff inset;
          color: #333;
          display: inline-block;
          font-family: 'Droid Sans Mono', monospace;
          font-size: 80%;
          font-weight: normal;
          line-height: inherit;
          margin: 0 .1em;
          padding: .08em .4em;
          text-shadow: 0 1px 0 #fff;
          word-spacing: -4px;
        
          box-shadow: 2px 2px 2px #222; /* MA: An extra I've added. */
        }
  </style>
  <link rel="stylesheet" type="text/css" href=
  "/assets/css/tooltipster.bundle.min.css">
  <link rel="stylesheet" type="text/css" href=
  "/assets/css/tooltipster-sideTip-punk.min.css">
  <script type="text/javascript">
            if (typeof jQuery == 'undefined') {
                document.write(unescape('%3Cscript src="https://code.jquery.com/jquery-1.10.0.min.js"%3E%3C/script%3E'));
            }
  </script>
  <script type="text/javascript" src=
  "/assets/js/tooltipster.bundle.min.js"></script>
  <script type="text/javascript" src=
  "/assets/js/tooltipster-scrollableTip.min.js"></script>
  <script type="text/javascript" src=
  "/assets/js/dist/tooltips.js"></script>
  <style>
           abbr {color: red;}
        
           .tooltip { border-bottom: 1px dotted #000;
                      color:red;
                      text-decoration: none;}
  </style>
</head>
<body>
  <div id="content" class="content">
    <h1 class="title">build your own vue compiler-sfc</h1>
    <div id="table-of-contents" role="doc-toc">
      <h2>Table of Contents</h2>
      <div id="text-table-of-contents" role="doc-toc">
        <ul>
          <li>
            <a href="#org756af32">1. script</a>
            <ul>
              <li>
                <a href="#org8e66a57">1.1. compileScript()</a>
              </li>
              <li>
                <a href="#org7c93f4f">1.2. utils</a>
                <ul>
                  <li>
                    <a href="#orgecdf7a7">1.2.1. helper()</a>
                  </li>
                  <li>
                    <a href="#org9b5560e">1.2.2. parse()</a>
                  </li>
                  <li>
                    <a href="#org9e4efbb">1.2.3. error()</a>
                  </li>
                  <li>
                    <a href="#org45020fa">1.2.4.
                    registerUserImport()</a>
                  </li>
                  <li>
                    <a href="#orga539d5f">1.2.5.
                    processDefineProps()</a>
                  </li>
                  <li>
                    <a href="#org21c5d19">1.2.6.
                    processWithDefaults()</a>
                  </li>
                  <li>
                    <a href="#orgfc31448">1.2.7.
                    processDefineEmits()</a>
                  </li>
                  <li>
                    <a href="#org68971eb">1.2.8.
                    resolveQualifiedType()</a>
                  </li>
                  <li>
                    <a href="#org958a52f">1.2.9.
                    processDefineExpose()</a>
                  </li>
                  <li>
                    <a href="#orgca8526f">1.2.10.
                    checkInvalidScopeReference()</a>
                  </li>
                  <li>
                    <a href="#org14ae51e">1.2.11.
                    processAwait()</a>
                  </li>
                  <li>
                    <a href="#org175ada4">1.2.12.
                    hasStaticWithDefaults()</a>
                  </li>
                  <li>
                    <a href="#org1a5b75b">1.2.13.
                    genRuntimeProps()</a>
                  </li>
                  <li>
                    <a href="#orgbcbfce1">1.2.14.
                    genDestructuredDefaultValue()</a>
                  </li>
                  <li>
                    <a href="#org1bf22f6">1.2.15.
                    genSetupPropsType()</a>
                  </li>
                </ul>
              </li>
              <li>
                <a href="#org318e239">1.3. steps</a>
                <ul>
                  <li>
                    <a href="#org302009a">1.3.1. process normal
                    script</a>
                  </li>
                  <li>
                    <a href="#orgbbdbf3f">1.3.2. process setup
                    script</a>
                  </li>
                  <li>
                    <a href="#orge292ff1">1.3.3. apply reactivity
                    transform</a>
                  </li>
                  <li>
                    <a href="#org8fc7f68">1.3.4. extract runtime
                    props/emits</a>
                  </li>
                  <li>
                    <a href="#org6ed735c">1.3.5. check useOptions
                    dont ref setup scope variables</a>
                  </li>
                  <li>
                    <a href="#org893a633">1.3.6. remove non-script
                    content</a>
                  </li>
                  <li>
                    <a href="#org6b91885">1.3.7. analyze binding
                    metadata</a>
                  </li>
                  <li>
                    <a href="#org4ff3706">1.3.8. inject useCssVars
                    calls</a>
                  </li>
                  <li>
                    <a href="#org06f1637">1.3.9. finalize setup()
                    argument signature</a>
                  </li>
                  <li>
                    <a href="#orgb18f8cb">1.3.10. generate return
                    statement</a>
                  </li>
                  <li>
                    <a href="#org9a4824e">1.3.11. finalize default
                    export</a>
                  </li>
                  <li>
                    <a href="#orge172c72">1.3.12. finalize Vue
                    helper imports</a>
                  </li>
                </ul>
              </li>
              <li>
                <a href="#orgd09c3ba">1.4. functions</a>
                <ul>
                  <li>
                    <a href="#org1be5a97">1.4.1.
                    registerBinding()</a>
                  </li>
                  <li>
                    <a href="#orgf70aac2">1.4.2.
                    walkDeclaration()</a>
                  </li>
                  <li>
                    <a href="#org46aa7dd">1.4.3.
                    walkObjectPattern()</a>
                  </li>
                  <li>
                    <a href="#org6693c78">1.4.4.
                    walkArrayPattern()</a>
                  </li>
                  <li>
                    <a href="#org55e8e2a">1.4.5. walkPattern()</a>
                  </li>
                  <li>
                    <a href="#org8597d17">1.4.6. recordType()</a>
                  </li>
                  <li>
                    <a href="#orgf917328">1.4.7.
                    extractRuntimeProps()</a>
                  </li>
                  <li>
                    <a href="#orgc812607">1.4.8.
                    inferRuntimeType()</a>
                  </li>
                  <li>
                    <a href="#org8ea11f2">1.4.9.
                    toRuntimeTypeString()</a>
                  </li>
                  <li>
                    <a href="#orgb74a603">1.4.10.
                    extractRuntimeEmits()</a>
                  </li>
                  <li>
                    <a href="#orgfa2810d">1.4.11.
                    extractEventNames()</a>
                  </li>
                  <li>
                    <a href="#org96c8032">1.4.12.
                    genRuntimeEmits()</a>
                  </li>
                  <li>
                    <a href="#orga5b8753">1.4.13. isCallOf()</a>
                  </li>
                  <li>
                    <a href="#org686f766">1.4.14.
                    canNeverBeRef()</a>
                  </li>
                  <li>
                    <a href="#orgbcfccbc">1.4.15.
                    analyzeScriptBindings()</a>
                  </li>
                  <li>
                    <a href="#org65b62ae">1.4.16.
                    analyzeBindingsFromOptions()</a>
                  </li>
                  <li>
                    <a href="#org3512a7c">1.4.17.
                    getObjectExpressionKeys()</a>
                  </li>
                  <li>
                    <a href="#orgec7d4fd">1.4.18.
                    getArrayExpressionKeys()</a>
                  </li>
                  <li>
                    <a href="#org875116a">1.4.19.
                    getObjectOrArrayExpressionKeys()</a>
                  </li>
                  <li>
                    <a href="#orga3a03a2">1.4.20.
                    resolveTemplateUsageCheckString()</a>
                  </li>
                  <li>
                    <a href="#orgf2017c3">1.4.21.
                    stripStrings()</a>
                  </li>
                  <li>
                    <a href="#org34fd720">1.4.22.
                    stripTemplateString()</a>
                  </li>
                  <li>
                    <a href="#org8e339e4">1.4.23.
                    isImportUsed()</a>
                  </li>
                  <li>
                    <a href="#org03ef6b1">1.4.24.
                    hmrShouldReload()</a>
                  </li>
                </ul>
              </li>
              <li>
                <a href="#orga7e2b86">1.5. rewriteDefault</a>
              </li>
              <li>
                <a href="#org08cd59c">1.6. cssVars</a>
              </li>
              <li>
                <a href="#org32c24c2">1.7. testing</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#org19b67a4">2. template</a>
            <ul>
              <li>
                <a href="#orge791b0b">2.1. compileTemplate()</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#org1835ca0">3. mindmaps</a>
          </li>
          <li>
            <a href="#org06862ec">4. global variables</a>
            <ul>
              <li>
                <a href="#org95e1794">4.1. reactivity-transform</a>
              </li>
            </ul>
          </li>
        </ul>
      </div>
    </div>
    <p><a href="/"><img src=
    "https://img.shields.io/badge/GCCLL-Homepage-green?logo=gnu-emacs"></a></p>
    <p>TODO compiler-sfc</p><br>
    <details class="code-details" style=
    "padding: 1em; background-color: #e5f5e5; /* background-color: pink; */ border-radius: 15px; color: hsl(157 75%); font-size: 0.9em; box-shadow: 0.05em 0.1em 5px 0.01em #00000057;">
      <summary>
        <strong><font face="Courier" size="3" color=
        "green">compiler-dom</font></strong>
      </summary>
      <p><a href=
      "https://blog.cheng92.com/posts/build_your_own_vue_compiler_dom.html">
      build your own vue compiler-dom</a></p>
      <div class="org-src-container">
        <pre class="src src-js" id="org9284a9c"><span class=
        "linenr">   1: </span><span class=
        "org-doc">/** jsx?|tsx? file header */</span>
<span class="linenr">   2: </span><span class=
"org-keyword">let</span> <span class=
"org-variable-name">debugOn</span> = <span class=
"org-constant">true</span>
<span class="linenr">   3: </span><span class=
"org-keyword">let</span> <span class=
"org-variable-name">currentLogKey</span> = <span class=
"org-string">'cc'</span>
<span class="linenr">   4: </span><span class=
"org-keyword">let</span> <span class=
"org-variable-name">__BROWSER__</span> = <span class=
"org-keyword">typeof</span> window !== <span class=
"org-string">'undefined'</span>
<span class="linenr">   5: </span><span class=
"org-keyword">let</span> <span class=
"org-variable-name">logs</span> = {}
<span class="linenr">   6: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">__DEV__</span> = <span class=
"org-constant">true</span>
<span class="linenr">   7: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">log</span> = (fn, message) =&gt; {
<span class="linenr">   8: </span>  <span class=
"org-keyword">if</span> (debugOn) {
<span class="linenr">   9: </span>    <span class=
"org-keyword">if</span> (message === <span class=
"org-constant">undefined</span>) {
<span class="linenr">  10: </span>      console.log(fn)
<span class="linenr">  11: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr">  12: </span>      console.log(<span class=
"org-string">`[${fn}] ${message}`</span>)
<span class="linenr">  13: </span>    }
<span class="linenr">  14: </span>  }
<span class="linenr">  15: </span>}
<span class="linenr">  16: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">logOn</span> = () =&gt; (debugOn = <span class=
"org-constant">true</span>)
<span class="linenr">  17: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">logOff</span> = () =&gt; (debugOn = <span class="org-constant">false</span>)
<span class="linenr">  18: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">logEnd</span> = (hint = <span class=
"org-string">'END'</span>) =&gt; {
<span class="linenr">  19: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">m</span> = <span class=
"org-string">`--------- ${hint} ---------`</span>
<span class="linenr">  20: </span>  <span class=
"org-keyword">if</span> (debugOn) pushLog(m, <span class=
"org-string">'title'</span>)
<span class="linenr">  21: </span>  <span class=
"org-keyword">return</span> m
<span class="linenr">  22: </span>}
<span class="linenr">  23: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">logBr</span> = () =&gt; console.log(<span class="org-string">'\n'</span>)
<span class="linenr">  24: </span><span class=
"org-keyword">let</span> <span class=
"org-variable-name">debugTraverseOn</span> = <span class=
"org-constant">false</span>
<span class="linenr">  25: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">logTraverseOn</span> = () =&gt; (debugTraverseOn = <span class="org-constant">true</span>)
<span class="linenr">  26: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">logTraverseOff</span> = () =&gt; (debugTraverseOn = <span class="org-constant">false</span>)
<span class="linenr">  27: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">logg</span> = (hint, ...msg) =&gt; {
<span class="linenr">  28: </span>  <span class=
"org-keyword">if</span> (!debugTraverseOn &amp;& hint === <span class="org-string">'traverseNode'</span>) <span class="org-keyword">return</span>
<span class="linenr">  29: </span>  <span class=
"org-keyword">if</span> (debugOn) {
<span class="linenr">  30: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">m</span> = logEnd(hint)
<span class=
"linenr">  31: </span>    msg.forEach((m) =&gt; pushLog(m))
<span class="linenr">  32: </span>  }
<span class="linenr">  33: </span>}
<span class="linenr">  34: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">pushLog</span>(<span class=
"org-variable-name">m</span>, <span class=
"org-variable-name">type</span> = <span class=
"org-string">'normal'</span>) {
<span class=
"linenr">  35: </span>  ;(logs[currentLogKey] || (logs[currentLogKey] = [])).push({ value: m, type })
<span class="linenr">  36: </span>  log(m)
<span class="linenr">  37: </span>}
<span class="linenr">  38: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">clearLog</span>(<span class=
"org-variable-name">key</span>) {
<span class="linenr">  39: </span>  <span class=
"org-keyword">if</span> (key) {
<span class="linenr">  40: </span>    logs[key] = []
<span class="linenr">  41: </span>  } <span class=
"org-keyword">else</span> {
<span class="linenr">  42: </span>    logs = {}
<span class="linenr">  43: </span>  }
<span class="linenr">  44: </span>}
<span class="linenr">  45: </span>
<span class="linenr">  46: </span><span class=
"org-keyword">let</span> <span class=
"org-variable-name">w</span> = {}
<span class="linenr">  47: </span><span class=
"org-keyword">let</span> <span class=
"org-variable-name">debugEle</span> = <span class=
"org-constant">null</span>
<span class="linenr">  48: </span><span class=
"org-keyword">if</span> (__BROWSER__) {
<span class="linenr">  49: </span>  w = <span class=
"org-keyword">typeof</span> window !== <span class=
"org-string">'undefined'</span> ? window : {}
<span class="linenr">  50: </span>}
<span class=
"linenr">  51: </span>w.log = (msg, isLine = <span class=
"org-constant">false</span>) =&gt; {
<span class="linenr">  52: </span>  <span class=
"org-keyword">if</span> (debugEle) {
<span class="linenr">  53: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">cls</span> = [<span class=
"org-string">'debug'</span>, isLine ? <span class=
"org-string">'line'</span> : <span class=
"org-string">''</span>].filter(Boolen)
<span class="linenr">  54: </span>    ele.innerHTML = <span class=
"org-string">`${debugEl.innerHTML}&lt;pre class="${cls.join(' ')}"&gt;&lt;code&gt;${</span>
<span class="linenr">  55: </span><span class=
"org-string">      typeof msg === 'object' ? syntaxHighlight(msg) : msg</span>
<span class="linenr">  56: </span><span class=
"org-string">    }&lt;/code&gt;&lt;/pre&gt;`</span>
<span class="linenr">  57: </span>    <span class=
"org-keyword">return</span> ele.innerHTML
<span class="linenr">  58: </span>  }
<span class="linenr">  59: </span>}
<span class="linenr">  60: </span>
<span class="linenr">  61: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">syntaxHighlight</span>(<span class=
"org-variable-name">json</span>) {
<span class="linenr">  62: </span>  <span class=
"org-keyword">if</span> (<span class=
"org-keyword">typeof</span> json != <span class=
"org-string">'string'</span>) {
<span class=
"linenr">  63: </span>    json = JSON.stringify(json, <span class=
"org-constant">undefined</span>, <span class=
"org-highlight-numbers-number">2</span>)
<span class="linenr">  64: </span>  }
<span class=
"linenr">  65: </span>  json = json.replace(<span class="org-string">/&amp;/</span>g, <span class="org-string">'&amp;amp;'</span>).replace(<span class="org-string">/&lt;/</span>g, <span class="org-string">'&amp;lt;'</span>).replace(<span class="org-string">/&gt;/</span>g, <span class="org-string">'&amp;gt;'</span>)
<span class="linenr">  66: </span>  <span class=
"org-keyword">return</span> json.replace(
<span class="linenr">  67: </span>    <span class=
"org-string">/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/</span>g,
<span class="linenr">  68: </span>    <span class=
"org-keyword">function</span> (<span class=
"org-variable-name">match</span>) {
<span class="linenr">  69: </span>      <span class=
"org-keyword">var</span> <span class=
"org-variable-name">cls</span> = <span class=
"org-string">'number'</span>
<span class="linenr">  70: </span>      <span class=
"org-keyword">if</span> (<span class=
"org-string">/^"/</span>.test(match)) {
<span class="linenr">  71: </span>        <span class=
"org-keyword">if</span> (<span class=
"org-string">/:$/</span>.test(match)) {
<span class="linenr">  72: </span>          cls = <span class=
"org-string">'key'</span>
<span class="linenr">  73: </span>        } <span class=
"org-keyword">else</span> {
<span class="linenr">  74: </span>          cls = <span class=
"org-string">'string'</span>
<span class="linenr">  75: </span>        }
<span class="linenr">  76: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (<span class=
"org-string">/true|false/</span>.test(match)) {
<span class="linenr">  77: </span>        cls = <span class=
"org-string">'boolean'</span>
<span class="linenr">  78: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (<span class=
"org-string">/null/</span>.test(match)) {
<span class="linenr">  79: </span>        cls = <span class=
"org-string">'null'</span>
<span class="linenr">  80: </span>      }
<span class="linenr">  81: </span>      <span class=
"org-keyword">return</span> <span class=
"org-string">'&lt;span class="'</span> + cls + <span class=
"org-string">'"&gt;'</span> + match + <span class=
"org-string">'&lt;/span&gt;'</span>
<span class="linenr">  82: </span>    }
<span class="linenr">  83: </span>  )
<span class="linenr">  84: </span>}
<span class="linenr">  85: </span>
<span class="linenr">  86: </span><span class=
"org-keyword">let</span> <span class=
"org-variable-name">babelParser</span>
<span class="linenr">  87: </span><span class=
"org-keyword">if</span> (!__BROWSER__) {
<span class=
"linenr">  88: </span>  babelParser = require(process.env.NODE_LIB + <span class="org-string">'/@babel/parser'</span>)
<span class="linenr">  89: </span>}
<span class="linenr">  90: </span><span class=
"org-comment-delimiter">// </span><span class=
"org-comment">The default decoder only provides escapes for characters reserved as part of</span>
<span class="linenr">  91: </span><span class=
"org-comment-delimiter">// </span><span class=
"org-comment">the template syntax, and is only used if the custom renderer did not provide</span>
<span class="linenr">  92: </span><span class=
"org-comment-delimiter">// </span><span class=
"org-comment">a platform-specific decoder.</span>
<span class="linenr">  93: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">decodeRE</span> = <span class=
"org-string">/&amp;(gt|lt|amp|apos|quot);/</span>g
<span class="linenr">  94: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">decodeMap</span> = {
<span class="linenr">  95: </span>  gt: <span class=
"org-string">'&gt;'</span>,
<span class="linenr">  96: </span>  lt: <span class=
"org-string">'&lt;'</span>,
<span class="linenr">  97: </span>  amp: <span class=
"org-string">'&amp;'</span>,
<span class="linenr">  98: </span>  apos: <span class=
"org-string">"'"</span>,
<span class="linenr">  99: </span>  quot: <span class=
"org-string">'"'</span>
<span class="linenr"> 100: </span>}
<span class="linenr"> 101: </span>
<span class="linenr"> 102: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">EMPTY_OBJ</span> = {}
<span class="linenr"> 103: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">NO</span> = () =&gt; <span class=
"org-constant">false</span>
<span class="linenr"> 104: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">NOOP</span> = () =&gt; {}
<span class="linenr"> 105: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">locStub</span> = {
<span class="linenr"> 106: </span>  source: <span class=
"org-string">''</span>,
<span class="linenr"> 107: </span>  start: { line: <span class=
"org-highlight-numbers-number">1</span>, column: <span class=
"org-highlight-numbers-number">1</span>, offset: <span class=
"org-highlight-numbers-number">0</span> },
<span class="linenr"> 108: </span>  end: { line: <span class=
"org-highlight-numbers-number">1</span>, column: <span class=
"org-highlight-numbers-number">1</span>, offset: <span class=
"org-highlight-numbers-number">0</span> }
<span class="linenr"> 109: </span>}
<span class="linenr"> 110: </span>
<span class="linenr"> 111: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">ConstantTypes</span> = {
<span class="linenr"> 112: </span>  NOT_CONSTANT: <span class=
"org-highlight-numbers-number">0</span>,
<span class="linenr"> 113: </span>  CAN_SKIP_PATCH: <span class=
"org-highlight-numbers-number">1</span>,
<span class="linenr"> 114: </span>  CAN_HOIST: <span class=
"org-highlight-numbers-number">2</span>,
<span class="linenr"> 115: </span>  CAN_STRINGIFY: <span class=
"org-highlight-numbers-number">3</span>
<span class="linenr"> 116: </span>}
<span class="linenr"> 117: </span>
<span class="linenr"> 118: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">ElementTypes</span> = {
<span class="linenr"> 119: </span>  ELEMENT: <span class=
"org-highlight-numbers-number">0</span>,
<span class="linenr"> 120: </span>  COMPONENT: <span class=
"org-highlight-numbers-number">1</span>,
<span class="linenr"> 121: </span>  SLOT: <span class=
"org-highlight-numbers-number">2</span>,
<span class="linenr"> 122: </span>  TEMPLATE: <span class=
"org-highlight-numbers-number">3</span>
<span class="linenr"> 123: </span>}
<span class="linenr"> 124: </span>
<span class="linenr"> 125: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">Namespaces</span> = {
<span class="linenr"> 126: </span>  HTML: <span class=
"org-highlight-numbers-number">0</span>
<span class="linenr"> 127: </span>}
<span class="linenr"> 128: </span>
<span class="linenr"> 129: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">NodeTypes</span> = {
<span class="linenr"> 130: </span>  ROOT: <span class=
"org-highlight-numbers-number">0</span>,
<span class="linenr"> 131: </span>  ELEMENT: <span class=
"org-highlight-numbers-number">1</span>,
<span class="linenr"> 132: </span>  TEXT: <span class=
"org-highlight-numbers-number">2</span>,
<span class="linenr"> 133: </span>  COMMENT: <span class=
"org-highlight-numbers-number">3</span>,
<span class="linenr"> 134: </span>  SIMPLE_EXPRESSION: <span class=
"org-highlight-numbers-number">4</span>,
<span class="linenr"> 135: </span>  INTERPOLATION: <span class=
"org-highlight-numbers-number">5</span>,
<span class="linenr"> 136: </span>  ATTRIBUTE: <span class=
"org-highlight-numbers-number">6</span>,
<span class="linenr"> 137: </span>  DIRECTIVE: <span class=
"org-highlight-numbers-number">7</span>,
<span class="linenr"> 138: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">containers</span>
<span class=
"linenr"> 139: </span>  COMPOUND_EXPRESSION: <span class=
"org-highlight-numbers-number">8</span>,
<span class="linenr"> 140: </span>  IF: <span class=
"org-highlight-numbers-number">9</span>,
<span class="linenr"> 141: </span>  IF_BRANCH: <span class=
"org-highlight-numbers-number">10</span>,
<span class="linenr"> 142: </span>  FOR: <span class=
"org-highlight-numbers-number">11</span>,
<span class="linenr"> 143: </span>  TEXT_CALL: <span class=
"org-highlight-numbers-number">12</span>,
<span class="linenr"> 144: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">codegen</span>
<span class="linenr"> 145: </span>  VNODE_CALL: <span class=
"org-highlight-numbers-number">13</span>,
<span class=
"linenr"> 146: </span>  JS_CALL_EXPRESSION: <span class="org-highlight-numbers-number">14</span>,
<span class=
"linenr"> 147: </span>  JS_OBJECT_EXPRESSION: <span class=
"org-highlight-numbers-number">15</span>,
<span class="linenr"> 148: </span>  JS_PROPERTY: <span class=
"org-highlight-numbers-number">16</span>,
<span class=
"linenr"> 149: </span>  JS_ARRAY_EXPRESSION: <span class=
"org-highlight-numbers-number">17</span>,
<span class=
"linenr"> 150: </span>  JS_FUNCTION_EXPRESSION: <span class=
"org-highlight-numbers-number">18</span>,
<span class=
"linenr"> 151: </span>  JS_CONDITIONAL_EXPRESSION: <span class=
"org-highlight-numbers-number">19</span>,
<span class=
"linenr"> 152: </span>  JS_CACHE_EXPRESSION: <span class=
"org-highlight-numbers-number">20</span>,
<span class="linenr"> 153: </span>
<span class="linenr"> 154: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">ssr codegen</span>
<span class=
"linenr"> 155: </span>  JS_BLOCK_STATEMENT: <span class="org-highlight-numbers-number">21</span>,
<span class=
"linenr"> 156: </span>  JS_TEMPLATE_LITERAL: <span class=
"org-highlight-numbers-number">22</span>,
<span class="linenr"> 157: </span>  JS_IF_STATEMENT: <span class=
"org-highlight-numbers-number">23</span>,
<span class=
"linenr"> 158: </span>  JS_ASSIGNMENT_EXPRESSION: <span class=
"org-highlight-numbers-number">24</span>,
<span class=
"linenr"> 159: </span>  JS_SEQUENCE_EXPRESSION: <span class=
"org-highlight-numbers-number">25</span>,
<span class=
"linenr"> 160: </span>  JS_RETURN_STATEMENT: <span class=
"org-highlight-numbers-number">26</span>
<span class="linenr"> 161: </span>}
<span class="linenr"> 162: </span>
<span class="linenr"> 163: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">defaultParserOptions</span> = {
<span class="linenr"> 164: </span>  delimiters: [<span class=
"org-string">`{{`</span>, <span class="org-string">`}}`</span>],
<span class=
"linenr"> 165: </span>  getNamespace: () =&gt; Namespaces.HTML,
<span class=
"linenr"> 166: </span>  getTextMode: () =&gt; TextModes.DATA,
<span class="linenr"> 167: </span>  isVoidTag: NO,
<span class="linenr"> 168: </span>  isPreTag: NO,
<span class="linenr"> 169: </span>  isCustomElement: NO,
<span class="linenr"> 170: </span>  decodeEntities: (rawText) =&gt;
<span class=
"linenr"> 171: </span>    rawText.replace(decodeRE, (_, p1) =&gt; decodeMap[p1]),
<span class="linenr"> 172: </span>  onError: defaultOnError,
<span class="linenr"> 173: </span>  onWarn: defaultOnWarn,
<span class="linenr"> 174: </span>  comments: __DEV__
<span class="linenr"> 175: </span>}
<span class="linenr"> 176: </span>
<span class="linenr"> 177: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">TagType</span> = {
<span class="linenr"> 178: </span>  Start: <span class=
"org-highlight-numbers-number">0</span>,
<span class="linenr"> 179: </span>  End: <span class=
"org-highlight-numbers-number">1</span>
<span class="linenr"> 180: </span>}
<span class="linenr"> 181: </span>
<span class="linenr"> 182: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">TextModes</span> = {
<span class="linenr"> 183: </span>  DATA: <span class=
"org-highlight-numbers-number">0</span>,
<span class="linenr"> 184: </span>  RCDATA: <span class=
"org-highlight-numbers-number">1</span>,
<span class="linenr"> 185: </span>  RAWTEXT: <span class=
"org-highlight-numbers-number">2</span>,
<span class="linenr"> 186: </span>  CDATA: <span class=
"org-highlight-numbers-number">3</span>,
<span class="linenr"> 187: </span>  ATTRIBUTE_VALUE: <span class=
"org-highlight-numbers-number">4</span>
<span class="linenr"> 188: </span>}
<span class="linenr"> 189: </span>
<span class="linenr"> 190: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">extend</span> = Object.assign
<span class="linenr"> 191: </span>
<span class="linenr"> 192: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">defaultOnError</span>(<span class=
"org-variable-name">error</span>) {
<span class="linenr"> 193: </span>  <span class=
"org-keyword">throw</span> error
<span class="linenr"> 194: </span>}
<span class="linenr"> 195: </span>
<span class="linenr"> 196: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">defaultOnWarn</span>(<span class=
"org-variable-name">msg</span>) {
<span class=
"linenr"> 197: </span>  __DEV__ &amp;& console.warn(<span class=
"org-string">`[Vue warn] ${msg.message}`</span>)
<span class="linenr"> 198: </span>}
<span class="linenr"> 199: </span>
<span class="linenr"> 200: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">makeMap</span>(<span class=
"org-variable-name">str</span>, <span class=
"org-variable-name">expectsLowerCase</span>) {
<span class="linenr"> 201: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">map</span> = Object.create(<span class=
"org-constant">null</span>)
<span class="linenr"> 202: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">list</span> = str.split(<span class=
"org-string">','</span>)
<span class="linenr"> 203: </span>  <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; list.length; i++) {
<span class="linenr"> 204: </span>    map[list[i]] = <span class=
"org-constant">true</span>
<span class="linenr"> 205: </span>  }
<span class="linenr"> 206: </span>  <span class=
"org-keyword">return</span> expectsLowerCase
<span class=
"linenr"> 207: </span>    ? (val) =&gt; !!map[val.toLowerCase()]
<span class="linenr"> 208: </span>    : (val) =&gt; !!map[val]
<span class="linenr"> 209: </span>}
<span class="linenr"> 210: </span>
<span class="linenr"> 211: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">hasOwnProperty</span> = Object.<span class=
"org-constant">prototype</span>.hasOwnProperty
<span class="linenr"> 212: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">hasOwn</span> = (val, key) =&gt; hasOwnProperty.call(val, key)
<span class="linenr"> 213: </span>
<span class="linenr"> 214: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">isArray</span> = Array.isArray
<span class="linenr"> 215: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">isMap</span> = (val) =&gt; toTypeString(val) === <span class="org-string">'[object Map]'</span>
<span class="linenr"> 216: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">isSet</span> = (val) =&gt; toTypeString(val) === <span class="org-string">'[object Set]'</span>
<span class="linenr"> 217: </span>
<span class="linenr"> 218: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">isDate</span> = (val) =&gt; val <span class=
"org-keyword">instanceof</span> <span class="org-type">Date</span>
<span class="linenr"> 219: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">isFunction</span> = (val) =&gt; <span class=
"org-keyword">typeof</span> val === <span class=
"org-string">'function'</span>
<span class="linenr"> 220: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">isString</span> = (val) =&gt; <span class=
"org-keyword">typeof</span> val === <span class=
"org-string">'string'</span>
<span class="linenr"> 221: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">isSymbol</span> = (val) =&gt; <span class=
"org-keyword">typeof</span> val === <span class=
"org-string">'symbol'</span>
<span class="linenr"> 222: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">isObject</span> = (val) =&gt; val !== <span class="org-constant">null</span> &amp;& <span class="org-keyword">typeof</span> val === <span class="org-string">'object'</span>
<span class="linenr"> 223: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">onRE</span> = <span class=
"org-string">/^on[^a-z]/</span>
<span class="linenr"> 224: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">isOn</span> = (key) =&gt; onRE.test(key)
<span class="linenr"> 225: </span>
<span class="linenr"> 226: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">isPromise</span> = (val) =&gt; {
<span class="linenr"> 227: </span>  <span class=
"org-keyword">return</span> isObject(val) &amp;& isFunction(val.then) &amp;& isFunction(val.<span class="org-keyword">catch</span>)
<span class="linenr"> 228: </span>}
<span class="linenr"> 229: </span>
<span class="linenr"> 230: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">objectToString</span> = Object.<span class=
"org-constant">prototype</span>.toString
<span class="linenr"> 231: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">toTypeString</span> = (value) =&gt; objectToString.call(value)
<span class="linenr"> 232: </span>
<span class="linenr"> 233: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">toRawType</span> = (value) =&gt; {
<span class="linenr"> 234: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">extract "RawType" from strings like "[object RawType]"</span>
<span class="linenr"> 235: </span>  <span class=
"org-keyword">return</span> toTypeString(value).slice(<span class=
"org-highlight-numbers-number">8</span>, -<span class=
"org-highlight-numbers-number">1</span>)
<span class="linenr"> 236: </span>}
<span class="linenr"> 237: </span>
<span class="linenr"> 238: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">isText</span>(<span class=
"org-variable-name">node</span>) {
<span id="coderef-isText" class="coderef-off"><span class=
"linenr"> 239: </span>  <span class=
"org-comment-delimiter">//</span></span>
<span class="linenr"> 240: </span>  <span class=
"org-keyword">return</span> node.type === NodeTypes.INTERPOLATION || node.type === NodeTypes.TEXT
<span class="linenr"> 241: </span>}
<span class="linenr"> 242: </span>
<span class="linenr"> 243: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">isPlainObject</span> = (val) =&gt; toTypeString(val) === <span class="org-string">'[object Object]'</span>
<span class="linenr"> 244: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">isIntegerKey</span> = (key) =&gt;
<span class="linenr"> 245: </span>  isString(key) &amp;&
<span class="linenr"> 246: </span>  key !== <span class=
"org-string">'NaN'</span> &amp;&
<span class="linenr"> 247: </span>  key[<span class=
"org-highlight-numbers-number">0</span>] !== <span class=
"org-string">'-'</span> &amp;&
<span class="linenr"> 248: </span>  <span class=
"org-string">''</span> + parseInt(key, <span class=
"org-highlight-numbers-number">10</span>) === key
<span class="linenr"> 249: </span>
<span class="linenr"> 250: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">isReservedProp</span> = <span class=
"org-comment-delimiter">/*</span><span class=
"org-comment">#__PURE__</span><span class=
"org-comment-delimiter">*/</span> makeMap(
<span class="linenr"> 251: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">the leading comma is intentional so empty string "" is also included</span>
<span class="linenr"> 252: </span>  <span class=
"org-string">',key,ref,ref_for,ref_key,'</span> +
<span class="linenr"> 253: </span>    <span class=
"org-string">'onVnodeBeforeMount,onVnodeMounted,'</span> +
<span class="linenr"> 254: </span>    <span class=
"org-string">'onVnodeBeforeUpdate,onVnodeUpdated,'</span> +
<span class="linenr"> 255: </span>    <span class=
"org-string">'onVnodeBeforeUnmount,onVnodeUnmounted'</span>
<span class="linenr"> 256: </span>)
<span class="linenr"> 257: </span>
<span class="linenr"> 258: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">GLOBALS_WHITE_LISTED</span> =
<span class="linenr"> 259: </span>  <span class=
"org-string">'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,'</span> +
<span class="linenr"> 260: </span>  <span class=
"org-string">'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,'</span> +
<span class="linenr"> 261: </span>  <span class=
"org-string">'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt'</span>
<span class="linenr"> 262: </span>
<span class="linenr"> 263: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">isGloballyWhitelisted</span> = <span class=
"org-comment-delimiter">/*</span><span class=
"org-comment">#__PURE__</span><span class=
"org-comment-delimiter">*/</span> makeMap(GLOBALS_WHITE_LISTED)
<span class="linenr"> 264: </span>
<span class="linenr"> 265: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">nonIdentifierRE</span> = <span class=
"org-string">/^\d|[^\$\w]/</span>
<span class="linenr"> 266: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">isSimpleIdentifier</span> = (name) =&gt; !nonIdentifierRE.test(name)
<span class="linenr"> 267: </span>
<span class="linenr"> 268: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">isBuiltInDirective</span> = <span class=
"org-comment-delimiter">/*</span><span class=
"org-comment">#__PURE__</span><span class=
"org-comment-delimiter">*/</span> makeMap(
<span class="linenr"> 269: </span>  <span class=
"org-string">'bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo'</span>
<span class="linenr"> 270: </span>)
<span class="linenr"> 271: </span>
<span class="linenr"> 272: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">getCursor</span>(<span class=
"org-variable-name">context</span>) {
<span class="linenr"> 273: </span>  <span class=
"org-keyword">const</span> { column, line, offset } = context
<span class="linenr"> 274: </span>  <span class=
"org-keyword">return</span> { column, line, offset }
<span class="linenr"> 275: </span>}
<span class="linenr"> 276: </span>
<span class="linenr"> 277: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">getSelection</span>(<span class=
"org-variable-name">context</span>, <span class=
"org-variable-name">start</span>, <span class=
"org-variable-name">end</span>) {
<span class="linenr"> 278: </span>  end = end || getCursor(context)
<span class="linenr"> 279: </span>  <span class=
"org-keyword">return</span> {
<span class="linenr"> 280: </span>    start,
<span class="linenr"> 281: </span>    end,
<span class=
"linenr"> 282: </span>    source: context.originalSource.slice(start.offset, end.offset)
<span class="linenr"> 283: </span>  }
<span class="linenr"> 284: </span>}
<span class="linenr"> 285: </span>
<span class="linenr"> 286: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">last</span>(<span class=
"org-variable-name">xs</span>) {
<span class="linenr"> 287: </span>  <span class=
"org-keyword">return</span> xs[xs.length - <span class=
"org-highlight-numbers-number">1</span>]
<span class="linenr"> 288: </span>}
<span class="linenr"> 289: </span>
<span class="linenr"> 290: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">startsWith</span>(<span class=
"org-variable-name">source</span>, <span class=
"org-variable-name">searchString</span>) {
<span class="linenr"> 291: </span>  <span class=
"org-keyword">return</span> source.startsWith(searchString)
<span class="linenr"> 292: </span>}
<span class="linenr"> 293: </span>
<span class="linenr"> 294: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">advancePositionWithMutation</span>(
<span class="linenr"> 295: </span>  <span class=
"org-variable-name">pos</span>,
<span class="linenr"> 296: </span>  <span class=
"org-variable-name">source</span>,
<span class=
"linenr"> 297: </span>  numberOfCharacters = source.length
<span class="linenr"> 298: </span>) {
<span class="linenr"> 299: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">linesCount</span> = <span class=
"org-highlight-numbers-number">0</span>
<span class="linenr"> 300: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">lastNewLinePos</span> = -<span class=
"org-highlight-numbers-number">1</span>
<span class="linenr"> 301: </span>  <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; numberOfCharacters; i++) {
<span class="linenr"> 302: </span>    <span class=
"org-keyword">if</span> (source.charCodeAt(i) === <span class=
"org-highlight-numbers-number">10</span> <span class=
"org-comment-delimiter">/* </span><span class=
"org-comment">newline char code</span><span class=
"org-comment-delimiter"> */</span>) {
<span class="linenr"> 303: </span>      linesCount++
<span class="linenr"> 304: </span>      lastNewLinePos = i
<span class="linenr"> 305: </span>    }
<span class="linenr"> 306: </span>  }
<span class="linenr"> 307: </span>
<span class=
"linenr"> 308: </span>  pos.offset += numberOfCharacters
<span class="linenr"> 309: </span>  pos.line += linesCount
<span class="linenr"> 310: </span>  pos.column =
<span class=
"linenr"> 311: </span>    lastNewLinePos === -<span class=
"org-highlight-numbers-number">1</span>
<span class=
"linenr"> 312: </span>      ? pos.column + numberOfCharacters
<span class=
"linenr"> 313: </span>      : numberOfCharacters - lastNewLinePos
<span class="linenr"> 314: </span>
<span class="linenr"> 315: </span>  <span class=
"org-keyword">return</span> pos
<span class="linenr"> 316: </span>}
<span class="linenr"> 317: </span>
<span class="linenr"> 318: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">advancePositionWithClone</span>(
<span class="linenr"> 319: </span>  <span class=
"org-variable-name">pos</span>,
<span class="linenr"> 320: </span>  <span class=
"org-variable-name">source</span>,
<span class=
"linenr"> 321: </span>  numberOfCharacters = source.length
<span class="linenr"> 322: </span>) {
<span class="linenr"> 323: </span>  <span class=
"org-keyword">return</span> advancePositionWithMutation(
<span class="linenr"> 324: </span>    extend({}, pos),
<span class="linenr"> 325: </span>    source,
<span class="linenr"> 326: </span>    numberOfCharacters
<span class="linenr"> 327: </span>  )
<span class="linenr"> 328: </span>}
<span class="linenr"> 329: </span>
<span class="linenr"> 330: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">advanceBy</span>(<span class=
"org-variable-name">context</span>, <span class=
"org-variable-name">numberOfCharacters</span>) {
<span class="linenr"> 331: </span>  <span class=
"org-keyword">const</span> { source } = context
<span class=
"linenr"> 332: </span>  advancePositionWithMutation(context, source, numberOfCharacters)
<span class=
"linenr"> 333: </span>  context.source = source.slice(numberOfCharacters)
<span class="linenr"> 334: </span>}
<span class="linenr"> 335: </span>
<span class="linenr"> 336: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">advanceSpaces</span>(<span class=
"org-variable-name">context</span>) {
<span class="linenr"> 337: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">match</span> = <span class=
"org-string">/^[\t\r\n\f ]+/</span>.exec(context.source)
<span class="linenr"> 338: </span>  <span class=
"org-keyword">if</span> (match) {
<span class=
"linenr"> 339: </span>    advanceBy(context, match[<span class=
"org-highlight-numbers-number">0</span>].length)
<span class="linenr"> 340: </span>  }
<span class="linenr"> 341: </span>}
<span class="linenr"> 342: </span>
<span class="linenr"> 343: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">getNewPosition</span>(<span class=
"org-variable-name">context</span>, <span class=
"org-variable-name">start</span>, <span class=
"org-variable-name">numberOfCharacters</span>) {
<span class="linenr"> 344: </span>  <span class=
"org-keyword">return</span> advancePositionWithClone(
<span class="linenr"> 345: </span>    start,
<span class=
"linenr"> 346: </span>    context.originalSource.slice(start.offset, numberOfCharacters),
<span class="linenr"> 347: </span>    numberOfCharacters
<span class="linenr"> 348: </span>  )
<span class="linenr"> 349: </span>}
<span class="linenr"> 350: </span>
<span class="linenr"> 351: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">emitError</span>(<span class=
"org-variable-name">context</span>, <span class=
"org-variable-name">code</span>, <span class=
"org-variable-name">offset</span>, <span class=
"org-variable-name">loc</span> = <span class=
"org-variable-name">getCursor</span>(<span class=
"org-variable-name">context</span>)) {
<span class="linenr"> 352: </span>  <span class=
"org-keyword">if</span> (offset) {
<span class="linenr"> 353: </span>    loc.offset += offset
<span class="linenr"> 354: </span>    loc.column += offset
<span class="linenr"> 355: </span>  }
<span class="linenr"> 356: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">ignore...</span>
<span class="linenr"> 357: </span>}
<span class="linenr"> 358: </span>
<span class="linenr"> 359: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">isEnd</span>(<span class=
"org-variable-name">context</span>, <span class=
"org-variable-name">mode</span>, <span class=
"org-variable-name">ancestors</span>) {
<span class="linenr"> 360: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">s</span> = context.source
<span class="linenr"> 361: </span>
<span class="linenr"> 362: </span>  <span class=
"org-keyword">switch</span> (mode) {
<span class="linenr"> 363: </span>    <span class=
"org-keyword">case</span> TextModes.DATA:
<span class="linenr"> 364: </span>      <span class=
"org-keyword">if</span> (startsWith(s, <span class=
"org-string">'&lt;/'</span>)) {
<span class="linenr"> 365: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment"><span class="org-bold"><span class=
"org-warning">TODO:</span></span></span><span class=
"org-comment"> probably bad performance</span>
<span class="linenr"> 366: </span>        <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = ancestors.length - <span class=
"org-highlight-numbers-number">1</span>; i &gt;= <span class=
"org-highlight-numbers-number">0</span>; --i) {
<span class="linenr"> 367: </span>          <span class=
"org-keyword">if</span> (startsWithEndTagOpen(s, ancestors[i].tag)) {
<span class="linenr"> 368: </span>            <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr"> 369: </span>          }
<span class="linenr"> 370: </span>        }
<span class="linenr"> 371: </span>      }
<span class="linenr"> 372: </span>      <span class=
"org-keyword">break</span>
<span class="linenr"> 373: </span>
<span class="linenr"> 374: </span>    <span class=
"org-keyword">case</span> TextModes.RCDATA:
<span class="linenr"> 375: </span>    <span class=
"org-keyword">case</span> TextModes.RAWTEXT: {
<span class="linenr"> 376: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">parent</span> = last(ancestors)
<span class="linenr"> 377: </span>      <span class=
"org-keyword">if</span> (parent &amp;& startsWithEndTagOpen(s, parent.tag)) {
<span class="linenr"> 378: </span>        <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr"> 379: </span>      }
<span class="linenr"> 380: </span>      <span class=
"org-keyword">break</span>
<span class="linenr"> 381: </span>    }
<span class="linenr"> 382: </span>
<span class="linenr"> 383: </span>    <span class=
"org-keyword">case</span> TextModes.CDATA:
<span class="linenr"> 384: </span>      <span class=
"org-keyword">if</span> (startsWith(s, <span class=
"org-string">']]&gt;'</span>)) {
<span class="linenr"> 385: </span>        <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr"> 386: </span>      }
<span class="linenr"> 387: </span>      <span class=
"org-keyword">break</span>
<span class="linenr"> 388: </span>  }
<span class="linenr"> 389: </span>
<span class="linenr"> 390: </span>  <span class=
"org-keyword">return</span> !s
<span class="linenr"> 391: </span>}
<span class="linenr"> 392: </span>
<span class="linenr"> 393: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">startsWithEndTagOpen</span>(<span class=
"org-variable-name">source</span>, <span class=
"org-variable-name">tag</span>) {
<span class="linenr"> 394: </span>  <span class=
"org-keyword">return</span> (
<span class=
"linenr"> 395: </span>    startsWith(source, <span class=
"org-string">'&lt;/'</span>) &amp;&
<span class="linenr"> 396: </span>    source.slice(<span class=
"org-highlight-numbers-number">2</span>, <span class=
"org-highlight-numbers-number">2</span> + tag.length).toLowerCase() === tag.toLowerCase() &amp;&
<span class=
"linenr"> 397: </span>    /[\t\r\n\f /&gt;]/.test(source[<span class="org-highlight-numbers-number">2</span> + tag.length] || <span class="org-string">'&gt;'</span>)
<span class="linenr"> 398: </span>  )
<span class="linenr"> 399: </span>}
<span class="linenr"> 400: </span>
<span class="linenr"> 401: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">cacheStringFunction</span> = (fn) =&gt; {
<span class="linenr"> 402: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">cache</span> = Object.create(<span class=
"org-constant">null</span>)
<span class="linenr"> 403: </span>  <span class=
"org-keyword">return</span> (str) =&gt; {
<span class="linenr"> 404: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">hit</span> = cache[str]
<span class="linenr"> 405: </span>    <span class=
"org-keyword">return</span> hit || (cache[str] = fn(str))
<span class="linenr"> 406: </span>  }
<span class="linenr"> 407: </span>}
<span class="linenr"> 408: </span>
<span class="linenr"> 409: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">camelizeRE</span> = <span class=
"org-string">/-(\w)/</span>g
<span class="linenr"> 410: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">camelize</span> = cacheStringFunction((str) =&gt; {
<span class="linenr"> 411: </span>  <span class=
"org-keyword">return</span> str.replace(camelizeRE, (_, c) =&gt; (c ? c.toUpperCase() : <span class="org-string">''</span>))
<span class="linenr"> 412: </span>})
<span class="linenr"> 413: </span>
<span class="linenr"> 414: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">hyphenateRE</span> = <span class=
"org-string">/\B([A-Z])/</span>g
<span class="linenr"> 415: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">hyphenate</span> = cacheStringFunction((str) =&gt;
<span class=
"linenr"> 416: </span>  str.replace(hyphenateRE, <span class=
"org-string">'-$1'</span>).toLowerCase()
<span class="linenr"> 417: </span>)
<span class="linenr"> 418: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">capitalize</span> = cacheStringFunction(
<span class=
"linenr"> 419: </span>  (str) =&gt; str.charAt(<span class=
"org-highlight-numbers-number">0</span>).toUpperCase() + str.slice(<span class="org-highlight-numbers-number">1</span>)
<span class="linenr"> 420: </span>)
<span class="linenr"> 421: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">toHandlerKey</span> = cacheStringFunction((str) =&gt;
<span class="linenr"> 422: </span>  str ? <span class=
"org-string">`on${capitalize(str)}`</span> : <span class=
"org-string">``</span>
<span class="linenr"> 423: </span>)
<span class="linenr"> 424: </span>
<span class="linenr"> 425: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">isBuiltInType</span> = (tag, expected) =&gt;
<span class=
"linenr"> 426: </span>  tag === expected || tag === hyphenate(expected)
<span class="linenr"> 427: </span>
<span class="linenr"> 428: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">isCoreComponent</span>(<span class=
"org-variable-name">tag</span>) {
<span class="linenr"> 429: </span>  <span class=
"org-keyword">if</span> (isBuiltInType(tag, <span class=
"org-string">'Teleport'</span>)) {
<span class="linenr"> 430: </span>    <span class=
"org-keyword">return</span> TELEPORT
<span class="linenr"> 431: </span>  } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (isBuiltInType(tag, <span class=
"org-string">'Suspense'</span>)) {
<span class="linenr"> 432: </span>    <span class=
"org-keyword">return</span> SUSPENSE
<span class="linenr"> 433: </span>  } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (isBuiltInType(tag, <span class=
"org-string">'KeepAlive'</span>)) {
<span class="linenr"> 434: </span>    <span class=
"org-keyword">return</span> KEEP_ALIVE
<span class="linenr"> 435: </span>  } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (isBuiltInType(tag, <span class=
"org-string">'BaseTransition'</span>)) {
<span class="linenr"> 436: </span>    <span class=
"org-keyword">return</span> BASE_TRANSITION
<span class="linenr"> 437: </span>  }
<span class="linenr"> 438: </span>}
<span class="linenr"> 439: </span>
<span class="linenr"> 440: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">isSpecialTemplateDirective</span> = <span class="org-comment-delimiter">/*</span><span class="org-comment">#__PURE__</span><span class="org-comment-delimiter">*/</span> makeMap(
<span class="linenr"> 441: </span>  <span class=
"org-string">`if,else,else-if,for,slot`</span>
<span class="linenr"> 442: </span>)
<span class="linenr"> 443: </span>
<span class="linenr"> 444: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">getVNodeHelper</span>(<span class=
"org-variable-name">ssr</span>, <span class=
"org-variable-name">isComponent</span>) {
<span class="linenr"> 445: </span>  <span class=
"org-keyword">return</span> ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE
<span class="linenr"> 446: </span>}
<span class="linenr"> 447: </span>
<span class="linenr"> 448: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">getVNodeBlockHelper</span>(<span class=
"org-variable-name">ssr</span>, <span class=
"org-variable-name">isComponent</span>) {
<span class="linenr"> 449: </span>  <span class=
"org-keyword">return</span> ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK
<span class="linenr"> 450: </span>}
<span class="linenr"> 451: </span>
<span class="linenr"> 452: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">isSingleElementRoot</span>(<span class=
"org-variable-name">root</span>, <span class=
"org-variable-name">child</span>) {
<span class="linenr"> 453: </span>  <span class=
"org-keyword">const</span> { children } = root
<span class="linenr"> 454: </span>  <span class=
"org-keyword">return</span> (
<span class=
"linenr"> 455: </span>    children.length === <span class=
"org-highlight-numbers-number">1</span> &amp;&
<span class=
"linenr"> 456: </span>    child.type === NodeTypes.ELEMENT &amp;&
<span class="linenr"> 457: </span>    !isSlotOutlet(child)
<span class="linenr"> 458: </span>  )
<span class="linenr"> 459: </span>}
<span class="linenr"> 460: </span>
<span class="linenr"> 461: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">isSlotOutlet</span>(<span class=
"org-variable-name">node</span>) {
<span class="linenr"> 462: </span>  <span class=
"org-keyword">return</span> node.type === NodeTypes.ELEMENT &amp;& node.tagType === ElementTypes.SLOT
<span class="linenr"> 463: </span>}
<span class="linenr"> 464: </span>
<span class="linenr"> 465: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">findDir</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">name</span>, <span class=
"org-variable-name">allowEmpty</span> = <span class=
"org-constant">false</span>) {
<span class="linenr"> 466: </span>  <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; node.props.length; i++) {
<span class="linenr"> 467: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">p</span> = node.props[i]
<span class="linenr"> 468: </span>    <span class=
"org-keyword">if</span> (
<span class=
"linenr"> 469: </span>      p.type === NodeTypes.DIRECTIVE &amp;&
<span class=
"linenr"> 470: </span>      (allowEmpty || p.exp) &amp;&
<span class=
"linenr"> 471: </span>      (isString(name) ? p.name === name : name.test(p.name))
<span class="linenr"> 472: </span>    ) {
<span class="linenr"> 473: </span>      <span class=
"org-keyword">return</span> p
<span class="linenr"> 474: </span>    }
<span class="linenr"> 475: </span>  }
<span class="linenr"> 476: </span>}
<span class="linenr"> 477: </span>
<span class="linenr"> 478: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">findProp</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">name</span>, <span class=
"org-variable-name">dynamicOnly</span> = <span class=
"org-constant">false</span>, <span class=
"org-variable-name">allowEmpty</span> = <span class=
"org-constant">false</span>) {
<span class="linenr"> 479: </span>  <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; node.props.length; i++) {
<span class="linenr"> 480: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">p</span> = node.props[i]
<span class="linenr"> 481: </span>    <span class=
"org-keyword">if</span> (p.type === NodeTypes.ATTRIBUTE) {
<span class="linenr"> 482: </span>      <span class=
"org-keyword">if</span> (dynamicOnly) <span class=
"org-keyword">continue</span>
<span class="linenr"> 483: </span>      <span class=
"org-keyword">if</span> (p.name === name &amp;& (p.value || allowEmpty)) {
<span class="linenr"> 484: </span>        <span class=
"org-keyword">return</span> p
<span class="linenr"> 485: </span>      }
<span class="linenr"> 486: </span>    } <span class=
"org-keyword">else</span> <span class="org-keyword">if</span> (
<span class="linenr"> 487: </span>      p.name === <span class=
"org-string">'bind'</span> &amp;&
<span class=
"linenr"> 488: </span>      (p.exp || allowEmpty) &amp;&
<span class="linenr"> 489: </span>      isStaticArgOf(p.arg, name)
<span class="linenr"> 490: </span>    ) {
<span class="linenr"> 491: </span>      <span class=
"org-keyword">return</span> p
<span class="linenr"> 492: </span>    }
<span class="linenr"> 493: </span>  }
<span class="linenr"> 494: </span>}
<span class="linenr"> 495: </span>
<span class="linenr"> 496: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">isStaticExp</span> = (p) =&gt; p.type === NodeTypes.SIMPLE_EXPRESSION &amp;& p.isStatic
<span class="linenr"> 497: </span>
<span class="linenr"> 498: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">isStaticArgOf</span>(<span class=
"org-variable-name">arg</span>, <span class=
"org-variable-name">name</span>) {
<span class="linenr"> 499: </span>  <span class=
"org-keyword">return</span> !!(arg &amp;& isStaticExp(arg) &amp;& arg.content === name)
<span class="linenr"> 500: </span>}
<span class="linenr"> 501: </span>
<span class="linenr"> 502: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">isVSlot</span>(<span class=
"org-variable-name">p</span>) {
<span class="linenr"> 503: </span>  <span class=
"org-keyword">return</span> p.type === NodeTypes.DIRECTIVE &amp;& p.name === <span class="org-string">'slot'</span>
<span class="linenr"> 504: </span>}
<span class="linenr"> 505: </span>
<span class="linenr"> 506: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">getMemoedVNodeCall</span>(<span class=
"org-variable-name">node</span>) {
<span class="linenr"> 507: </span>  <span class=
"org-keyword">if</span> (node.type === NodeTypes.JS_CALL_EXPRESSION &amp;& node.callee === WITH_MEMO) {
<span class="linenr"> 508: </span>    <span class=
"org-keyword">return</span> node.<span class=
"org-constant">arguments</span>[<span class=
"org-highlight-numbers-number">1</span>].returns
<span class="linenr"> 509: </span>  } <span class=
"org-keyword">else</span> {
<span class="linenr"> 510: </span>    <span class=
"org-keyword">return</span> node
<span class="linenr"> 511: </span>  }
<span class="linenr"> 512: </span>}
<span class="linenr"> 513: </span>
<span class="linenr"> 514: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">getInnerRange</span>(<span class=
"org-variable-name">loc</span>, <span class=
"org-variable-name">offset</span>, <span class=
"org-variable-name">length</span>) {
<span class="linenr"> 515: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">source</span> = loc.source.slice(offset, offset + length)
<span class="linenr"> 516: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">newLoc</span> = {
<span class="linenr"> 517: </span>    source,
<span class=
"linenr"> 518: </span>    start: advancePositionWithClone(loc.start, loc.source, offset),
<span class="linenr"> 519: </span>    end: loc.end
<span class="linenr"> 520: </span>  }
<span class="linenr"> 521: </span>
<span class="linenr"> 522: </span>  <span class=
"org-keyword">if</span> (length != <span class=
"org-constant">null</span>) {
<span class=
"linenr"> 523: </span>    newLoc.end = advancePositionWithClone(
<span class="linenr"> 524: </span>      loc.start,
<span class="linenr"> 525: </span>      loc.source,
<span class="linenr"> 526: </span>      offset + length
<span class="linenr"> 527: </span>    )
<span class="linenr"> 528: </span>  }
<span class="linenr"> 529: </span>
<span class="linenr"> 530: </span>  <span class=
"org-keyword">return</span> newLoc
<span class="linenr"> 531: </span>}
<span class="linenr"> 532: </span>
<span class="linenr"> 533: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">toValidAssetId</span>(<span class=
"org-variable-name">name</span>, <span class=
"org-variable-name">type</span>) {
<span class="linenr"> 534: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">see issue#4422, we need adding identifier on validAssetId if variable `name` has specific character</span>
<span class="linenr"> 535: </span>  <span class=
"org-keyword">return</span> <span class=
"org-string">`_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) =&gt; {</span>
<span class="linenr"> 536: </span><span class=
"org-string">    return searchValue === '-' ? '_' : name.charCodeAt(replaceValue).toString()</span>
<span class="linenr"> 537: </span><span class=
"org-string">  })}`</span>
<span class="linenr"> 538: </span>}
<span class="linenr"> 539: </span>
<span class="linenr"> 540: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">isTemplateNode</span>(<span class=
"org-variable-name">node</span>) {
<span class="linenr"> 541: </span>  <span class=
"org-keyword">return</span> (
<span class=
"linenr"> 542: </span>    node.type === NodeTypes.ELEMENT &amp;& node.tagType === ElementTypes.TEMPLATE
<span class="linenr"> 543: </span>  )
<span class="linenr"> 544: </span>}
<span class="linenr"> 545: </span>
<span class="linenr"> 546: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">isComponent</span>(<span class=
"org-variable-name">tag</span>, <span class=
"org-variable-name">props</span>, <span class=
"org-variable-name">context</span>) {
<span class="linenr"> 547: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">options</span> = context.options
<span class="linenr"> 548: </span>  <span class=
"org-keyword">if</span> (options.isCustomElement(tag)) {
<span class="linenr"> 549: </span>    <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr"> 550: </span>  }
<span class="linenr"> 551: </span>  <span class=
"org-keyword">if</span> (
<span class="linenr"> 552: </span>    tag === <span class=
"org-string">'component'</span> ||
<span class="linenr"> 553: </span>    /^[A-Z]/.test(tag) ||
<span class="linenr"> 554: </span>    isCoreComponent(tag) ||
<span class=
"linenr"> 555: </span>    (options.isBuiltInComponent &amp;& options.isBuiltInComponent(tag)) ||
<span class=
"linenr"> 556: </span>    (options.isNativeTag &amp;& !options.isNativeTag(tag))
<span class="linenr"> 557: </span>  ) {
<span class="linenr"> 558: </span>    <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr"> 559: </span>  }
<span class="linenr"> 560: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">at this point the tag should be a native tag, but check for potential "is"</span>
<span class="linenr"> 561: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">casting</span>
<span class="linenr"> 562: </span>  <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; props.length; i++) {
<span class="linenr"> 563: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">p</span> = props[i]
<span class="linenr"> 564: </span>    <span class=
"org-keyword">if</span> (p.type === NodeTypes.ATTRIBUTE) {
<span class="linenr"> 565: </span>      <span class=
"org-keyword">if</span> (p.name === <span class=
"org-string">'is'</span> &amp;& p.value) {
<span class="linenr"> 566: </span>        <span class=
"org-keyword">if</span> (p.value.content.startsWith(<span class=
"org-string">'vue:'</span>)) {
<span class="linenr"> 567: </span>          <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr"> 568: </span>        }
<span class="linenr"> 569: </span>      }
<span class="linenr"> 570: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr"> 571: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">directive</span>
<span class="linenr"> 572: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">v-is (</span><span class="org-comment"><span class=
"org-bold"><span class=
"org-warning">TODO</span></span></span><span class=
"org-comment"> Deprecate)</span>
<span class="linenr"> 573: </span>      <span class=
"org-keyword">if</span> (p.name === <span class=
"org-string">'is'</span>) {
<span class="linenr"> 574: </span>        <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr"> 575: </span>      }
<span class="linenr"> 576: </span>    }
<span class="linenr"> 577: </span>  }
<span class="linenr"> 578: </span>}
<span class="linenr"> 579: </span>
<span class="linenr"> 580: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">pushNode</span>(<span class=
"org-variable-name">nodes</span>, <span class=
"org-variable-name">node</span>) {
<span class="linenr"> 581: </span>  <span class=
"org-keyword">if</span> (node.type === NodeTypes.TEXT) {
<span class="linenr"> 582: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">prev</span> = last(nodes)
<span class="linenr"> 583: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">Merge if both this and the previous node are text and those are</span>
<span class="linenr"> 584: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">consecutive. This happens for cases like "a &lt; b".</span>
<span class="linenr"> 585: </span>    <span class=
"org-keyword">if</span> (
<span class="linenr"> 586: </span>      prev &amp;&
<span class=
"linenr"> 587: </span>      prev.type === NodeTypes.TEXT &amp;&
<span class=
"linenr"> 588: </span>      prev.loc.end.offset === node.loc.start.offset
<span class="linenr"> 589: </span>    ) {
<span class=
"linenr"> 590: </span>      prev.content += node.content
<span class="linenr"> 591: </span>      prev.loc.end = node.loc.end
<span class=
"linenr"> 592: </span>      prev.loc.source += node.loc.source
<span class="linenr"> 593: </span>      <span class=
"org-keyword">return</span>
<span class="linenr"> 594: </span>    }
<span class="linenr"> 595: </span>  }
<span class="linenr"> 596: </span>
<span class="linenr"> 597: </span>  nodes.push(node)
<span class="linenr"> 598: </span>}
<span class="linenr"> 599: </span>
<span class="linenr"> 600: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">FRAGMENT</span> = Symbol(__DEV__ ? <span class=
"org-string">`Fragment`</span> : <span class=
"org-string">``</span>)
<span class="linenr"> 601: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">TELEPORT</span> = Symbol(__DEV__ ? <span class=
"org-string">`Teleport`</span> : <span class=
"org-string">``</span>)
<span class="linenr"> 602: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">SUSPENSE</span> = Symbol(__DEV__ ? <span class=
"org-string">`Suspense`</span> : <span class=
"org-string">``</span>)
<span class="linenr"> 603: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">KEEP_ALIVE</span> = Symbol(__DEV__ ? <span class="org-string">`KeepAlive`</span> : <span class="org-string">``</span>)
<span class="linenr"> 604: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">BASE_TRANSITION</span> = Symbol(__DEV__ ? <span class="org-string">`BaseTransition`</span> : <span class="org-string">``</span>)
<span class="linenr"> 605: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">OPEN_BLOCK</span> = Symbol(__DEV__ ? <span class="org-string">`openBlock`</span> : <span class="org-string">``</span>)
<span class="linenr"> 606: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">CREATE_BLOCK</span> = Symbol(__DEV__ ? <span class="org-string">`createBlock`</span> : <span class="org-string">``</span>)
<span class="linenr"> 607: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">CREATE_ELEMENT_BLOCK</span> = Symbol(__DEV__ ? <span class="org-string">`createElementBlock`</span> : <span class="org-string">``</span>)
<span class="linenr"> 608: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">CREATE_VNODE</span> = Symbol(__DEV__ ? <span class="org-string">`createVNode`</span> : <span class="org-string">``</span>)
<span class="linenr"> 609: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">CREATE_ELEMENT_VNODE</span> = Symbol(__DEV__ ? <span class="org-string">`createElementVNode`</span> : <span class="org-string">``</span>)
<span class="linenr"> 610: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">CREATE_COMMENT</span> = Symbol(__DEV__ ? <span class="org-string">`createCommentVNode`</span> : <span class="org-string">``</span>)
<span class="linenr"> 611: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">CREATE_TEXT</span> = Symbol(__DEV__ ? <span class="org-string">`createTextVNode`</span> : <span class="org-string">``</span>)
<span class="linenr"> 612: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">CREATE_STATIC</span> = Symbol(__DEV__ ? <span class="org-string">`createStaticVNode`</span> : <span class="org-string">``</span>)
<span class="linenr"> 613: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">RESOLVE_COMPONENT</span> = Symbol(__DEV__ ? <span class="org-string">`resolveComponent`</span> : <span class="org-string">``</span>)
<span class="linenr"> 614: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">RESOLVE_DYNAMIC_COMPONENT</span> = Symbol(
<span class="linenr"> 615: </span>  __DEV__ ? <span class=
"org-string">`resolveDynamicComponent`</span> : <span class=
"org-string">``</span>
<span class="linenr"> 616: </span>)
<span class="linenr"> 617: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">RESOLVE_DIRECTIVE</span> = Symbol(__DEV__ ? <span class="org-string">`resolveDirective`</span> : <span class="org-string">``</span>)
<span class="linenr"> 618: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">RESOLVE_FILTER</span> = Symbol(__DEV__ ? <span class="org-string">`resolveFilter`</span> : <span class="org-string">``</span>)
<span class="linenr"> 619: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">WITH_DIRECTIVES</span> = Symbol(__DEV__ ? <span class="org-string">`withDirectives`</span> : <span class="org-string">``</span>)
<span class="linenr"> 620: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">RENDER_LIST</span> = Symbol(__DEV__ ? <span class="org-string">`renderList`</span> : <span class="org-string">``</span>)
<span class="linenr"> 621: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">RENDER_SLOT</span> = Symbol(__DEV__ ? <span class="org-string">`renderSlot`</span> : <span class="org-string">``</span>)
<span class="linenr"> 622: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">CREATE_SLOTS</span> = Symbol(__DEV__ ? <span class="org-string">`createSlots`</span> : <span class="org-string">``</span>)
<span class="linenr"> 623: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">TO_DISPLAY_STRING</span> = Symbol(__DEV__ ? <span class="org-string">`toDisplayString`</span> : <span class="org-string">``</span>)
<span class="linenr"> 624: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">MERGE_PROPS</span> = Symbol(__DEV__ ? <span class="org-string">`mergeProps`</span> : <span class="org-string">``</span>)
<span class="linenr"> 625: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">NORMALIZE_CLASS</span> = Symbol(__DEV__ ? <span class="org-string">`normalizeClass`</span> : <span class="org-string">``</span>)
<span class="linenr"> 626: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">NORMALIZE_STYLE</span> = Symbol(__DEV__ ? <span class="org-string">`normalizeStyle`</span> : <span class="org-string">``</span>)
<span class="linenr"> 627: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">NORMALIZE_PROPS</span> = Symbol(__DEV__ ? <span class="org-string">`normalizeProps`</span> : <span class="org-string">``</span>)
<span class="linenr"> 628: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">GUARD_REACTIVE_PROPS</span> = Symbol(__DEV__ ? <span class="org-string">`guardReactiveProps`</span> : <span class="org-string">``</span>)
<span class="linenr"> 629: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">TO_HANDLERS</span> = Symbol(__DEV__ ? <span class="org-string">`toHandlers`</span> : <span class="org-string">``</span>)
<span class="linenr"> 630: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">CAMELIZE</span> = Symbol(__DEV__ ? <span class=
"org-string">`camelize`</span> : <span class=
"org-string">``</span>)
<span class="linenr"> 631: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">CAPITALIZE</span> = Symbol(__DEV__ ? <span class="org-string">`capitalize`</span> : <span class="org-string">``</span>)
<span class="linenr"> 632: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">TO_HANDLER_KEY</span> = Symbol(__DEV__ ? <span class="org-string">`toHandlerKey`</span> : <span class="org-string">``</span>)
<span class="linenr"> 633: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">SET_BLOCK_TRACKING</span> = Symbol(__DEV__ ? <span class="org-string">`setBlockTracking`</span> : <span class="org-string">``</span>)
<span class="linenr"> 634: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">PUSH_SCOPE_ID</span> = Symbol(__DEV__ ? <span class="org-string">`pushScopeId`</span> : <span class="org-string">``</span>)
<span class="linenr"> 635: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">POP_SCOPE_ID</span> = Symbol(__DEV__ ? <span class="org-string">`popScopeId`</span> : <span class="org-string">``</span>)
<span class="linenr"> 636: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">WITH_CTX</span> = Symbol(__DEV__ ? <span class=
"org-string">`withCtx`</span> : <span class="org-string">``</span>)
<span class="linenr"> 637: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">UNREF</span> = Symbol(__DEV__ ? <span class=
"org-string">`unref`</span> : <span class="org-string">``</span>)
<span class="linenr"> 638: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">IS_REF</span> = Symbol(__DEV__ ? <span class=
"org-string">`isRef`</span> : <span class="org-string">``</span>)
<span class="linenr"> 639: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">WITH_MEMO</span> = Symbol(__DEV__ ? <span class="org-string">`withMemo`</span> : <span class="org-string">``</span>)
<span class="linenr"> 640: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">IS_MEMO_SAME</span> = Symbol(__DEV__ ? <span class="org-string">`isMemoSame`</span> : <span class="org-string">``</span>)
<span class="linenr"> 641: </span>
<span class="linenr"> 642: </span><span class=
"org-comment-delimiter">// </span><span class=
"org-comment">Name mapping for runtime helpers that need to be imported from 'vue' in</span>
<span class="linenr"> 643: </span><span class=
"org-comment-delimiter">// </span><span class=
"org-comment">generated code. Make sure these are correctly exported in the runtime!</span>
<span class="linenr"> 644: </span><span class=
"org-comment-delimiter">// </span><span class=
"org-comment">Using `any` here because TS doesn't allow symbols as index type.</span>
<span class="linenr"> 645: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">helperNameMap</span> = {
<span class="linenr"> 646: </span>  [FRAGMENT]: <span class=
"org-string">`Fragment`</span>,
<span class="linenr"> 647: </span>  [TELEPORT]: <span class=
"org-string">`Teleport`</span>,
<span class="linenr"> 648: </span>  [SUSPENSE]: <span class=
"org-string">`Suspense`</span>,
<span class="linenr"> 649: </span>  [KEEP_ALIVE]: <span class=
"org-string">`KeepAlive`</span>,
<span class="linenr"> 650: </span>  [BASE_TRANSITION]: <span class=
"org-string">`BaseTransition`</span>,
<span class="linenr"> 651: </span>  [OPEN_BLOCK]: <span class=
"org-string">`openBlock`</span>,
<span class="linenr"> 652: </span>  [CREATE_BLOCK]: <span class=
"org-string">`createBlock`</span>,
<span class=
"linenr"> 653: </span>  [CREATE_ELEMENT_BLOCK]: <span class=
"org-string">`createElementBlock`</span>,
<span class="linenr"> 654: </span>  [CREATE_VNODE]: <span class=
"org-string">`createVNode`</span>,
<span class=
"linenr"> 655: </span>  [CREATE_ELEMENT_VNODE]: <span class=
"org-string">`createElementVNode`</span>,
<span class="linenr"> 656: </span>  [CREATE_COMMENT]: <span class=
"org-string">`createCommentVNode`</span>,
<span class="linenr"> 657: </span>  [CREATE_TEXT]: <span class=
"org-string">`createTextVNode`</span>,
<span class="linenr"> 658: </span>  [CREATE_STATIC]: <span class=
"org-string">`createStaticVNode`</span>,
<span class=
"linenr"> 659: </span>  [RESOLVE_COMPONENT]: <span class=
"org-string">`resolveComponent`</span>,
<span class=
"linenr"> 660: </span>  [RESOLVE_DYNAMIC_COMPONENT]: <span class=
"org-string">`resolveDynamicComponent`</span>,
<span class=
"linenr"> 661: </span>  [RESOLVE_DIRECTIVE]: <span class=
"org-string">`resolveDirective`</span>,
<span class="linenr"> 662: </span>  [RESOLVE_FILTER]: <span class=
"org-string">`resolveFilter`</span>,
<span class="linenr"> 663: </span>  [WITH_DIRECTIVES]: <span class=
"org-string">`withDirectives`</span>,
<span class="linenr"> 664: </span>  [RENDER_LIST]: <span class=
"org-string">`renderList`</span>,
<span class="linenr"> 665: </span>  [RENDER_SLOT]: <span class=
"org-string">`renderSlot`</span>,
<span class="linenr"> 666: </span>  [CREATE_SLOTS]: <span class=
"org-string">`createSlots`</span>,
<span class=
"linenr"> 667: </span>  [TO_DISPLAY_STRING]: <span class=
"org-string">`toDisplayString`</span>,
<span class="linenr"> 668: </span>  [MERGE_PROPS]: <span class=
"org-string">`mergeProps`</span>,
<span class="linenr"> 669: </span>  [NORMALIZE_CLASS]: <span class=
"org-string">`normalizeClass`</span>,
<span class="linenr"> 670: </span>  [NORMALIZE_STYLE]: <span class=
"org-string">`normalizeStyle`</span>,
<span class="linenr"> 671: </span>  [NORMALIZE_PROPS]: <span class=
"org-string">`normalizeProps`</span>,
<span class=
"linenr"> 672: </span>  [GUARD_REACTIVE_PROPS]: <span class=
"org-string">`guardReactiveProps`</span>,
<span class="linenr"> 673: </span>  [TO_HANDLERS]: <span class=
"org-string">`toHandlers`</span>,
<span class="linenr"> 674: </span>  [CAMELIZE]: <span class=
"org-string">`camelize`</span>,
<span class="linenr"> 675: </span>  [CAPITALIZE]: <span class=
"org-string">`capitalize`</span>,
<span class="linenr"> 676: </span>  [TO_HANDLER_KEY]: <span class=
"org-string">`toHandlerKey`</span>,
<span class=
"linenr"> 677: </span>  [SET_BLOCK_TRACKING]: <span class=
"org-string">`setBlockTracking`</span>,
<span class="linenr"> 678: </span>  [PUSH_SCOPE_ID]: <span class=
"org-string">`pushScopeId`</span>,
<span class="linenr"> 679: </span>  [POP_SCOPE_ID]: <span class=
"org-string">`popScopeId`</span>,
<span class="linenr"> 680: </span>  [WITH_CTX]: <span class=
"org-string">`withCtx`</span>,
<span class="linenr"> 681: </span>  [UNREF]: <span class=
"org-string">`unref`</span>,
<span class="linenr"> 682: </span>  [IS_REF]: <span class=
"org-string">`isRef`</span>,
<span class="linenr"> 683: </span>  [WITH_MEMO]: <span class=
"org-string">`withMemo`</span>,
<span class="linenr"> 684: </span>  [IS_MEMO_SAME]: <span class=
"org-string">`isMemoSame`</span>
<span class="linenr"> 685: </span>}
<span class="linenr"> 686: </span>
<span class="linenr"> 687: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">registerRuntimeHelpers</span>(<span class=
"org-variable-name">helpers</span>) {
<span class=
"linenr"> 688: </span>  Object.getOwnPropertySymbols(helpers).forEach((s) =&gt; {
<span class="linenr"> 689: </span>    helperNameMap[s] = helpers[s]
<span class="linenr"> 690: </span>  })
<span class="linenr"> 691: </span>}
<span class="linenr"> 692: </span>
<span class="linenr"> 693: </span><span class="org-doc">/**</span>
<span class="linenr"> 694: </span><span class=
"org-doc"> * Patch flags are optimization hints generated by the compiler.</span>
<span class="linenr"> 695: </span><span class=
"org-doc"> * when a block with dynamicChildren is encountered during diff, the algorithm</span>
<span class="linenr"> 696: </span><span class=
"org-doc"> * enters "optimized mode". In this mode, we know that the vdom is produced by</span>
<span class="linenr"> 697: </span><span class=
"org-doc"> * a render function generated by the compiler, so the algorithm only needs to</span>
<span class="linenr"> 698: </span><span class=
"org-doc"> * handle updates explicitly marked by these patch flags.</span>
<span class="linenr"> 699: </span><span class="org-doc"> *</span>
<span class="linenr"> 700: </span><span class=
"org-doc"> * Patch flags can be combined using the | bitwise operator and can be checked</span>
<span class="linenr"> 701: </span><span class=
"org-doc"> * using the & operator, e.g.</span>
<span class="linenr"> 702: </span><span class="org-doc"> *</span>
<span class="linenr"> 703: </span><span class=
"org-doc"> * ```js</span>
<span class="linenr"> 704: </span><span class=
"org-doc"> * const flag = TEXT | CLASS</span>
<span class="linenr"> 705: </span><span class=
"org-doc"> * if (flag & TEXT) { ... }</span>
<span class="linenr"> 706: </span><span class=
"org-doc"> * ```</span>
<span class="linenr"> 707: </span><span class="org-doc"> *</span>
<span class="linenr"> 708: </span><span class=
"org-doc"> * Check the `patchElement` function in '../../runtime-core/src/renderer.ts' to see how the</span>
<span class="linenr"> 709: </span><span class=
"org-doc"> * flags are handled during diff.</span>
<span class="linenr"> 710: </span><span class="org-doc"> */</span>
<span class="linenr"> 711: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">PatchFlags</span> = {
<span class="linenr"> 712: </span>  <span class=
"org-doc">/**</span>
<span class="linenr"> 713: </span><span class=
"org-doc">   * Indicates an element with dynamic textContent (children fast path)</span>
<span class="linenr"> 714: </span><span class=
"org-doc">   */</span>
<span class="linenr"> 715: </span>  TEXT: <span class=
"org-highlight-numbers-number">1</span>,
<span class="linenr"> 716: </span>
<span class="linenr"> 717: </span>  <span class=
"org-doc">/**</span>
<span class="linenr"> 718: </span><span class=
"org-doc">   * Indicates an element with dynamic class binding.</span>
<span class="linenr"> 719: </span><span class=
"org-doc">   */</span>
<span class="linenr"> 720: </span>  CLASS: <span class=
"org-highlight-numbers-number">1</span> &lt;&lt; <span class=
"org-highlight-numbers-number">1</span>,
<span class="linenr"> 721: </span>
<span class="linenr"> 722: </span>  <span class=
"org-doc">/**</span>
<span class="linenr"> 723: </span><span class=
"org-doc">   * Indicates an element with dynamic style</span>
<span class="linenr"> 724: </span><span class=
"org-doc">   * The compiler pre-compiles static string styles into static objects</span>
<span class="linenr"> 725: </span><span class=
"org-doc">   * + detects and hoists inline static objects</span>
<span class="linenr"> 726: </span><span class=
"org-doc">   * e.g. `style="color: red"` and `:style="{ color: 'red' }"` both get hoisted</span>
<span class="linenr"> 727: </span><span class=
"org-doc">   * as:</span>
<span class="linenr"> 728: </span><span class=
"org-doc">   * ```js</span>
<span class="linenr"> 729: </span><span class=
"org-doc">   * const style = { color: 'red' }</span>
<span class="linenr"> 730: </span><span class=
"org-doc">   * render() { return e('div', { style }) }</span>
<span class="linenr"> 731: </span><span class=
"org-doc">   * ```</span>
<span class="linenr"> 732: </span><span class=
"org-doc">   */</span>
<span class="linenr"> 733: </span>  STYLE: <span class=
"org-highlight-numbers-number">1</span> &lt;&lt; <span class=
"org-highlight-numbers-number">2</span>,
<span class="linenr"> 734: </span>
<span class="linenr"> 735: </span>  <span class=
"org-doc">/**</span>
<span class="linenr"> 736: </span><span class=
"org-doc">   * Indicates an element that has non-class/style dynamic props.</span>
<span class="linenr"> 737: </span><span class=
"org-doc">   * Can also be on a component that has any dynamic props (includes</span>
<span class="linenr"> 738: </span><span class=
"org-doc">   * class/style). when this flag is present, the vnode also has a dynamicProps</span>
<span class="linenr"> 739: </span><span class=
"org-doc">   * array that contains the keys of the props that may change so the runtime</span>
<span class="linenr"> 740: </span><span class=
"org-doc">   * can diff them faster (without having to worry about removed props)</span>
<span class="linenr"> 741: </span><span class=
"org-doc">   */</span>
<span class="linenr"> 742: </span>  PROPS: <span class=
"org-highlight-numbers-number">1</span> &lt;&lt; <span class=
"org-highlight-numbers-number">3</span>,
<span class="linenr"> 743: </span>
<span class="linenr"> 744: </span>  <span class=
"org-doc">/**</span>
<span class="linenr"> 745: </span><span class=
"org-doc">   * Indicates an element with props with dynamic keys. When keys change, a full</span>
<span class="linenr"> 746: </span><span class=
"org-doc">   * diff is always needed to remove the old key. This flag is mutually</span>
<span class="linenr"> 747: </span><span class=
"org-doc">   * exclusive with CLASS, STYLE and PROPS.</span>
<span class="linenr"> 748: </span><span class=
"org-doc">   */</span>
<span class="linenr"> 749: </span>  FULL_PROPS: <span class=
"org-highlight-numbers-number">1</span> &lt;&lt; <span class=
"org-highlight-numbers-number">4</span>,
<span class="linenr"> 750: </span>
<span class="linenr"> 751: </span>  <span class=
"org-doc">/**</span>
<span class="linenr"> 752: </span><span class=
"org-doc">   * Indicates an element with event listeners (which need to be attached</span>
<span class="linenr"> 753: </span><span class=
"org-doc">   * during hydration)</span>
<span class="linenr"> 754: </span><span class=
"org-doc">   */</span>
<span class="linenr"> 755: </span>  HYDRATE_EVENTS: <span class=
"org-highlight-numbers-number">1</span> &lt;&lt; <span class=
"org-highlight-numbers-number">5</span>,
<span class="linenr"> 756: </span>
<span class="linenr"> 757: </span>  <span class=
"org-doc">/**</span>
<span class="linenr"> 758: </span><span class=
"org-doc">   * Indicates a fragment whose children order doesn't change.</span>
<span class="linenr"> 759: </span><span class=
"org-doc">   */</span>
<span class="linenr"> 760: </span>  STABLE_FRAGMENT: <span class=
"org-highlight-numbers-number">1</span> &lt;&lt; <span class=
"org-highlight-numbers-number">6</span>,
<span class="linenr"> 761: </span>
<span class="linenr"> 762: </span>  <span class=
"org-doc">/**</span>
<span class="linenr"> 763: </span><span class=
"org-doc">   * Indicates a fragment with keyed or partially keyed children</span>
<span class="linenr"> 764: </span><span class=
"org-doc">   */</span>
<span class="linenr"> 765: </span>  KEYED_FRAGMENT: <span class=
"org-highlight-numbers-number">1</span> &lt;&lt; <span class=
"org-highlight-numbers-number">7</span>,
<span class="linenr"> 766: </span>
<span class="linenr"> 767: </span>  <span class=
"org-doc">/**</span>
<span class="linenr"> 768: </span><span class=
"org-doc">   * Indicates a fragment with unkeyed children.</span>
<span class="linenr"> 769: </span><span class=
"org-doc">   */</span>
<span class="linenr"> 770: </span>  UNKEYED_FRAGMENT: <span class=
"org-highlight-numbers-number">1</span> &lt;&lt; <span class=
"org-highlight-numbers-number">8</span>,
<span class="linenr"> 771: </span>
<span class="linenr"> 772: </span>  <span class=
"org-doc">/**</span>
<span class="linenr"> 773: </span><span class=
"org-doc">   * Indicates an element that only needs non-props patching, e.g. ref or</span>
<span class="linenr"> 774: </span><span class=
"org-doc">   * directives (onVnodeXXX hooks). since every patched vnode checks for refs</span>
<span class="linenr"> 775: </span><span class=
"org-doc">   * and onVnodeXXX hooks, it simply marks the vnode so that a parent block</span>
<span class="linenr"> 776: </span><span class=
"org-doc">   * will track it.</span>
<span class="linenr"> 777: </span><span class=
"org-doc">   */</span>
<span class="linenr"> 778: </span>  NEED_PATCH: <span class=
"org-highlight-numbers-number">1</span> &lt;&lt; <span class=
"org-highlight-numbers-number">9</span>,
<span class="linenr"> 779: </span>
<span class="linenr"> 780: </span>  <span class=
"org-doc">/**</span>
<span class="linenr"> 781: </span><span class=
"org-doc">   * Indicates a component with dynamic slots (e.g. slot that references a v-for</span>
<span class="linenr"> 782: </span><span class=
"org-doc">   * iterated value, or dynamic slot names).</span>
<span class="linenr"> 783: </span><span class=
"org-doc">   * Components with this flag are always force updated.</span>
<span class="linenr"> 784: </span><span class=
"org-doc">   */</span>
<span class="linenr"> 785: </span>  DYNAMIC_SLOTS: <span class=
"org-highlight-numbers-number">1</span> &lt;&lt; <span class=
"org-highlight-numbers-number">10</span>,
<span class="linenr"> 786: </span>
<span class="linenr"> 787: </span>  <span class=
"org-doc">/**</span>
<span class="linenr"> 788: </span><span class=
"org-doc">   * Indicates a fragment that was created only because the user has placed</span>
<span class="linenr"> 789: </span><span class=
"org-doc">   * comments at the root level of a template. This is a dev-only flag since</span>
<span class="linenr"> 790: </span><span class=
"org-doc">   * comments are stripped in production.</span>
<span class="linenr"> 791: </span><span class=
"org-doc">   */</span>
<span class="linenr"> 792: </span>  DEV_ROOT_FRAGMENT: <span class=
"org-highlight-numbers-number">1</span> &lt;&lt; <span class=
"org-highlight-numbers-number">11</span>,
<span class="linenr"> 793: </span>
<span class="linenr"> 794: </span>  <span class=
"org-doc">/**</span>
<span class="linenr"> 795: </span><span class=
"org-doc">   * SPECIAL FLAGS -------------------------------------------------------------</span>
<span class="linenr"> 796: </span><span class=
"org-doc">   * Special flags are negative integers. They are never matched against using</span>
<span class="linenr"> 797: </span><span class=
"org-doc">   * bitwise operators (bitwise matching should only happen in branches where</span>
<span class="linenr"> 798: </span><span class=
"org-doc">   * patchFlag &gt; 0), and are mutually exclusive. When checking for a special</span>
<span class="linenr"> 799: </span><span class=
"org-doc">   * flag, simply check patchFlag === FLAG.</span>
<span class="linenr"> 800: </span><span class=
"org-doc">   */</span>
<span class="linenr"> 801: </span>
<span class="linenr"> 802: </span>  <span class=
"org-doc">/**</span>
<span class="linenr"> 803: </span><span class=
"org-doc">   * Indicates a hoisted static vnode. This is a hint for hydration to skip</span>
<span class="linenr"> 804: </span><span class=
"org-doc">   * the entire sub tree since static content never needs to be updated.</span>
<span class="linenr"> 805: </span><span class=
"org-doc">   */</span>
<span class="linenr"> 806: </span>  HOISTED: -<span class=
"org-highlight-numbers-number">1</span>,
<span class="linenr"> 807: </span>  <span class=
"org-doc">/**</span>
<span class="linenr"> 808: </span><span class=
"org-doc">   * A special flag that indicates that the diffing algorithm should bail out</span>
<span class="linenr"> 809: </span><span class=
"org-doc">   * of optimized mode. For example, on block fragments created by renderSlot()</span>
<span class="linenr"> 810: </span><span class=
"org-doc">   * when encountering non-compiler generated slots (i.e. manually written</span>
<span class="linenr"> 811: </span><span class=
"org-doc">   * render functions, which should always be fully diffed)</span>
<span class="linenr"> 812: </span><span class=
"org-doc">   * OR manually cloneVNodes</span>
<span class="linenr"> 813: </span><span class=
"org-doc">   */</span>
<span class="linenr"> 814: </span>  BAIL: -<span class=
"org-highlight-numbers-number">2</span>
<span class="linenr"> 815: </span>}
<span class="linenr"> 816: </span>
<span class="linenr"> 817: </span><span class="org-doc">/**</span>
<span class="linenr"> 818: </span><span class=
"org-doc"> * dev only flag -&gt; name mapping</span>
<span class="linenr"> 819: </span><span class="org-doc"> */</span>
<span class="linenr"> 820: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">PatchFlagNames</span> = {
<span class="linenr"> 821: </span>  [PatchFlags.TEXT]: <span class=
"org-string">`TEXT`</span>,
<span class=
"linenr"> 822: </span>  [PatchFlags.CLASS]: <span class="org-string">`CLASS`</span>,
<span class=
"linenr"> 823: </span>  [PatchFlags.STYLE]: <span class="org-string">`STYLE`</span>,
<span class=
"linenr"> 824: </span>  [PatchFlags.PROPS]: <span class="org-string">`PROPS`</span>,
<span class=
"linenr"> 825: </span>  [PatchFlags.FULL_PROPS]: <span class=
"org-string">`FULL_PROPS`</span>,
<span class=
"linenr"> 826: </span>  [PatchFlags.HYDRATE_EVENTS]: <span class=
"org-string">`HYDRATE_EVENTS`</span>,
<span class=
"linenr"> 827: </span>  [PatchFlags.STABLE_FRAGMENT]: <span class=
"org-string">`STABLE_FRAGMENT`</span>,
<span class=
"linenr"> 828: </span>  [PatchFlags.KEYED_FRAGMENT]: <span class=
"org-string">`KEYED_FRAGMENT`</span>,
<span class=
"linenr"> 829: </span>  [PatchFlags.UNKEYED_FRAGMENT]: <span class=
"org-string">`UNKEYED_FRAGMENT`</span>,
<span class=
"linenr"> 830: </span>  [PatchFlags.NEED_PATCH]: <span class=
"org-string">`NEED_PATCH`</span>,
<span class=
"linenr"> 831: </span>  [PatchFlags.DYNAMIC_SLOTS]: <span class=
"org-string">`DYNAMIC_SLOTS`</span>,
<span class=
"linenr"> 832: </span>  [PatchFlags.DEV_ROOT_FRAGMENT]: <span class="org-string">`DEV_ROOT_FRAGMENT`</span>,
<span class=
"linenr"> 833: </span>  [PatchFlags.HOISTED]: <span class=
"org-string">`HOISTED`</span>,
<span class="linenr"> 834: </span>  [PatchFlags.BAIL]: <span class=
"org-string">`BAIL`</span>
<span class="linenr"> 835: </span>}
<span class="linenr"> 836: </span>
<span class="linenr"> 837: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">genFlagText</span>(<span class=
"org-variable-name">flag</span>, <span class=
"org-variable-name">names</span> = <span class=
"org-variable-name">PatchFlagNames</span>) {
<span class="linenr"> 838: </span>  <span class=
"org-keyword">if</span> (isArray(flag)) {
<span class="linenr"> 839: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">f</span> = <span class=
"org-highlight-numbers-number">0</span>
<span class="linenr"> 840: </span>    flag.forEach((ff) =&gt; {
<span class="linenr"> 841: </span>      f |= ff
<span class="linenr"> 842: </span>    })
<span class="linenr"> 843: </span>    <span class=
"org-keyword">return</span> <span class=
"org-string">`${f} /* ${flag.map((f) =&gt; names[f]).join(', ')} */`</span>
<span class="linenr"> 844: </span>  } <span class=
"org-keyword">else</span> {
<span class="linenr"> 845: </span>    <span class=
"org-keyword">return</span> <span class=
"org-string">`${flag} /* ${names[flag]} */`</span>
<span class="linenr"> 846: </span>  }
<span class="linenr"> 847: </span>}
<span class="linenr"> 848: </span>
<span class="linenr"> 849: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">propsHelperSet</span> = <span class=
"org-keyword">new</span> <span class=
"org-type">Set</span>([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS])
<span class="linenr"> 850: </span>
<span class="linenr"> 851: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">getUnnormalizedProps</span>(<span class=
"org-variable-name">props</span>, <span class=
"org-variable-name">callPath</span> = []) {
<span class="linenr"> 852: </span>  <span class=
"org-keyword">if</span> (
<span class="linenr"> 853: </span>    props &amp;&
<span class="linenr"> 854: </span>    !isString(props) &amp;&
<span class=
"linenr"> 855: </span>    props.type === NodeTypes.JS_CALL_EXPRESSION
<span class="linenr"> 856: </span>  ) {
<span class="linenr"> 857: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">callee</span> = props.callee
<span class="linenr"> 858: </span>    <span class=
"org-keyword">if</span> (!isString(callee) &amp;& propsHelperSet.has(callee)) {
<span class="linenr"> 859: </span>      <span class=
"org-keyword">return</span> getUnnormalizedProps(props.<span class=
"org-constant">arguments</span>[<span class=
"org-highlight-numbers-number">0</span>], callPath.concat(props))
<span class="linenr"> 860: </span>    }
<span class="linenr"> 861: </span>  }
<span class="linenr"> 862: </span>  <span class=
"org-keyword">return</span> [props, callPath]
<span class="linenr"> 863: </span>}
<span class="linenr"> 864: </span>
<span class="linenr"> 865: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">injectProp</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">prop</span>, <span class=
"org-variable-name">context</span>) {
<span class="linenr"> 866: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">propsWithInjection</span>
<span class="linenr"> 867: </span>  <span class=
"org-doc">/**</span>
<span class="linenr"> 868: </span><span class=
"org-doc">   * 1. mergeProps(...)</span>
<span class="linenr"> 869: </span><span class=
"org-doc">   * 2. toHandlers(...)</span>
<span class="linenr"> 870: </span><span class=
"org-doc">   * 3. normalizeProps(...)</span>
<span class="linenr"> 871: </span><span class=
"org-doc">   * 4. normalizeProps(guardReactiveProps(...))</span>
<span class="linenr"> 872: </span><span class="org-doc">   *</span>
<span class="linenr"> 873: </span><span class=
"org-doc">   * we need to get the real props before normalization</span>
<span class="linenr"> 874: </span><span class=
"org-doc">   */</span>
<span class="linenr"> 875: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">props</span> =
<span class=
"linenr"> 876: </span>    node.type === NodeTypes.VNODE_CALL ? node.props : node.<span class="org-constant">arguments</span>[<span class="org-highlight-numbers-number">2</span>]
<span class="linenr"> 877: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">callPath</span> = []
<span class="linenr"> 878: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">parentCall</span>
<span class="linenr"> 879: </span>  <span class=
"org-keyword">if</span> (
<span class="linenr"> 880: </span>    props &amp;&
<span class="linenr"> 881: </span>    !isString(props) &amp;&
<span class=
"linenr"> 882: </span>    props.type === NodeTypes.JS_CALL_EXPRESSION
<span class="linenr"> 883: </span>  ) {
<span class="linenr"> 884: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">ret</span> = getUnnormalizedProps(props)
<span class="linenr"> 885: </span>    props = ret[<span class=
"org-highlight-numbers-number">0</span>]
<span class="linenr"> 886: </span>    callPath = ret[<span class=
"org-highlight-numbers-number">1</span>]
<span class=
"linenr"> 887: </span>    parentCall = callPath[callPath.length - <span class="org-highlight-numbers-number">1</span>]
<span class="linenr"> 888: </span>  }
<span class="linenr"> 889: </span>
<span class="linenr"> 890: </span>  <span class=
"org-keyword">if</span> (props == <span class=
"org-constant">null</span> || isString(props)) {
<span class=
"linenr"> 891: </span>    propsWithInjection = createObjectExpression([prop])
<span class="linenr"> 892: </span>  } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (props.type === NodeTypes.JS_CALL_EXPRESSION) {
<span class="linenr"> 893: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">merged props... add ours</span>
<span class="linenr"> 894: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">only inject key to object literal if it's the first argument so that</span>
<span class="linenr"> 895: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">if doesn't override user provided keys</span>
<span class="linenr"> 896: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">first</span> = props.<span class=
"org-constant">arguments</span>[<span class=
"org-highlight-numbers-number">0</span>] | JSChildNode
<span class="linenr"> 897: </span>    <span class=
"org-keyword">if</span> (!isString(first) &amp;& first.type === NodeTypes.JS_OBJECT_EXPRESSION) {
<span class=
"linenr"> 898: </span>      first.properties.unshift(prop)
<span class="linenr"> 899: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr"> 900: </span>      <span class=
"org-keyword">if</span> (props.callee === TO_HANDLERS) {
<span class="linenr"> 901: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">#2366</span>
<span class=
"linenr"> 902: </span>        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
<span class=
"linenr"> 903: </span>          createObjectExpression([prop]),
<span class="linenr"> 904: </span>          props
<span class="linenr"> 905: </span>        ])
<span class="linenr"> 906: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr"> 907: </span>        props.<span class=
"org-constant">arguments</span>.unshift(createObjectExpression([prop]))
<span class="linenr"> 908: </span>      }
<span class="linenr"> 909: </span>    }
<span class=
"linenr"> 910: </span>    !propsWithInjection &amp;& (propsWithInjection = props)
<span class="linenr"> 911: </span>  } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (props.type === NodeTypes.JS_OBJECT_EXPRESSION) {
<span class="linenr"> 912: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">alreadyExists</span> = <span class=
"org-constant">false</span>
<span class="linenr"> 913: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">check existing key to avoid overriding user provided keys</span>
<span class="linenr"> 914: </span>    <span class=
"org-keyword">if</span> (prop.key.type === NodeTypes.SIMPLE_EXPRESSION) {
<span class="linenr"> 915: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">propKeyName</span> = prop.key.content
<span class=
"linenr"> 916: </span>      alreadyExists = props.properties.some(
<span class="linenr"> 917: </span>        (p) =&gt;
<span class=
"linenr"> 918: </span>          p.key.type === NodeTypes.SIMPLE_EXPRESSION &amp;&
<span class=
"linenr"> 919: </span>          p.key.content === propKeyName
<span class="linenr"> 920: </span>      )
<span class="linenr"> 921: </span>    }
<span class="linenr"> 922: </span>    <span class=
"org-keyword">if</span> (!alreadyExists) {
<span class=
"linenr"> 923: </span>      props.properties.unshift(prop)
<span class="linenr"> 924: </span>    }
<span class="linenr"> 925: </span>    propsWithInjection = props
<span class="linenr"> 926: </span>  } <span class=
"org-keyword">else</span> {
<span class="linenr"> 927: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">single v-bind with expression, return a merged replacement</span>
<span class=
"linenr"> 928: </span>    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
<span class=
"linenr"> 929: </span>      createObjectExpression([prop]),
<span class="linenr"> 930: </span>      props
<span class="linenr"> 931: </span>    ])
<span class="linenr"> 932: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(props))`,</span>
<span class="linenr"> 933: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">it will be rewritten as `normalizeProps(mergeProps({ key: 0 }, props))`,</span>
<span class="linenr"> 934: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">the `guardReactiveProps` will no longer be needed</span>
<span class="linenr"> 935: </span>    <span class=
"org-keyword">if</span> (parentCall &amp;& parentCall.callee === GUARD_REACTIVE_PROPS) {
<span class=
"linenr"> 936: </span>      parentCall = callPath[callPath.length - <span class="org-highlight-numbers-number">2</span>]
<span class="linenr"> 937: </span>    }
<span class="linenr"> 938: </span>  }
<span class="linenr"> 939: </span>  <span class=
"org-keyword">if</span> (node.type === NodeTypes.VNODE_CALL) {
<span class="linenr"> 940: </span>    <span class=
"org-keyword">if</span> (parentCall) {
<span class="linenr"> 941: </span>      parentCall.<span class=
"org-constant">arguments</span>[<span class=
"org-highlight-numbers-number">0</span>] = propsWithInjection
<span class="linenr"> 942: </span>    } <span class=
"org-keyword">else</span> {
<span class=
"linenr"> 943: </span>      node.props = propsWithInjection
<span class="linenr"> 944: </span>    }
<span class="linenr"> 945: </span>  } <span class=
"org-keyword">else</span> {
<span class="linenr"> 946: </span>    <span class=
"org-keyword">if</span> (parentCall) {
<span class="linenr"> 947: </span>      parentCall.<span class=
"org-constant">arguments</span>[<span class=
"org-highlight-numbers-number">0</span>] = propsWithInjection
<span class="linenr"> 948: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr"> 949: </span>      node.<span class=
"org-constant">arguments</span>[<span class=
"org-highlight-numbers-number">2</span>] = propsWithInjection
<span class="linenr"> 950: </span>    }
<span class="linenr"> 951: </span>  }
<span class="linenr"> 952: </span>}
<span class="linenr"> 953: </span>
<span class="linenr"> 954: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">BindingTypes</span> = {
<span class="linenr"> 955: </span>  <span class=
"org-doc">/**</span>
<span class="linenr"> 956: </span><span class=
"org-doc">   * returned from data()</span>
<span class="linenr"> 957: </span><span class=
"org-doc">   */</span>
<span class="linenr"> 958: </span>  DATA: <span class=
"org-string">'data'</span>,
<span class="linenr"> 959: </span>  <span class=
"org-doc">/**</span>
<span class="linenr"> 960: </span><span class=
"org-doc">   * declared as a prop</span>
<span class="linenr"> 961: </span><span class=
"org-doc">   */</span>
<span class="linenr"> 962: </span>  PROPS: <span class=
"org-string">'props'</span>,
<span class="linenr"> 963: </span>  <span class=
"org-doc">/**</span>
<span class="linenr"> 964: </span><span class=
"org-doc">   * a local alias of a `&lt;script setup&gt;` destructured prop.</span>
<span class="linenr"> 965: </span><span class=
"org-doc">   * the original is stored in __propsAliases of the bindingMetadata object.</span>
<span class="linenr"> 966: </span><span class=
"org-doc">   */</span>
<span class="linenr"> 967: </span>  PROPS_ALIASED: <span class=
"org-string">'props-aliased'</span>,
<span class="linenr"> 968: </span>  <span class=
"org-doc">/**</span>
<span class="linenr"> 969: </span><span class=
"org-doc">   * a let binding (may or may not be a ref)</span>
<span class="linenr"> 970: </span><span class=
"org-doc">   */</span>
<span class="linenr"> 971: </span>  SETUP_LET: <span class=
"org-string">'setup-let'</span>,
<span class="linenr"> 972: </span>  <span class=
"org-doc">/**</span>
<span class="linenr"> 973: </span><span class=
"org-doc">   * a const binding that can never be a ref.</span>
<span class="linenr"> 974: </span><span class=
"org-doc">   * these bindings don't need `unref()` calls when processed in inlined</span>
<span class="linenr"> 975: </span><span class=
"org-doc">   * template expressions.</span>
<span class="linenr"> 976: </span><span class=
"org-doc">   */</span>
<span class="linenr"> 977: </span>  SETUP_CONST: <span class=
"org-string">'setup-const'</span>,
<span class="linenr"> 978: </span>  <span class=
"org-doc">/**</span>
<span class="linenr"> 979: </span><span class=
"org-doc">   * a const binding that may be a ref.</span>
<span class="linenr"> 980: </span><span class=
"org-doc">   */</span>
<span class="linenr"> 981: </span>  SETUP_MAYBE_REF: <span class=
"org-string">'setup-maybe-ref'</span>,
<span class="linenr"> 982: </span>  <span class=
"org-doc">/**</span>
<span class="linenr"> 983: </span><span class=
"org-doc">   * bindings that are guaranteed to be refs</span>
<span class="linenr"> 984: </span><span class=
"org-doc">   */</span>
<span class="linenr"> 985: </span>  SETUP_REF: <span class=
"org-string">'setup-ref'</span>,
<span class="linenr"> 986: </span>  <span class=
"org-doc">/**</span>
<span class="linenr"> 987: </span><span class=
"org-doc">   * declared by other options, e.g. computed, inject</span>
<span class="linenr"> 988: </span><span class=
"org-doc">   */</span>
<span class="linenr"> 989: </span>  OPTIONS: <span class=
"org-string">'options'</span>
<span class="linenr"> 990: </span>}
<span class="linenr"> 991: </span>
<span class="linenr"> 992: </span><span class=
"org-keyword">class</span> WalkerBase {
<span class="linenr"> 993: </span>  constructor() {
<span class="linenr"> 994: </span>    <span class=
"org-doc">/** @type {boolean} */</span>
<span class="linenr"> 995: </span>    <span class=
"org-constant">this</span>.should_skip = <span class=
"org-constant">false</span>
<span class="linenr"> 996: </span>
<span class="linenr"> 997: </span>    <span class=
"org-doc">/** @type {boolean} */</span>
<span class="linenr"> 998: </span>    <span class=
"org-constant">this</span>.should_remove = <span class=
"org-constant">false</span>
<span class="linenr"> 999: </span>
<span class="linenr">1000: </span>    <span class=
"org-doc">/** @type {BaseNode | null} */</span>
<span class="linenr">1001: </span>    <span class=
"org-constant">this</span>.replacement = <span class=
"org-constant">null</span>
<span class="linenr">1002: </span>
<span class="linenr">1003: </span>    <span class=
"org-doc">/** @type {WalkerContext} */</span>
<span class="linenr">1004: </span>    <span class=
"org-constant">this</span>.context = {
<span class=
"linenr">1005: </span>      skip: () =&gt; (<span class="org-constant">this</span>.should_skip = <span class="org-constant">true</span>),
<span class=
"linenr">1006: </span>      remove: () =&gt; (<span class=
"org-constant">this</span>.should_remove = <span class=
"org-constant">true</span>),
<span class=
"linenr">1007: </span>      replace: (node) =&gt; (<span class=
"org-constant">this</span>.replacement = node)
<span class="linenr">1008: </span>    }
<span class="linenr">1009: </span>  }
<span class="linenr">1010: </span>
<span class=
"linenr">1011: </span>  replace(parent, prop, index, node) {
<span class="linenr">1012: </span>    <span class=
"org-keyword">if</span> (parent) {
<span class="linenr">1013: </span>      <span class=
"org-keyword">if</span> (index !== <span class=
"org-constant">null</span>) {
<span class=
"linenr">1014: </span>        parent[prop][index] = node
<span class="linenr">1015: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr">1016: </span>        parent[prop] = node
<span class="linenr">1017: </span>      }
<span class="linenr">1018: </span>    }
<span class="linenr">1019: </span>  }
<span class="linenr">1020: </span>
<span class="linenr">1021: </span>  remove(parent, prop, index) {
<span class="linenr">1022: </span>    <span class=
"org-keyword">if</span> (parent) {
<span class="linenr">1023: </span>      <span class=
"org-keyword">if</span> (index !== <span class=
"org-constant">null</span>) {
<span class=
"linenr">1024: </span>        parent[prop].splice(index, <span class="org-highlight-numbers-number">1</span>)
<span class="linenr">1025: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr">1026: </span>        <span class=
"org-keyword">delete</span> parent[prop]
<span class="linenr">1027: </span>      }
<span class="linenr">1028: </span>    }
<span class="linenr">1029: </span>  }
<span class="linenr">1030: </span>}
<span class="linenr">1031: </span>
<span class="linenr">1032: </span><span class=
"org-keyword">class</span> SyncWalker <span class=
"org-keyword">extends</span> WalkerBase {
<span class="linenr">1033: </span>  constructor(enter, leave) {
<span class="linenr">1034: </span>    <span class=
"org-keyword">super</span>()
<span class="linenr">1035: </span>
<span class="linenr">1036: </span>    <span class=
"org-doc">/** @type {SyncHandler} */</span>
<span class="linenr">1037: </span>    <span class=
"org-constant">this</span>.enter = enter
<span class="linenr">1038: </span>
<span class="linenr">1039: </span>    <span class=
"org-doc">/** @type {SyncHandler} */</span>
<span class="linenr">1040: </span>    <span class=
"org-constant">this</span>.leave = leave
<span class="linenr">1041: </span>  }
<span class="linenr">1042: </span>
<span class=
"linenr">1043: </span>  visit(node, parent, prop, index) {
<span class="linenr">1044: </span>    <span class=
"org-keyword">if</span> (node) {
<span class="linenr">1045: </span>      <span class=
"org-keyword">if</span> (<span class=
"org-constant">this</span>.enter) {
<span class="linenr">1046: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">_should_skip</span> = <span class=
"org-constant">this</span>.should_skip
<span class="linenr">1047: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">_should_remove</span> = <span class=
"org-constant">this</span>.should_remove
<span class="linenr">1048: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">_replacement</span> = <span class=
"org-constant">this</span>.replacement
<span class="linenr">1049: </span>        <span class=
"org-constant">this</span>.should_skip = <span class=
"org-constant">false</span>
<span class="linenr">1050: </span>        <span class=
"org-constant">this</span>.should_remove = <span class=
"org-constant">false</span>
<span class="linenr">1051: </span>        <span class=
"org-constant">this</span>.replacement = <span class=
"org-constant">null</span>
<span class="linenr">1052: </span>
<span class="linenr">1053: </span>        <span class=
"org-constant">this</span>.enter.call(<span class=
"org-constant">this</span>.context, node, parent, prop, index)
<span class="linenr">1054: </span>
<span class="linenr">1055: </span>        <span class=
"org-keyword">if</span> (<span class=
"org-constant">this</span>.replacement) {
<span class="linenr">1056: </span>          node = <span class=
"org-constant">this</span>.replacement
<span class="linenr">1057: </span>          <span class=
"org-constant">this</span>.replace(parent, prop, index, node)
<span class="linenr">1058: </span>        }
<span class="linenr">1059: </span>
<span class="linenr">1060: </span>        <span class=
"org-keyword">if</span> (<span class=
"org-constant">this</span>.should_remove) {
<span class="linenr">1061: </span>          <span class=
"org-constant">this</span>.remove(parent, prop, index)
<span class="linenr">1062: </span>        }
<span class="linenr">1063: </span>
<span class="linenr">1064: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">skipped</span> = <span class=
"org-constant">this</span>.should_skip
<span class="linenr">1065: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">removed</span> = <span class=
"org-constant">this</span>.should_remove
<span class="linenr">1066: </span>
<span class="linenr">1067: </span>        <span class=
"org-constant">this</span>.should_skip = _should_skip
<span class="linenr">1068: </span>        <span class=
"org-constant">this</span>.should_remove = _should_remove
<span class="linenr">1069: </span>        <span class=
"org-constant">this</span>.replacement = _replacement
<span class="linenr">1070: </span>
<span class="linenr">1071: </span>        <span class=
"org-keyword">if</span> (skipped) <span class=
"org-keyword">return</span> node
<span class="linenr">1072: </span>        <span class=
"org-keyword">if</span> (removed) <span class=
"org-keyword">return</span> <span class="org-constant">null</span>
<span class="linenr">1073: </span>      }
<span class="linenr">1074: </span>
<span class="linenr">1075: </span>      <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">in</span> node) {
<span class="linenr">1076: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">value</span> = node[key]
<span class="linenr">1077: </span>
<span class="linenr">1078: </span>        <span class=
"org-keyword">if</span> (<span class=
"org-keyword">typeof</span> value !== <span class=
"org-string">'object'</span>) {
<span class="linenr">1079: </span>          <span class=
"org-keyword">continue</span>
<span class="linenr">1080: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (Array.isArray(value)) {
<span class="linenr">1081: </span>          <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; value.length; i += <span class="org-highlight-numbers-number">1</span>) {
<span class="linenr">1082: </span>            <span class=
"org-keyword">if</span> (value[i] !== <span class=
"org-constant">null</span> &amp;& <span class=
"org-keyword">typeof</span> value[i].type === <span class=
"org-string">'string'</span>) {
<span class="linenr">1083: </span>              <span class=
"org-keyword">if</span> (!<span class=
"org-constant">this</span>.visit(value[i], node, key, i)) {
<span class="linenr">1084: </span>                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">removed</span>
<span class="linenr">1085: </span>                i--
<span class="linenr">1086: </span>              }
<span class="linenr">1087: </span>            }
<span class="linenr">1088: </span>          }
<span class="linenr">1089: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (value !== <span class=
"org-constant">null</span> &amp;& <span class=
"org-keyword">typeof</span> value.type === <span class=
"org-string">'string'</span>) {
<span class="linenr">1090: </span>          <span class=
"org-constant">this</span>.visit(value, node, key, <span class=
"org-constant">null</span>)
<span class="linenr">1091: </span>        }
<span class="linenr">1092: </span>      }
<span class="linenr">1093: </span>
<span class="linenr">1094: </span>      <span class=
"org-keyword">if</span> (<span class=
"org-constant">this</span>.leave) {
<span class="linenr">1095: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">_replacement</span> = <span class=
"org-constant">this</span>.replacement
<span class="linenr">1096: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">_should_remove</span> = <span class=
"org-constant">this</span>.should_remove
<span class="linenr">1097: </span>        <span class=
"org-constant">this</span>.replacement = <span class=
"org-constant">null</span>
<span class="linenr">1098: </span>        <span class=
"org-constant">this</span>.should_remove = <span class=
"org-constant">false</span>
<span class="linenr">1099: </span>
<span class="linenr">1100: </span>        <span class=
"org-constant">this</span>.leave.call(<span class=
"org-constant">this</span>.context, node, parent, prop, index)
<span class="linenr">1101: </span>
<span class="linenr">1102: </span>        <span class=
"org-keyword">if</span> (<span class=
"org-constant">this</span>.replacement) {
<span class="linenr">1103: </span>          node = <span class=
"org-constant">this</span>.replacement
<span class="linenr">1104: </span>          <span class=
"org-constant">this</span>.replace(parent, prop, index, node)
<span class="linenr">1105: </span>        }
<span class="linenr">1106: </span>
<span class="linenr">1107: </span>        <span class=
"org-keyword">if</span> (<span class=
"org-constant">this</span>.should_remove) {
<span class="linenr">1108: </span>          <span class=
"org-constant">this</span>.remove(parent, prop, index)
<span class="linenr">1109: </span>        }
<span class="linenr">1110: </span>
<span class="linenr">1111: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">removed</span> = <span class=
"org-constant">this</span>.should_remove
<span class="linenr">1112: </span>
<span class="linenr">1113: </span>        <span class=
"org-constant">this</span>.replacement = _replacement
<span class="linenr">1114: </span>        <span class=
"org-constant">this</span>.should_remove = _should_remove
<span class="linenr">1115: </span>
<span class="linenr">1116: </span>        <span class=
"org-keyword">if</span> (removed) <span class=
"org-keyword">return</span> <span class="org-constant">null</span>
<span class="linenr">1117: </span>      }
<span class="linenr">1118: </span>    }
<span class="linenr">1119: </span>
<span class="linenr">1120: </span>    <span class=
"org-keyword">return</span> node
<span class="linenr">1121: </span>  }
<span class="linenr">1122: </span>}
<span class="linenr">1123: </span>
<span class="linenr">1124: </span><span class=
"org-keyword">class</span> AsyncWalker <span class=
"org-keyword">extends</span> WalkerBase {
<span class="linenr">1125: </span>  constructor(enter, leave) {
<span class="linenr">1126: </span>    <span class=
"org-keyword">super</span>()
<span class="linenr">1127: </span>
<span class="linenr">1128: </span>    <span class=
"org-doc">/** @type {AsyncHandler} */</span>
<span class="linenr">1129: </span>    <span class=
"org-constant">this</span>.enter = enter
<span class="linenr">1130: </span>
<span class="linenr">1131: </span>    <span class=
"org-doc">/** @type {AsyncHandler} */</span>
<span class="linenr">1132: </span>    <span class=
"org-constant">this</span>.leave = leave
<span class="linenr">1133: </span>  }
<span class="linenr">1134: </span>
<span class="linenr">1135: </span>  <span class=
"org-keyword">async</span> visit(node, parent, prop, index) {
<span class="linenr">1136: </span>    <span class=
"org-keyword">if</span> (node) {
<span class="linenr">1137: </span>      <span class=
"org-keyword">if</span> (<span class=
"org-constant">this</span>.enter) {
<span class="linenr">1138: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">_should_skip</span> = <span class=
"org-constant">this</span>.should_skip
<span class="linenr">1139: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">_should_remove</span> = <span class=
"org-constant">this</span>.should_remove
<span class="linenr">1140: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">_replacement</span> = <span class=
"org-constant">this</span>.replacement
<span class="linenr">1141: </span>        <span class=
"org-constant">this</span>.should_skip = <span class=
"org-constant">false</span>
<span class="linenr">1142: </span>        <span class=
"org-constant">this</span>.should_remove = <span class=
"org-constant">false</span>
<span class="linenr">1143: </span>        <span class=
"org-constant">this</span>.replacement = <span class=
"org-constant">null</span>
<span class="linenr">1144: </span>
<span class="linenr">1145: </span>        <span class=
"org-keyword">await</span> <span class=
"org-constant">this</span>.enter.call(<span class=
"org-constant">this</span>.context, node, parent, prop, index)
<span class="linenr">1146: </span>
<span class="linenr">1147: </span>        <span class=
"org-keyword">if</span> (<span class=
"org-constant">this</span>.replacement) {
<span class="linenr">1148: </span>          node = <span class=
"org-constant">this</span>.replacement
<span class="linenr">1149: </span>          <span class=
"org-constant">this</span>.replace(parent, prop, index, node)
<span class="linenr">1150: </span>        }
<span class="linenr">1151: </span>
<span class="linenr">1152: </span>        <span class=
"org-keyword">if</span> (<span class=
"org-constant">this</span>.should_remove) {
<span class="linenr">1153: </span>          <span class=
"org-constant">this</span>.remove(parent, prop, index)
<span class="linenr">1154: </span>        }
<span class="linenr">1155: </span>
<span class="linenr">1156: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">skipped</span> = <span class=
"org-constant">this</span>.should_skip
<span class="linenr">1157: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">removed</span> = <span class=
"org-constant">this</span>.should_remove
<span class="linenr">1158: </span>
<span class="linenr">1159: </span>        <span class=
"org-constant">this</span>.should_skip = _should_skip
<span class="linenr">1160: </span>        <span class=
"org-constant">this</span>.should_remove = _should_remove
<span class="linenr">1161: </span>        <span class=
"org-constant">this</span>.replacement = _replacement
<span class="linenr">1162: </span>
<span class="linenr">1163: </span>        <span class=
"org-keyword">if</span> (skipped) <span class=
"org-keyword">return</span> node
<span class="linenr">1164: </span>        <span class=
"org-keyword">if</span> (removed) <span class=
"org-keyword">return</span> <span class="org-constant">null</span>
<span class="linenr">1165: </span>      }
<span class="linenr">1166: </span>
<span class="linenr">1167: </span>      <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">in</span> node) {
<span class="linenr">1168: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">value</span> = node[key]
<span class="linenr">1169: </span>
<span class="linenr">1170: </span>        <span class=
"org-keyword">if</span> (<span class=
"org-keyword">typeof</span> value !== <span class=
"org-string">'object'</span>) {
<span class="linenr">1171: </span>          <span class=
"org-keyword">continue</span>
<span class="linenr">1172: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (Array.isArray(value)) {
<span class="linenr">1173: </span>          <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; value.length; i += <span class="org-highlight-numbers-number">1</span>) {
<span class="linenr">1174: </span>            <span class=
"org-keyword">if</span> (value[i] !== <span class=
"org-constant">null</span> &amp;& <span class=
"org-keyword">typeof</span> value[i].type === <span class=
"org-string">'string'</span>) {
<span class="linenr">1175: </span>              <span class=
"org-keyword">if</span> (!(<span class=
"org-keyword">await</span> <span class=
"org-constant">this</span>.visit(value[i], node, key, i))) {
<span class="linenr">1176: </span>                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">removed</span>
<span class="linenr">1177: </span>                i--
<span class="linenr">1178: </span>              }
<span class="linenr">1179: </span>            }
<span class="linenr">1180: </span>          }
<span class="linenr">1181: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (value !== <span class=
"org-constant">null</span> &amp;& <span class=
"org-keyword">typeof</span> value.type === <span class=
"org-string">'string'</span>) {
<span class="linenr">1182: </span>          <span class=
"org-keyword">await</span> <span class=
"org-constant">this</span>.visit(value, node, key, <span class=
"org-constant">null</span>)
<span class="linenr">1183: </span>        }
<span class="linenr">1184: </span>      }
<span class="linenr">1185: </span>
<span class="linenr">1186: </span>      <span class=
"org-keyword">if</span> (<span class=
"org-constant">this</span>.leave) {
<span class="linenr">1187: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">_replacement</span> = <span class=
"org-constant">this</span>.replacement
<span class="linenr">1188: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">_should_remove</span> = <span class=
"org-constant">this</span>.should_remove
<span class="linenr">1189: </span>        <span class=
"org-constant">this</span>.replacement = <span class=
"org-constant">null</span>
<span class="linenr">1190: </span>        <span class=
"org-constant">this</span>.should_remove = <span class=
"org-constant">false</span>
<span class="linenr">1191: </span>
<span class="linenr">1192: </span>        <span class=
"org-keyword">await</span> <span class=
"org-constant">this</span>.leave.call(<span class=
"org-constant">this</span>.context, node, parent, prop, index)
<span class="linenr">1193: </span>
<span class="linenr">1194: </span>        <span class=
"org-keyword">if</span> (<span class=
"org-constant">this</span>.replacement) {
<span class="linenr">1195: </span>          node = <span class=
"org-constant">this</span>.replacement
<span class="linenr">1196: </span>          <span class=
"org-constant">this</span>.replace(parent, prop, index, node)
<span class="linenr">1197: </span>        }
<span class="linenr">1198: </span>
<span class="linenr">1199: </span>        <span class=
"org-keyword">if</span> (<span class=
"org-constant">this</span>.should_remove) {
<span class="linenr">1200: </span>          <span class=
"org-constant">this</span>.remove(parent, prop, index)
<span class="linenr">1201: </span>        }
<span class="linenr">1202: </span>
<span class="linenr">1203: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">removed</span> = <span class=
"org-constant">this</span>.should_remove
<span class="linenr">1204: </span>
<span class="linenr">1205: </span>        <span class=
"org-constant">this</span>.replacement = _replacement
<span class="linenr">1206: </span>        <span class=
"org-constant">this</span>.should_remove = _should_remove
<span class="linenr">1207: </span>
<span class="linenr">1208: </span>        <span class=
"org-keyword">if</span> (removed) <span class=
"org-keyword">return</span> <span class="org-constant">null</span>
<span class="linenr">1209: </span>      }
<span class="linenr">1210: </span>    }
<span class="linenr">1211: </span>
<span class="linenr">1212: </span>    <span class=
"org-keyword">return</span> node
<span class="linenr">1213: </span>  }
<span class="linenr">1214: </span>}
<span class="linenr">1215: </span>
<span class="linenr">1216: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">walk</span>(<span class=
"org-variable-name">ast</span>, { <span class=
"org-variable-name">enter</span>, <span class=
"org-variable-name">leave</span> }) {
<span class="linenr">1217: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">instance</span> = <span class=
"org-keyword">new</span> <span class=
"org-type">SyncWalker</span>(enter, leave)
<span class="linenr">1218: </span>  <span class=
"org-keyword">return</span> instance.visit(ast, <span class=
"org-constant">null</span>)
<span class="linenr">1219: </span>}
<span class="linenr">1220: </span>
<span class="linenr">1221: </span><span class=
"org-keyword">async</span> <span class=
"org-keyword">function</span> asyncWalk(<span class=
"org-variable-name">ast</span>, { <span class=
"org-variable-name">enter</span>, <span class=
"org-variable-name">leave</span> }) {
<span class="linenr">1222: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">instance</span> = <span class=
"org-keyword">new</span> <span class=
"org-type">AsyncWalker</span>(enter, leave)
<span class="linenr">1223: </span>  <span class=
"org-keyword">return</span> <span class=
"org-keyword">await</span> instance.visit(ast, <span class=
"org-constant">null</span>)
<span class="linenr">1224: </span>}
<span class="linenr">1225: </span>
<span class="linenr">1226: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">isInDestructureAssignment</span>(<span class=
"org-variable-name">parent</span>, <span class=
"org-variable-name">parentStack</span>) {
<span class="linenr">1227: </span>  <span class=
"org-keyword">if</span> (
<span class="linenr">1228: </span>    parent &amp;&
<span class="linenr">1229: </span>    (parent.type === <span class=
"org-string">'ObjectProperty'</span> || parent.type === <span class="org-string">'ArrayPattern'</span>)
<span class="linenr">1230: </span>  ) {
<span class="linenr">1231: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = parentStack.length
<span class="linenr">1232: </span>    <span class=
"org-keyword">while</span> (i--) {
<span class="linenr">1233: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">p</span> = parentStack[i]
<span class="linenr">1234: </span>      <span class=
"org-keyword">if</span> (p.type === <span class=
"org-string">'AssignmentExpression'</span>) {
<span class="linenr">1235: </span>        <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr">1236: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (p.type !== <span class=
"org-string">'ObjectProperty'</span> &amp;& !p.type.endsWith(<span class="org-string">'Pattern'</span>)) {
<span class="linenr">1237: </span>        <span class=
"org-keyword">break</span>
<span class="linenr">1238: </span>      }
<span class="linenr">1239: </span>    }
<span class="linenr">1240: </span>  }
<span class="linenr">1241: </span>  <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">1242: </span>}
<span class="linenr">1243: </span>
<span class="linenr">1244: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">walkIdentifiers</span>(
<span class="linenr">1245: </span>  <span class=
"org-variable-name">root</span>,
<span class="linenr">1246: </span>  <span class=
"org-variable-name">onIdentifier</span>,
<span class="linenr">1247: </span>  includeAll = <span class=
"org-constant">false</span>,
<span class="linenr">1248: </span>  parentStack = [],
<span class=
"linenr">1249: </span>  knownIds = Object.create(<span class=
"org-constant">null</span>)
<span class="linenr">1250: </span>) {
<span class="linenr">1251: </span>  <span class=
"org-keyword">if</span> (__BROWSER__) {
<span class="linenr">1252: </span>    <span class=
"org-keyword">return</span>
<span class="linenr">1253: </span>  }
<span class="linenr">1254: </span>
<span class="linenr">1255: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">rootExp</span> =
<span class="linenr">1256: </span>    root.type === <span class=
"org-string">'Program'</span> &amp;&
<span class="linenr">1257: </span>    root.body[<span class=
"org-highlight-numbers-number">0</span>].type === <span class=
"org-string">'ExpressionStatement'</span> &amp;&
<span class="linenr">1258: </span>    root.body[<span class=
"org-highlight-numbers-number">0</span>].expression
<span class="linenr">1259: </span>
<span class="linenr">1260: </span>  walk(root, {
<span class="linenr">1261: </span>    enter(node, parent) {
<span class=
"linenr">1262: </span>      parent &amp;& parentStack.push(parent)
<span class="linenr">1263: </span>      <span class=
"org-keyword">if</span> (
<span class="linenr">1264: </span>        parent &amp;&
<span class=
"linenr">1265: </span>        parent.type.startsWith(<span class=
"org-string">'TS'</span>) &amp;&
<span class=
"linenr">1266: </span>        parent.type !== <span class=
"org-string">'TSAsExpression'</span> &amp;&
<span class=
"linenr">1267: </span>        parent.type !== <span class=
"org-string">'TSNonNullExpression'</span> &amp;&
<span class=
"linenr">1268: </span>        parent.type !== <span class=
"org-string">'TSTypeAssertion'</span>
<span class="linenr">1269: </span>      ) {
<span class="linenr">1270: </span>        <span class=
"org-keyword">return</span> <span class=
"org-constant">this</span>.skip()
<span class="linenr">1271: </span>      }
<span class="linenr">1272: </span>      <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'Identifier'</span>) {
<span class="linenr">1273: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isLocal</span> = !!knownIds[node.name]
<span class="linenr">1274: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isRefed</span> = isReferencedIdentifier(node, parent, parentStack)
<span class="linenr">1275: </span>        <span class=
"org-keyword">if</span> (includeAll || (isRefed &amp;& !isLocal)) {
<span class=
"linenr">1276: </span>          onIdentifier(node, parent, parentStack, isRefed, isLocal)
<span class="linenr">1277: </span>        }
<span class="linenr">1278: </span>      } <span class=
"org-keyword">else</span> <span class="org-keyword">if</span> (
<span class=
"linenr">1279: </span>        node.type === <span class="org-string">'ObjectProperty'</span> &amp;&
<span class=
"linenr">1280: </span>        parent.type === <span class=
"org-string">'ObjectPattern'</span>
<span class="linenr">1281: </span>      ) {
<span class="linenr">1282: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">mark property in destructure pattern</span>
<span class=
"linenr">1283: </span>        node.inPattern = <span class=
"org-constant">true</span>
<span class="linenr">1284: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (isFunctionType(node)) {
<span class="linenr">1285: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">walk function expressions and add its arguments to known identifiers</span>
<span class="linenr">1286: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">so that we don't prefix them</span>
<span class=
"linenr">1287: </span>        walkFunctionParams(node, (id) =&gt;
<span class=
"linenr">1288: </span>          markScopeIdentifier(node, id, knownIds)
<span class="linenr">1289: </span>        )
<span class="linenr">1290: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'BlockStatement'</span>) {
<span class="linenr">1291: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">#3445 record block-level local variables</span>
<span class=
"linenr">1292: </span>        walkBlockDeclarations(node, (id) =&gt;
<span class=
"linenr">1293: </span>          markScopeIdentifier(node, id, knownIds)
<span class="linenr">1294: </span>        )
<span class="linenr">1295: </span>      }
<span class="linenr">1296: </span>    },
<span class="linenr">1297: </span>    leave(node, parent) {
<span class=
"linenr">1298: </span>      parent &amp;& parentStack.pop()
<span class="linenr">1299: </span>      <span class=
"org-keyword">if</span> (node !== rootExp &amp;& node.scopeIds) {
<span class="linenr">1300: </span>        <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">id</span> <span class=
"org-keyword">of</span> node.scopeIds) {
<span class="linenr">1301: </span>          knownIds[id]--
<span class="linenr">1302: </span>          <span class=
"org-keyword">if</span> (knownIds[id] === <span class=
"org-highlight-numbers-number">0</span>) {
<span class="linenr">1303: </span>            <span class=
"org-keyword">delete</span> knownIds[id]
<span class="linenr">1304: </span>          }
<span class="linenr">1305: </span>        }
<span class="linenr">1306: </span>      }
<span class="linenr">1307: </span>    }
<span class="linenr">1308: </span>  })
<span class="linenr">1309: </span>}
<span class="linenr">1310: </span>
<span class="linenr">1311: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">isReferencedIdentifier</span>(<span class=
"org-variable-name">id</span>, <span class=
"org-variable-name">parent</span>, <span class=
"org-variable-name">parentStack</span>) {
<span class="linenr">1312: </span>  <span class=
"org-keyword">if</span> (__BROWSER__) {
<span class="linenr">1313: </span>    <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">1314: </span>  }
<span class="linenr">1315: </span>
<span class="linenr">1316: </span>  <span class=
"org-keyword">if</span> (!parent) {
<span class="linenr">1317: </span>    <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr">1318: </span>  }
<span class="linenr">1319: </span>
<span class="linenr">1320: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">is a special keyword but parsed as identifier</span>
<span class="linenr">1321: </span>  <span class=
"org-keyword">if</span> (id.name === <span class=
"org-string">'arguments'</span>) {
<span class="linenr">1322: </span>    <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">1323: </span>  }
<span class="linenr">1324: </span>
<span class="linenr">1325: </span>  <span class=
"org-keyword">if</span> (isReferenced(id, parent)) {
<span class="linenr">1326: </span>    <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr">1327: </span>  }
<span class="linenr">1328: </span>
<span class="linenr">1329: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">babel's isReferenced check returns false for ids being assigned to, so we</span>
<span class="linenr">1330: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">need to cover those cases here</span>
<span class="linenr">1331: </span>  <span class=
"org-keyword">switch</span> (parent.type) {
<span class="linenr">1332: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'AssignmentExpression'</span>:
<span class="linenr">1333: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'AssignmentPattern'</span>:
<span class="linenr">1334: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr">1335: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'ObjectPattern'</span>:
<span class="linenr">1336: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'ArrayPattern'</span>:
<span class="linenr">1337: </span>      <span class=
"org-keyword">return</span> isInDestructureAssignment(parent, parentStack)
<span class="linenr">1338: </span>  }
<span class="linenr">1339: </span>
<span class="linenr">1340: </span>  <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">1341: </span>}
<span class="linenr">1342: </span>
<span class="linenr">1343: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">isInDestructureAssignment</span>(<span class=
"org-variable-name">parent</span>, <span class=
"org-variable-name">parentStack</span>) {
<span class="linenr">1344: </span>  <span class=
"org-keyword">if</span> (
<span class="linenr">1345: </span>    parent &amp;&
<span class="linenr">1346: </span>    (parent.type === <span class=
"org-string">'ObjectProperty'</span> || parent.type === <span class="org-string">'ArrayPattern'</span>)
<span class="linenr">1347: </span>  ) {
<span class="linenr">1348: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = parentStack.length
<span class="linenr">1349: </span>    <span class=
"org-keyword">while</span> (i--) {
<span class="linenr">1350: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">p</span> = parentStack[i]
<span class="linenr">1351: </span>      <span class=
"org-keyword">if</span> (p.type === <span class=
"org-string">'AssignmentExpression'</span>) {
<span class="linenr">1352: </span>        <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr">1353: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (p.type !== <span class=
"org-string">'ObjectProperty'</span> &amp;& !p.type.endsWith(<span class="org-string">'Pattern'</span>)) {
<span class="linenr">1354: </span>        <span class=
"org-keyword">break</span>
<span class="linenr">1355: </span>      }
<span class="linenr">1356: </span>    }
<span class="linenr">1357: </span>  }
<span class="linenr">1358: </span>  <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">1359: </span>}
<span class="linenr">1360: </span>
<span class="linenr">1361: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">walkFunctionParams</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">onIdent</span>) {
<span class="linenr">1362: </span>  <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">p</span> <span class=
"org-keyword">of</span> node.params) {
<span class="linenr">1363: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">id</span> <span class=
"org-keyword">of</span> extractIdentifiers(p)) {
<span class="linenr">1364: </span>      onIdent(id)
<span class="linenr">1365: </span>    }
<span class="linenr">1366: </span>  }
<span class="linenr">1367: </span>}
<span class="linenr">1368: </span>
<span class="linenr">1369: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">walkBlockDeclarations</span>(<span class=
"org-variable-name">block</span>, <span class=
"org-variable-name">onIdent</span>) {
<span class="linenr">1370: </span>  <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">stmt</span> <span class=
"org-keyword">of</span> block.body) {
<span class="linenr">1371: </span>    <span class=
"org-keyword">if</span> (stmt.type === <span class=
"org-string">'VariableDeclaration'</span>) {
<span class="linenr">1372: </span>      <span class=
"org-keyword">if</span> (stmt.declare) <span class=
"org-keyword">continue</span>
<span class="linenr">1373: </span>      <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">decl</span> <span class=
"org-keyword">of</span> stmt.declarations) {
<span class="linenr">1374: </span>        <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">id</span> <span class=
"org-keyword">of</span> extractIdentifiers(decl.id)) {
<span class="linenr">1375: </span>          onIdent(id)
<span class="linenr">1376: </span>        }
<span class="linenr">1377: </span>      }
<span class="linenr">1378: </span>    } <span class=
"org-keyword">else</span> <span class="org-keyword">if</span> (
<span class="linenr">1379: </span>      stmt.type === <span class=
"org-string">'FunctionDeclaration'</span> ||
<span class="linenr">1380: </span>      stmt.type === <span class=
"org-string">'ClassDeclaration'</span>
<span class="linenr">1381: </span>    ) {
<span class="linenr">1382: </span>      <span class=
"org-keyword">if</span> (stmt.declare || !stmt.id) <span class=
"org-keyword">continue</span>
<span class="linenr">1383: </span>      onIdent(stmt.id)
<span class="linenr">1384: </span>    }
<span class="linenr">1385: </span>  }
<span class="linenr">1386: </span>}
<span class="linenr">1387: </span>
<span class="linenr">1388: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">extractIdentifiers</span>(<span class=
"org-variable-name">param</span>, <span class=
"org-variable-name">nodes</span> = []) {
<span class="linenr">1389: </span>  <span class=
"org-keyword">switch</span> (param.type) {
<span class="linenr">1390: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'Identifier'</span>:
<span class="linenr">1391: </span>      nodes.push(param)
<span class="linenr">1392: </span>      <span class=
"org-keyword">break</span>
<span class="linenr">1393: </span>
<span class="linenr">1394: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'MemberExpression'</span>:
<span class="linenr">1395: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">object</span> = param
<span class="linenr">1396: </span>      <span class=
"org-keyword">while</span> (object.type === <span class=
"org-string">'MemberExpression'</span>) {
<span class="linenr">1397: </span>        object = object.object
<span class="linenr">1398: </span>      }
<span class="linenr">1399: </span>      nodes.push(object)
<span class="linenr">1400: </span>      <span class=
"org-keyword">break</span>
<span class="linenr">1401: </span>
<span class="linenr">1402: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'ObjectPattern'</span>:
<span class="linenr">1403: </span>      <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">prop</span> <span class=
"org-keyword">of</span> param.properties) {
<span class="linenr">1404: </span>        <span class=
"org-keyword">if</span> (prop.type === <span class=
"org-string">'RestElement'</span>) {
<span class=
"linenr">1405: </span>          extractIdentifiers(prop.argument, nodes)
<span class="linenr">1406: </span>        } <span class=
"org-keyword">else</span> {
<span class=
"linenr">1407: </span>          extractIdentifiers(prop.value, nodes)
<span class="linenr">1408: </span>        }
<span class="linenr">1409: </span>      }
<span class="linenr">1410: </span>      <span class=
"org-keyword">break</span>
<span class="linenr">1411: </span>
<span class="linenr">1412: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'ArrayPattern'</span>:
<span class=
"linenr">1413: </span>      param.elements.forEach((element) =&gt; {
<span class="linenr">1414: </span>        <span class=
"org-keyword">if</span> (element) extractIdentifiers(element, nodes)
<span class="linenr">1415: </span>      })
<span class="linenr">1416: </span>      <span class=
"org-keyword">break</span>
<span class="linenr">1417: </span>
<span class="linenr">1418: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'RestElement'</span>:
<span class=
"linenr">1419: </span>      extractIdentifiers(param.argument, nodes)
<span class="linenr">1420: </span>      <span class=
"org-keyword">break</span>
<span class="linenr">1421: </span>
<span class="linenr">1422: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'AssignmentPattern'</span>:
<span class=
"linenr">1423: </span>      extractIdentifiers(param.left, nodes)
<span class="linenr">1424: </span>      <span class=
"org-keyword">break</span>
<span class="linenr">1425: </span>  }
<span class="linenr">1426: </span>
<span class="linenr">1427: </span>  <span class=
"org-keyword">return</span> nodes
<span class="linenr">1428: </span>}
<span class="linenr">1429: </span>
<span class="linenr">1430: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">markScopeIdentifier</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">child</span>, <span class=
"org-variable-name">knownIds</span>) {
<span class="linenr">1431: </span>  <span class=
"org-keyword">const</span> { name } = child
<span class="linenr">1432: </span>  <span class=
"org-keyword">if</span> (node.scopeIds &amp;& node.scopeIds.has(name)) {
<span class="linenr">1433: </span>    <span class=
"org-keyword">return</span>
<span class="linenr">1434: </span>  }
<span class="linenr">1435: </span>  <span class=
"org-keyword">if</span> (name <span class=
"org-keyword">in</span> knownIds) {
<span class="linenr">1436: </span>    knownIds[name]++
<span class="linenr">1437: </span>  } <span class=
"org-keyword">else</span> {
<span class="linenr">1438: </span>    knownIds[name] = <span class=
"org-highlight-numbers-number">1</span>
<span class="linenr">1439: </span>  }
<span class=
"linenr">1440: </span>  ;(node.scopeIds || (node.scopeIds = <span class="org-keyword">new</span> <span class="org-type">Set</span>())).add(name)
<span class="linenr">1441: </span>}
<span class="linenr">1442: </span>
<span class="linenr">1443: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">isFunctionType</span> = (node) =&gt; {
<span class="linenr">1444: </span>  <span class=
"org-keyword">return</span> <span class=
"org-string">/Function(?:Expression|Declaration)$|Method$/</span>.test(node.type)
<span class="linenr">1445: </span>}
<span class="linenr">1446: </span>
<span class="linenr">1447: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">isStaticProperty</span> = (node) =&gt;
<span class="linenr">1448: </span>  node &amp;&
<span class="linenr">1449: </span>  (node.type === <span class=
"org-string">'ObjectProperty'</span> || node.type === <span class=
"org-string">'ObjectMethod'</span>) &amp;&
<span class="linenr">1450: </span>  !node.computed
<span class="linenr">1451: </span>
<span class="linenr">1452: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">isStaticPropertyKey</span> = (node, parent) =&gt;
<span class=
"linenr">1453: </span>  isStaticProperty(parent) &amp;& parent.key === node
<span class="linenr">1454: </span>
<span class="linenr">1455: </span><span class="org-doc">/**</span>
<span class="linenr">1456: </span><span class=
"org-doc"> * Copied from https://github.com/babel/babel/blob/main/packages/babel-types/src/validators/isReferenced.ts</span>
<span class="linenr">1457: </span><span class=
"org-doc"> * To avoid runtime dependency on @babel/types (which includes process references)</span>
<span class="linenr">1458: </span><span class=
"org-doc"> * This file should not change very often in babel but we may need to keep it</span>
<span class="linenr">1459: </span><span class=
"org-doc"> * up-to-date from time to time.</span>
<span class="linenr">1460: </span><span class="org-doc"> *</span>
<span class="linenr">1461: </span><span class=
"org-doc"> * https://github.com/babel/babel/blob/main/LICENSE</span>
<span class="linenr">1462: </span><span class="org-doc"> *</span>
<span class="linenr">1463: </span><span class="org-doc"> */</span>
<span class="linenr">1464: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">isReferenced</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">parent</span>, <span class=
"org-variable-name">grandparent</span>) {
<span class="linenr">1465: </span>  <span class=
"org-keyword">switch</span> (parent.type) {
<span class="linenr">1466: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">yes: PARENT[NODE]</span>
<span class="linenr">1467: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">yes: NODE.child</span>
<span class="linenr">1468: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no: parent.NODE</span>
<span class="linenr">1469: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'MemberExpression'</span>:
<span class="linenr">1470: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'OptionalMemberExpression'</span>:
<span class="linenr">1471: </span>      <span class=
"org-keyword">if</span> (parent.property === node) {
<span class="linenr">1472: </span>        <span class=
"org-keyword">return</span> !!parent.computed
<span class="linenr">1473: </span>      }
<span class="linenr">1474: </span>      <span class=
"org-keyword">return</span> parent.object === node
<span class="linenr">1475: </span>
<span class="linenr">1476: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'JSXMemberExpression'</span>:
<span class="linenr">1477: </span>      <span class=
"org-keyword">return</span> parent.object === node
<span class="linenr">1478: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no: let NODE = init;</span>
<span class="linenr">1479: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">yes: let id = NODE;</span>
<span class="linenr">1480: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'VariableDeclarator'</span>:
<span class="linenr">1481: </span>      <span class=
"org-keyword">return</span> parent.init === node
<span class="linenr">1482: </span>
<span class="linenr">1483: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">yes: () =&gt; NODE</span>
<span class="linenr">1484: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no: (NODE) =&gt; {}</span>
<span class="linenr">1485: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'ArrowFunctionExpression'</span>:
<span class="linenr">1486: </span>      <span class=
"org-keyword">return</span> parent.body === node
<span class="linenr">1487: </span>
<span class="linenr">1488: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no: class { #NODE; }</span>
<span class="linenr">1489: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no: class { get #NODE() {} }</span>
<span class="linenr">1490: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no: class { #NODE() {} }</span>
<span class="linenr">1491: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no: class { fn() { return this.#NODE; } }</span>
<span class="linenr">1492: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'PrivateName'</span>:
<span class="linenr">1493: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">1494: </span>
<span class="linenr">1495: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no: class { NODE() {} }</span>
<span class="linenr">1496: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">yes: class { [NODE]() {} }</span>
<span class="linenr">1497: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no: class { foo(NODE) {} }</span>
<span class="linenr">1498: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'ClassMethod'</span>:
<span class="linenr">1499: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'ClassPrivateMethod'</span>:
<span class="linenr">1500: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'ObjectMethod'</span>:
<span class="linenr">1501: </span>      <span class=
"org-keyword">if</span> (parent.key === node) {
<span class="linenr">1502: </span>        <span class=
"org-keyword">return</span> !!parent.computed
<span class="linenr">1503: </span>      }
<span class="linenr">1504: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">1505: </span>
<span class="linenr">1506: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">yes: { [NODE]: "" }</span>
<span class="linenr">1507: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no: { NODE: "" }</span>
<span class="linenr">1508: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">depends: { NODE }</span>
<span class="linenr">1509: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">depends: { key: NODE }</span>
<span class="linenr">1510: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'ObjectProperty'</span>:
<span class="linenr">1511: </span>      <span class=
"org-keyword">if</span> (parent.key === node) {
<span class="linenr">1512: </span>        <span class=
"org-keyword">return</span> !!parent.computed
<span class="linenr">1513: </span>      }
<span class="linenr">1514: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">parent.value === node</span>
<span class="linenr">1515: </span>      <span class=
"org-keyword">return</span> !grandparent || grandparent.type !== <span class="org-string">'ObjectPattern'</span>
<span class="linenr">1516: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no: class { NODE = value; }</span>
<span class="linenr">1517: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">yes: class { [NODE] = value; }</span>
<span class="linenr">1518: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">yes: class { key = NODE; }</span>
<span class="linenr">1519: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'ClassProperty'</span>:
<span class="linenr">1520: </span>      <span class=
"org-keyword">if</span> (parent.key === node) {
<span class="linenr">1521: </span>        <span class=
"org-keyword">return</span> !!parent.computed
<span class="linenr">1522: </span>      }
<span class="linenr">1523: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr">1524: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'ClassPrivateProperty'</span>:
<span class="linenr">1525: </span>      <span class=
"org-keyword">return</span> parent.key !== node
<span class="linenr">1526: </span>
<span class="linenr">1527: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no: class NODE {}</span>
<span class="linenr">1528: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">yes: class Foo extends NODE {}</span>
<span class="linenr">1529: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'ClassDeclaration'</span>:
<span class="linenr">1530: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'ClassExpression'</span>:
<span class="linenr">1531: </span>      <span class=
"org-keyword">return</span> parent.superClass === node
<span class="linenr">1532: </span>
<span class="linenr">1533: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">yes: left = NODE;</span>
<span class="linenr">1534: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no: NODE = right;</span>
<span class="linenr">1535: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'AssignmentExpression'</span>:
<span class="linenr">1536: </span>      <span class=
"org-keyword">return</span> parent.right === node
<span class="linenr">1537: </span>
<span class="linenr">1538: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no: [NODE = foo] = [];</span>
<span class="linenr">1539: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">yes: [foo = NODE] = [];</span>
<span class="linenr">1540: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'AssignmentPattern'</span>:
<span class="linenr">1541: </span>      <span class=
"org-keyword">return</span> parent.right === node
<span class="linenr">1542: </span>
<span class="linenr">1543: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no: NODE: for (;;) {}</span>
<span class="linenr">1544: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'LabeledStatement'</span>:
<span class="linenr">1545: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">1546: </span>
<span class="linenr">1547: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no: try {} catch (NODE) {}</span>
<span class="linenr">1548: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'CatchClause'</span>:
<span class="linenr">1549: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">1550: </span>
<span class="linenr">1551: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no: function foo(...NODE) {}</span>
<span class="linenr">1552: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'RestElement'</span>:
<span class="linenr">1553: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">1554: </span>
<span class="linenr">1555: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'BreakStatement'</span>:
<span class="linenr">1556: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'ContinueStatement'</span>:
<span class="linenr">1557: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">1558: </span>
<span class="linenr">1559: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no: function NODE() {}</span>
<span class="linenr">1560: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no: function foo(NODE) {}</span>
<span class="linenr">1561: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'FunctionDeclaration'</span>:
<span class="linenr">1562: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'FunctionExpression'</span>:
<span class="linenr">1563: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">1564: </span>
<span class="linenr">1565: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no: export NODE from "foo";</span>
<span class="linenr">1566: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no: export * as NODE from "foo";</span>
<span class="linenr">1567: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'ExportNamespaceSpecifier'</span>:
<span class="linenr">1568: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'ExportDefaultSpecifier'</span>:
<span class="linenr">1569: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">1570: </span>
<span class="linenr">1571: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no: export { foo as NODE };</span>
<span class="linenr">1572: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">yes: export { NODE as foo };</span>
<span class="linenr">1573: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no: export { NODE as foo } from "foo";</span>
<span class="linenr">1574: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'ExportSpecifier'</span>:
<span class="linenr">1575: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">@ts-expect-error</span>
<span class="linenr">1576: </span>      <span class=
"org-keyword">if</span> (grandparent?.source) {
<span class="linenr">1577: </span>        <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">1578: </span>      }
<span class="linenr">1579: </span>      <span class=
"org-keyword">return</span> parent.local === node
<span class="linenr">1580: </span>
<span class="linenr">1581: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no: import NODE from "foo";</span>
<span class="linenr">1582: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no: import * as NODE from "foo";</span>
<span class="linenr">1583: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no: import { NODE as foo } from "foo";</span>
<span class="linenr">1584: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no: import { foo as NODE } from "foo";</span>
<span class="linenr">1585: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no: import NODE from "bar";</span>
<span class="linenr">1586: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'ImportDefaultSpecifier'</span>:
<span class="linenr">1587: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'ImportNamespaceSpecifier'</span>:
<span class="linenr">1588: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'ImportSpecifier'</span>:
<span class="linenr">1589: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">1590: </span>
<span class="linenr">1591: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no: import "foo" assert { NODE: "json" }</span>
<span class="linenr">1592: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'ImportAttribute'</span>:
<span class="linenr">1593: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">1594: </span>
<span class="linenr">1595: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no: &lt;div NODE="foo" /&gt;</span>
<span class="linenr">1596: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'JSXAttribute'</span>:
<span class="linenr">1597: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">1598: </span>
<span class="linenr">1599: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no: [NODE] = [];</span>
<span class="linenr">1600: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no: ({ NODE }) = [];</span>
<span class="linenr">1601: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'ObjectPattern'</span>:
<span class="linenr">1602: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'ArrayPattern'</span>:
<span class="linenr">1603: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">1604: </span>
<span class="linenr">1605: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no: new.NODE</span>
<span class="linenr">1606: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no: NODE.target</span>
<span class="linenr">1607: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'MetaProperty'</span>:
<span class="linenr">1608: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">1609: </span>
<span class="linenr">1610: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">yes: type X = { someProperty: NODE }</span>
<span class="linenr">1611: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no: type X = { NODE: OtherType }</span>
<span class="linenr">1612: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'ObjectTypeProperty'</span>:
<span class="linenr">1613: </span>      <span class=
"org-keyword">return</span> parent.key !== node
<span class="linenr">1614: </span>
<span class="linenr">1615: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">yes: enum X { Foo = NODE }</span>
<span class="linenr">1616: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no: enum X { NODE }</span>
<span class="linenr">1617: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'TSEnumMember'</span>:
<span class="linenr">1618: </span>      <span class=
"org-keyword">return</span> parent.id !== node
<span class="linenr">1619: </span>
<span class="linenr">1620: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">yes: { [NODE]: value }</span>
<span class="linenr">1621: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no: { NODE: value }</span>
<span class="linenr">1622: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'TSPropertySignature'</span>:
<span class="linenr">1623: </span>      <span class=
"org-keyword">if</span> (parent.key === node) {
<span class="linenr">1624: </span>        <span class=
"org-keyword">return</span> !!parent.computed
<span class="linenr">1625: </span>      }
<span class="linenr">1626: </span>
<span class="linenr">1627: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr">1628: </span>  }
<span class="linenr">1629: </span>
<span class="linenr">1630: </span>  <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr">1631: </span>}
<span class="linenr">1632: </span>
<span class="linenr">1633: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">validFirstIdentCharRE</span> = <span class=
"org-string">/[A-Za-z_$\xA0-\uFFFF]/</span>
<span class="linenr">1634: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">validIdentCharRE</span> = <span class=
"org-string">/[\.\?\w$\xA0-\uFFFF]/</span>
<span class="linenr">1635: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">whitespaceRE</span> = <span class=
"org-string">/\s+[.[]\s*|\s*[.[]\s+/</span>g
<span class="linenr">1636: </span>
<span class="linenr">1637: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">MemberExpLexState</span> = {
<span class="linenr">1638: </span>  inMemberExp: <span class=
"org-highlight-numbers-number">0</span>,
<span class="linenr">1639: </span>  inBrackets: <span class=
"org-highlight-numbers-number">1</span>,
<span class="linenr">1640: </span>  inParens: <span class=
"org-highlight-numbers-number">2</span>,
<span class="linenr">1641: </span>  inString: <span class=
"org-highlight-numbers-number">3</span>
<span class="linenr">1642: </span>}
<span class="linenr">1643: </span>
<span class="linenr">1644: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">isMemberExpressionBrowser</span> = (path) =&gt; {
<span class="linenr">1645: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">remove whitespaces around . or [ first</span>
<span class=
"linenr">1646: </span>  path = path.trim().replace(whitespaceRE, (s) =&gt; s.trim())
<span class="linenr">1647: </span>
<span class="linenr">1648: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">state</span> = MemberExpLexState.inMemberExp
<span class="linenr">1649: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">stateStack</span> = []
<span class="linenr">1650: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">currentOpenBracketCount</span> = <span class=
"org-highlight-numbers-number">0</span>
<span class="linenr">1651: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">currentOpenParensCount</span> = <span class=
"org-highlight-numbers-number">0</span>
<span class="linenr">1652: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">currentStringType</span> = <span class=
"org-constant">null</span>
<span class="linenr">1653: </span>
<span class="linenr">1654: </span>  <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; path.length; i++) {
<span class="linenr">1655: </span>    <span class=
"org-keyword">const</span> <span class=
"org-type">char</span> = path.charAt(i)
<span class="linenr">1656: </span>    <span class=
"org-keyword">switch</span> (state) {
<span class="linenr">1657: </span>      <span class=
"org-keyword">case</span> MemberExpLexState.inMemberExp:
<span class="linenr">1658: </span>        <span class=
"org-keyword">if</span> (<span class=
"org-type">char</span> === <span class="org-string">'['</span>) {
<span class="linenr">1659: </span>          stateStack.push(state)
<span class=
"linenr">1660: </span>          state = MemberExpLexState.inBrackets
<span class=
"linenr">1661: </span>          currentOpenBracketCount++
<span class="linenr">1662: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (<span class=
"org-type">char</span> === <span class="org-string">'('</span>) {
<span class="linenr">1663: </span>          stateStack.push(state)
<span class=
"linenr">1664: </span>          state = MemberExpLexState.inParens
<span class=
"linenr">1665: </span>          currentOpenParensCount++
<span class="linenr">1666: </span>        } <span class=
"org-keyword">else</span> <span class="org-keyword">if</span> (
<span class="linenr">1667: </span>          !(i === <span class=
"org-highlight-numbers-number">0</span> ? validFirstIdentCharRE : validIdentCharRE).test(<span class="org-type">char</span>)
<span class="linenr">1668: </span>        ) {
<span class="linenr">1669: </span>          <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">1670: </span>        }
<span class="linenr">1671: </span>        <span class=
"org-keyword">break</span>
<span class="linenr">1672: </span>      <span class=
"org-keyword">case</span> MemberExpLexState.inBrackets:
<span class="linenr">1673: </span>        <span class=
"org-keyword">if</span> (<span class=
"org-type">char</span> === <span class=
"org-string">`'`</span> || <span class=
"org-type">char</span> === <span class=
"org-string">`"`</span> || <span class=
"org-type">char</span> === <span class="org-string">'`'</span>) {
<span class="linenr">1674: </span>          stateStack.push(state)
<span class=
"linenr">1675: </span>          state = MemberExpLexState.inString
<span class=
"linenr">1676: </span>          currentStringType = <span class=
"org-type">char</span>
<span class="linenr">1677: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (<span class=
"org-type">char</span> === <span class="org-string">`[`</span>) {
<span class=
"linenr">1678: </span>          currentOpenBracketCount++
<span class="linenr">1679: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (<span class=
"org-type">char</span> === <span class="org-string">`]`</span>) {
<span class="linenr">1680: </span>          <span class=
"org-keyword">if</span> (!--currentOpenBracketCount) {
<span class=
"linenr">1681: </span>            state = stateStack.pop()
<span class="linenr">1682: </span>          }
<span class="linenr">1683: </span>        }
<span class="linenr">1684: </span>        <span class=
"org-keyword">break</span>
<span class="linenr">1685: </span>      <span class=
"org-keyword">case</span> MemberExpLexState.inParens:
<span class="linenr">1686: </span>        <span class=
"org-keyword">if</span> (<span class=
"org-type">char</span> === <span class=
"org-string">`'`</span> || <span class=
"org-type">char</span> === <span class=
"org-string">`"`</span> || <span class=
"org-type">char</span> === <span class="org-string">'`'</span>) {
<span class="linenr">1687: </span>          stateStack.push(state)
<span class=
"linenr">1688: </span>          state = MemberExpLexState.inString
<span class=
"linenr">1689: </span>          currentStringType = <span class=
"org-type">char</span>
<span class="linenr">1690: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (<span class=
"org-type">char</span> === <span class="org-string">`(`</span>) {
<span class=
"linenr">1691: </span>          currentOpenParensCount++
<span class="linenr">1692: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (<span class=
"org-type">char</span> === <span class="org-string">`)`</span>) {
<span class="linenr">1693: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">if the exp ends as a call then it should not be considered valid</span>
<span class="linenr">1694: </span>          <span class=
"org-keyword">if</span> (i === path.length - <span class=
"org-highlight-numbers-number">1</span>) {
<span class="linenr">1695: </span>            <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">1696: </span>          }
<span class="linenr">1697: </span>          <span class=
"org-keyword">if</span> (!--currentOpenParensCount) {
<span class=
"linenr">1698: </span>            state = stateStack.pop()
<span class="linenr">1699: </span>          }
<span class="linenr">1700: </span>        }
<span class="linenr">1701: </span>        <span class=
"org-keyword">break</span>
<span class="linenr">1702: </span>      <span class=
"org-keyword">case</span> MemberExpLexState.inString:
<span class="linenr">1703: </span>        <span class=
"org-keyword">if</span> (<span class=
"org-type">char</span> === currentStringType) {
<span class=
"linenr">1704: </span>          state = stateStack.pop()
<span class=
"linenr">1705: </span>          currentStringType = <span class=
"org-constant">null</span>
<span class="linenr">1706: </span>        }
<span class="linenr">1707: </span>        <span class=
"org-keyword">break</span>
<span class="linenr">1708: </span>    }
<span class="linenr">1709: </span>  }
<span class="linenr">1710: </span>  <span class=
"org-keyword">return</span> !currentOpenBracketCount &amp;& !currentOpenParensCount
<span class="linenr">1711: </span>}
<span class="linenr">1712: </span>
<span class="linenr">1713: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">isMemberExpressionNode</span> = __BROWSER__
<span class="linenr">1714: </span>  ? NOOP
<span class="linenr">1715: </span>  : (path, context) =&gt; {
<span class="linenr">1716: </span>      <span class=
"org-keyword">try</span> {
<span class="linenr">1717: </span>        <span class=
"org-keyword">let</span> <span class=
"org-variable-name">ret</span> = babelParser.parseExpression(path, {
<span class=
"linenr">1718: </span>          plugins: context.expressionPlugins
<span class="linenr">1719: </span>        })
<span class="linenr">1720: </span>        <span class=
"org-keyword">if</span> (ret.type === <span class=
"org-string">'TSAsExpression'</span> || ret.type === <span class=
"org-string">'TSTypeAssertion'</span>) {
<span class="linenr">1721: </span>          ret = ret.expression
<span class="linenr">1722: </span>        }
<span class="linenr">1723: </span>        <span class=
"org-keyword">return</span> (
<span class=
"linenr">1724: </span>          ret.type === <span class=
"org-string">'MemberExpression'</span> ||
<span class=
"linenr">1725: </span>          ret.type === <span class=
"org-string">'OptionalMemberExpression'</span> ||
<span class=
"linenr">1726: </span>          ret.type === <span class=
"org-string">'Identifier'</span>
<span class="linenr">1727: </span>        )
<span class="linenr">1728: </span>      } <span class=
"org-keyword">catch</span> (e) {
<span class="linenr">1729: </span>        <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">1730: </span>      }
<span class="linenr">1731: </span>    }
<span class="linenr">1732: </span>
<span class="linenr">1733: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">isMemberExpression</span> = __BROWSER__
<span class="linenr">1734: </span>  ? isMemberExpressionBrowser
<span class="linenr">1735: </span>  : isMemberExpressionNode
<span class="linenr">1736: </span>
<span class="linenr">1737: </span><span class=
"org-comment-delimiter">// </span><span class=
"org-comment">Check if a node contains expressions that reference current context scope ids</span>
<span class="linenr">1738: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">hasScopeRef</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">ids</span>) {
<span class="linenr">1739: </span>  <span class=
"org-keyword">if</span> (!node || Object.keys(ids).length === <span class="org-highlight-numbers-number">0</span>) {
<span class="linenr">1740: </span>    <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">1741: </span>  }
<span class="linenr">1742: </span>  <span class=
"org-keyword">switch</span> (node.type) {
<span class="linenr">1743: </span>    <span class=
"org-keyword">case</span> NodeTypes.ELEMENT:
<span class="linenr">1744: </span>      <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; node.props.length; i++) {
<span class="linenr">1745: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">p</span> = node.props[i]
<span class="linenr">1746: </span>        <span class=
"org-keyword">if</span> (
<span class=
"linenr">1747: </span>          p.type === NodeTypes.DIRECTIVE &amp;&
<span class=
"linenr">1748: </span>          (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))
<span class="linenr">1749: </span>        ) {
<span class="linenr">1750: </span>          <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr">1751: </span>        }
<span class="linenr">1752: </span>      }
<span class="linenr">1753: </span>      <span class=
"org-keyword">return</span> node.children.some((c) =&gt; hasScopeRef(c, ids))
<span class="linenr">1754: </span>    <span class=
"org-keyword">case</span> NodeTypes.FOR:
<span class="linenr">1755: </span>      <span class=
"org-keyword">if</span> (hasScopeRef(node.source, ids)) {
<span class="linenr">1756: </span>        <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr">1757: </span>      }
<span class="linenr">1758: </span>      <span class=
"org-keyword">return</span> node.children.some((c) =&gt; hasScopeRef(c, ids))
<span class="linenr">1759: </span>    <span class=
"org-keyword">case</span> NodeTypes.IF:
<span class="linenr">1760: </span>      <span class=
"org-keyword">return</span> node.branches.some((b) =&gt; hasScopeRef(b, ids))
<span class="linenr">1761: </span>    <span class=
"org-keyword">case</span> NodeTypes.IF_BRANCH:
<span class="linenr">1762: </span>      <span class=
"org-keyword">if</span> (hasScopeRef(node.condition, ids)) {
<span class="linenr">1763: </span>        <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr">1764: </span>      }
<span class="linenr">1765: </span>      <span class=
"org-keyword">return</span> node.children.some((c) =&gt; hasScopeRef(c, ids))
<span class="linenr">1766: </span>    <span class=
"org-keyword">case</span> NodeTypes.SIMPLE_EXPRESSION:
<span class="linenr">1767: </span>      <span class=
"org-keyword">return</span> (
<span class="linenr">1768: </span>        !node.isStatic &amp;&
<span class=
"linenr">1769: </span>        isSimpleIdentifier(node.content) &amp;&
<span class="linenr">1770: </span>        !!ids[node.content]
<span class="linenr">1771: </span>      )
<span class="linenr">1772: </span>    <span class=
"org-keyword">case</span> NodeTypes.COMPOUND_EXPRESSION:
<span class="linenr">1773: </span>      <span class=
"org-keyword">return</span> node.children.some((c) =&gt; isObject(c) &amp;& hasScopeRef(c, ids))
<span class="linenr">1774: </span>    <span class=
"org-keyword">case</span> NodeTypes.INTERPOLATION:
<span class="linenr">1775: </span>    <span class=
"org-keyword">case</span> NodeTypes.TEXT_CALL:
<span class="linenr">1776: </span>      <span class=
"org-keyword">return</span> hasScopeRef(node.content, ids)
<span class="linenr">1777: </span>    <span class=
"org-keyword">case</span> NodeTypes.TEXT:
<span class="linenr">1778: </span>    <span class=
"org-keyword">case</span> NodeTypes.COMMENT:
<span class="linenr">1779: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">1780: </span>    <span class=
"org-keyword">default</span>:
<span class="linenr">1781: </span>      <span class=
"org-keyword">if</span> (__DEV__) {
<span class="linenr">1782: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">exhaustiveCheck</span> = node
<span class="linenr">1783: </span>        exhaustiveCheck
<span class="linenr">1784: </span>      }
<span class="linenr">1785: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">1786: </span>  }
<span class="linenr">1787: </span>}
<span class="linenr">1788: </span>
<span class="linenr">1789: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">SlotFlags</span> = {
<span id="coderef-SlotFlags" class="coderef-off"><span class=
"linenr">1790: </span>  <span class=
"org-comment-delimiter">//</span></span>
<span class="linenr">1791: </span>  <span class=
"org-doc">/**</span>
<span class="linenr">1792: </span><span class=
"org-doc">   * Stable slots that only reference slot props or context state. The slot</span>
<span class="linenr">1793: </span><span class=
"org-doc">   * can fully capture its own dependencies so when passed down the parent won't</span>
<span class="linenr">1794: </span><span class=
"org-doc">   * need to force the child to update.</span>
<span class="linenr">1795: </span><span class=
"org-doc">   */</span>
<span class="linenr">1796: </span>  STABLE: <span class=
"org-highlight-numbers-number">1</span>,
<span class="linenr">1797: </span>  <span class=
"org-doc">/**</span>
<span class="linenr">1798: </span><span class=
"org-doc">   * Slots that reference scope variables (v-for or an outer slot prop), or</span>
<span class="linenr">1799: </span><span class=
"org-doc">   * has conditional structure (v-if, v-for). The parent will need to force</span>
<span class="linenr">1800: </span><span class=
"org-doc">   * the child to update because the slot does not fully capture its dependencies.</span>
<span class="linenr">1801: </span><span class=
"org-doc">   */</span>
<span class="linenr">1802: </span>  DYNAMIC: <span class=
"org-highlight-numbers-number">2</span>,
<span class="linenr">1803: </span>  <span class=
"org-doc">/**</span>
<span class="linenr">1804: </span><span class=
"org-doc">   * `&lt;slot/&gt;` being forwarded into a child component. Whether the parent needs</span>
<span class="linenr">1805: </span><span class=
"org-doc">   * to update the child is dependent on what kind of slots the parent itself</span>
<span class="linenr">1806: </span><span class=
"org-doc">   * received. This has to be refined at runtime, when the child's vnode</span>
<span class="linenr">1807: </span><span class=
"org-doc">   * is being created (in `normalizeChildren`)</span>
<span class="linenr">1808: </span><span class=
"org-doc">   */</span>
<span class="linenr">1809: </span>  FORWARDED: <span class=
"org-highlight-numbers-number">3</span>
<span class="linenr">1810: </span>}
<span class="linenr">1811: </span>
<span class="linenr">1812: </span><span class="org-doc">/**</span>
<span class="linenr">1813: </span><span class=
"org-doc"> * Dev only</span>
<span class="linenr">1814: </span><span class="org-doc"> */</span>
<span class="linenr">1815: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">slotFlagsText</span> = {
<span class=
"linenr">1816: </span>  [SlotFlags.STABLE]: <span class="org-string">'STABLE'</span>,
<span class=
"linenr">1817: </span>  [SlotFlags.DYNAMIC]: <span class=
"org-string">'DYNAMIC'</span>,
<span class=
"linenr">1818: </span>  [SlotFlags.FORWARDED]: <span class=
"org-string">'FORWARDED'</span>
<span class="linenr">1819: </span>}
<span class="linenr">1820: </span>
<span class="linenr">1821: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">createElementWithCodegen</span>(
<span class="linenr">1822: </span>  <span class=
"org-variable-name">tag</span>,
<span class="linenr">1823: </span>  <span class=
"org-variable-name">props</span>,
<span class="linenr">1824: </span>  <span class=
"org-variable-name">children</span>,
<span class="linenr">1825: </span>  <span class=
"org-variable-name">patchFlag</span>,
<span class="linenr">1826: </span>  dynamicProps
<span class="linenr">1827: </span>) {
<span class="linenr">1828: </span>  <span class=
"org-keyword">return</span> {
<span class="linenr">1829: </span>    type: NodeTypes.ELEMENT,
<span class="linenr">1830: </span>    loc: locStub,
<span class="linenr">1831: </span>    ns: Namespaces.HTML,
<span class="linenr">1832: </span>    tag: <span class=
"org-string">'div'</span>,
<span class=
"linenr">1833: </span>    tagType: ElementTypes.ELEMENT,
<span class="linenr">1834: </span>    isSelfClosing: <span class=
"org-constant">false</span>,
<span class="linenr">1835: </span>    props: [],
<span class="linenr">1836: </span>    children: [],
<span class="linenr">1837: </span>    codegenNode: {
<span class="linenr">1838: </span>      type: NodeTypes.VNODE_CALL,
<span class="linenr">1839: </span>      tag,
<span class="linenr">1840: </span>      props,
<span class="linenr">1841: </span>      children,
<span class="linenr">1842: </span>      patchFlag,
<span class="linenr">1843: </span>      dynamicProps,
<span class="linenr">1844: </span>      directives: <span class=
"org-constant">undefined</span>,
<span class="linenr">1845: </span>      isBlock: <span class=
"org-constant">false</span>,
<span class=
"linenr">1846: </span>      disableTracking: <span class=
"org-constant">false</span>,
<span class="linenr">1847: </span>      isComponent: <span class=
"org-constant">false</span>,
<span class="linenr">1848: </span>      loc: locStub
<span class="linenr">1849: </span>    }
<span class="linenr">1850: </span>  }
<span class="linenr">1851: </span>}
<span class="linenr">1852: </span>
<span class="linenr">1853: </span><span class=
"org-comment-delimiter">// </span><span class=
"org-comment">codegen utils</span>
<span class="linenr">1854: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">PURE_ANNOTATION</span> = <span class=
"org-string">`/*#__PURE__*/`</span>
<span class="linenr">1855: </span>
<span class="linenr">1856: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">isText$1</span>(<span class=
"org-variable-name">n</span>) {
<span class="linenr">1857: </span>  <span class=
"org-keyword">return</span> (
<span class="linenr">1858: </span>    isString(n) ||
<span class=
"linenr">1859: </span>    n.type === NodeTypes.SIMPLE_EXPRESSION ||
<span class="linenr">1860: </span>    n.type === NodeTypes.TEXT ||
<span class=
"linenr">1861: </span>    n.type === NodeTypes.INTERPOLATION ||
<span class=
"linenr">1862: </span>    n.type === NodeTypes.COMPOUND_EXPRESSION
<span class="linenr">1863: </span>  )
<span class="linenr">1864: </span>}
<span class="linenr">1865: </span>
<span class="linenr">1866: </span><span class=
"org-comment-delimiter">// </span><span class=
"org-comment">过滤掉后面空值参数fn(a, b, c, null, undefined, '') =&gt; fn(a,b,c)</span>
<span class="linenr">1867: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">genNullableArgs</span>(<span class=
"org-variable-name">args</span>) {
<span class="linenr">1868: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = args.length
<span class="linenr">1869: </span>  <span class=
"org-keyword">while</span> (i--) {
<span class="linenr">1870: </span>    <span class=
"org-keyword">if</span> (args[i] != <span class=
"org-constant">null</span>) <span class="org-keyword">break</span>
<span class="linenr">1871: </span>  }
<span class="linenr">1872: </span>  <span class=
"org-keyword">return</span> args.slice(<span class=
"org-highlight-numbers-number">0</span>, i + <span class=
"org-highlight-numbers-number">1</span>).map((arg) =&gt; arg || <span class="org-string">`null`</span>)
<span class="linenr">1873: </span>}
<span class="linenr">1874: </span>
<span class="linenr">1875: </span><span class=
"org-comment-delimiter">// </span><span class=
"org-comment">生成对象的 key 值，可能是个表达式，如： { [a + b + c]: value }</span>
<span class="linenr">1876: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">genExpressionAsPropertyKey</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
<span class="linenr">1877: </span>  <span class=
"org-keyword">const</span> { push } = context
<span class="linenr">1878: </span>  <span class=
"org-keyword">if</span> (node.type === NodeTypes.COMPOUND_EXPRESSION) {
<span class="linenr">1879: </span>    push(<span class=
"org-string">`[`</span>)
<span class=
"linenr">1880: </span>    genCompoundExpression(node, context)
<span class="linenr">1881: </span>    push(<span class=
"org-string">`]`</span>)
<span class="linenr">1882: </span>  } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (node.isStatic) {
<span class="linenr">1883: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">only quote keys if necessary</span>
<span class="linenr">1884: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">text</span> = isSimpleIdentifier(node.content)
<span class="linenr">1885: </span>      ? node.content
<span class=
"linenr">1886: </span>      : JSON.stringify(node.content)
<span class="linenr">1887: </span>    push(text, node)
<span class="linenr">1888: </span>  } <span class=
"org-keyword">else</span> {
<span class="linenr">1889: </span>    push(<span class=
"org-string">`[${node.content}]`</span>, node)
<span class="linenr">1890: </span>  }
<span class="linenr">1891: </span>}
</pre>
      </div>
      <div class="org-src-container">
        <pre class="src src-js" id="org9baea18"><span class=
        "linenr">   1: </span><span class=
        "org-keyword">const</span> <span class=
        "org-variable-name">namedCharacterReferences</span> = {
<span class="linenr">   2: </span>  <span class=
"org-string">"GT"</span>: <span class="org-string">"&gt;"</span>,
<span class="linenr">   3: </span>  <span class=
"org-string">"gt"</span>: <span class="org-string">"&gt;"</span>,
<span class="linenr">   4: </span>  <span class=
"org-string">"LT"</span>: <span class="org-string">"&lt;"</span>,
<span class="linenr">   5: </span>  <span class=
"org-string">"lt"</span>: <span class="org-string">"&lt;"</span>,
<span class="linenr">   6: </span>  <span class=
"org-string">"ac;"</span>: <span class="org-string">"∾"</span>,
<span class="linenr">   7: </span>  <span class=
"org-string">"af;"</span>: <span class="org-string">"⁡"</span>,
<span class="linenr">   8: </span>  <span class=
"org-string">"AMP"</span>: <span class="org-string">"&amp;"</span>,
<span class="linenr">   9: </span>  <span class=
"org-string">"amp"</span>: <span class="org-string">"&amp;"</span>,
<span class="linenr">  10: </span>  <span class=
"org-string">"ap;"</span>: <span class="org-string">"≈"</span>,
<span class="linenr">  11: </span>  <span class=
"org-string">"DD;"</span>: <span class="org-string">"ⅅ"</span>,
<span class="linenr">  12: </span>  <span class=
"org-string">"dd;"</span>: <span class="org-string">"ⅆ"</span>,
<span class="linenr">  13: </span>  <span class=
"org-string">"deg"</span>: <span class="org-string">"°"</span>,
<span class="linenr">  14: </span>  <span class=
"org-string">"ee;"</span>: <span class="org-string">"ⅇ"</span>,
<span class="linenr">  15: </span>  <span class=
"org-string">"eg;"</span>: <span class="org-string">"⪚"</span>,
<span class="linenr">  16: </span>  <span class=
"org-string">"el;"</span>: <span class="org-string">"⪙"</span>,
<span class="linenr">  17: </span>  <span class=
"org-string">"ETH"</span>: <span class="org-string">"Ð"</span>,
<span class="linenr">  18: </span>  <span class=
"org-string">"eth"</span>: <span class="org-string">"ð"</span>,
<span class="linenr">  19: </span>  <span class=
"org-string">"gE;"</span>: <span class="org-string">"≧"</span>,
<span class="linenr">  20: </span>  <span class=
"org-string">"ge;"</span>: <span class="org-string">"≥"</span>,
<span class="linenr">  21: </span>  <span class=
"org-string">"Gg;"</span>: <span class="org-string">"⋙"</span>,
<span class="linenr">  22: </span>  <span class=
"org-string">"gg;"</span>: <span class="org-string">"≫"</span>,
<span class="linenr">  23: </span>  <span class=
"org-string">"gl;"</span>: <span class="org-string">"≷"</span>,
<span class="linenr">  24: </span>  <span class=
"org-string">"GT;"</span>: <span class="org-string">"&gt;"</span>,
<span class="linenr">  25: </span>  <span class=
"org-string">"Gt;"</span>: <span class="org-string">"≫"</span>,
<span class="linenr">  26: </span>  <span class=
"org-string">"gt;"</span>: <span class="org-string">"&gt;"</span>,
<span class="linenr">  27: </span>  <span class=
"org-string">"ic;"</span>: <span class="org-string">"⁣"</span>,
<span class="linenr">  28: </span>  <span class=
"org-string">"ii;"</span>: <span class="org-string">"ⅈ"</span>,
<span class="linenr">  29: </span>  <span class=
"org-string">"Im;"</span>: <span class="org-string">"ℑ"</span>,
<span class="linenr">  30: </span>  <span class=
"org-string">"in;"</span>: <span class="org-string">"∈"</span>,
<span class="linenr">  31: </span>  <span class=
"org-string">"it;"</span>: <span class="org-string">"⁢"</span>,
<span class="linenr">  32: </span>  <span class=
"org-string">"lE;"</span>: <span class="org-string">"≦"</span>,
<span class="linenr">  33: </span>  <span class=
"org-string">"le;"</span>: <span class="org-string">"≤"</span>,
<span class="linenr">  34: </span>  <span class=
"org-string">"lg;"</span>: <span class="org-string">"≶"</span>,
<span class="linenr">  35: </span>  <span class=
"org-string">"Ll;"</span>: <span class="org-string">"⋘"</span>,
<span class="linenr">  36: </span>  <span class=
"org-string">"ll;"</span>: <span class="org-string">"≪"</span>,
<span class="linenr">  37: </span>  <span class=
"org-string">"LT;"</span>: <span class="org-string">"&lt;"</span>,
<span class="linenr">  38: </span>  <span class=
"org-string">"Lt;"</span>: <span class="org-string">"≪"</span>,
<span class="linenr">  39: </span>  <span class=
"org-string">"lt;"</span>: <span class="org-string">"&lt;"</span>,
<span class="linenr">  40: </span>  <span class=
"org-string">"mp;"</span>: <span class="org-string">"∓"</span>,
<span class="linenr">  41: </span>  <span class=
"org-string">"Mu;"</span>: <span class="org-string">"Μ"</span>,
<span class="linenr">  42: </span>  <span class=
"org-string">"mu;"</span>: <span class="org-string">"μ"</span>,
<span class="linenr">  43: </span>  <span class=
"org-string">"ne;"</span>: <span class="org-string">"≠"</span>,
<span class="linenr">  44: </span>  <span class=
"org-string">"ni;"</span>: <span class="org-string">"∋"</span>,
<span class="linenr">  45: </span>  <span class=
"org-string">"not"</span>: <span class="org-string">"¬"</span>,
<span class="linenr">  46: </span>  <span class=
"org-string">"Nu;"</span>: <span class="org-string">"Ν"</span>,
<span class="linenr">  47: </span>  <span class=
"org-string">"nu;"</span>: <span class="org-string">"ν"</span>,
<span class="linenr">  48: </span>  <span class=
"org-string">"Or;"</span>: <span class="org-string">"⩔"</span>,
<span class="linenr">  49: </span>  <span class=
"org-string">"or;"</span>: <span class="org-string">"∨"</span>,
<span class="linenr">  50: </span>  <span class=
"org-string">"oS;"</span>: <span class="org-string">"Ⓢ"</span>,
<span class="linenr">  51: </span>  <span class=
"org-string">"Pi;"</span>: <span class="org-string">"Π"</span>,
<span class="linenr">  52: </span>  <span class=
"org-string">"pi;"</span>: <span class="org-string">"π"</span>,
<span class="linenr">  53: </span>  <span class=
"org-string">"pm;"</span>: <span class="org-string">"±"</span>,
<span class="linenr">  54: </span>  <span class=
"org-string">"Pr;"</span>: <span class="org-string">"⪻"</span>,
<span class="linenr">  55: </span>  <span class=
"org-string">"pr;"</span>: <span class="org-string">"≺"</span>,
<span class="linenr">  56: </span>  <span class=
"org-string">"Re;"</span>: <span class="org-string">"ℜ"</span>,
<span class="linenr">  57: </span>  <span class=
"org-string">"REG"</span>: <span class="org-string">"®"</span>,
<span class="linenr">  58: </span>  <span class=
"org-string">"reg"</span>: <span class="org-string">"®"</span>,
<span class="linenr">  59: </span>  <span class=
"org-string">"rx;"</span>: <span class="org-string">"℞"</span>,
<span class="linenr">  60: </span>  <span class=
"org-string">"Sc;"</span>: <span class="org-string">"⪼"</span>,
<span class="linenr">  61: </span>  <span class=
"org-string">"sc;"</span>: <span class="org-string">"≻"</span>,
<span class="linenr">  62: </span>  <span class=
"org-string">"shy"</span>: <span class="org-string">"­"</span>,
<span class="linenr">  63: </span>  <span class=
"org-string">"uml"</span>: <span class="org-string">"¨"</span>,
<span class="linenr">  64: </span>  <span class=
"org-string">"wp;"</span>: <span class="org-string">"℘"</span>,
<span class="linenr">  65: </span>  <span class=
"org-string">"wr;"</span>: <span class="org-string">"≀"</span>,
<span class="linenr">  66: </span>  <span class=
"org-string">"Xi;"</span>: <span class="org-string">"Ξ"</span>,
<span class="linenr">  67: </span>  <span class=
"org-string">"xi;"</span>: <span class="org-string">"ξ"</span>,
<span class="linenr">  68: </span>  <span class=
"org-string">"yen"</span>: <span class="org-string">"¥"</span>,
<span class="linenr">  69: </span>  <span class=
"org-string">"acd;"</span>: <span class="org-string">"∿"</span>,
<span class="linenr">  70: </span>  <span class=
"org-string">"acE;"</span>: <span class="org-string">"∾̳"</span>,
<span class="linenr">  71: </span>  <span class=
"org-string">"Acy;"</span>: <span class="org-string">"А"</span>,
<span class="linenr">  72: </span>  <span class=
"org-string">"acy;"</span>: <span class="org-string">"а"</span>,
<span class="linenr">  73: </span>  <span class=
"org-string">"Afr;"</span>: <span class="org-string">"𝔄"</span>,
<span class="linenr">  74: </span>  <span class=
"org-string">"afr;"</span>: <span class="org-string">"𝔞"</span>,
<span class="linenr">  75: </span>  <span class=
"org-string">"AMP;"</span>: <span class=
"org-string">"&amp;"</span>,
<span class="linenr">  76: </span>  <span class=
"org-string">"amp;"</span>: <span class=
"org-string">"&amp;"</span>,
<span class="linenr">  77: </span>  <span class=
"org-string">"And;"</span>: <span class="org-string">"⩓"</span>,
<span class="linenr">  78: </span>  <span class=
"org-string">"and;"</span>: <span class="org-string">"∧"</span>,
<span class="linenr">  79: </span>  <span class=
"org-string">"ang;"</span>: <span class="org-string">"∠"</span>,
<span class="linenr">  80: </span>  <span class=
"org-string">"apE;"</span>: <span class="org-string">"⩰"</span>,
<span class="linenr">  81: </span>  <span class=
"org-string">"ape;"</span>: <span class="org-string">"≊"</span>,
<span class="linenr">  82: </span>  <span class=
"org-string">"ast;"</span>: <span class="org-string">"*"</span>,
<span class="linenr">  83: </span>  <span class=
"org-string">"Auml"</span>: <span class="org-string">"Ä"</span>,
<span class="linenr">  84: </span>  <span class=
"org-string">"auml"</span>: <span class="org-string">"ä"</span>,
<span class="linenr">  85: </span>  <span class=
"org-string">"Bcy;"</span>: <span class="org-string">"Б"</span>,
<span class="linenr">  86: </span>  <span class=
"org-string">"bcy;"</span>: <span class="org-string">"б"</span>,
<span class="linenr">  87: </span>  <span class=
"org-string">"Bfr;"</span>: <span class="org-string">"𝔅"</span>,
<span class="linenr">  88: </span>  <span class=
"org-string">"bfr;"</span>: <span class="org-string">"𝔟"</span>,
<span class="linenr">  89: </span>  <span class=
"org-string">"bne;"</span>: <span class="org-string">"=⃥"</span>,
<span class="linenr">  90: </span>  <span class=
"org-string">"bot;"</span>: <span class="org-string">"⊥"</span>,
<span class="linenr">  91: </span>  <span class=
"org-string">"Cap;"</span>: <span class="org-string">"⋒"</span>,
<span class="linenr">  92: </span>  <span class=
"org-string">"cap;"</span>: <span class="org-string">"∩"</span>,
<span class="linenr">  93: </span>  <span class=
"org-string">"cent"</span>: <span class="org-string">"¢"</span>,
<span class="linenr">  94: </span>  <span class=
"org-string">"Cfr;"</span>: <span class="org-string">"ℭ"</span>,
<span class="linenr">  95: </span>  <span class=
"org-string">"cfr;"</span>: <span class="org-string">"𝔠"</span>,
<span class="linenr">  96: </span>  <span class=
"org-string">"Chi;"</span>: <span class="org-string">"Χ"</span>,
<span class="linenr">  97: </span>  <span class=
"org-string">"chi;"</span>: <span class="org-string">"χ"</span>,
<span class="linenr">  98: </span>  <span class=
"org-string">"cir;"</span>: <span class="org-string">"○"</span>,
<span class="linenr">  99: </span>  <span class=
"org-string">"COPY"</span>: <span class="org-string">"©"</span>,
<span class="linenr"> 100: </span>  <span class=
"org-string">"copy"</span>: <span class="org-string">"©"</span>,
<span class="linenr"> 101: </span>  <span class=
"org-string">"Cup;"</span>: <span class="org-string">"⋓"</span>,
<span class="linenr"> 102: </span>  <span class=
"org-string">"cup;"</span>: <span class="org-string">"∪"</span>,
<span class="linenr"> 103: </span>  <span class=
"org-string">"Dcy;"</span>: <span class="org-string">"Д"</span>,
<span class="linenr"> 104: </span>  <span class=
"org-string">"dcy;"</span>: <span class="org-string">"д"</span>,
<span class="linenr"> 105: </span>  <span class=
"org-string">"deg;"</span>: <span class="org-string">"°"</span>,
<span class="linenr"> 106: </span>  <span class=
"org-string">"Del;"</span>: <span class="org-string">"∇"</span>,
<span class="linenr"> 107: </span>  <span class=
"org-string">"Dfr;"</span>: <span class="org-string">"𝔇"</span>,
<span class="linenr"> 108: </span>  <span class=
"org-string">"dfr;"</span>: <span class="org-string">"𝔡"</span>,
<span class="linenr"> 109: </span>  <span class=
"org-string">"die;"</span>: <span class="org-string">"¨"</span>,
<span class="linenr"> 110: </span>  <span class=
"org-string">"div;"</span>: <span class="org-string">"÷"</span>,
<span class="linenr"> 111: </span>  <span class=
"org-string">"Dot;"</span>: <span class="org-string">"¨"</span>,
<span class="linenr"> 112: </span>  <span class=
"org-string">"dot;"</span>: <span class="org-string">"˙"</span>,
<span class="linenr"> 113: </span>  <span class=
"org-string">"Ecy;"</span>: <span class="org-string">"Э"</span>,
<span class="linenr"> 114: </span>  <span class=
"org-string">"ecy;"</span>: <span class="org-string">"э"</span>,
<span class="linenr"> 115: </span>  <span class=
"org-string">"Efr;"</span>: <span class="org-string">"𝔈"</span>,
<span class="linenr"> 116: </span>  <span class=
"org-string">"efr;"</span>: <span class="org-string">"𝔢"</span>,
<span class="linenr"> 117: </span>  <span class=
"org-string">"egs;"</span>: <span class="org-string">"⪖"</span>,
<span class="linenr"> 118: </span>  <span class=
"org-string">"ell;"</span>: <span class="org-string">"ℓ"</span>,
<span class="linenr"> 119: </span>  <span class=
"org-string">"els;"</span>: <span class="org-string">"⪕"</span>,
<span class="linenr"> 120: </span>  <span class=
"org-string">"ENG;"</span>: <span class="org-string">"Ŋ"</span>,
<span class="linenr"> 121: </span>  <span class=
"org-string">"eng;"</span>: <span class="org-string">"ŋ"</span>,
<span class="linenr"> 122: </span>  <span class=
"org-string">"Eta;"</span>: <span class="org-string">"Η"</span>,
<span class="linenr"> 123: </span>  <span class=
"org-string">"eta;"</span>: <span class="org-string">"η"</span>,
<span class="linenr"> 124: </span>  <span class=
"org-string">"ETH;"</span>: <span class="org-string">"Ð"</span>,
<span class="linenr"> 125: </span>  <span class=
"org-string">"eth;"</span>: <span class="org-string">"ð"</span>,
<span class="linenr"> 126: </span>  <span class=
"org-string">"Euml"</span>: <span class="org-string">"Ë"</span>,
<span class="linenr"> 127: </span>  <span class=
"org-string">"euml"</span>: <span class="org-string">"ë"</span>,
<span class="linenr"> 128: </span>  <span class=
"org-string">"Fcy;"</span>: <span class="org-string">"Ф"</span>,
<span class="linenr"> 129: </span>  <span class=
"org-string">"fcy;"</span>: <span class="org-string">"ф"</span>,
<span class="linenr"> 130: </span>  <span class=
"org-string">"Ffr;"</span>: <span class="org-string">"𝔉"</span>,
<span class="linenr"> 131: </span>  <span class=
"org-string">"ffr;"</span>: <span class="org-string">"𝔣"</span>,
<span class="linenr"> 132: </span>  <span class=
"org-string">"gap;"</span>: <span class="org-string">"⪆"</span>,
<span class="linenr"> 133: </span>  <span class=
"org-string">"Gcy;"</span>: <span class="org-string">"Г"</span>,
<span class="linenr"> 134: </span>  <span class=
"org-string">"gcy;"</span>: <span class="org-string">"г"</span>,
<span class="linenr"> 135: </span>  <span class=
"org-string">"gEl;"</span>: <span class="org-string">"⪌"</span>,
<span class="linenr"> 136: </span>  <span class=
"org-string">"gel;"</span>: <span class="org-string">"⋛"</span>,
<span class="linenr"> 137: </span>  <span class=
"org-string">"geq;"</span>: <span class="org-string">"≥"</span>,
<span class="linenr"> 138: </span>  <span class=
"org-string">"ges;"</span>: <span class="org-string">"⩾"</span>,
<span class="linenr"> 139: </span>  <span class=
"org-string">"Gfr;"</span>: <span class="org-string">"𝔊"</span>,
<span class="linenr"> 140: </span>  <span class=
"org-string">"gfr;"</span>: <span class="org-string">"𝔤"</span>,
<span class="linenr"> 141: </span>  <span class=
"org-string">"ggg;"</span>: <span class="org-string">"⋙"</span>,
<span class="linenr"> 142: </span>  <span class=
"org-string">"gla;"</span>: <span class="org-string">"⪥"</span>,
<span class="linenr"> 143: </span>  <span class=
"org-string">"glE;"</span>: <span class="org-string">"⪒"</span>,
<span class="linenr"> 144: </span>  <span class=
"org-string">"glj;"</span>: <span class="org-string">"⪤"</span>,
<span class="linenr"> 145: </span>  <span class=
"org-string">"gnE;"</span>: <span class="org-string">"≩"</span>,
<span class="linenr"> 146: </span>  <span class=
"org-string">"gne;"</span>: <span class="org-string">"⪈"</span>,
<span class="linenr"> 147: </span>  <span class=
"org-string">"Hat;"</span>: <span class="org-string">"^"</span>,
<span class="linenr"> 148: </span>  <span class=
"org-string">"Hfr;"</span>: <span class="org-string">"ℌ"</span>,
<span class="linenr"> 149: </span>  <span class=
"org-string">"hfr;"</span>: <span class="org-string">"𝔥"</span>,
<span class="linenr"> 150: </span>  <span class=
"org-string">"Icy;"</span>: <span class="org-string">"И"</span>,
<span class="linenr"> 151: </span>  <span class=
"org-string">"icy;"</span>: <span class="org-string">"и"</span>,
<span class="linenr"> 152: </span>  <span class=
"org-string">"iff;"</span>: <span class="org-string">"⇔"</span>,
<span class="linenr"> 153: </span>  <span class=
"org-string">"Ifr;"</span>: <span class="org-string">"ℑ"</span>,
<span class="linenr"> 154: </span>  <span class=
"org-string">"ifr;"</span>: <span class="org-string">"𝔦"</span>,
<span class="linenr"> 155: </span>  <span class=
"org-string">"Int;"</span>: <span class="org-string">"∬"</span>,
<span class="linenr"> 156: </span>  <span class=
"org-string">"int;"</span>: <span class="org-string">"∫"</span>,
<span class="linenr"> 157: </span>  <span class=
"org-string">"Iuml"</span>: <span class="org-string">"Ï"</span>,
<span class="linenr"> 158: </span>  <span class=
"org-string">"iuml"</span>: <span class="org-string">"ï"</span>,
<span class="linenr"> 159: </span>  <span class=
"org-string">"Jcy;"</span>: <span class="org-string">"Й"</span>,
<span class="linenr"> 160: </span>  <span class=
"org-string">"jcy;"</span>: <span class="org-string">"й"</span>,
<span class="linenr"> 161: </span>  <span class=
"org-string">"Jfr;"</span>: <span class="org-string">"𝔍"</span>,
<span class="linenr"> 162: </span>  <span class=
"org-string">"jfr;"</span>: <span class="org-string">"𝔧"</span>,
<span class="linenr"> 163: </span>  <span class=
"org-string">"Kcy;"</span>: <span class="org-string">"К"</span>,
<span class="linenr"> 164: </span>  <span class=
"org-string">"kcy;"</span>: <span class="org-string">"к"</span>,
<span class="linenr"> 165: </span>  <span class=
"org-string">"Kfr;"</span>: <span class="org-string">"𝔎"</span>,
<span class="linenr"> 166: </span>  <span class=
"org-string">"kfr;"</span>: <span class="org-string">"𝔨"</span>,
<span class="linenr"> 167: </span>  <span class=
"org-string">"lap;"</span>: <span class="org-string">"⪅"</span>,
<span class="linenr"> 168: </span>  <span class=
"org-string">"lat;"</span>: <span class="org-string">"⪫"</span>,
<span class="linenr"> 169: </span>  <span class=
"org-string">"Lcy;"</span>: <span class="org-string">"Л"</span>,
<span class="linenr"> 170: </span>  <span class=
"org-string">"lcy;"</span>: <span class="org-string">"л"</span>,
<span class="linenr"> 171: </span>  <span class=
"org-string">"lEg;"</span>: <span class="org-string">"⪋"</span>,
<span class="linenr"> 172: </span>  <span class=
"org-string">"leg;"</span>: <span class="org-string">"⋚"</span>,
<span class="linenr"> 173: </span>  <span class=
"org-string">"leq;"</span>: <span class="org-string">"≤"</span>,
<span class="linenr"> 174: </span>  <span class=
"org-string">"les;"</span>: <span class="org-string">"⩽"</span>,
<span class="linenr"> 175: </span>  <span class=
"org-string">"Lfr;"</span>: <span class="org-string">"𝔏"</span>,
<span class="linenr"> 176: </span>  <span class=
"org-string">"lfr;"</span>: <span class="org-string">"𝔩"</span>,
<span class="linenr"> 177: </span>  <span class=
"org-string">"lgE;"</span>: <span class="org-string">"⪑"</span>,
<span class="linenr"> 178: </span>  <span class=
"org-string">"lnE;"</span>: <span class="org-string">"≨"</span>,
<span class="linenr"> 179: </span>  <span class=
"org-string">"lne;"</span>: <span class="org-string">"⪇"</span>,
<span class="linenr"> 180: </span>  <span class=
"org-string">"loz;"</span>: <span class="org-string">"◊"</span>,
<span class="linenr"> 181: </span>  <span class=
"org-string">"lrm;"</span>: <span class="org-string">"‎"</span>,
<span class="linenr"> 182: </span>  <span class=
"org-string">"Lsh;"</span>: <span class="org-string">"↰"</span>,
<span class="linenr"> 183: </span>  <span class=
"org-string">"lsh;"</span>: <span class="org-string">"↰"</span>,
<span class="linenr"> 184: </span>  <span class=
"org-string">"macr"</span>: <span class="org-string">"¯"</span>,
<span class="linenr"> 185: </span>  <span class=
"org-string">"Map;"</span>: <span class="org-string">"⤅"</span>,
<span class="linenr"> 186: </span>  <span class=
"org-string">"map;"</span>: <span class="org-string">"↦"</span>,
<span class="linenr"> 187: </span>  <span class=
"org-string">"Mcy;"</span>: <span class="org-string">"М"</span>,
<span class="linenr"> 188: </span>  <span class=
"org-string">"mcy;"</span>: <span class="org-string">"м"</span>,
<span class="linenr"> 189: </span>  <span class=
"org-string">"Mfr;"</span>: <span class="org-string">"𝔐"</span>,
<span class="linenr"> 190: </span>  <span class=
"org-string">"mfr;"</span>: <span class="org-string">"𝔪"</span>,
<span class="linenr"> 191: </span>  <span class=
"org-string">"mho;"</span>: <span class="org-string">"℧"</span>,
<span class="linenr"> 192: </span>  <span class=
"org-string">"mid;"</span>: <span class="org-string">"∣"</span>,
<span class="linenr"> 193: </span>  <span class=
"org-string">"nap;"</span>: <span class="org-string">"≉"</span>,
<span class="linenr"> 194: </span>  <span class=
"org-string">"nbsp"</span>: <span class="org-string">" "</span>,
<span class="linenr"> 195: </span>  <span class=
"org-string">"Ncy;"</span>: <span class="org-string">"Н"</span>,
<span class="linenr"> 196: </span>  <span class=
"org-string">"ncy;"</span>: <span class="org-string">"н"</span>,
<span class="linenr"> 197: </span>  <span class=
"org-string">"Nfr;"</span>: <span class="org-string">"𝔑"</span>,
<span class="linenr"> 198: </span>  <span class=
"org-string">"nfr;"</span>: <span class="org-string">"𝔫"</span>,
<span class="linenr"> 199: </span>  <span class=
"org-string">"ngE;"</span>: <span class="org-string">"≧̸"</span>,
<span class="linenr"> 200: </span>  <span class=
"org-string">"nge;"</span>: <span class="org-string">"≱"</span>,
<span class="linenr"> 201: </span>  <span class=
"org-string">"nGg;"</span>: <span class="org-string">"⋙̸"</span>,
<span class="linenr"> 202: </span>  <span class=
"org-string">"nGt;"</span>: <span class="org-string">"≫⃒"</span>,
<span class="linenr"> 203: </span>  <span class=
"org-string">"ngt;"</span>: <span class="org-string">"≯"</span>,
<span class="linenr"> 204: </span>  <span class=
"org-string">"nis;"</span>: <span class="org-string">"⋼"</span>,
<span class="linenr"> 205: </span>  <span class=
"org-string">"niv;"</span>: <span class="org-string">"∋"</span>,
<span class="linenr"> 206: </span>  <span class=
"org-string">"nlE;"</span>: <span class="org-string">"≦̸"</span>,
<span class="linenr"> 207: </span>  <span class=
"org-string">"nle;"</span>: <span class="org-string">"≰"</span>,
<span class="linenr"> 208: </span>  <span class=
"org-string">"nLl;"</span>: <span class="org-string">"⋘̸"</span>,
<span class="linenr"> 209: </span>  <span class=
"org-string">"nLt;"</span>: <span class="org-string">"≪⃒"</span>,
<span class="linenr"> 210: </span>  <span class=
"org-string">"nlt;"</span>: <span class="org-string">"≮"</span>,
<span class="linenr"> 211: </span>  <span class=
"org-string">"Not;"</span>: <span class="org-string">"⫬"</span>,
<span class="linenr"> 212: </span>  <span class=
"org-string">"not;"</span>: <span class="org-string">"¬"</span>,
<span class="linenr"> 213: </span>  <span class=
"org-string">"npr;"</span>: <span class="org-string">"⊀"</span>,
<span class="linenr"> 214: </span>  <span class=
"org-string">"nsc;"</span>: <span class="org-string">"⊁"</span>,
<span class="linenr"> 215: </span>  <span class=
"org-string">"num;"</span>: <span class="org-string">"#"</span>,
<span class="linenr"> 216: </span>  <span class=
"org-string">"Ocy;"</span>: <span class="org-string">"О"</span>,
<span class="linenr"> 217: </span>  <span class=
"org-string">"ocy;"</span>: <span class="org-string">"о"</span>,
<span class="linenr"> 218: </span>  <span class=
"org-string">"Ofr;"</span>: <span class="org-string">"𝔒"</span>,
<span class="linenr"> 219: </span>  <span class=
"org-string">"ofr;"</span>: <span class="org-string">"𝔬"</span>,
<span class="linenr"> 220: </span>  <span class=
"org-string">"ogt;"</span>: <span class="org-string">"⧁"</span>,
<span class="linenr"> 221: </span>  <span class=
"org-string">"ohm;"</span>: <span class="org-string">"Ω"</span>,
<span class="linenr"> 222: </span>  <span class=
"org-string">"olt;"</span>: <span class="org-string">"⧀"</span>,
<span class="linenr"> 223: </span>  <span class=
"org-string">"ord;"</span>: <span class="org-string">"⩝"</span>,
<span class="linenr"> 224: </span>  <span class=
"org-string">"ordf"</span>: <span class="org-string">"ª"</span>,
<span class="linenr"> 225: </span>  <span class=
"org-string">"ordm"</span>: <span class="org-string">"º"</span>,
<span class="linenr"> 226: </span>  <span class=
"org-string">"orv;"</span>: <span class="org-string">"⩛"</span>,
<span class="linenr"> 227: </span>  <span class=
"org-string">"Ouml"</span>: <span class="org-string">"Ö"</span>,
<span class="linenr"> 228: </span>  <span class=
"org-string">"ouml"</span>: <span class="org-string">"ö"</span>,
<span class="linenr"> 229: </span>  <span class=
"org-string">"par;"</span>: <span class="org-string">"∥"</span>,
<span class="linenr"> 230: </span>  <span class=
"org-string">"para"</span>: <span class="org-string">"¶"</span>,
<span class="linenr"> 231: </span>  <span class=
"org-string">"Pcy;"</span>: <span class="org-string">"П"</span>,
<span class="linenr"> 232: </span>  <span class=
"org-string">"pcy;"</span>: <span class="org-string">"п"</span>,
<span class="linenr"> 233: </span>  <span class=
"org-string">"Pfr;"</span>: <span class="org-string">"𝔓"</span>,
<span class="linenr"> 234: </span>  <span class=
"org-string">"pfr;"</span>: <span class="org-string">"𝔭"</span>,
<span class="linenr"> 235: </span>  <span class=
"org-string">"Phi;"</span>: <span class="org-string">"Φ"</span>,
<span class="linenr"> 236: </span>  <span class=
"org-string">"phi;"</span>: <span class="org-string">"φ"</span>,
<span class="linenr"> 237: </span>  <span class=
"org-string">"piv;"</span>: <span class="org-string">"ϖ"</span>,
<span class="linenr"> 238: </span>  <span class=
"org-string">"prE;"</span>: <span class="org-string">"⪳"</span>,
<span class="linenr"> 239: </span>  <span class=
"org-string">"pre;"</span>: <span class="org-string">"⪯"</span>,
<span class="linenr"> 240: </span>  <span class=
"org-string">"Psi;"</span>: <span class="org-string">"Ψ"</span>,
<span class="linenr"> 241: </span>  <span class=
"org-string">"psi;"</span>: <span class="org-string">"ψ"</span>,
<span class="linenr"> 242: </span>  <span class=
"org-string">"Qfr;"</span>: <span class="org-string">"𝔔"</span>,
<span class="linenr"> 243: </span>  <span class=
"org-string">"qfr;"</span>: <span class="org-string">"𝔮"</span>,
<span class="linenr"> 244: </span>  <span class=
"org-string">"QUOT"</span>: <span class="org-string">"\""</span>,
<span class="linenr"> 245: </span>  <span class=
"org-string">"quot"</span>: <span class="org-string">"\""</span>,
<span class="linenr"> 246: </span>  <span class=
"org-string">"Rcy;"</span>: <span class="org-string">"Р"</span>,
<span class="linenr"> 247: </span>  <span class=
"org-string">"rcy;"</span>: <span class="org-string">"р"</span>,
<span class="linenr"> 248: </span>  <span class=
"org-string">"REG;"</span>: <span class="org-string">"®"</span>,
<span class="linenr"> 249: </span>  <span class=
"org-string">"reg;"</span>: <span class="org-string">"®"</span>,
<span class="linenr"> 250: </span>  <span class=
"org-string">"Rfr;"</span>: <span class="org-string">"ℜ"</span>,
<span class="linenr"> 251: </span>  <span class=
"org-string">"rfr;"</span>: <span class="org-string">"𝔯"</span>,
<span class="linenr"> 252: </span>  <span class=
"org-string">"Rho;"</span>: <span class="org-string">"Ρ"</span>,
<span class="linenr"> 253: </span>  <span class=
"org-string">"rho;"</span>: <span class="org-string">"ρ"</span>,
<span class="linenr"> 254: </span>  <span class=
"org-string">"rlm;"</span>: <span class="org-string">"‏"</span>,
<span class="linenr"> 255: </span>  <span class=
"org-string">"Rsh;"</span>: <span class="org-string">"↱"</span>,
<span class="linenr"> 256: </span>  <span class=
"org-string">"rsh;"</span>: <span class="org-string">"↱"</span>,
<span class="linenr"> 257: </span>  <span class=
"org-string">"scE;"</span>: <span class="org-string">"⪴"</span>,
<span class="linenr"> 258: </span>  <span class=
"org-string">"sce;"</span>: <span class="org-string">"⪰"</span>,
<span class="linenr"> 259: </span>  <span class=
"org-string">"Scy;"</span>: <span class="org-string">"С"</span>,
<span class="linenr"> 260: </span>  <span class=
"org-string">"scy;"</span>: <span class="org-string">"с"</span>,
<span class="linenr"> 261: </span>  <span class=
"org-string">"sect"</span>: <span class="org-string">"§"</span>,
<span class="linenr"> 262: </span>  <span class=
"org-string">"Sfr;"</span>: <span class="org-string">"𝔖"</span>,
<span class="linenr"> 263: </span>  <span class=
"org-string">"sfr;"</span>: <span class="org-string">"𝔰"</span>,
<span class="linenr"> 264: </span>  <span class=
"org-string">"shy;"</span>: <span class="org-string">"­"</span>,
<span class="linenr"> 265: </span>  <span class=
"org-string">"sim;"</span>: <span class="org-string">"∼"</span>,
<span class="linenr"> 266: </span>  <span class=
"org-string">"smt;"</span>: <span class="org-string">"⪪"</span>,
<span class="linenr"> 267: </span>  <span class=
"org-string">"sol;"</span>: <span class="org-string">"/"</span>,
<span class="linenr"> 268: </span>  <span class=
"org-string">"squ;"</span>: <span class="org-string">"□"</span>,
<span class="linenr"> 269: </span>  <span class=
"org-string">"Sub;"</span>: <span class="org-string">"⋐"</span>,
<span class="linenr"> 270: </span>  <span class=
"org-string">"sub;"</span>: <span class="org-string">"⊂"</span>,
<span class="linenr"> 271: </span>  <span class=
"org-string">"Sum;"</span>: <span class="org-string">"∑"</span>,
<span class="linenr"> 272: </span>  <span class=
"org-string">"sum;"</span>: <span class="org-string">"∑"</span>,
<span class="linenr"> 273: </span>  <span class=
"org-string">"Sup;"</span>: <span class="org-string">"⋑"</span>,
<span class="linenr"> 274: </span>  <span class=
"org-string">"sup;"</span>: <span class="org-string">"⊃"</span>,
<span class="linenr"> 275: </span>  <span class=
"org-string">"sup1"</span>: <span class="org-string">"¹"</span>,
<span class="linenr"> 276: </span>  <span class=
"org-string">"sup2"</span>: <span class="org-string">"²"</span>,
<span class="linenr"> 277: </span>  <span class=
"org-string">"sup3"</span>: <span class="org-string">"³"</span>,
<span class="linenr"> 278: </span>  <span class=
"org-string">"Tab;"</span>: <span class="org-string">"\t"</span>,
<span class="linenr"> 279: </span>  <span class=
"org-string">"Tau;"</span>: <span class="org-string">"Τ"</span>,
<span class="linenr"> 280: </span>  <span class=
"org-string">"tau;"</span>: <span class="org-string">"τ"</span>,
<span class="linenr"> 281: </span>  <span class=
"org-string">"Tcy;"</span>: <span class="org-string">"Т"</span>,
<span class="linenr"> 282: </span>  <span class=
"org-string">"tcy;"</span>: <span class="org-string">"т"</span>,
<span class="linenr"> 283: </span>  <span class=
"org-string">"Tfr;"</span>: <span class="org-string">"𝔗"</span>,
<span class="linenr"> 284: </span>  <span class=
"org-string">"tfr;"</span>: <span class="org-string">"𝔱"</span>,
<span class="linenr"> 285: </span>  <span class=
"org-string">"top;"</span>: <span class="org-string">"⊤"</span>,
<span class="linenr"> 286: </span>  <span class=
"org-string">"Ucy;"</span>: <span class="org-string">"У"</span>,
<span class="linenr"> 287: </span>  <span class=
"org-string">"ucy;"</span>: <span class="org-string">"у"</span>,
<span class="linenr"> 288: </span>  <span class=
"org-string">"Ufr;"</span>: <span class="org-string">"𝔘"</span>,
<span class="linenr"> 289: </span>  <span class=
"org-string">"ufr;"</span>: <span class="org-string">"𝔲"</span>,
<span class="linenr"> 290: </span>  <span class=
"org-string">"uml;"</span>: <span class="org-string">"¨"</span>,
<span class="linenr"> 291: </span>  <span class=
"org-string">"Uuml"</span>: <span class="org-string">"Ü"</span>,
<span class="linenr"> 292: </span>  <span class=
"org-string">"uuml"</span>: <span class="org-string">"ü"</span>,
<span class="linenr"> 293: </span>  <span class=
"org-string">"Vcy;"</span>: <span class="org-string">"В"</span>,
<span class="linenr"> 294: </span>  <span class=
"org-string">"vcy;"</span>: <span class="org-string">"в"</span>,
<span class="linenr"> 295: </span>  <span class=
"org-string">"Vee;"</span>: <span class="org-string">"⋁"</span>,
<span class="linenr"> 296: </span>  <span class=
"org-string">"vee;"</span>: <span class="org-string">"∨"</span>,
<span class="linenr"> 297: </span>  <span class=
"org-string">"Vfr;"</span>: <span class="org-string">"𝔙"</span>,
<span class="linenr"> 298: </span>  <span class=
"org-string">"vfr;"</span>: <span class="org-string">"𝔳"</span>,
<span class="linenr"> 299: </span>  <span class=
"org-string">"Wfr;"</span>: <span class="org-string">"𝔚"</span>,
<span class="linenr"> 300: </span>  <span class=
"org-string">"wfr;"</span>: <span class="org-string">"𝔴"</span>,
<span class="linenr"> 301: </span>  <span class=
"org-string">"Xfr;"</span>: <span class="org-string">"𝔛"</span>,
<span class="linenr"> 302: </span>  <span class=
"org-string">"xfr;"</span>: <span class="org-string">"𝔵"</span>,
<span class="linenr"> 303: </span>  <span class=
"org-string">"Ycy;"</span>: <span class="org-string">"Ы"</span>,
<span class="linenr"> 304: </span>  <span class=
"org-string">"ycy;"</span>: <span class="org-string">"ы"</span>,
<span class="linenr"> 305: </span>  <span class=
"org-string">"yen;"</span>: <span class="org-string">"¥"</span>,
<span class="linenr"> 306: </span>  <span class=
"org-string">"Yfr;"</span>: <span class="org-string">"𝔜"</span>,
<span class="linenr"> 307: </span>  <span class=
"org-string">"yfr;"</span>: <span class="org-string">"𝔶"</span>,
<span class="linenr"> 308: </span>  <span class=
"org-string">"yuml"</span>: <span class="org-string">"ÿ"</span>,
<span class="linenr"> 309: </span>  <span class=
"org-string">"Zcy;"</span>: <span class="org-string">"З"</span>,
<span class="linenr"> 310: </span>  <span class=
"org-string">"zcy;"</span>: <span class="org-string">"з"</span>,
<span class="linenr"> 311: </span>  <span class=
"org-string">"Zfr;"</span>: <span class="org-string">"ℨ"</span>,
<span class="linenr"> 312: </span>  <span class=
"org-string">"zfr;"</span>: <span class="org-string">"𝔷"</span>,
<span class="linenr"> 313: </span>  <span class=
"org-string">"zwj;"</span>: <span class="org-string">"‍"</span>,
<span class="linenr"> 314: </span>  <span class=
"org-string">"Acirc"</span>: <span class="org-string">"Â"</span>,
<span class="linenr"> 315: </span>  <span class=
"org-string">"acirc"</span>: <span class="org-string">"â"</span>,
<span class="linenr"> 316: </span>  <span class=
"org-string">"acute"</span>: <span class="org-string">"´"</span>,
<span class="linenr"> 317: </span>  <span class=
"org-string">"AElig"</span>: <span class="org-string">"Æ"</span>,
<span class="linenr"> 318: </span>  <span class=
"org-string">"aelig"</span>: <span class="org-string">"æ"</span>,
<span class="linenr"> 319: </span>  <span class=
"org-string">"andd;"</span>: <span class="org-string">"⩜"</span>,
<span class="linenr"> 320: </span>  <span class=
"org-string">"andv;"</span>: <span class="org-string">"⩚"</span>,
<span class="linenr"> 321: </span>  <span class=
"org-string">"ange;"</span>: <span class="org-string">"⦤"</span>,
<span class="linenr"> 322: </span>  <span class=
"org-string">"Aopf;"</span>: <span class="org-string">"𝔸"</span>,
<span class="linenr"> 323: </span>  <span class=
"org-string">"aopf;"</span>: <span class="org-string">"𝕒"</span>,
<span class="linenr"> 324: </span>  <span class=
"org-string">"apid;"</span>: <span class="org-string">"≋"</span>,
<span class="linenr"> 325: </span>  <span class=
"org-string">"apos;"</span>: <span class="org-string">"'"</span>,
<span class="linenr"> 326: </span>  <span class=
"org-string">"Aring"</span>: <span class="org-string">"Å"</span>,
<span class="linenr"> 327: </span>  <span class=
"org-string">"aring"</span>: <span class="org-string">"å"</span>,
<span class="linenr"> 328: </span>  <span class=
"org-string">"Ascr;"</span>: <span class="org-string">"𝒜"</span>,
<span class="linenr"> 329: </span>  <span class=
"org-string">"ascr;"</span>: <span class="org-string">"𝒶"</span>,
<span class="linenr"> 330: </span>  <span class=
"org-string">"Auml;"</span>: <span class="org-string">"Ä"</span>,
<span class="linenr"> 331: </span>  <span class=
"org-string">"auml;"</span>: <span class="org-string">"ä"</span>,
<span class="linenr"> 332: </span>  <span class=
"org-string">"Barv;"</span>: <span class="org-string">"⫧"</span>,
<span class="linenr"> 333: </span>  <span class=
"org-string">"bbrk;"</span>: <span class="org-string">"⎵"</span>,
<span class="linenr"> 334: </span>  <span class=
"org-string">"Beta;"</span>: <span class="org-string">"Β"</span>,
<span class="linenr"> 335: </span>  <span class=
"org-string">"beta;"</span>: <span class="org-string">"β"</span>,
<span class="linenr"> 336: </span>  <span class=
"org-string">"beth;"</span>: <span class="org-string">"ℶ"</span>,
<span class="linenr"> 337: </span>  <span class=
"org-string">"bNot;"</span>: <span class="org-string">"⫭"</span>,
<span class="linenr"> 338: </span>  <span class=
"org-string">"bnot;"</span>: <span class="org-string">"⌐"</span>,
<span class="linenr"> 339: </span>  <span class=
"org-string">"Bopf;"</span>: <span class="org-string">"𝔹"</span>,
<span class="linenr"> 340: </span>  <span class=
"org-string">"bopf;"</span>: <span class="org-string">"𝕓"</span>,
<span class="linenr"> 341: </span>  <span class=
"org-string">"boxH;"</span>: <span class="org-string">"═"</span>,
<span class="linenr"> 342: </span>  <span class=
"org-string">"boxh;"</span>: <span class="org-string">"─"</span>,
<span class="linenr"> 343: </span>  <span class=
"org-string">"boxV;"</span>: <span class="org-string">"║"</span>,
<span class="linenr"> 344: </span>  <span class=
"org-string">"boxv;"</span>: <span class="org-string">"│"</span>,
<span class="linenr"> 345: </span>  <span class=
"org-string">"Bscr;"</span>: <span class="org-string">"ℬ"</span>,
<span class="linenr"> 346: </span>  <span class=
"org-string">"bscr;"</span>: <span class="org-string">"𝒷"</span>,
<span class="linenr"> 347: </span>  <span class=
"org-string">"bsim;"</span>: <span class="org-string">"∽"</span>,
<span class="linenr"> 348: </span>  <span class=
"org-string">"bsol;"</span>: <span class="org-string">"\\"</span>,
<span class="linenr"> 349: </span>  <span class=
"org-string">"bull;"</span>: <span class="org-string">"•"</span>,
<span class="linenr"> 350: </span>  <span class=
"org-string">"bump;"</span>: <span class="org-string">"≎"</span>,
<span class="linenr"> 351: </span>  <span class=
"org-string">"caps;"</span>: <span class="org-string">"∩︀"</span>,
<span class="linenr"> 352: </span>  <span class=
"org-string">"Cdot;"</span>: <span class="org-string">"Ċ"</span>,
<span class="linenr"> 353: </span>  <span class=
"org-string">"cdot;"</span>: <span class="org-string">"ċ"</span>,
<span class="linenr"> 354: </span>  <span class=
"org-string">"cedil"</span>: <span class="org-string">"¸"</span>,
<span class="linenr"> 355: </span>  <span class=
"org-string">"cent;"</span>: <span class="org-string">"¢"</span>,
<span class="linenr"> 356: </span>  <span class=
"org-string">"CHcy;"</span>: <span class="org-string">"Ч"</span>,
<span class="linenr"> 357: </span>  <span class=
"org-string">"chcy;"</span>: <span class="org-string">"ч"</span>,
<span class="linenr"> 358: </span>  <span class=
"org-string">"circ;"</span>: <span class="org-string">"ˆ"</span>,
<span class="linenr"> 359: </span>  <span class=
"org-string">"cirE;"</span>: <span class="org-string">"⧃"</span>,
<span class="linenr"> 360: </span>  <span class=
"org-string">"cire;"</span>: <span class="org-string">"≗"</span>,
<span class="linenr"> 361: </span>  <span class=
"org-string">"comp;"</span>: <span class="org-string">"∁"</span>,
<span class="linenr"> 362: </span>  <span class=
"org-string">"cong;"</span>: <span class="org-string">"≅"</span>,
<span class="linenr"> 363: </span>  <span class=
"org-string">"Copf;"</span>: <span class="org-string">"ℂ"</span>,
<span class="linenr"> 364: </span>  <span class=
"org-string">"copf;"</span>: <span class="org-string">"𝕔"</span>,
<span class="linenr"> 365: </span>  <span class=
"org-string">"COPY;"</span>: <span class="org-string">"©"</span>,
<span class="linenr"> 366: </span>  <span class=
"org-string">"copy;"</span>: <span class="org-string">"©"</span>,
<span class="linenr"> 367: </span>  <span class=
"org-string">"Cscr;"</span>: <span class="org-string">"𝒞"</span>,
<span class="linenr"> 368: </span>  <span class=
"org-string">"cscr;"</span>: <span class="org-string">"𝒸"</span>,
<span class="linenr"> 369: </span>  <span class=
"org-string">"csub;"</span>: <span class="org-string">"⫏"</span>,
<span class="linenr"> 370: </span>  <span class=
"org-string">"csup;"</span>: <span class="org-string">"⫐"</span>,
<span class="linenr"> 371: </span>  <span class=
"org-string">"cups;"</span>: <span class="org-string">"∪︀"</span>,
<span class="linenr"> 372: </span>  <span class=
"org-string">"Darr;"</span>: <span class="org-string">"↡"</span>,
<span class="linenr"> 373: </span>  <span class=
"org-string">"dArr;"</span>: <span class="org-string">"⇓"</span>,
<span class="linenr"> 374: </span>  <span class=
"org-string">"darr;"</span>: <span class="org-string">"↓"</span>,
<span class="linenr"> 375: </span>  <span class=
"org-string">"dash;"</span>: <span class="org-string">"‐"</span>,
<span class="linenr"> 376: </span>  <span class=
"org-string">"dHar;"</span>: <span class="org-string">"⥥"</span>,
<span class="linenr"> 377: </span>  <span class=
"org-string">"diam;"</span>: <span class="org-string">"⋄"</span>,
<span class="linenr"> 378: </span>  <span class=
"org-string">"DJcy;"</span>: <span class="org-string">"Ђ"</span>,
<span class="linenr"> 379: </span>  <span class=
"org-string">"djcy;"</span>: <span class="org-string">"ђ"</span>,
<span class="linenr"> 380: </span>  <span class=
"org-string">"Dopf;"</span>: <span class="org-string">"𝔻"</span>,
<span class="linenr"> 381: </span>  <span class=
"org-string">"dopf;"</span>: <span class="org-string">"𝕕"</span>,
<span class="linenr"> 382: </span>  <span class=
"org-string">"Dscr;"</span>: <span class="org-string">"𝒟"</span>,
<span class="linenr"> 383: </span>  <span class=
"org-string">"dscr;"</span>: <span class="org-string">"𝒹"</span>,
<span class="linenr"> 384: </span>  <span class=
"org-string">"DScy;"</span>: <span class="org-string">"Ѕ"</span>,
<span class="linenr"> 385: </span>  <span class=
"org-string">"dscy;"</span>: <span class="org-string">"ѕ"</span>,
<span class="linenr"> 386: </span>  <span class=
"org-string">"dsol;"</span>: <span class="org-string">"⧶"</span>,
<span class="linenr"> 387: </span>  <span class=
"org-string">"dtri;"</span>: <span class="org-string">"▿"</span>,
<span class="linenr"> 388: </span>  <span class=
"org-string">"DZcy;"</span>: <span class="org-string">"Џ"</span>,
<span class="linenr"> 389: </span>  <span class=
"org-string">"dzcy;"</span>: <span class="org-string">"џ"</span>,
<span class="linenr"> 390: </span>  <span class=
"org-string">"ecir;"</span>: <span class="org-string">"≖"</span>,
<span class="linenr"> 391: </span>  <span class=
"org-string">"Ecirc"</span>: <span class="org-string">"Ê"</span>,
<span class="linenr"> 392: </span>  <span class=
"org-string">"ecirc"</span>: <span class="org-string">"ê"</span>,
<span class="linenr"> 393: </span>  <span class=
"org-string">"Edot;"</span>: <span class="org-string">"Ė"</span>,
<span class="linenr"> 394: </span>  <span class=
"org-string">"eDot;"</span>: <span class="org-string">"≑"</span>,
<span class="linenr"> 395: </span>  <span class=
"org-string">"edot;"</span>: <span class="org-string">"ė"</span>,
<span class="linenr"> 396: </span>  <span class=
"org-string">"emsp;"</span>: <span class="org-string">" "</span>,
<span class="linenr"> 397: </span>  <span class=
"org-string">"ensp;"</span>: <span class="org-string">" "</span>,
<span class="linenr"> 398: </span>  <span class=
"org-string">"Eopf;"</span>: <span class="org-string">"𝔼"</span>,
<span class="linenr"> 399: </span>  <span class=
"org-string">"eopf;"</span>: <span class="org-string">"𝕖"</span>,
<span class="linenr"> 400: </span>  <span class=
"org-string">"epar;"</span>: <span class="org-string">"⋕"</span>,
<span class="linenr"> 401: </span>  <span class=
"org-string">"epsi;"</span>: <span class="org-string">"ε"</span>,
<span class="linenr"> 402: </span>  <span class=
"org-string">"Escr;"</span>: <span class="org-string">"ℰ"</span>,
<span class="linenr"> 403: </span>  <span class=
"org-string">"escr;"</span>: <span class="org-string">"ℯ"</span>,
<span class="linenr"> 404: </span>  <span class=
"org-string">"Esim;"</span>: <span class="org-string">"⩳"</span>,
<span class="linenr"> 405: </span>  <span class=
"org-string">"esim;"</span>: <span class="org-string">"≂"</span>,
<span class="linenr"> 406: </span>  <span class=
"org-string">"Euml;"</span>: <span class="org-string">"Ë"</span>,
<span class="linenr"> 407: </span>  <span class=
"org-string">"euml;"</span>: <span class="org-string">"ë"</span>,
<span class="linenr"> 408: </span>  <span class=
"org-string">"euro;"</span>: <span class="org-string">"€"</span>,
<span class="linenr"> 409: </span>  <span class=
"org-string">"excl;"</span>: <span class="org-string">"!"</span>,
<span class="linenr"> 410: </span>  <span class=
"org-string">"flat;"</span>: <span class="org-string">"♭"</span>,
<span class="linenr"> 411: </span>  <span class=
"org-string">"fnof;"</span>: <span class="org-string">"ƒ"</span>,
<span class="linenr"> 412: </span>  <span class=
"org-string">"Fopf;"</span>: <span class="org-string">"𝔽"</span>,
<span class="linenr"> 413: </span>  <span class=
"org-string">"fopf;"</span>: <span class="org-string">"𝕗"</span>,
<span class="linenr"> 414: </span>  <span class=
"org-string">"fork;"</span>: <span class="org-string">"⋔"</span>,
<span class="linenr"> 415: </span>  <span class=
"org-string">"Fscr;"</span>: <span class="org-string">"ℱ"</span>,
<span class="linenr"> 416: </span>  <span class=
"org-string">"fscr;"</span>: <span class="org-string">"𝒻"</span>,
<span class="linenr"> 417: </span>  <span class=
"org-string">"Gdot;"</span>: <span class="org-string">"Ġ"</span>,
<span class="linenr"> 418: </span>  <span class=
"org-string">"gdot;"</span>: <span class="org-string">"ġ"</span>,
<span class="linenr"> 419: </span>  <span class=
"org-string">"geqq;"</span>: <span class="org-string">"≧"</span>,
<span class="linenr"> 420: </span>  <span class=
"org-string">"gesl;"</span>: <span class="org-string">"⋛︀"</span>,
<span class="linenr"> 421: </span>  <span class=
"org-string">"GJcy;"</span>: <span class="org-string">"Ѓ"</span>,
<span class="linenr"> 422: </span>  <span class=
"org-string">"gjcy;"</span>: <span class="org-string">"ѓ"</span>,
<span class="linenr"> 423: </span>  <span class=
"org-string">"gnap;"</span>: <span class="org-string">"⪊"</span>,
<span class="linenr"> 424: </span>  <span class=
"org-string">"gneq;"</span>: <span class="org-string">"⪈"</span>,
<span class="linenr"> 425: </span>  <span class=
"org-string">"Gopf;"</span>: <span class="org-string">"𝔾"</span>,
<span class="linenr"> 426: </span>  <span class=
"org-string">"gopf;"</span>: <span class="org-string">"𝕘"</span>,
<span class="linenr"> 427: </span>  <span class=
"org-string">"Gscr;"</span>: <span class="org-string">"𝒢"</span>,
<span class="linenr"> 428: </span>  <span class=
"org-string">"gscr;"</span>: <span class="org-string">"ℊ"</span>,
<span class="linenr"> 429: </span>  <span class=
"org-string">"gsim;"</span>: <span class="org-string">"≳"</span>,
<span class="linenr"> 430: </span>  <span class=
"org-string">"gtcc;"</span>: <span class="org-string">"⪧"</span>,
<span class="linenr"> 431: </span>  <span class=
"org-string">"gvnE;"</span>: <span class="org-string">"≩︀"</span>,
<span class="linenr"> 432: </span>  <span class=
"org-string">"half;"</span>: <span class="org-string">"½"</span>,
<span class="linenr"> 433: </span>  <span class=
"org-string">"hArr;"</span>: <span class="org-string">"⇔"</span>,
<span class="linenr"> 434: </span>  <span class=
"org-string">"harr;"</span>: <span class="org-string">"↔"</span>,
<span class="linenr"> 435: </span>  <span class=
"org-string">"hbar;"</span>: <span class="org-string">"ℏ"</span>,
<span class="linenr"> 436: </span>  <span class=
"org-string">"Hopf;"</span>: <span class="org-string">"ℍ"</span>,
<span class="linenr"> 437: </span>  <span class=
"org-string">"hopf;"</span>: <span class="org-string">"𝕙"</span>,
<span class="linenr"> 438: </span>  <span class=
"org-string">"Hscr;"</span>: <span class="org-string">"ℋ"</span>,
<span class="linenr"> 439: </span>  <span class=
"org-string">"hscr;"</span>: <span class="org-string">"𝒽"</span>,
<span class="linenr"> 440: </span>  <span class=
"org-string">"Icirc"</span>: <span class="org-string">"Î"</span>,
<span class="linenr"> 441: </span>  <span class=
"org-string">"icirc"</span>: <span class="org-string">"î"</span>,
<span class="linenr"> 442: </span>  <span class=
"org-string">"Idot;"</span>: <span class="org-string">"İ"</span>,
<span class="linenr"> 443: </span>  <span class=
"org-string">"IEcy;"</span>: <span class="org-string">"Е"</span>,
<span class="linenr"> 444: </span>  <span class=
"org-string">"iecy;"</span>: <span class="org-string">"е"</span>,
<span class="linenr"> 445: </span>  <span class=
"org-string">"iexcl"</span>: <span class="org-string">"¡"</span>,
<span class="linenr"> 446: </span>  <span class=
"org-string">"imof;"</span>: <span class="org-string">"⊷"</span>,
<span class="linenr"> 447: </span>  <span class=
"org-string">"IOcy;"</span>: <span class="org-string">"Ё"</span>,
<span class="linenr"> 448: </span>  <span class=
"org-string">"iocy;"</span>: <span class="org-string">"ё"</span>,
<span class="linenr"> 449: </span>  <span class=
"org-string">"Iopf;"</span>: <span class="org-string">"𝕀"</span>,
<span class="linenr"> 450: </span>  <span class=
"org-string">"iopf;"</span>: <span class="org-string">"𝕚"</span>,
<span class="linenr"> 451: </span>  <span class=
"org-string">"Iota;"</span>: <span class="org-string">"Ι"</span>,
<span class="linenr"> 452: </span>  <span class=
"org-string">"iota;"</span>: <span class="org-string">"ι"</span>,
<span class="linenr"> 453: </span>  <span class=
"org-string">"Iscr;"</span>: <span class="org-string">"ℐ"</span>,
<span class="linenr"> 454: </span>  <span class=
"org-string">"iscr;"</span>: <span class="org-string">"𝒾"</span>,
<span class="linenr"> 455: </span>  <span class=
"org-string">"isin;"</span>: <span class="org-string">"∈"</span>,
<span class="linenr"> 456: </span>  <span class=
"org-string">"Iuml;"</span>: <span class="org-string">"Ï"</span>,
<span class="linenr"> 457: </span>  <span class=
"org-string">"iuml;"</span>: <span class="org-string">"ï"</span>,
<span class="linenr"> 458: </span>  <span class=
"org-string">"Jopf;"</span>: <span class="org-string">"𝕁"</span>,
<span class="linenr"> 459: </span>  <span class=
"org-string">"jopf;"</span>: <span class="org-string">"𝕛"</span>,
<span class="linenr"> 460: </span>  <span class=
"org-string">"Jscr;"</span>: <span class="org-string">"𝒥"</span>,
<span class="linenr"> 461: </span>  <span class=
"org-string">"jscr;"</span>: <span class="org-string">"𝒿"</span>,
<span class="linenr"> 462: </span>  <span class=
"org-string">"KHcy;"</span>: <span class="org-string">"Х"</span>,
<span class="linenr"> 463: </span>  <span class=
"org-string">"khcy;"</span>: <span class="org-string">"х"</span>,
<span class="linenr"> 464: </span>  <span class=
"org-string">"KJcy;"</span>: <span class="org-string">"Ќ"</span>,
<span class="linenr"> 465: </span>  <span class=
"org-string">"kjcy;"</span>: <span class="org-string">"ќ"</span>,
<span class="linenr"> 466: </span>  <span class=
"org-string">"Kopf;"</span>: <span class="org-string">"𝕂"</span>,
<span class="linenr"> 467: </span>  <span class=
"org-string">"kopf;"</span>: <span class="org-string">"𝕜"</span>,
<span class="linenr"> 468: </span>  <span class=
"org-string">"Kscr;"</span>: <span class="org-string">"𝒦"</span>,
<span class="linenr"> 469: </span>  <span class=
"org-string">"kscr;"</span>: <span class="org-string">"𝓀"</span>,
<span class="linenr"> 470: </span>  <span class=
"org-string">"Lang;"</span>: <span class="org-string">"⟪"</span>,
<span class="linenr"> 471: </span>  <span class=
"org-string">"lang;"</span>: <span class="org-string">"⟨"</span>,
<span class="linenr"> 472: </span>  <span class=
"org-string">"laquo"</span>: <span class="org-string">"«"</span>,
<span class="linenr"> 473: </span>  <span class=
"org-string">"Larr;"</span>: <span class="org-string">"↞"</span>,
<span class="linenr"> 474: </span>  <span class=
"org-string">"lArr;"</span>: <span class="org-string">"⇐"</span>,
<span class="linenr"> 475: </span>  <span class=
"org-string">"larr;"</span>: <span class="org-string">"←"</span>,
<span class="linenr"> 476: </span>  <span class=
"org-string">"late;"</span>: <span class="org-string">"⪭"</span>,
<span class="linenr"> 477: </span>  <span class=
"org-string">"lcub;"</span>: <span class="org-string">"{"</span>,
<span class="linenr"> 478: </span>  <span class=
"org-string">"ldca;"</span>: <span class="org-string">"⤶"</span>,
<span class="linenr"> 479: </span>  <span class=
"org-string">"ldsh;"</span>: <span class="org-string">"↲"</span>,
<span class="linenr"> 480: </span>  <span class=
"org-string">"leqq;"</span>: <span class="org-string">"≦"</span>,
<span class="linenr"> 481: </span>  <span class=
"org-string">"lesg;"</span>: <span class="org-string">"⋚︀"</span>,
<span class="linenr"> 482: </span>  <span class=
"org-string">"lHar;"</span>: <span class="org-string">"⥢"</span>,
<span class="linenr"> 483: </span>  <span class=
"org-string">"LJcy;"</span>: <span class="org-string">"Љ"</span>,
<span class="linenr"> 484: </span>  <span class=
"org-string">"ljcy;"</span>: <span class="org-string">"љ"</span>,
<span class="linenr"> 485: </span>  <span class=
"org-string">"lnap;"</span>: <span class="org-string">"⪉"</span>,
<span class="linenr"> 486: </span>  <span class=
"org-string">"lneq;"</span>: <span class="org-string">"⪇"</span>,
<span class="linenr"> 487: </span>  <span class=
"org-string">"Lopf;"</span>: <span class="org-string">"𝕃"</span>,
<span class="linenr"> 488: </span>  <span class=
"org-string">"lopf;"</span>: <span class="org-string">"𝕝"</span>,
<span class="linenr"> 489: </span>  <span class=
"org-string">"lozf;"</span>: <span class="org-string">"⧫"</span>,
<span class="linenr"> 490: </span>  <span class=
"org-string">"lpar;"</span>: <span class="org-string">"("</span>,
<span class="linenr"> 491: </span>  <span class=
"org-string">"Lscr;"</span>: <span class="org-string">"ℒ"</span>,
<span class="linenr"> 492: </span>  <span class=
"org-string">"lscr;"</span>: <span class="org-string">"𝓁"</span>,
<span class="linenr"> 493: </span>  <span class=
"org-string">"lsim;"</span>: <span class="org-string">"≲"</span>,
<span class="linenr"> 494: </span>  <span class=
"org-string">"lsqb;"</span>: <span class="org-string">"["</span>,
<span class="linenr"> 495: </span>  <span class=
"org-string">"ltcc;"</span>: <span class="org-string">"⪦"</span>,
<span class="linenr"> 496: </span>  <span class=
"org-string">"ltri;"</span>: <span class="org-string">"◃"</span>,
<span class="linenr"> 497: </span>  <span class=
"org-string">"lvnE;"</span>: <span class="org-string">"≨︀"</span>,
<span class="linenr"> 498: </span>  <span class=
"org-string">"macr;"</span>: <span class="org-string">"¯"</span>,
<span class="linenr"> 499: </span>  <span class=
"org-string">"male;"</span>: <span class="org-string">"♂"</span>,
<span class="linenr"> 500: </span>  <span class=
"org-string">"malt;"</span>: <span class="org-string">"✠"</span>,
<span class="linenr"> 501: </span>  <span class=
"org-string">"micro"</span>: <span class="org-string">"µ"</span>,
<span class="linenr"> 502: </span>  <span class=
"org-string">"mlcp;"</span>: <span class="org-string">"⫛"</span>,
<span class="linenr"> 503: </span>  <span class=
"org-string">"mldr;"</span>: <span class="org-string">"…"</span>,
<span class="linenr"> 504: </span>  <span class=
"org-string">"Mopf;"</span>: <span class="org-string">"𝕄"</span>,
<span class="linenr"> 505: </span>  <span class=
"org-string">"mopf;"</span>: <span class="org-string">"𝕞"</span>,
<span class="linenr"> 506: </span>  <span class=
"org-string">"Mscr;"</span>: <span class="org-string">"ℳ"</span>,
<span class="linenr"> 507: </span>  <span class=
"org-string">"mscr;"</span>: <span class="org-string">"𝓂"</span>,
<span class="linenr"> 508: </span>  <span class=
"org-string">"nang;"</span>: <span class="org-string">"∠⃒"</span>,
<span class="linenr"> 509: </span>  <span class=
"org-string">"napE;"</span>: <span class="org-string">"⩰̸"</span>,
<span class="linenr"> 510: </span>  <span class=
"org-string">"nbsp;"</span>: <span class="org-string">" "</span>,
<span class="linenr"> 511: </span>  <span class=
"org-string">"ncap;"</span>: <span class="org-string">"⩃"</span>,
<span class="linenr"> 512: </span>  <span class=
"org-string">"ncup;"</span>: <span class="org-string">"⩂"</span>,
<span class="linenr"> 513: </span>  <span class=
"org-string">"ngeq;"</span>: <span class="org-string">"≱"</span>,
<span class="linenr"> 514: </span>  <span class=
"org-string">"nges;"</span>: <span class="org-string">"⩾̸"</span>,
<span class="linenr"> 515: </span>  <span class=
"org-string">"ngtr;"</span>: <span class="org-string">"≯"</span>,
<span class="linenr"> 516: </span>  <span class=
"org-string">"nGtv;"</span>: <span class="org-string">"≫̸"</span>,
<span class="linenr"> 517: </span>  <span class=
"org-string">"nisd;"</span>: <span class="org-string">"⋺"</span>,
<span class="linenr"> 518: </span>  <span class=
"org-string">"NJcy;"</span>: <span class="org-string">"Њ"</span>,
<span class="linenr"> 519: </span>  <span class=
"org-string">"njcy;"</span>: <span class="org-string">"њ"</span>,
<span class="linenr"> 520: </span>  <span class=
"org-string">"nldr;"</span>: <span class="org-string">"‥"</span>,
<span class="linenr"> 521: </span>  <span class=
"org-string">"nleq;"</span>: <span class="org-string">"≰"</span>,
<span class="linenr"> 522: </span>  <span class=
"org-string">"nles;"</span>: <span class="org-string">"⩽̸"</span>,
<span class="linenr"> 523: </span>  <span class=
"org-string">"nLtv;"</span>: <span class="org-string">"≪̸"</span>,
<span class="linenr"> 524: </span>  <span class=
"org-string">"nmid;"</span>: <span class="org-string">"∤"</span>,
<span class="linenr"> 525: </span>  <span class=
"org-string">"Nopf;"</span>: <span class="org-string">"ℕ"</span>,
<span class="linenr"> 526: </span>  <span class=
"org-string">"nopf;"</span>: <span class="org-string">"𝕟"</span>,
<span class="linenr"> 527: </span>  <span class=
"org-string">"npar;"</span>: <span class="org-string">"∦"</span>,
<span class="linenr"> 528: </span>  <span class=
"org-string">"npre;"</span>: <span class="org-string">"⪯̸"</span>,
<span class="linenr"> 529: </span>  <span class=
"org-string">"nsce;"</span>: <span class="org-string">"⪰̸"</span>,
<span class="linenr"> 530: </span>  <span class=
"org-string">"Nscr;"</span>: <span class="org-string">"𝒩"</span>,
<span class="linenr"> 531: </span>  <span class=
"org-string">"nscr;"</span>: <span class="org-string">"𝓃"</span>,
<span class="linenr"> 532: </span>  <span class=
"org-string">"nsim;"</span>: <span class="org-string">"≁"</span>,
<span class="linenr"> 533: </span>  <span class=
"org-string">"nsub;"</span>: <span class="org-string">"⊄"</span>,
<span class="linenr"> 534: </span>  <span class=
"org-string">"nsup;"</span>: <span class="org-string">"⊅"</span>,
<span class="linenr"> 535: </span>  <span class=
"org-string">"ntgl;"</span>: <span class="org-string">"≹"</span>,
<span class="linenr"> 536: </span>  <span class=
"org-string">"ntlg;"</span>: <span class="org-string">"≸"</span>,
<span class="linenr"> 537: </span>  <span class=
"org-string">"nvap;"</span>: <span class="org-string">"≍⃒"</span>,
<span class="linenr"> 538: </span>  <span class=
"org-string">"nvge;"</span>: <span class="org-string">"≥⃒"</span>,
<span class="linenr"> 539: </span>  <span class=
"org-string">"nvgt;"</span>: <span class=
"org-string">"&gt;⃒"</span>,
<span class="linenr"> 540: </span>  <span class=
"org-string">"nvle;"</span>: <span class="org-string">"≤⃒"</span>,
<span class="linenr"> 541: </span>  <span class=
"org-string">"nvlt;"</span>: <span class=
"org-string">"&lt;⃒"</span>,
<span class="linenr"> 542: </span>  <span class=
"org-string">"oast;"</span>: <span class="org-string">"⊛"</span>,
<span class="linenr"> 543: </span>  <span class=
"org-string">"ocir;"</span>: <span class="org-string">"⊚"</span>,
<span class="linenr"> 544: </span>  <span class=
"org-string">"Ocirc"</span>: <span class="org-string">"Ô"</span>,
<span class="linenr"> 545: </span>  <span class=
"org-string">"ocirc"</span>: <span class="org-string">"ô"</span>,
<span class="linenr"> 546: </span>  <span class=
"org-string">"odiv;"</span>: <span class="org-string">"⨸"</span>,
<span class="linenr"> 547: </span>  <span class=
"org-string">"odot;"</span>: <span class="org-string">"⊙"</span>,
<span class="linenr"> 548: </span>  <span class=
"org-string">"ogon;"</span>: <span class="org-string">"˛"</span>,
<span class="linenr"> 549: </span>  <span class=
"org-string">"oint;"</span>: <span class="org-string">"∮"</span>,
<span class="linenr"> 550: </span>  <span class=
"org-string">"omid;"</span>: <span class="org-string">"⦶"</span>,
<span class="linenr"> 551: </span>  <span class=
"org-string">"Oopf;"</span>: <span class="org-string">"𝕆"</span>,
<span class="linenr"> 552: </span>  <span class=
"org-string">"oopf;"</span>: <span class="org-string">"𝕠"</span>,
<span class="linenr"> 553: </span>  <span class=
"org-string">"opar;"</span>: <span class="org-string">"⦷"</span>,
<span class="linenr"> 554: </span>  <span class=
"org-string">"ordf;"</span>: <span class="org-string">"ª"</span>,
<span class="linenr"> 555: </span>  <span class=
"org-string">"ordm;"</span>: <span class="org-string">"º"</span>,
<span class="linenr"> 556: </span>  <span class=
"org-string">"oror;"</span>: <span class="org-string">"⩖"</span>,
<span class="linenr"> 557: </span>  <span class=
"org-string">"Oscr;"</span>: <span class="org-string">"𝒪"</span>,
<span class="linenr"> 558: </span>  <span class=
"org-string">"oscr;"</span>: <span class="org-string">"ℴ"</span>,
<span class="linenr"> 559: </span>  <span class=
"org-string">"osol;"</span>: <span class="org-string">"⊘"</span>,
<span class="linenr"> 560: </span>  <span class=
"org-string">"Ouml;"</span>: <span class="org-string">"Ö"</span>,
<span class="linenr"> 561: </span>  <span class=
"org-string">"ouml;"</span>: <span class="org-string">"ö"</span>,
<span class="linenr"> 562: </span>  <span class=
"org-string">"para;"</span>: <span class="org-string">"¶"</span>,
<span class="linenr"> 563: </span>  <span class=
"org-string">"part;"</span>: <span class="org-string">"∂"</span>,
<span class="linenr"> 564: </span>  <span class=
"org-string">"perp;"</span>: <span class="org-string">"⊥"</span>,
<span class="linenr"> 565: </span>  <span class=
"org-string">"phiv;"</span>: <span class="org-string">"ϕ"</span>,
<span class="linenr"> 566: </span>  <span class=
"org-string">"plus;"</span>: <span class="org-string">"+"</span>,
<span class="linenr"> 567: </span>  <span class=
"org-string">"Popf;"</span>: <span class="org-string">"ℙ"</span>,
<span class="linenr"> 568: </span>  <span class=
"org-string">"popf;"</span>: <span class="org-string">"𝕡"</span>,
<span class="linenr"> 569: </span>  <span class=
"org-string">"pound"</span>: <span class="org-string">"£"</span>,
<span class="linenr"> 570: </span>  <span class=
"org-string">"prap;"</span>: <span class="org-string">"⪷"</span>,
<span class="linenr"> 571: </span>  <span class=
"org-string">"prec;"</span>: <span class="org-string">"≺"</span>,
<span class="linenr"> 572: </span>  <span class=
"org-string">"prnE;"</span>: <span class="org-string">"⪵"</span>,
<span class="linenr"> 573: </span>  <span class=
"org-string">"prod;"</span>: <span class="org-string">"∏"</span>,
<span class="linenr"> 574: </span>  <span class=
"org-string">"prop;"</span>: <span class="org-string">"∝"</span>,
<span class="linenr"> 575: </span>  <span class=
"org-string">"Pscr;"</span>: <span class="org-string">"𝒫"</span>,
<span class="linenr"> 576: </span>  <span class=
"org-string">"pscr;"</span>: <span class="org-string">"𝓅"</span>,
<span class="linenr"> 577: </span>  <span class=
"org-string">"qint;"</span>: <span class="org-string">"⨌"</span>,
<span class="linenr"> 578: </span>  <span class=
"org-string">"Qopf;"</span>: <span class="org-string">"ℚ"</span>,
<span class="linenr"> 579: </span>  <span class=
"org-string">"qopf;"</span>: <span class="org-string">"𝕢"</span>,
<span class="linenr"> 580: </span>  <span class=
"org-string">"Qscr;"</span>: <span class="org-string">"𝒬"</span>,
<span class="linenr"> 581: </span>  <span class=
"org-string">"qscr;"</span>: <span class="org-string">"𝓆"</span>,
<span class="linenr"> 582: </span>  <span class=
"org-string">"QUOT;"</span>: <span class="org-string">"\""</span>,
<span class="linenr"> 583: </span>  <span class=
"org-string">"quot;"</span>: <span class="org-string">"\""</span>,
<span class="linenr"> 584: </span>  <span class=
"org-string">"race;"</span>: <span class="org-string">"∽̱"</span>,
<span class="linenr"> 585: </span>  <span class=
"org-string">"Rang;"</span>: <span class="org-string">"⟫"</span>,
<span class="linenr"> 586: </span>  <span class=
"org-string">"rang;"</span>: <span class="org-string">"⟩"</span>,
<span class="linenr"> 587: </span>  <span class=
"org-string">"raquo"</span>: <span class="org-string">"»"</span>,
<span class="linenr"> 588: </span>  <span class=
"org-string">"Rarr;"</span>: <span class="org-string">"↠"</span>,
<span class="linenr"> 589: </span>  <span class=
"org-string">"rArr;"</span>: <span class="org-string">"⇒"</span>,
<span class="linenr"> 590: </span>  <span class=
"org-string">"rarr;"</span>: <span class="org-string">"→"</span>,
<span class="linenr"> 591: </span>  <span class=
"org-string">"rcub;"</span>: <span class="org-string">"}"</span>,
<span class="linenr"> 592: </span>  <span class=
"org-string">"rdca;"</span>: <span class="org-string">"⤷"</span>,
<span class="linenr"> 593: </span>  <span class=
"org-string">"rdsh;"</span>: <span class="org-string">"↳"</span>,
<span class="linenr"> 594: </span>  <span class=
"org-string">"real;"</span>: <span class="org-string">"ℜ"</span>,
<span class="linenr"> 595: </span>  <span class=
"org-string">"rect;"</span>: <span class="org-string">"▭"</span>,
<span class="linenr"> 596: </span>  <span class=
"org-string">"rHar;"</span>: <span class="org-string">"⥤"</span>,
<span class="linenr"> 597: </span>  <span class=
"org-string">"rhov;"</span>: <span class="org-string">"ϱ"</span>,
<span class="linenr"> 598: </span>  <span class=
"org-string">"ring;"</span>: <span class="org-string">"˚"</span>,
<span class="linenr"> 599: </span>  <span class=
"org-string">"Ropf;"</span>: <span class="org-string">"ℝ"</span>,
<span class="linenr"> 600: </span>  <span class=
"org-string">"ropf;"</span>: <span class="org-string">"𝕣"</span>,
<span class="linenr"> 601: </span>  <span class=
"org-string">"rpar;"</span>: <span class="org-string">")"</span>,
<span class="linenr"> 602: </span>  <span class=
"org-string">"Rscr;"</span>: <span class="org-string">"ℛ"</span>,
<span class="linenr"> 603: </span>  <span class=
"org-string">"rscr;"</span>: <span class="org-string">"𝓇"</span>,
<span class="linenr"> 604: </span>  <span class=
"org-string">"rsqb;"</span>: <span class="org-string">"]"</span>,
<span class="linenr"> 605: </span>  <span class=
"org-string">"rtri;"</span>: <span class="org-string">"▹"</span>,
<span class="linenr"> 606: </span>  <span class=
"org-string">"scap;"</span>: <span class="org-string">"⪸"</span>,
<span class="linenr"> 607: </span>  <span class=
"org-string">"scnE;"</span>: <span class="org-string">"⪶"</span>,
<span class="linenr"> 608: </span>  <span class=
"org-string">"sdot;"</span>: <span class="org-string">"⋅"</span>,
<span class="linenr"> 609: </span>  <span class=
"org-string">"sect;"</span>: <span class="org-string">"§"</span>,
<span class="linenr"> 610: </span>  <span class=
"org-string">"semi;"</span>: <span class="org-string">";"</span>,
<span class="linenr"> 611: </span>  <span class=
"org-string">"sext;"</span>: <span class="org-string">"✶"</span>,
<span class="linenr"> 612: </span>  <span class=
"org-string">"SHcy;"</span>: <span class="org-string">"Ш"</span>,
<span class="linenr"> 613: </span>  <span class=
"org-string">"shcy;"</span>: <span class="org-string">"ш"</span>,
<span class="linenr"> 614: </span>  <span class=
"org-string">"sime;"</span>: <span class="org-string">"≃"</span>,
<span class="linenr"> 615: </span>  <span class=
"org-string">"simg;"</span>: <span class="org-string">"⪞"</span>,
<span class="linenr"> 616: </span>  <span class=
"org-string">"siml;"</span>: <span class="org-string">"⪝"</span>,
<span class="linenr"> 617: </span>  <span class=
"org-string">"smid;"</span>: <span class="org-string">"∣"</span>,
<span class="linenr"> 618: </span>  <span class=
"org-string">"smte;"</span>: <span class="org-string">"⪬"</span>,
<span class="linenr"> 619: </span>  <span class=
"org-string">"solb;"</span>: <span class="org-string">"⧄"</span>,
<span class="linenr"> 620: </span>  <span class=
"org-string">"Sopf;"</span>: <span class="org-string">"𝕊"</span>,
<span class="linenr"> 621: </span>  <span class=
"org-string">"sopf;"</span>: <span class="org-string">"𝕤"</span>,
<span class="linenr"> 622: </span>  <span class=
"org-string">"spar;"</span>: <span class="org-string">"∥"</span>,
<span class="linenr"> 623: </span>  <span class=
"org-string">"Sqrt;"</span>: <span class="org-string">"√"</span>,
<span class="linenr"> 624: </span>  <span class=
"org-string">"squf;"</span>: <span class="org-string">"▪"</span>,
<span class="linenr"> 625: </span>  <span class=
"org-string">"Sscr;"</span>: <span class="org-string">"𝒮"</span>,
<span class="linenr"> 626: </span>  <span class=
"org-string">"sscr;"</span>: <span class="org-string">"𝓈"</span>,
<span class="linenr"> 627: </span>  <span class=
"org-string">"Star;"</span>: <span class="org-string">"⋆"</span>,
<span class="linenr"> 628: </span>  <span class=
"org-string">"star;"</span>: <span class="org-string">"☆"</span>,
<span class="linenr"> 629: </span>  <span class=
"org-string">"subE;"</span>: <span class="org-string">"⫅"</span>,
<span class="linenr"> 630: </span>  <span class=
"org-string">"sube;"</span>: <span class="org-string">"⊆"</span>,
<span class="linenr"> 631: </span>  <span class=
"org-string">"succ;"</span>: <span class="org-string">"≻"</span>,
<span class="linenr"> 632: </span>  <span class=
"org-string">"sung;"</span>: <span class="org-string">"♪"</span>,
<span class="linenr"> 633: </span>  <span class=
"org-string">"sup1;"</span>: <span class="org-string">"¹"</span>,
<span class="linenr"> 634: </span>  <span class=
"org-string">"sup2;"</span>: <span class="org-string">"²"</span>,
<span class="linenr"> 635: </span>  <span class=
"org-string">"sup3;"</span>: <span class="org-string">"³"</span>,
<span class="linenr"> 636: </span>  <span class=
"org-string">"supE;"</span>: <span class="org-string">"⫆"</span>,
<span class="linenr"> 637: </span>  <span class=
"org-string">"supe;"</span>: <span class="org-string">"⊇"</span>,
<span class="linenr"> 638: </span>  <span class=
"org-string">"szlig"</span>: <span class="org-string">"ß"</span>,
<span class="linenr"> 639: </span>  <span class=
"org-string">"tbrk;"</span>: <span class="org-string">"⎴"</span>,
<span class="linenr"> 640: </span>  <span class=
"org-string">"tdot;"</span>: <span class="org-string">"⃛"</span>,
<span class="linenr"> 641: </span>  <span class=
"org-string">"THORN"</span>: <span class="org-string">"Þ"</span>,
<span class="linenr"> 642: </span>  <span class=
"org-string">"thorn"</span>: <span class="org-string">"þ"</span>,
<span class="linenr"> 643: </span>  <span class=
"org-string">"times"</span>: <span class="org-string">"×"</span>,
<span class="linenr"> 644: </span>  <span class=
"org-string">"tint;"</span>: <span class="org-string">"∭"</span>,
<span class="linenr"> 645: </span>  <span class=
"org-string">"toea;"</span>: <span class="org-string">"⤨"</span>,
<span class="linenr"> 646: </span>  <span class=
"org-string">"Topf;"</span>: <span class="org-string">"𝕋"</span>,
<span class="linenr"> 647: </span>  <span class=
"org-string">"topf;"</span>: <span class="org-string">"𝕥"</span>,
<span class="linenr"> 648: </span>  <span class=
"org-string">"tosa;"</span>: <span class="org-string">"⤩"</span>,
<span class="linenr"> 649: </span>  <span class=
"org-string">"trie;"</span>: <span class="org-string">"≜"</span>,
<span class="linenr"> 650: </span>  <span class=
"org-string">"Tscr;"</span>: <span class="org-string">"𝒯"</span>,
<span class="linenr"> 651: </span>  <span class=
"org-string">"tscr;"</span>: <span class="org-string">"𝓉"</span>,
<span class="linenr"> 652: </span>  <span class=
"org-string">"TScy;"</span>: <span class="org-string">"Ц"</span>,
<span class="linenr"> 653: </span>  <span class=
"org-string">"tscy;"</span>: <span class="org-string">"ц"</span>,
<span class="linenr"> 654: </span>  <span class=
"org-string">"Uarr;"</span>: <span class="org-string">"↟"</span>,
<span class="linenr"> 655: </span>  <span class=
"org-string">"uArr;"</span>: <span class="org-string">"⇑"</span>,
<span class="linenr"> 656: </span>  <span class=
"org-string">"uarr;"</span>: <span class="org-string">"↑"</span>,
<span class="linenr"> 657: </span>  <span class=
"org-string">"Ucirc"</span>: <span class="org-string">"Û"</span>,
<span class="linenr"> 658: </span>  <span class=
"org-string">"ucirc"</span>: <span class="org-string">"û"</span>,
<span class="linenr"> 659: </span>  <span class=
"org-string">"uHar;"</span>: <span class="org-string">"⥣"</span>,
<span class="linenr"> 660: </span>  <span class=
"org-string">"Uopf;"</span>: <span class="org-string">"𝕌"</span>,
<span class="linenr"> 661: </span>  <span class=
"org-string">"uopf;"</span>: <span class="org-string">"𝕦"</span>,
<span class="linenr"> 662: </span>  <span class=
"org-string">"Upsi;"</span>: <span class="org-string">"ϒ"</span>,
<span class="linenr"> 663: </span>  <span class=
"org-string">"upsi;"</span>: <span class="org-string">"υ"</span>,
<span class="linenr"> 664: </span>  <span class=
"org-string">"Uscr;"</span>: <span class="org-string">"𝒰"</span>,
<span class="linenr"> 665: </span>  <span class=
"org-string">"uscr;"</span>: <span class="org-string">"𝓊"</span>,
<span class="linenr"> 666: </span>  <span class=
"org-string">"utri;"</span>: <span class="org-string">"▵"</span>,
<span class="linenr"> 667: </span>  <span class=
"org-string">"Uuml;"</span>: <span class="org-string">"Ü"</span>,
<span class="linenr"> 668: </span>  <span class=
"org-string">"uuml;"</span>: <span class="org-string">"ü"</span>,
<span class="linenr"> 669: </span>  <span class=
"org-string">"vArr;"</span>: <span class="org-string">"⇕"</span>,
<span class="linenr"> 670: </span>  <span class=
"org-string">"varr;"</span>: <span class="org-string">"↕"</span>,
<span class="linenr"> 671: </span>  <span class=
"org-string">"Vbar;"</span>: <span class="org-string">"⫫"</span>,
<span class="linenr"> 672: </span>  <span class=
"org-string">"vBar;"</span>: <span class="org-string">"⫨"</span>,
<span class="linenr"> 673: </span>  <span class=
"org-string">"Vert;"</span>: <span class="org-string">"‖"</span>,
<span class="linenr"> 674: </span>  <span class=
"org-string">"vert;"</span>: <span class="org-string">"|"</span>,
<span class="linenr"> 675: </span>  <span class=
"org-string">"Vopf;"</span>: <span class="org-string">"𝕍"</span>,
<span class="linenr"> 676: </span>  <span class=
"org-string">"vopf;"</span>: <span class="org-string">"𝕧"</span>,
<span class="linenr"> 677: </span>  <span class=
"org-string">"Vscr;"</span>: <span class="org-string">"𝒱"</span>,
<span class="linenr"> 678: </span>  <span class=
"org-string">"vscr;"</span>: <span class="org-string">"𝓋"</span>,
<span class="linenr"> 679: </span>  <span class=
"org-string">"Wopf;"</span>: <span class="org-string">"𝕎"</span>,
<span class="linenr"> 680: </span>  <span class=
"org-string">"wopf;"</span>: <span class="org-string">"𝕨"</span>,
<span class="linenr"> 681: </span>  <span class=
"org-string">"Wscr;"</span>: <span class="org-string">"𝒲"</span>,
<span class="linenr"> 682: </span>  <span class=
"org-string">"wscr;"</span>: <span class="org-string">"𝓌"</span>,
<span class="linenr"> 683: </span>  <span class=
"org-string">"xcap;"</span>: <span class="org-string">"⋂"</span>,
<span class="linenr"> 684: </span>  <span class=
"org-string">"xcup;"</span>: <span class="org-string">"⋃"</span>,
<span class="linenr"> 685: </span>  <span class=
"org-string">"xmap;"</span>: <span class="org-string">"⟼"</span>,
<span class="linenr"> 686: </span>  <span class=
"org-string">"xnis;"</span>: <span class="org-string">"⋻"</span>,
<span class="linenr"> 687: </span>  <span class=
"org-string">"Xopf;"</span>: <span class="org-string">"𝕏"</span>,
<span class="linenr"> 688: </span>  <span class=
"org-string">"xopf;"</span>: <span class="org-string">"𝕩"</span>,
<span class="linenr"> 689: </span>  <span class=
"org-string">"Xscr;"</span>: <span class="org-string">"𝒳"</span>,
<span class="linenr"> 690: </span>  <span class=
"org-string">"xscr;"</span>: <span class="org-string">"𝓍"</span>,
<span class="linenr"> 691: </span>  <span class=
"org-string">"xvee;"</span>: <span class="org-string">"⋁"</span>,
<span class="linenr"> 692: </span>  <span class=
"org-string">"YAcy;"</span>: <span class="org-string">"Я"</span>,
<span class="linenr"> 693: </span>  <span class=
"org-string">"yacy;"</span>: <span class="org-string">"я"</span>,
<span class="linenr"> 694: </span>  <span class=
"org-string">"YIcy;"</span>: <span class="org-string">"Ї"</span>,
<span class="linenr"> 695: </span>  <span class=
"org-string">"yicy;"</span>: <span class="org-string">"ї"</span>,
<span class="linenr"> 696: </span>  <span class=
"org-string">"Yopf;"</span>: <span class="org-string">"𝕐"</span>,
<span class="linenr"> 697: </span>  <span class=
"org-string">"yopf;"</span>: <span class="org-string">"𝕪"</span>,
<span class="linenr"> 698: </span>  <span class=
"org-string">"Yscr;"</span>: <span class="org-string">"𝒴"</span>,
<span class="linenr"> 699: </span>  <span class=
"org-string">"yscr;"</span>: <span class="org-string">"𝓎"</span>,
<span class="linenr"> 700: </span>  <span class=
"org-string">"YUcy;"</span>: <span class="org-string">"Ю"</span>,
<span class="linenr"> 701: </span>  <span class=
"org-string">"yucy;"</span>: <span class="org-string">"ю"</span>,
<span class="linenr"> 702: </span>  <span class=
"org-string">"Yuml;"</span>: <span class="org-string">"Ÿ"</span>,
<span class="linenr"> 703: </span>  <span class=
"org-string">"yuml;"</span>: <span class="org-string">"ÿ"</span>,
<span class="linenr"> 704: </span>  <span class=
"org-string">"Zdot;"</span>: <span class="org-string">"Ż"</span>,
<span class="linenr"> 705: </span>  <span class=
"org-string">"zdot;"</span>: <span class="org-string">"ż"</span>,
<span class="linenr"> 706: </span>  <span class=
"org-string">"Zeta;"</span>: <span class="org-string">"Ζ"</span>,
<span class="linenr"> 707: </span>  <span class=
"org-string">"zeta;"</span>: <span class="org-string">"ζ"</span>,
<span class="linenr"> 708: </span>  <span class=
"org-string">"ZHcy;"</span>: <span class="org-string">"Ж"</span>,
<span class="linenr"> 709: </span>  <span class=
"org-string">"zhcy;"</span>: <span class="org-string">"ж"</span>,
<span class="linenr"> 710: </span>  <span class=
"org-string">"Zopf;"</span>: <span class="org-string">"ℤ"</span>,
<span class="linenr"> 711: </span>  <span class=
"org-string">"zopf;"</span>: <span class="org-string">"𝕫"</span>,
<span class="linenr"> 712: </span>  <span class=
"org-string">"Zscr;"</span>: <span class="org-string">"𝒵"</span>,
<span class="linenr"> 713: </span>  <span class=
"org-string">"zscr;"</span>: <span class="org-string">"𝓏"</span>,
<span class="linenr"> 714: </span>  <span class=
"org-string">"zwnj;"</span>: <span class="org-string">"‌"</span>,
<span class="linenr"> 715: </span>  <span class=
"org-string">"Aacute"</span>: <span class="org-string">"Á"</span>,
<span class="linenr"> 716: </span>  <span class=
"org-string">"aacute"</span>: <span class="org-string">"á"</span>,
<span class="linenr"> 717: </span>  <span class=
"org-string">"Acirc;"</span>: <span class="org-string">"Â"</span>,
<span class="linenr"> 718: </span>  <span class=
"org-string">"acirc;"</span>: <span class="org-string">"â"</span>,
<span class="linenr"> 719: </span>  <span class=
"org-string">"acute;"</span>: <span class="org-string">"´"</span>,
<span class="linenr"> 720: </span>  <span class=
"org-string">"AElig;"</span>: <span class="org-string">"Æ"</span>,
<span class="linenr"> 721: </span>  <span class=
"org-string">"aelig;"</span>: <span class="org-string">"æ"</span>,
<span class="linenr"> 722: </span>  <span class=
"org-string">"Agrave"</span>: <span class="org-string">"À"</span>,
<span class="linenr"> 723: </span>  <span class=
"org-string">"agrave"</span>: <span class="org-string">"à"</span>,
<span class="linenr"> 724: </span>  <span class=
"org-string">"aleph;"</span>: <span class="org-string">"ℵ"</span>,
<span class="linenr"> 725: </span>  <span class=
"org-string">"Alpha;"</span>: <span class="org-string">"Α"</span>,
<span class="linenr"> 726: </span>  <span class=
"org-string">"alpha;"</span>: <span class="org-string">"α"</span>,
<span class="linenr"> 727: </span>  <span class=
"org-string">"Amacr;"</span>: <span class="org-string">"Ā"</span>,
<span class="linenr"> 728: </span>  <span class=
"org-string">"amacr;"</span>: <span class="org-string">"ā"</span>,
<span class="linenr"> 729: </span>  <span class=
"org-string">"amalg;"</span>: <span class="org-string">"⨿"</span>,
<span class="linenr"> 730: </span>  <span class=
"org-string">"angle;"</span>: <span class="org-string">"∠"</span>,
<span class="linenr"> 731: </span>  <span class=
"org-string">"angrt;"</span>: <span class="org-string">"∟"</span>,
<span class="linenr"> 732: </span>  <span class=
"org-string">"angst;"</span>: <span class="org-string">"Å"</span>,
<span class="linenr"> 733: </span>  <span class=
"org-string">"Aogon;"</span>: <span class="org-string">"Ą"</span>,
<span class="linenr"> 734: </span>  <span class=
"org-string">"aogon;"</span>: <span class="org-string">"ą"</span>,
<span class="linenr"> 735: </span>  <span class=
"org-string">"Aring;"</span>: <span class="org-string">"Å"</span>,
<span class="linenr"> 736: </span>  <span class=
"org-string">"aring;"</span>: <span class="org-string">"å"</span>,
<span class="linenr"> 737: </span>  <span class=
"org-string">"asymp;"</span>: <span class="org-string">"≈"</span>,
<span class="linenr"> 738: </span>  <span class=
"org-string">"Atilde"</span>: <span class="org-string">"Ã"</span>,
<span class="linenr"> 739: </span>  <span class=
"org-string">"atilde"</span>: <span class="org-string">"ã"</span>,
<span class="linenr"> 740: </span>  <span class=
"org-string">"awint;"</span>: <span class="org-string">"⨑"</span>,
<span class="linenr"> 741: </span>  <span class=
"org-string">"bcong;"</span>: <span class="org-string">"≌"</span>,
<span class="linenr"> 742: </span>  <span class=
"org-string">"bdquo;"</span>: <span class="org-string">"„"</span>,
<span class="linenr"> 743: </span>  <span class=
"org-string">"bepsi;"</span>: <span class="org-string">"϶"</span>,
<span class="linenr"> 744: </span>  <span class=
"org-string">"blank;"</span>: <span class="org-string">"␣"</span>,
<span class="linenr"> 745: </span>  <span class=
"org-string">"blk12;"</span>: <span class="org-string">"▒"</span>,
<span class="linenr"> 746: </span>  <span class=
"org-string">"blk14;"</span>: <span class="org-string">"░"</span>,
<span class="linenr"> 747: </span>  <span class=
"org-string">"blk34;"</span>: <span class="org-string">"▓"</span>,
<span class="linenr"> 748: </span>  <span class=
"org-string">"block;"</span>: <span class="org-string">"█"</span>,
<span class="linenr"> 749: </span>  <span class=
"org-string">"boxDL;"</span>: <span class="org-string">"╗"</span>,
<span class="linenr"> 750: </span>  <span class=
"org-string">"boxDl;"</span>: <span class="org-string">"╖"</span>,
<span class="linenr"> 751: </span>  <span class=
"org-string">"boxdL;"</span>: <span class="org-string">"╕"</span>,
<span class="linenr"> 752: </span>  <span class=
"org-string">"boxdl;"</span>: <span class="org-string">"┐"</span>,
<span class="linenr"> 753: </span>  <span class=
"org-string">"boxDR;"</span>: <span class="org-string">"╔"</span>,
<span class="linenr"> 754: </span>  <span class=
"org-string">"boxDr;"</span>: <span class="org-string">"╓"</span>,
<span class="linenr"> 755: </span>  <span class=
"org-string">"boxdR;"</span>: <span class="org-string">"╒"</span>,
<span class="linenr"> 756: </span>  <span class=
"org-string">"boxdr;"</span>: <span class="org-string">"┌"</span>,
<span class="linenr"> 757: </span>  <span class=
"org-string">"boxHD;"</span>: <span class="org-string">"╦"</span>,
<span class="linenr"> 758: </span>  <span class=
"org-string">"boxHd;"</span>: <span class="org-string">"╤"</span>,
<span class="linenr"> 759: </span>  <span class=
"org-string">"boxhD;"</span>: <span class="org-string">"╥"</span>,
<span class="linenr"> 760: </span>  <span class=
"org-string">"boxhd;"</span>: <span class="org-string">"┬"</span>,
<span class="linenr"> 761: </span>  <span class=
"org-string">"boxHU;"</span>: <span class="org-string">"╩"</span>,
<span class="linenr"> 762: </span>  <span class=
"org-string">"boxHu;"</span>: <span class="org-string">"╧"</span>,
<span class="linenr"> 763: </span>  <span class=
"org-string">"boxhU;"</span>: <span class="org-string">"╨"</span>,
<span class="linenr"> 764: </span>  <span class=
"org-string">"boxhu;"</span>: <span class="org-string">"┴"</span>,
<span class="linenr"> 765: </span>  <span class=
"org-string">"boxUL;"</span>: <span class="org-string">"╝"</span>,
<span class="linenr"> 766: </span>  <span class=
"org-string">"boxUl;"</span>: <span class="org-string">"╜"</span>,
<span class="linenr"> 767: </span>  <span class=
"org-string">"boxuL;"</span>: <span class="org-string">"╛"</span>,
<span class="linenr"> 768: </span>  <span class=
"org-string">"boxul;"</span>: <span class="org-string">"┘"</span>,
<span class="linenr"> 769: </span>  <span class=
"org-string">"boxUR;"</span>: <span class="org-string">"╚"</span>,
<span class="linenr"> 770: </span>  <span class=
"org-string">"boxUr;"</span>: <span class="org-string">"╙"</span>,
<span class="linenr"> 771: </span>  <span class=
"org-string">"boxuR;"</span>: <span class="org-string">"╘"</span>,
<span class="linenr"> 772: </span>  <span class=
"org-string">"boxur;"</span>: <span class="org-string">"└"</span>,
<span class="linenr"> 773: </span>  <span class=
"org-string">"boxVH;"</span>: <span class="org-string">"╬"</span>,
<span class="linenr"> 774: </span>  <span class=
"org-string">"boxVh;"</span>: <span class="org-string">"╫"</span>,
<span class="linenr"> 775: </span>  <span class=
"org-string">"boxvH;"</span>: <span class="org-string">"╪"</span>,
<span class="linenr"> 776: </span>  <span class=
"org-string">"boxvh;"</span>: <span class="org-string">"┼"</span>,
<span class="linenr"> 777: </span>  <span class=
"org-string">"boxVL;"</span>: <span class="org-string">"╣"</span>,
<span class="linenr"> 778: </span>  <span class=
"org-string">"boxVl;"</span>: <span class="org-string">"╢"</span>,
<span class="linenr"> 779: </span>  <span class=
"org-string">"boxvL;"</span>: <span class="org-string">"╡"</span>,
<span class="linenr"> 780: </span>  <span class=
"org-string">"boxvl;"</span>: <span class="org-string">"┤"</span>,
<span class="linenr"> 781: </span>  <span class=
"org-string">"boxVR;"</span>: <span class="org-string">"╠"</span>,
<span class="linenr"> 782: </span>  <span class=
"org-string">"boxVr;"</span>: <span class="org-string">"╟"</span>,
<span class="linenr"> 783: </span>  <span class=
"org-string">"boxvR;"</span>: <span class="org-string">"╞"</span>,
<span class="linenr"> 784: </span>  <span class=
"org-string">"boxvr;"</span>: <span class="org-string">"├"</span>,
<span class="linenr"> 785: </span>  <span class=
"org-string">"Breve;"</span>: <span class="org-string">"˘"</span>,
<span class="linenr"> 786: </span>  <span class=
"org-string">"breve;"</span>: <span class="org-string">"˘"</span>,
<span class="linenr"> 787: </span>  <span class=
"org-string">"brvbar"</span>: <span class="org-string">"¦"</span>,
<span class="linenr"> 788: </span>  <span class=
"org-string">"bsemi;"</span>: <span class="org-string">"⁏"</span>,
<span class="linenr"> 789: </span>  <span class=
"org-string">"bsime;"</span>: <span class="org-string">"⋍"</span>,
<span class="linenr"> 790: </span>  <span class=
"org-string">"bsolb;"</span>: <span class="org-string">"⧅"</span>,
<span class="linenr"> 791: </span>  <span class=
"org-string">"bumpE;"</span>: <span class="org-string">"⪮"</span>,
<span class="linenr"> 792: </span>  <span class=
"org-string">"bumpe;"</span>: <span class="org-string">"≏"</span>,
<span class="linenr"> 793: </span>  <span class=
"org-string">"caret;"</span>: <span class="org-string">"⁁"</span>,
<span class="linenr"> 794: </span>  <span class=
"org-string">"caron;"</span>: <span class="org-string">"ˇ"</span>,
<span class="linenr"> 795: </span>  <span class=
"org-string">"ccaps;"</span>: <span class="org-string">"⩍"</span>,
<span class="linenr"> 796: </span>  <span class=
"org-string">"Ccedil"</span>: <span class="org-string">"Ç"</span>,
<span class="linenr"> 797: </span>  <span class=
"org-string">"ccedil"</span>: <span class="org-string">"ç"</span>,
<span class="linenr"> 798: </span>  <span class=
"org-string">"Ccirc;"</span>: <span class="org-string">"Ĉ"</span>,
<span class="linenr"> 799: </span>  <span class=
"org-string">"ccirc;"</span>: <span class="org-string">"ĉ"</span>,
<span class="linenr"> 800: </span>  <span class=
"org-string">"ccups;"</span>: <span class="org-string">"⩌"</span>,
<span class="linenr"> 801: </span>  <span class=
"org-string">"cedil;"</span>: <span class="org-string">"¸"</span>,
<span class="linenr"> 802: </span>  <span class=
"org-string">"check;"</span>: <span class="org-string">"✓"</span>,
<span class="linenr"> 803: </span>  <span class=
"org-string">"clubs;"</span>: <span class="org-string">"♣"</span>,
<span class="linenr"> 804: </span>  <span class=
"org-string">"Colon;"</span>: <span class="org-string">"∷"</span>,
<span class="linenr"> 805: </span>  <span class=
"org-string">"colon;"</span>: <span class="org-string">":"</span>,
<span class="linenr"> 806: </span>  <span class=
"org-string">"comma;"</span>: <span class="org-string">","</span>,
<span class="linenr"> 807: </span>  <span class=
"org-string">"crarr;"</span>: <span class="org-string">"↵"</span>,
<span class="linenr"> 808: </span>  <span class=
"org-string">"Cross;"</span>: <span class="org-string">"⨯"</span>,
<span class="linenr"> 809: </span>  <span class=
"org-string">"cross;"</span>: <span class="org-string">"✗"</span>,
<span class="linenr"> 810: </span>  <span class=
"org-string">"csube;"</span>: <span class="org-string">"⫑"</span>,
<span class="linenr"> 811: </span>  <span class=
"org-string">"csupe;"</span>: <span class="org-string">"⫒"</span>,
<span class="linenr"> 812: </span>  <span class=
"org-string">"ctdot;"</span>: <span class="org-string">"⋯"</span>,
<span class="linenr"> 813: </span>  <span class=
"org-string">"cuepr;"</span>: <span class="org-string">"⋞"</span>,
<span class="linenr"> 814: </span>  <span class=
"org-string">"cuesc;"</span>: <span class="org-string">"⋟"</span>,
<span class="linenr"> 815: </span>  <span class=
"org-string">"cupor;"</span>: <span class="org-string">"⩅"</span>,
<span class="linenr"> 816: </span>  <span class=
"org-string">"curren"</span>: <span class="org-string">"¤"</span>,
<span class="linenr"> 817: </span>  <span class=
"org-string">"cuvee;"</span>: <span class="org-string">"⋎"</span>,
<span class="linenr"> 818: </span>  <span class=
"org-string">"cuwed;"</span>: <span class="org-string">"⋏"</span>,
<span class="linenr"> 819: </span>  <span class=
"org-string">"cwint;"</span>: <span class="org-string">"∱"</span>,
<span class="linenr"> 820: </span>  <span class=
"org-string">"Dashv;"</span>: <span class="org-string">"⫤"</span>,
<span class="linenr"> 821: </span>  <span class=
"org-string">"dashv;"</span>: <span class="org-string">"⊣"</span>,
<span class="linenr"> 822: </span>  <span class=
"org-string">"dblac;"</span>: <span class="org-string">"˝"</span>,
<span class="linenr"> 823: </span>  <span class=
"org-string">"ddarr;"</span>: <span class="org-string">"⇊"</span>,
<span class="linenr"> 824: </span>  <span class=
"org-string">"Delta;"</span>: <span class="org-string">"Δ"</span>,
<span class="linenr"> 825: </span>  <span class=
"org-string">"delta;"</span>: <span class="org-string">"δ"</span>,
<span class="linenr"> 826: </span>  <span class=
"org-string">"dharl;"</span>: <span class="org-string">"⇃"</span>,
<span class="linenr"> 827: </span>  <span class=
"org-string">"dharr;"</span>: <span class="org-string">"⇂"</span>,
<span class="linenr"> 828: </span>  <span class=
"org-string">"diams;"</span>: <span class="org-string">"♦"</span>,
<span class="linenr"> 829: </span>  <span class=
"org-string">"disin;"</span>: <span class="org-string">"⋲"</span>,
<span class="linenr"> 830: </span>  <span class=
"org-string">"divide"</span>: <span class="org-string">"÷"</span>,
<span class="linenr"> 831: </span>  <span class=
"org-string">"doteq;"</span>: <span class="org-string">"≐"</span>,
<span class="linenr"> 832: </span>  <span class=
"org-string">"dtdot;"</span>: <span class="org-string">"⋱"</span>,
<span class="linenr"> 833: </span>  <span class=
"org-string">"dtrif;"</span>: <span class="org-string">"▾"</span>,
<span class="linenr"> 834: </span>  <span class=
"org-string">"duarr;"</span>: <span class="org-string">"⇵"</span>,
<span class="linenr"> 835: </span>  <span class=
"org-string">"duhar;"</span>: <span class="org-string">"⥯"</span>,
<span class="linenr"> 836: </span>  <span class=
"org-string">"Eacute"</span>: <span class="org-string">"É"</span>,
<span class="linenr"> 837: </span>  <span class=
"org-string">"eacute"</span>: <span class="org-string">"é"</span>,
<span class="linenr"> 838: </span>  <span class=
"org-string">"Ecirc;"</span>: <span class="org-string">"Ê"</span>,
<span class="linenr"> 839: </span>  <span class=
"org-string">"ecirc;"</span>: <span class="org-string">"ê"</span>,
<span class="linenr"> 840: </span>  <span class=
"org-string">"eDDot;"</span>: <span class="org-string">"⩷"</span>,
<span class="linenr"> 841: </span>  <span class=
"org-string">"efDot;"</span>: <span class="org-string">"≒"</span>,
<span class="linenr"> 842: </span>  <span class=
"org-string">"Egrave"</span>: <span class="org-string">"È"</span>,
<span class="linenr"> 843: </span>  <span class=
"org-string">"egrave"</span>: <span class="org-string">"è"</span>,
<span class="linenr"> 844: </span>  <span class=
"org-string">"Emacr;"</span>: <span class="org-string">"Ē"</span>,
<span class="linenr"> 845: </span>  <span class=
"org-string">"emacr;"</span>: <span class="org-string">"ē"</span>,
<span class="linenr"> 846: </span>  <span class=
"org-string">"empty;"</span>: <span class="org-string">"∅"</span>,
<span class="linenr"> 847: </span>  <span class=
"org-string">"Eogon;"</span>: <span class="org-string">"Ę"</span>,
<span class="linenr"> 848: </span>  <span class=
"org-string">"eogon;"</span>: <span class="org-string">"ę"</span>,
<span class="linenr"> 849: </span>  <span class=
"org-string">"eplus;"</span>: <span class="org-string">"⩱"</span>,
<span class="linenr"> 850: </span>  <span class=
"org-string">"epsiv;"</span>: <span class="org-string">"ϵ"</span>,
<span class="linenr"> 851: </span>  <span class=
"org-string">"eqsim;"</span>: <span class="org-string">"≂"</span>,
<span class="linenr"> 852: </span>  <span class=
"org-string">"Equal;"</span>: <span class="org-string">"⩵"</span>,
<span class="linenr"> 853: </span>  <span class=
"org-string">"equiv;"</span>: <span class="org-string">"≡"</span>,
<span class="linenr"> 854: </span>  <span class=
"org-string">"erarr;"</span>: <span class="org-string">"⥱"</span>,
<span class="linenr"> 855: </span>  <span class=
"org-string">"erDot;"</span>: <span class="org-string">"≓"</span>,
<span class="linenr"> 856: </span>  <span class=
"org-string">"esdot;"</span>: <span class="org-string">"≐"</span>,
<span class="linenr"> 857: </span>  <span class=
"org-string">"exist;"</span>: <span class="org-string">"∃"</span>,
<span class="linenr"> 858: </span>  <span class=
"org-string">"fflig;"</span>: <span class="org-string">"ﬀ"</span>,
<span class="linenr"> 859: </span>  <span class=
"org-string">"filig;"</span>: <span class="org-string">"ﬁ"</span>,
<span class="linenr"> 860: </span>  <span class=
"org-string">"fjlig;"</span>: <span class="org-string">"fj"</span>,
<span class="linenr"> 861: </span>  <span class=
"org-string">"fllig;"</span>: <span class="org-string">"ﬂ"</span>,
<span class="linenr"> 862: </span>  <span class=
"org-string">"fltns;"</span>: <span class="org-string">"▱"</span>,
<span class="linenr"> 863: </span>  <span class=
"org-string">"forkv;"</span>: <span class="org-string">"⫙"</span>,
<span class="linenr"> 864: </span>  <span class=
"org-string">"frac12"</span>: <span class="org-string">"½"</span>,
<span class="linenr"> 865: </span>  <span class=
"org-string">"frac14"</span>: <span class="org-string">"¼"</span>,
<span class="linenr"> 866: </span>  <span class=
"org-string">"frac34"</span>: <span class="org-string">"¾"</span>,
<span class="linenr"> 867: </span>  <span class=
"org-string">"frasl;"</span>: <span class="org-string">"⁄"</span>,
<span class="linenr"> 868: </span>  <span class=
"org-string">"frown;"</span>: <span class="org-string">"⌢"</span>,
<span class="linenr"> 869: </span>  <span class=
"org-string">"Gamma;"</span>: <span class="org-string">"Γ"</span>,
<span class="linenr"> 870: </span>  <span class=
"org-string">"gamma;"</span>: <span class="org-string">"γ"</span>,
<span class="linenr"> 871: </span>  <span class=
"org-string">"Gcirc;"</span>: <span class="org-string">"Ĝ"</span>,
<span class="linenr"> 872: </span>  <span class=
"org-string">"gcirc;"</span>: <span class="org-string">"ĝ"</span>,
<span class="linenr"> 873: </span>  <span class=
"org-string">"gescc;"</span>: <span class="org-string">"⪩"</span>,
<span class="linenr"> 874: </span>  <span class=
"org-string">"gimel;"</span>: <span class="org-string">"ℷ"</span>,
<span class="linenr"> 875: </span>  <span class=
"org-string">"gneqq;"</span>: <span class="org-string">"≩"</span>,
<span class="linenr"> 876: </span>  <span class=
"org-string">"gnsim;"</span>: <span class="org-string">"⋧"</span>,
<span class="linenr"> 877: </span>  <span class=
"org-string">"grave;"</span>: <span class="org-string">"`"</span>,
<span class="linenr"> 878: </span>  <span class=
"org-string">"gsime;"</span>: <span class="org-string">"⪎"</span>,
<span class="linenr"> 879: </span>  <span class=
"org-string">"gsiml;"</span>: <span class="org-string">"⪐"</span>,
<span class="linenr"> 880: </span>  <span class=
"org-string">"gtcir;"</span>: <span class="org-string">"⩺"</span>,
<span class="linenr"> 881: </span>  <span class=
"org-string">"gtdot;"</span>: <span class="org-string">"⋗"</span>,
<span class="linenr"> 882: </span>  <span class=
"org-string">"Hacek;"</span>: <span class="org-string">"ˇ"</span>,
<span class="linenr"> 883: </span>  <span class=
"org-string">"harrw;"</span>: <span class="org-string">"↭"</span>,
<span class="linenr"> 884: </span>  <span class=
"org-string">"Hcirc;"</span>: <span class="org-string">"Ĥ"</span>,
<span class="linenr"> 885: </span>  <span class=
"org-string">"hcirc;"</span>: <span class="org-string">"ĥ"</span>,
<span class="linenr"> 886: </span>  <span class=
"org-string">"hoarr;"</span>: <span class="org-string">"⇿"</span>,
<span class="linenr"> 887: </span>  <span class=
"org-string">"Iacute"</span>: <span class="org-string">"Í"</span>,
<span class="linenr"> 888: </span>  <span class=
"org-string">"iacute"</span>: <span class="org-string">"í"</span>,
<span class="linenr"> 889: </span>  <span class=
"org-string">"Icirc;"</span>: <span class="org-string">"Î"</span>,
<span class="linenr"> 890: </span>  <span class=
"org-string">"icirc;"</span>: <span class="org-string">"î"</span>,
<span class="linenr"> 891: </span>  <span class=
"org-string">"iexcl;"</span>: <span class="org-string">"¡"</span>,
<span class="linenr"> 892: </span>  <span class=
"org-string">"Igrave"</span>: <span class="org-string">"Ì"</span>,
<span class="linenr"> 893: </span>  <span class=
"org-string">"igrave"</span>: <span class="org-string">"ì"</span>,
<span class="linenr"> 894: </span>  <span class=
"org-string">"iiint;"</span>: <span class="org-string">"∭"</span>,
<span class="linenr"> 895: </span>  <span class=
"org-string">"iiota;"</span>: <span class="org-string">"℩"</span>,
<span class="linenr"> 896: </span>  <span class=
"org-string">"IJlig;"</span>: <span class="org-string">"Ĳ"</span>,
<span class="linenr"> 897: </span>  <span class=
"org-string">"ijlig;"</span>: <span class="org-string">"ĳ"</span>,
<span class="linenr"> 898: </span>  <span class=
"org-string">"Imacr;"</span>: <span class="org-string">"Ī"</span>,
<span class="linenr"> 899: </span>  <span class=
"org-string">"imacr;"</span>: <span class="org-string">"ī"</span>,
<span class="linenr"> 900: </span>  <span class=
"org-string">"image;"</span>: <span class="org-string">"ℑ"</span>,
<span class="linenr"> 901: </span>  <span class=
"org-string">"imath;"</span>: <span class="org-string">"ı"</span>,
<span class="linenr"> 902: </span>  <span class=
"org-string">"imped;"</span>: <span class="org-string">"Ƶ"</span>,
<span class="linenr"> 903: </span>  <span class=
"org-string">"infin;"</span>: <span class="org-string">"∞"</span>,
<span class="linenr"> 904: </span>  <span class=
"org-string">"Iogon;"</span>: <span class="org-string">"Į"</span>,
<span class="linenr"> 905: </span>  <span class=
"org-string">"iogon;"</span>: <span class="org-string">"į"</span>,
<span class="linenr"> 906: </span>  <span class=
"org-string">"iprod;"</span>: <span class="org-string">"⨼"</span>,
<span class="linenr"> 907: </span>  <span class=
"org-string">"iquest"</span>: <span class="org-string">"¿"</span>,
<span class="linenr"> 908: </span>  <span class=
"org-string">"isinE;"</span>: <span class="org-string">"⋹"</span>,
<span class="linenr"> 909: </span>  <span class=
"org-string">"isins;"</span>: <span class="org-string">"⋴"</span>,
<span class="linenr"> 910: </span>  <span class=
"org-string">"isinv;"</span>: <span class="org-string">"∈"</span>,
<span class="linenr"> 911: </span>  <span class=
"org-string">"Iukcy;"</span>: <span class="org-string">"І"</span>,
<span class="linenr"> 912: </span>  <span class=
"org-string">"iukcy;"</span>: <span class="org-string">"і"</span>,
<span class="linenr"> 913: </span>  <span class=
"org-string">"Jcirc;"</span>: <span class="org-string">"Ĵ"</span>,
<span class="linenr"> 914: </span>  <span class=
"org-string">"jcirc;"</span>: <span class="org-string">"ĵ"</span>,
<span class="linenr"> 915: </span>  <span class=
"org-string">"jmath;"</span>: <span class="org-string">"ȷ"</span>,
<span class="linenr"> 916: </span>  <span class=
"org-string">"Jukcy;"</span>: <span class="org-string">"Є"</span>,
<span class="linenr"> 917: </span>  <span class=
"org-string">"jukcy;"</span>: <span class="org-string">"є"</span>,
<span class="linenr"> 918: </span>  <span class=
"org-string">"Kappa;"</span>: <span class="org-string">"Κ"</span>,
<span class="linenr"> 919: </span>  <span class=
"org-string">"kappa;"</span>: <span class="org-string">"κ"</span>,
<span class="linenr"> 920: </span>  <span class=
"org-string">"lAarr;"</span>: <span class="org-string">"⇚"</span>,
<span class="linenr"> 921: </span>  <span class=
"org-string">"langd;"</span>: <span class="org-string">"⦑"</span>,
<span class="linenr"> 922: </span>  <span class=
"org-string">"laquo;"</span>: <span class="org-string">"«"</span>,
<span class="linenr"> 923: </span>  <span class=
"org-string">"larrb;"</span>: <span class="org-string">"⇤"</span>,
<span class="linenr"> 924: </span>  <span class=
"org-string">"lates;"</span>: <span class="org-string">"⪭︀"</span>,
<span class="linenr"> 925: </span>  <span class=
"org-string">"lBarr;"</span>: <span class="org-string">"⤎"</span>,
<span class="linenr"> 926: </span>  <span class=
"org-string">"lbarr;"</span>: <span class="org-string">"⤌"</span>,
<span class="linenr"> 927: </span>  <span class=
"org-string">"lbbrk;"</span>: <span class="org-string">"❲"</span>,
<span class="linenr"> 928: </span>  <span class=
"org-string">"lbrke;"</span>: <span class="org-string">"⦋"</span>,
<span class="linenr"> 929: </span>  <span class=
"org-string">"lceil;"</span>: <span class="org-string">"⌈"</span>,
<span class="linenr"> 930: </span>  <span class=
"org-string">"ldquo;"</span>: <span class="org-string">"“"</span>,
<span class="linenr"> 931: </span>  <span class=
"org-string">"lescc;"</span>: <span class="org-string">"⪨"</span>,
<span class="linenr"> 932: </span>  <span class=
"org-string">"lhard;"</span>: <span class="org-string">"↽"</span>,
<span class="linenr"> 933: </span>  <span class=
"org-string">"lharu;"</span>: <span class="org-string">"↼"</span>,
<span class="linenr"> 934: </span>  <span class=
"org-string">"lhblk;"</span>: <span class="org-string">"▄"</span>,
<span class="linenr"> 935: </span>  <span class=
"org-string">"llarr;"</span>: <span class="org-string">"⇇"</span>,
<span class="linenr"> 936: </span>  <span class=
"org-string">"lltri;"</span>: <span class="org-string">"◺"</span>,
<span class="linenr"> 937: </span>  <span class=
"org-string">"lneqq;"</span>: <span class="org-string">"≨"</span>,
<span class="linenr"> 938: </span>  <span class=
"org-string">"lnsim;"</span>: <span class="org-string">"⋦"</span>,
<span class="linenr"> 939: </span>  <span class=
"org-string">"loang;"</span>: <span class="org-string">"⟬"</span>,
<span class="linenr"> 940: </span>  <span class=
"org-string">"loarr;"</span>: <span class="org-string">"⇽"</span>,
<span class="linenr"> 941: </span>  <span class=
"org-string">"lobrk;"</span>: <span class="org-string">"⟦"</span>,
<span class="linenr"> 942: </span>  <span class=
"org-string">"lopar;"</span>: <span class="org-string">"⦅"</span>,
<span class="linenr"> 943: </span>  <span class=
"org-string">"lrarr;"</span>: <span class="org-string">"⇆"</span>,
<span class="linenr"> 944: </span>  <span class=
"org-string">"lrhar;"</span>: <span class="org-string">"⇋"</span>,
<span class="linenr"> 945: </span>  <span class=
"org-string">"lrtri;"</span>: <span class="org-string">"⊿"</span>,
<span class="linenr"> 946: </span>  <span class=
"org-string">"lsime;"</span>: <span class="org-string">"⪍"</span>,
<span class="linenr"> 947: </span>  <span class=
"org-string">"lsimg;"</span>: <span class="org-string">"⪏"</span>,
<span class="linenr"> 948: </span>  <span class=
"org-string">"lsquo;"</span>: <span class="org-string">"‘"</span>,
<span class="linenr"> 949: </span>  <span class=
"org-string">"ltcir;"</span>: <span class="org-string">"⩹"</span>,
<span class="linenr"> 950: </span>  <span class=
"org-string">"ltdot;"</span>: <span class="org-string">"⋖"</span>,
<span class="linenr"> 951: </span>  <span class=
"org-string">"ltrie;"</span>: <span class="org-string">"⊴"</span>,
<span class="linenr"> 952: </span>  <span class=
"org-string">"ltrif;"</span>: <span class="org-string">"◂"</span>,
<span class="linenr"> 953: </span>  <span class=
"org-string">"mdash;"</span>: <span class="org-string">"—"</span>,
<span class="linenr"> 954: </span>  <span class=
"org-string">"mDDot;"</span>: <span class="org-string">"∺"</span>,
<span class="linenr"> 955: </span>  <span class=
"org-string">"micro;"</span>: <span class="org-string">"µ"</span>,
<span class="linenr"> 956: </span>  <span class=
"org-string">"middot"</span>: <span class="org-string">"·"</span>,
<span class="linenr"> 957: </span>  <span class=
"org-string">"minus;"</span>: <span class="org-string">"−"</span>,
<span class="linenr"> 958: </span>  <span class=
"org-string">"mumap;"</span>: <span class="org-string">"⊸"</span>,
<span class="linenr"> 959: </span>  <span class=
"org-string">"nabla;"</span>: <span class="org-string">"∇"</span>,
<span class="linenr"> 960: </span>  <span class=
"org-string">"napid;"</span>: <span class="org-string">"≋̸"</span>,
<span class="linenr"> 961: </span>  <span class=
"org-string">"napos;"</span>: <span class="org-string">"ŉ"</span>,
<span class="linenr"> 962: </span>  <span class=
"org-string">"natur;"</span>: <span class="org-string">"♮"</span>,
<span class="linenr"> 963: </span>  <span class=
"org-string">"nbump;"</span>: <span class="org-string">"≎̸"</span>,
<span class="linenr"> 964: </span>  <span class=
"org-string">"ncong;"</span>: <span class="org-string">"≇"</span>,
<span class="linenr"> 965: </span>  <span class=
"org-string">"ndash;"</span>: <span class="org-string">"–"</span>,
<span class="linenr"> 966: </span>  <span class=
"org-string">"neArr;"</span>: <span class="org-string">"⇗"</span>,
<span class="linenr"> 967: </span>  <span class=
"org-string">"nearr;"</span>: <span class="org-string">"↗"</span>,
<span class="linenr"> 968: </span>  <span class=
"org-string">"nedot;"</span>: <span class="org-string">"≐̸"</span>,
<span class="linenr"> 969: </span>  <span class=
"org-string">"nesim;"</span>: <span class="org-string">"≂̸"</span>,
<span class="linenr"> 970: </span>  <span class=
"org-string">"ngeqq;"</span>: <span class="org-string">"≧̸"</span>,
<span class="linenr"> 971: </span>  <span class=
"org-string">"ngsim;"</span>: <span class="org-string">"≵"</span>,
<span class="linenr"> 972: </span>  <span class=
"org-string">"nhArr;"</span>: <span class="org-string">"⇎"</span>,
<span class="linenr"> 973: </span>  <span class=
"org-string">"nharr;"</span>: <span class="org-string">"↮"</span>,
<span class="linenr"> 974: </span>  <span class=
"org-string">"nhpar;"</span>: <span class="org-string">"⫲"</span>,
<span class="linenr"> 975: </span>  <span class=
"org-string">"nlArr;"</span>: <span class="org-string">"⇍"</span>,
<span class="linenr"> 976: </span>  <span class=
"org-string">"nlarr;"</span>: <span class="org-string">"↚"</span>,
<span class="linenr"> 977: </span>  <span class=
"org-string">"nleqq;"</span>: <span class="org-string">"≦̸"</span>,
<span class="linenr"> 978: </span>  <span class=
"org-string">"nless;"</span>: <span class="org-string">"≮"</span>,
<span class="linenr"> 979: </span>  <span class=
"org-string">"nlsim;"</span>: <span class="org-string">"≴"</span>,
<span class="linenr"> 980: </span>  <span class=
"org-string">"nltri;"</span>: <span class="org-string">"⋪"</span>,
<span class="linenr"> 981: </span>  <span class=
"org-string">"notin;"</span>: <span class="org-string">"∉"</span>,
<span class="linenr"> 982: </span>  <span class=
"org-string">"notni;"</span>: <span class="org-string">"∌"</span>,
<span class="linenr"> 983: </span>  <span class=
"org-string">"npart;"</span>: <span class="org-string">"∂̸"</span>,
<span class="linenr"> 984: </span>  <span class=
"org-string">"nprec;"</span>: <span class="org-string">"⊀"</span>,
<span class="linenr"> 985: </span>  <span class=
"org-string">"nrArr;"</span>: <span class="org-string">"⇏"</span>,
<span class="linenr"> 986: </span>  <span class=
"org-string">"nrarr;"</span>: <span class="org-string">"↛"</span>,
<span class="linenr"> 987: </span>  <span class=
"org-string">"nrtri;"</span>: <span class="org-string">"⋫"</span>,
<span class="linenr"> 988: </span>  <span class=
"org-string">"nsime;"</span>: <span class="org-string">"≄"</span>,
<span class="linenr"> 989: </span>  <span class=
"org-string">"nsmid;"</span>: <span class="org-string">"∤"</span>,
<span class="linenr"> 990: </span>  <span class=
"org-string">"nspar;"</span>: <span class="org-string">"∦"</span>,
<span class="linenr"> 991: </span>  <span class=
"org-string">"nsubE;"</span>: <span class="org-string">"⫅̸"</span>,
<span class="linenr"> 992: </span>  <span class=
"org-string">"nsube;"</span>: <span class="org-string">"⊈"</span>,
<span class="linenr"> 993: </span>  <span class=
"org-string">"nsucc;"</span>: <span class="org-string">"⊁"</span>,
<span class="linenr"> 994: </span>  <span class=
"org-string">"nsupE;"</span>: <span class="org-string">"⫆̸"</span>,
<span class="linenr"> 995: </span>  <span class=
"org-string">"nsupe;"</span>: <span class="org-string">"⊉"</span>,
<span class="linenr"> 996: </span>  <span class=
"org-string">"Ntilde"</span>: <span class="org-string">"Ñ"</span>,
<span class="linenr"> 997: </span>  <span class=
"org-string">"ntilde"</span>: <span class="org-string">"ñ"</span>,
<span class="linenr"> 998: </span>  <span class=
"org-string">"numsp;"</span>: <span class="org-string">" "</span>,
<span class="linenr"> 999: </span>  <span class=
"org-string">"nvsim;"</span>: <span class="org-string">"∼⃒"</span>,
<span class="linenr">1000: </span>  <span class=
"org-string">"nwArr;"</span>: <span class="org-string">"⇖"</span>,
<span class="linenr">1001: </span>  <span class=
"org-string">"nwarr;"</span>: <span class="org-string">"↖"</span>,
<span class="linenr">1002: </span>  <span class=
"org-string">"Oacute"</span>: <span class="org-string">"Ó"</span>,
<span class="linenr">1003: </span>  <span class=
"org-string">"oacute"</span>: <span class="org-string">"ó"</span>,
<span class="linenr">1004: </span>  <span class=
"org-string">"Ocirc;"</span>: <span class="org-string">"Ô"</span>,
<span class="linenr">1005: </span>  <span class=
"org-string">"ocirc;"</span>: <span class="org-string">"ô"</span>,
<span class="linenr">1006: </span>  <span class=
"org-string">"odash;"</span>: <span class="org-string">"⊝"</span>,
<span class="linenr">1007: </span>  <span class=
"org-string">"OElig;"</span>: <span class="org-string">"Œ"</span>,
<span class="linenr">1008: </span>  <span class=
"org-string">"oelig;"</span>: <span class="org-string">"œ"</span>,
<span class="linenr">1009: </span>  <span class=
"org-string">"ofcir;"</span>: <span class="org-string">"⦿"</span>,
<span class="linenr">1010: </span>  <span class=
"org-string">"Ograve"</span>: <span class="org-string">"Ò"</span>,
<span class="linenr">1011: </span>  <span class=
"org-string">"ograve"</span>: <span class="org-string">"ò"</span>,
<span class="linenr">1012: </span>  <span class=
"org-string">"ohbar;"</span>: <span class="org-string">"⦵"</span>,
<span class="linenr">1013: </span>  <span class=
"org-string">"olarr;"</span>: <span class="org-string">"↺"</span>,
<span class="linenr">1014: </span>  <span class=
"org-string">"olcir;"</span>: <span class="org-string">"⦾"</span>,
<span class="linenr">1015: </span>  <span class=
"org-string">"oline;"</span>: <span class="org-string">"‾"</span>,
<span class="linenr">1016: </span>  <span class=
"org-string">"Omacr;"</span>: <span class="org-string">"Ō"</span>,
<span class="linenr">1017: </span>  <span class=
"org-string">"omacr;"</span>: <span class="org-string">"ō"</span>,
<span class="linenr">1018: </span>  <span class=
"org-string">"Omega;"</span>: <span class="org-string">"Ω"</span>,
<span class="linenr">1019: </span>  <span class=
"org-string">"omega;"</span>: <span class="org-string">"ω"</span>,
<span class="linenr">1020: </span>  <span class=
"org-string">"operp;"</span>: <span class="org-string">"⦹"</span>,
<span class="linenr">1021: </span>  <span class=
"org-string">"oplus;"</span>: <span class="org-string">"⊕"</span>,
<span class="linenr">1022: </span>  <span class=
"org-string">"orarr;"</span>: <span class="org-string">"↻"</span>,
<span class="linenr">1023: </span>  <span class=
"org-string">"order;"</span>: <span class="org-string">"ℴ"</span>,
<span class="linenr">1024: </span>  <span class=
"org-string">"Oslash"</span>: <span class="org-string">"Ø"</span>,
<span class="linenr">1025: </span>  <span class=
"org-string">"oslash"</span>: <span class="org-string">"ø"</span>,
<span class="linenr">1026: </span>  <span class=
"org-string">"Otilde"</span>: <span class="org-string">"Õ"</span>,
<span class="linenr">1027: </span>  <span class=
"org-string">"otilde"</span>: <span class="org-string">"õ"</span>,
<span class="linenr">1028: </span>  <span class=
"org-string">"ovbar;"</span>: <span class="org-string">"⌽"</span>,
<span class="linenr">1029: </span>  <span class=
"org-string">"parsl;"</span>: <span class="org-string">"⫽"</span>,
<span class="linenr">1030: </span>  <span class=
"org-string">"phone;"</span>: <span class="org-string">"☎"</span>,
<span class="linenr">1031: </span>  <span class=
"org-string">"plusb;"</span>: <span class="org-string">"⊞"</span>,
<span class="linenr">1032: </span>  <span class=
"org-string">"pluse;"</span>: <span class="org-string">"⩲"</span>,
<span class="linenr">1033: </span>  <span class=
"org-string">"plusmn"</span>: <span class="org-string">"±"</span>,
<span class="linenr">1034: </span>  <span class=
"org-string">"pound;"</span>: <span class="org-string">"£"</span>,
<span class="linenr">1035: </span>  <span class=
"org-string">"prcue;"</span>: <span class="org-string">"≼"</span>,
<span class="linenr">1036: </span>  <span class=
"org-string">"Prime;"</span>: <span class="org-string">"″"</span>,
<span class="linenr">1037: </span>  <span class=
"org-string">"prime;"</span>: <span class="org-string">"′"</span>,
<span class="linenr">1038: </span>  <span class=
"org-string">"prnap;"</span>: <span class="org-string">"⪹"</span>,
<span class="linenr">1039: </span>  <span class=
"org-string">"prsim;"</span>: <span class="org-string">"≾"</span>,
<span class="linenr">1040: </span>  <span class=
"org-string">"quest;"</span>: <span class="org-string">"?"</span>,
<span class="linenr">1041: </span>  <span class=
"org-string">"rAarr;"</span>: <span class="org-string">"⇛"</span>,
<span class="linenr">1042: </span>  <span class=
"org-string">"radic;"</span>: <span class="org-string">"√"</span>,
<span class="linenr">1043: </span>  <span class=
"org-string">"rangd;"</span>: <span class="org-string">"⦒"</span>,
<span class="linenr">1044: </span>  <span class=
"org-string">"range;"</span>: <span class="org-string">"⦥"</span>,
<span class="linenr">1045: </span>  <span class=
"org-string">"raquo;"</span>: <span class="org-string">"»"</span>,
<span class="linenr">1046: </span>  <span class=
"org-string">"rarrb;"</span>: <span class="org-string">"⇥"</span>,
<span class="linenr">1047: </span>  <span class=
"org-string">"rarrc;"</span>: <span class="org-string">"⤳"</span>,
<span class="linenr">1048: </span>  <span class=
"org-string">"rarrw;"</span>: <span class="org-string">"↝"</span>,
<span class="linenr">1049: </span>  <span class=
"org-string">"ratio;"</span>: <span class="org-string">"∶"</span>,
<span class="linenr">1050: </span>  <span class=
"org-string">"RBarr;"</span>: <span class="org-string">"⤐"</span>,
<span class="linenr">1051: </span>  <span class=
"org-string">"rBarr;"</span>: <span class="org-string">"⤏"</span>,
<span class="linenr">1052: </span>  <span class=
"org-string">"rbarr;"</span>: <span class="org-string">"⤍"</span>,
<span class="linenr">1053: </span>  <span class=
"org-string">"rbbrk;"</span>: <span class="org-string">"❳"</span>,
<span class="linenr">1054: </span>  <span class=
"org-string">"rbrke;"</span>: <span class="org-string">"⦌"</span>,
<span class="linenr">1055: </span>  <span class=
"org-string">"rceil;"</span>: <span class="org-string">"⌉"</span>,
<span class="linenr">1056: </span>  <span class=
"org-string">"rdquo;"</span>: <span class="org-string">"”"</span>,
<span class="linenr">1057: </span>  <span class=
"org-string">"reals;"</span>: <span class="org-string">"ℝ"</span>,
<span class="linenr">1058: </span>  <span class=
"org-string">"rhard;"</span>: <span class="org-string">"⇁"</span>,
<span class="linenr">1059: </span>  <span class=
"org-string">"rharu;"</span>: <span class="org-string">"⇀"</span>,
<span class="linenr">1060: </span>  <span class=
"org-string">"rlarr;"</span>: <span class="org-string">"⇄"</span>,
<span class="linenr">1061: </span>  <span class=
"org-string">"rlhar;"</span>: <span class="org-string">"⇌"</span>,
<span class="linenr">1062: </span>  <span class=
"org-string">"rnmid;"</span>: <span class="org-string">"⫮"</span>,
<span class="linenr">1063: </span>  <span class=
"org-string">"roang;"</span>: <span class="org-string">"⟭"</span>,
<span class="linenr">1064: </span>  <span class=
"org-string">"roarr;"</span>: <span class="org-string">"⇾"</span>,
<span class="linenr">1065: </span>  <span class=
"org-string">"robrk;"</span>: <span class="org-string">"⟧"</span>,
<span class="linenr">1066: </span>  <span class=
"org-string">"ropar;"</span>: <span class="org-string">"⦆"</span>,
<span class="linenr">1067: </span>  <span class=
"org-string">"rrarr;"</span>: <span class="org-string">"⇉"</span>,
<span class="linenr">1068: </span>  <span class=
"org-string">"rsquo;"</span>: <span class="org-string">"’"</span>,
<span class="linenr">1069: </span>  <span class=
"org-string">"rtrie;"</span>: <span class="org-string">"⊵"</span>,
<span class="linenr">1070: </span>  <span class=
"org-string">"rtrif;"</span>: <span class="org-string">"▸"</span>,
<span class="linenr">1071: </span>  <span class=
"org-string">"sbquo;"</span>: <span class="org-string">"‚"</span>,
<span class="linenr">1072: </span>  <span class=
"org-string">"sccue;"</span>: <span class="org-string">"≽"</span>,
<span class="linenr">1073: </span>  <span class=
"org-string">"Scirc;"</span>: <span class="org-string">"Ŝ"</span>,
<span class="linenr">1074: </span>  <span class=
"org-string">"scirc;"</span>: <span class="org-string">"ŝ"</span>,
<span class="linenr">1075: </span>  <span class=
"org-string">"scnap;"</span>: <span class="org-string">"⪺"</span>,
<span class="linenr">1076: </span>  <span class=
"org-string">"scsim;"</span>: <span class="org-string">"≿"</span>,
<span class="linenr">1077: </span>  <span class=
"org-string">"sdotb;"</span>: <span class="org-string">"⊡"</span>,
<span class="linenr">1078: </span>  <span class=
"org-string">"sdote;"</span>: <span class="org-string">"⩦"</span>,
<span class="linenr">1079: </span>  <span class=
"org-string">"seArr;"</span>: <span class="org-string">"⇘"</span>,
<span class="linenr">1080: </span>  <span class=
"org-string">"searr;"</span>: <span class="org-string">"↘"</span>,
<span class="linenr">1081: </span>  <span class=
"org-string">"setmn;"</span>: <span class="org-string">"∖"</span>,
<span class="linenr">1082: </span>  <span class=
"org-string">"sharp;"</span>: <span class="org-string">"♯"</span>,
<span class="linenr">1083: </span>  <span class=
"org-string">"Sigma;"</span>: <span class="org-string">"Σ"</span>,
<span class="linenr">1084: </span>  <span class=
"org-string">"sigma;"</span>: <span class="org-string">"σ"</span>,
<span class="linenr">1085: </span>  <span class=
"org-string">"simeq;"</span>: <span class="org-string">"≃"</span>,
<span class="linenr">1086: </span>  <span class=
"org-string">"simgE;"</span>: <span class="org-string">"⪠"</span>,
<span class="linenr">1087: </span>  <span class=
"org-string">"simlE;"</span>: <span class="org-string">"⪟"</span>,
<span class="linenr">1088: </span>  <span class=
"org-string">"simne;"</span>: <span class="org-string">"≆"</span>,
<span class="linenr">1089: </span>  <span class=
"org-string">"slarr;"</span>: <span class="org-string">"←"</span>,
<span class="linenr">1090: </span>  <span class=
"org-string">"smile;"</span>: <span class="org-string">"⌣"</span>,
<span class="linenr">1091: </span>  <span class=
"org-string">"smtes;"</span>: <span class="org-string">"⪬︀"</span>,
<span class="linenr">1092: </span>  <span class=
"org-string">"sqcap;"</span>: <span class="org-string">"⊓"</span>,
<span class="linenr">1093: </span>  <span class=
"org-string">"sqcup;"</span>: <span class="org-string">"⊔"</span>,
<span class="linenr">1094: </span>  <span class=
"org-string">"sqsub;"</span>: <span class="org-string">"⊏"</span>,
<span class="linenr">1095: </span>  <span class=
"org-string">"sqsup;"</span>: <span class="org-string">"⊐"</span>,
<span class="linenr">1096: </span>  <span class=
"org-string">"srarr;"</span>: <span class="org-string">"→"</span>,
<span class="linenr">1097: </span>  <span class=
"org-string">"starf;"</span>: <span class="org-string">"★"</span>,
<span class="linenr">1098: </span>  <span class=
"org-string">"strns;"</span>: <span class="org-string">"¯"</span>,
<span class="linenr">1099: </span>  <span class=
"org-string">"subnE;"</span>: <span class="org-string">"⫋"</span>,
<span class="linenr">1100: </span>  <span class=
"org-string">"subne;"</span>: <span class="org-string">"⊊"</span>,
<span class="linenr">1101: </span>  <span class=
"org-string">"supnE;"</span>: <span class="org-string">"⫌"</span>,
<span class="linenr">1102: </span>  <span class=
"org-string">"supne;"</span>: <span class="org-string">"⊋"</span>,
<span class="linenr">1103: </span>  <span class=
"org-string">"swArr;"</span>: <span class="org-string">"⇙"</span>,
<span class="linenr">1104: </span>  <span class=
"org-string">"swarr;"</span>: <span class="org-string">"↙"</span>,
<span class="linenr">1105: </span>  <span class=
"org-string">"szlig;"</span>: <span class="org-string">"ß"</span>,
<span class="linenr">1106: </span>  <span class=
"org-string">"Theta;"</span>: <span class="org-string">"Θ"</span>,
<span class="linenr">1107: </span>  <span class=
"org-string">"theta;"</span>: <span class="org-string">"θ"</span>,
<span class="linenr">1108: </span>  <span class=
"org-string">"thkap;"</span>: <span class="org-string">"≈"</span>,
<span class="linenr">1109: </span>  <span class=
"org-string">"THORN;"</span>: <span class="org-string">"Þ"</span>,
<span class="linenr">1110: </span>  <span class=
"org-string">"thorn;"</span>: <span class="org-string">"þ"</span>,
<span class="linenr">1111: </span>  <span class=
"org-string">"Tilde;"</span>: <span class="org-string">"∼"</span>,
<span class="linenr">1112: </span>  <span class=
"org-string">"tilde;"</span>: <span class="org-string">"˜"</span>,
<span class="linenr">1113: </span>  <span class=
"org-string">"times;"</span>: <span class="org-string">"×"</span>,
<span class="linenr">1114: </span>  <span class=
"org-string">"TRADE;"</span>: <span class="org-string">"™"</span>,
<span class="linenr">1115: </span>  <span class=
"org-string">"trade;"</span>: <span class="org-string">"™"</span>,
<span class="linenr">1116: </span>  <span class=
"org-string">"trisb;"</span>: <span class="org-string">"⧍"</span>,
<span class="linenr">1117: </span>  <span class=
"org-string">"TSHcy;"</span>: <span class="org-string">"Ћ"</span>,
<span class="linenr">1118: </span>  <span class=
"org-string">"tshcy;"</span>: <span class="org-string">"ћ"</span>,
<span class="linenr">1119: </span>  <span class=
"org-string">"twixt;"</span>: <span class="org-string">"≬"</span>,
<span class="linenr">1120: </span>  <span class=
"org-string">"Uacute"</span>: <span class="org-string">"Ú"</span>,
<span class="linenr">1121: </span>  <span class=
"org-string">"uacute"</span>: <span class="org-string">"ú"</span>,
<span class="linenr">1122: </span>  <span class=
"org-string">"Ubrcy;"</span>: <span class="org-string">"Ў"</span>,
<span class="linenr">1123: </span>  <span class=
"org-string">"ubrcy;"</span>: <span class="org-string">"ў"</span>,
<span class="linenr">1124: </span>  <span class=
"org-string">"Ucirc;"</span>: <span class="org-string">"Û"</span>,
<span class="linenr">1125: </span>  <span class=
"org-string">"ucirc;"</span>: <span class="org-string">"û"</span>,
<span class="linenr">1126: </span>  <span class=
"org-string">"udarr;"</span>: <span class="org-string">"⇅"</span>,
<span class="linenr">1127: </span>  <span class=
"org-string">"udhar;"</span>: <span class="org-string">"⥮"</span>,
<span class="linenr">1128: </span>  <span class=
"org-string">"Ugrave"</span>: <span class="org-string">"Ù"</span>,
<span class="linenr">1129: </span>  <span class=
"org-string">"ugrave"</span>: <span class="org-string">"ù"</span>,
<span class="linenr">1130: </span>  <span class=
"org-string">"uharl;"</span>: <span class="org-string">"↿"</span>,
<span class="linenr">1131: </span>  <span class=
"org-string">"uharr;"</span>: <span class="org-string">"↾"</span>,
<span class="linenr">1132: </span>  <span class=
"org-string">"uhblk;"</span>: <span class="org-string">"▀"</span>,
<span class="linenr">1133: </span>  <span class=
"org-string">"ultri;"</span>: <span class="org-string">"◸"</span>,
<span class="linenr">1134: </span>  <span class=
"org-string">"Umacr;"</span>: <span class="org-string">"Ū"</span>,
<span class="linenr">1135: </span>  <span class=
"org-string">"umacr;"</span>: <span class="org-string">"ū"</span>,
<span class="linenr">1136: </span>  <span class=
"org-string">"Union;"</span>: <span class="org-string">"⋃"</span>,
<span class="linenr">1137: </span>  <span class=
"org-string">"Uogon;"</span>: <span class="org-string">"Ų"</span>,
<span class="linenr">1138: </span>  <span class=
"org-string">"uogon;"</span>: <span class="org-string">"ų"</span>,
<span class="linenr">1139: </span>  <span class=
"org-string">"uplus;"</span>: <span class="org-string">"⊎"</span>,
<span class="linenr">1140: </span>  <span class=
"org-string">"upsih;"</span>: <span class="org-string">"ϒ"</span>,
<span class="linenr">1141: </span>  <span class=
"org-string">"UpTee;"</span>: <span class="org-string">"⊥"</span>,
<span class="linenr">1142: </span>  <span class=
"org-string">"Uring;"</span>: <span class="org-string">"Ů"</span>,
<span class="linenr">1143: </span>  <span class=
"org-string">"uring;"</span>: <span class="org-string">"ů"</span>,
<span class="linenr">1144: </span>  <span class=
"org-string">"urtri;"</span>: <span class="org-string">"◹"</span>,
<span class="linenr">1145: </span>  <span class=
"org-string">"utdot;"</span>: <span class="org-string">"⋰"</span>,
<span class="linenr">1146: </span>  <span class=
"org-string">"utrif;"</span>: <span class="org-string">"▴"</span>,
<span class="linenr">1147: </span>  <span class=
"org-string">"uuarr;"</span>: <span class="org-string">"⇈"</span>,
<span class="linenr">1148: </span>  <span class=
"org-string">"varpi;"</span>: <span class="org-string">"ϖ"</span>,
<span class="linenr">1149: </span>  <span class=
"org-string">"vBarv;"</span>: <span class="org-string">"⫩"</span>,
<span class="linenr">1150: </span>  <span class=
"org-string">"VDash;"</span>: <span class="org-string">"⊫"</span>,
<span class="linenr">1151: </span>  <span class=
"org-string">"Vdash;"</span>: <span class="org-string">"⊩"</span>,
<span class="linenr">1152: </span>  <span class=
"org-string">"vDash;"</span>: <span class="org-string">"⊨"</span>,
<span class="linenr">1153: </span>  <span class=
"org-string">"vdash;"</span>: <span class="org-string">"⊢"</span>,
<span class="linenr">1154: </span>  <span class=
"org-string">"veeeq;"</span>: <span class="org-string">"≚"</span>,
<span class="linenr">1155: </span>  <span class=
"org-string">"vltri;"</span>: <span class="org-string">"⊲"</span>,
<span class="linenr">1156: </span>  <span class=
"org-string">"vnsub;"</span>: <span class="org-string">"⊂⃒"</span>,
<span class="linenr">1157: </span>  <span class=
"org-string">"vnsup;"</span>: <span class="org-string">"⊃⃒"</span>,
<span class="linenr">1158: </span>  <span class=
"org-string">"vprop;"</span>: <span class="org-string">"∝"</span>,
<span class="linenr">1159: </span>  <span class=
"org-string">"vrtri;"</span>: <span class="org-string">"⊳"</span>,
<span class="linenr">1160: </span>  <span class=
"org-string">"Wcirc;"</span>: <span class="org-string">"Ŵ"</span>,
<span class="linenr">1161: </span>  <span class=
"org-string">"wcirc;"</span>: <span class="org-string">"ŵ"</span>,
<span class="linenr">1162: </span>  <span class=
"org-string">"Wedge;"</span>: <span class="org-string">"⋀"</span>,
<span class="linenr">1163: </span>  <span class=
"org-string">"wedge;"</span>: <span class="org-string">"∧"</span>,
<span class="linenr">1164: </span>  <span class=
"org-string">"xcirc;"</span>: <span class="org-string">"◯"</span>,
<span class="linenr">1165: </span>  <span class=
"org-string">"xdtri;"</span>: <span class="org-string">"▽"</span>,
<span class="linenr">1166: </span>  <span class=
"org-string">"xhArr;"</span>: <span class="org-string">"⟺"</span>,
<span class="linenr">1167: </span>  <span class=
"org-string">"xharr;"</span>: <span class="org-string">"⟷"</span>,
<span class="linenr">1168: </span>  <span class=
"org-string">"xlArr;"</span>: <span class="org-string">"⟸"</span>,
<span class="linenr">1169: </span>  <span class=
"org-string">"xlarr;"</span>: <span class="org-string">"⟵"</span>,
<span class="linenr">1170: </span>  <span class=
"org-string">"xodot;"</span>: <span class="org-string">"⨀"</span>,
<span class="linenr">1171: </span>  <span class=
"org-string">"xrArr;"</span>: <span class="org-string">"⟹"</span>,
<span class="linenr">1172: </span>  <span class=
"org-string">"xrarr;"</span>: <span class="org-string">"⟶"</span>,
<span class="linenr">1173: </span>  <span class=
"org-string">"xutri;"</span>: <span class="org-string">"△"</span>,
<span class="linenr">1174: </span>  <span class=
"org-string">"Yacute"</span>: <span class="org-string">"Ý"</span>,
<span class="linenr">1175: </span>  <span class=
"org-string">"yacute"</span>: <span class="org-string">"ý"</span>,
<span class="linenr">1176: </span>  <span class=
"org-string">"Ycirc;"</span>: <span class="org-string">"Ŷ"</span>,
<span class="linenr">1177: </span>  <span class=
"org-string">"ycirc;"</span>: <span class="org-string">"ŷ"</span>,
<span class="linenr">1178: </span>  <span class=
"org-string">"Aacute;"</span>: <span class="org-string">"Á"</span>,
<span class="linenr">1179: </span>  <span class=
"org-string">"aacute;"</span>: <span class="org-string">"á"</span>,
<span class="linenr">1180: </span>  <span class=
"org-string">"Abreve;"</span>: <span class="org-string">"Ă"</span>,
<span class="linenr">1181: </span>  <span class=
"org-string">"abreve;"</span>: <span class="org-string">"ă"</span>,
<span class="linenr">1182: </span>  <span class=
"org-string">"Agrave;"</span>: <span class="org-string">"À"</span>,
<span class="linenr">1183: </span>  <span class=
"org-string">"agrave;"</span>: <span class="org-string">"à"</span>,
<span class="linenr">1184: </span>  <span class=
"org-string">"andand;"</span>: <span class="org-string">"⩕"</span>,
<span class="linenr">1185: </span>  <span class=
"org-string">"angmsd;"</span>: <span class="org-string">"∡"</span>,
<span class="linenr">1186: </span>  <span class=
"org-string">"angsph;"</span>: <span class="org-string">"∢"</span>,
<span class="linenr">1187: </span>  <span class=
"org-string">"apacir;"</span>: <span class="org-string">"⩯"</span>,
<span class="linenr">1188: </span>  <span class=
"org-string">"approx;"</span>: <span class="org-string">"≈"</span>,
<span class="linenr">1189: </span>  <span class=
"org-string">"Assign;"</span>: <span class="org-string">"≔"</span>,
<span class="linenr">1190: </span>  <span class=
"org-string">"Atilde;"</span>: <span class="org-string">"Ã"</span>,
<span class="linenr">1191: </span>  <span class=
"org-string">"atilde;"</span>: <span class="org-string">"ã"</span>,
<span class="linenr">1192: </span>  <span class=
"org-string">"barvee;"</span>: <span class="org-string">"⊽"</span>,
<span class="linenr">1193: </span>  <span class=
"org-string">"Barwed;"</span>: <span class="org-string">"⌆"</span>,
<span class="linenr">1194: </span>  <span class=
"org-string">"barwed;"</span>: <span class="org-string">"⌅"</span>,
<span class="linenr">1195: </span>  <span class=
"org-string">"becaus;"</span>: <span class="org-string">"∵"</span>,
<span class="linenr">1196: </span>  <span class=
"org-string">"bernou;"</span>: <span class="org-string">"ℬ"</span>,
<span class="linenr">1197: </span>  <span class=
"org-string">"bigcap;"</span>: <span class="org-string">"⋂"</span>,
<span class="linenr">1198: </span>  <span class=
"org-string">"bigcup;"</span>: <span class="org-string">"⋃"</span>,
<span class="linenr">1199: </span>  <span class=
"org-string">"bigvee;"</span>: <span class="org-string">"⋁"</span>,
<span class="linenr">1200: </span>  <span class=
"org-string">"bkarow;"</span>: <span class="org-string">"⤍"</span>,
<span class="linenr">1201: </span>  <span class=
"org-string">"bottom;"</span>: <span class="org-string">"⊥"</span>,
<span class="linenr">1202: </span>  <span class=
"org-string">"bowtie;"</span>: <span class="org-string">"⋈"</span>,
<span class="linenr">1203: </span>  <span class=
"org-string">"boxbox;"</span>: <span class="org-string">"⧉"</span>,
<span class="linenr">1204: </span>  <span class=
"org-string">"bprime;"</span>: <span class="org-string">"‵"</span>,
<span class="linenr">1205: </span>  <span class=
"org-string">"brvbar;"</span>: <span class="org-string">"¦"</span>,
<span class="linenr">1206: </span>  <span class=
"org-string">"bullet;"</span>: <span class="org-string">"•"</span>,
<span class="linenr">1207: </span>  <span class=
"org-string">"Bumpeq;"</span>: <span class="org-string">"≎"</span>,
<span class="linenr">1208: </span>  <span class=
"org-string">"bumpeq;"</span>: <span class="org-string">"≏"</span>,
<span class="linenr">1209: </span>  <span class=
"org-string">"Cacute;"</span>: <span class="org-string">"Ć"</span>,
<span class="linenr">1210: </span>  <span class=
"org-string">"cacute;"</span>: <span class="org-string">"ć"</span>,
<span class="linenr">1211: </span>  <span class=
"org-string">"capand;"</span>: <span class="org-string">"⩄"</span>,
<span class="linenr">1212: </span>  <span class=
"org-string">"capcap;"</span>: <span class="org-string">"⩋"</span>,
<span class="linenr">1213: </span>  <span class=
"org-string">"capcup;"</span>: <span class="org-string">"⩇"</span>,
<span class="linenr">1214: </span>  <span class=
"org-string">"capdot;"</span>: <span class="org-string">"⩀"</span>,
<span class="linenr">1215: </span>  <span class=
"org-string">"Ccaron;"</span>: <span class="org-string">"Č"</span>,
<span class="linenr">1216: </span>  <span class=
"org-string">"ccaron;"</span>: <span class="org-string">"č"</span>,
<span class="linenr">1217: </span>  <span class=
"org-string">"Ccedil;"</span>: <span class="org-string">"Ç"</span>,
<span class="linenr">1218: </span>  <span class=
"org-string">"ccedil;"</span>: <span class="org-string">"ç"</span>,
<span class="linenr">1219: </span>  <span class=
"org-string">"circeq;"</span>: <span class="org-string">"≗"</span>,
<span class="linenr">1220: </span>  <span class=
"org-string">"cirmid;"</span>: <span class="org-string">"⫯"</span>,
<span class="linenr">1221: </span>  <span class=
"org-string">"Colone;"</span>: <span class="org-string">"⩴"</span>,
<span class="linenr">1222: </span>  <span class=
"org-string">"colone;"</span>: <span class="org-string">"≔"</span>,
<span class="linenr">1223: </span>  <span class=
"org-string">"commat;"</span>: <span class="org-string">"@"</span>,
<span class="linenr">1224: </span>  <span class=
"org-string">"compfn;"</span>: <span class="org-string">"∘"</span>,
<span class="linenr">1225: </span>  <span class=
"org-string">"Conint;"</span>: <span class="org-string">"∯"</span>,
<span class="linenr">1226: </span>  <span class=
"org-string">"conint;"</span>: <span class="org-string">"∮"</span>,
<span class="linenr">1227: </span>  <span class=
"org-string">"coprod;"</span>: <span class="org-string">"∐"</span>,
<span class="linenr">1228: </span>  <span class=
"org-string">"copysr;"</span>: <span class="org-string">"℗"</span>,
<span class="linenr">1229: </span>  <span class=
"org-string">"cularr;"</span>: <span class="org-string">"↶"</span>,
<span class="linenr">1230: </span>  <span class=
"org-string">"CupCap;"</span>: <span class="org-string">"≍"</span>,
<span class="linenr">1231: </span>  <span class=
"org-string">"cupcap;"</span>: <span class="org-string">"⩆"</span>,
<span class="linenr">1232: </span>  <span class=
"org-string">"cupcup;"</span>: <span class="org-string">"⩊"</span>,
<span class="linenr">1233: </span>  <span class=
"org-string">"cupdot;"</span>: <span class="org-string">"⊍"</span>,
<span class="linenr">1234: </span>  <span class=
"org-string">"curarr;"</span>: <span class="org-string">"↷"</span>,
<span class="linenr">1235: </span>  <span class=
"org-string">"curren;"</span>: <span class="org-string">"¤"</span>,
<span class="linenr">1236: </span>  <span class=
"org-string">"cylcty;"</span>: <span class="org-string">"⌭"</span>,
<span class="linenr">1237: </span>  <span class=
"org-string">"Dagger;"</span>: <span class="org-string">"‡"</span>,
<span class="linenr">1238: </span>  <span class=
"org-string">"dagger;"</span>: <span class="org-string">"†"</span>,
<span class="linenr">1239: </span>  <span class=
"org-string">"daleth;"</span>: <span class="org-string">"ℸ"</span>,
<span class="linenr">1240: </span>  <span class=
"org-string">"Dcaron;"</span>: <span class="org-string">"Ď"</span>,
<span class="linenr">1241: </span>  <span class=
"org-string">"dcaron;"</span>: <span class="org-string">"ď"</span>,
<span class="linenr">1242: </span>  <span class=
"org-string">"dfisht;"</span>: <span class="org-string">"⥿"</span>,
<span class="linenr">1243: </span>  <span class=
"org-string">"divide;"</span>: <span class="org-string">"÷"</span>,
<span class="linenr">1244: </span>  <span class=
"org-string">"divonx;"</span>: <span class="org-string">"⋇"</span>,
<span class="linenr">1245: </span>  <span class=
"org-string">"dlcorn;"</span>: <span class="org-string">"⌞"</span>,
<span class="linenr">1246: </span>  <span class=
"org-string">"dlcrop;"</span>: <span class="org-string">"⌍"</span>,
<span class="linenr">1247: </span>  <span class=
"org-string">"dollar;"</span>: <span class="org-string">"$"</span>,
<span class="linenr">1248: </span>  <span class=
"org-string">"DotDot;"</span>: <span class="org-string">"⃜"</span>,
<span class="linenr">1249: </span>  <span class=
"org-string">"drcorn;"</span>: <span class="org-string">"⌟"</span>,
<span class="linenr">1250: </span>  <span class=
"org-string">"drcrop;"</span>: <span class="org-string">"⌌"</span>,
<span class="linenr">1251: </span>  <span class=
"org-string">"Dstrok;"</span>: <span class="org-string">"Đ"</span>,
<span class="linenr">1252: </span>  <span class=
"org-string">"dstrok;"</span>: <span class="org-string">"đ"</span>,
<span class="linenr">1253: </span>  <span class=
"org-string">"Eacute;"</span>: <span class="org-string">"É"</span>,
<span class="linenr">1254: </span>  <span class=
"org-string">"eacute;"</span>: <span class="org-string">"é"</span>,
<span class="linenr">1255: </span>  <span class=
"org-string">"easter;"</span>: <span class="org-string">"⩮"</span>,
<span class="linenr">1256: </span>  <span class=
"org-string">"Ecaron;"</span>: <span class="org-string">"Ě"</span>,
<span class="linenr">1257: </span>  <span class=
"org-string">"ecaron;"</span>: <span class="org-string">"ě"</span>,
<span class="linenr">1258: </span>  <span class=
"org-string">"ecolon;"</span>: <span class="org-string">"≕"</span>,
<span class="linenr">1259: </span>  <span class=
"org-string">"Egrave;"</span>: <span class="org-string">"È"</span>,
<span class="linenr">1260: </span>  <span class=
"org-string">"egrave;"</span>: <span class="org-string">"è"</span>,
<span class="linenr">1261: </span>  <span class=
"org-string">"egsdot;"</span>: <span class="org-string">"⪘"</span>,
<span class="linenr">1262: </span>  <span class=
"org-string">"elsdot;"</span>: <span class="org-string">"⪗"</span>,
<span class="linenr">1263: </span>  <span class=
"org-string">"emptyv;"</span>: <span class="org-string">"∅"</span>,
<span class="linenr">1264: </span>  <span class=
"org-string">"emsp13;"</span>: <span class="org-string">" "</span>,
<span class="linenr">1265: </span>  <span class=
"org-string">"emsp14;"</span>: <span class="org-string">" "</span>,
<span class="linenr">1266: </span>  <span class=
"org-string">"eparsl;"</span>: <span class="org-string">"⧣"</span>,
<span class="linenr">1267: </span>  <span class=
"org-string">"eqcirc;"</span>: <span class="org-string">"≖"</span>,
<span class="linenr">1268: </span>  <span class=
"org-string">"equals;"</span>: <span class="org-string">"="</span>,
<span class="linenr">1269: </span>  <span class=
"org-string">"equest;"</span>: <span class="org-string">"≟"</span>,
<span class="linenr">1270: </span>  <span class=
"org-string">"Exists;"</span>: <span class="org-string">"∃"</span>,
<span class="linenr">1271: </span>  <span class=
"org-string">"female;"</span>: <span class="org-string">"♀"</span>,
<span class="linenr">1272: </span>  <span class=
"org-string">"ffilig;"</span>: <span class="org-string">"ﬃ"</span>,
<span class="linenr">1273: </span>  <span class=
"org-string">"ffllig;"</span>: <span class="org-string">"ﬄ"</span>,
<span class="linenr">1274: </span>  <span class=
"org-string">"ForAll;"</span>: <span class="org-string">"∀"</span>,
<span class="linenr">1275: </span>  <span class=
"org-string">"forall;"</span>: <span class="org-string">"∀"</span>,
<span class="linenr">1276: </span>  <span class=
"org-string">"frac12;"</span>: <span class="org-string">"½"</span>,
<span class="linenr">1277: </span>  <span class=
"org-string">"frac13;"</span>: <span class="org-string">"⅓"</span>,
<span class="linenr">1278: </span>  <span class=
"org-string">"frac14;"</span>: <span class="org-string">"¼"</span>,
<span class="linenr">1279: </span>  <span class=
"org-string">"frac15;"</span>: <span class="org-string">"⅕"</span>,
<span class="linenr">1280: </span>  <span class=
"org-string">"frac16;"</span>: <span class="org-string">"⅙"</span>,
<span class="linenr">1281: </span>  <span class=
"org-string">"frac18;"</span>: <span class="org-string">"⅛"</span>,
<span class="linenr">1282: </span>  <span class=
"org-string">"frac23;"</span>: <span class="org-string">"⅔"</span>,
<span class="linenr">1283: </span>  <span class=
"org-string">"frac25;"</span>: <span class="org-string">"⅖"</span>,
<span class="linenr">1284: </span>  <span class=
"org-string">"frac34;"</span>: <span class="org-string">"¾"</span>,
<span class="linenr">1285: </span>  <span class=
"org-string">"frac35;"</span>: <span class="org-string">"⅗"</span>,
<span class="linenr">1286: </span>  <span class=
"org-string">"frac38;"</span>: <span class="org-string">"⅜"</span>,
<span class="linenr">1287: </span>  <span class=
"org-string">"frac45;"</span>: <span class="org-string">"⅘"</span>,
<span class="linenr">1288: </span>  <span class=
"org-string">"frac56;"</span>: <span class="org-string">"⅚"</span>,
<span class="linenr">1289: </span>  <span class=
"org-string">"frac58;"</span>: <span class="org-string">"⅝"</span>,
<span class="linenr">1290: </span>  <span class=
"org-string">"frac78;"</span>: <span class="org-string">"⅞"</span>,
<span class="linenr">1291: </span>  <span class=
"org-string">"gacute;"</span>: <span class="org-string">"ǵ"</span>,
<span class="linenr">1292: </span>  <span class=
"org-string">"Gammad;"</span>: <span class="org-string">"Ϝ"</span>,
<span class="linenr">1293: </span>  <span class=
"org-string">"gammad;"</span>: <span class="org-string">"ϝ"</span>,
<span class="linenr">1294: </span>  <span class=
"org-string">"Gbreve;"</span>: <span class="org-string">"Ğ"</span>,
<span class="linenr">1295: </span>  <span class=
"org-string">"gbreve;"</span>: <span class="org-string">"ğ"</span>,
<span class="linenr">1296: </span>  <span class=
"org-string">"Gcedil;"</span>: <span class="org-string">"Ģ"</span>,
<span class="linenr">1297: </span>  <span class=
"org-string">"gesdot;"</span>: <span class="org-string">"⪀"</span>,
<span class="linenr">1298: </span>  <span class=
"org-string">"gesles;"</span>: <span class="org-string">"⪔"</span>,
<span class="linenr">1299: </span>  <span class=
"org-string">"gtlPar;"</span>: <span class="org-string">"⦕"</span>,
<span class="linenr">1300: </span>  <span class=
"org-string">"gtrarr;"</span>: <span class="org-string">"⥸"</span>,
<span class="linenr">1301: </span>  <span class=
"org-string">"gtrdot;"</span>: <span class="org-string">"⋗"</span>,
<span class="linenr">1302: </span>  <span class=
"org-string">"gtrsim;"</span>: <span class="org-string">"≳"</span>,
<span class="linenr">1303: </span>  <span class=
"org-string">"hairsp;"</span>: <span class="org-string">" "</span>,
<span class="linenr">1304: </span>  <span class=
"org-string">"hamilt;"</span>: <span class="org-string">"ℋ"</span>,
<span class="linenr">1305: </span>  <span class=
"org-string">"HARDcy;"</span>: <span class="org-string">"Ъ"</span>,
<span class="linenr">1306: </span>  <span class=
"org-string">"hardcy;"</span>: <span class="org-string">"ъ"</span>,
<span class="linenr">1307: </span>  <span class=
"org-string">"hearts;"</span>: <span class="org-string">"♥"</span>,
<span class="linenr">1308: </span>  <span class=
"org-string">"hellip;"</span>: <span class="org-string">"…"</span>,
<span class="linenr">1309: </span>  <span class=
"org-string">"hercon;"</span>: <span class="org-string">"⊹"</span>,
<span class="linenr">1310: </span>  <span class=
"org-string">"homtht;"</span>: <span class="org-string">"∻"</span>,
<span class="linenr">1311: </span>  <span class=
"org-string">"horbar;"</span>: <span class="org-string">"―"</span>,
<span class="linenr">1312: </span>  <span class=
"org-string">"hslash;"</span>: <span class="org-string">"ℏ"</span>,
<span class="linenr">1313: </span>  <span class=
"org-string">"Hstrok;"</span>: <span class="org-string">"Ħ"</span>,
<span class="linenr">1314: </span>  <span class=
"org-string">"hstrok;"</span>: <span class="org-string">"ħ"</span>,
<span class="linenr">1315: </span>  <span class=
"org-string">"hybull;"</span>: <span class="org-string">"⁃"</span>,
<span class="linenr">1316: </span>  <span class=
"org-string">"hyphen;"</span>: <span class="org-string">"‐"</span>,
<span class="linenr">1317: </span>  <span class=
"org-string">"Iacute;"</span>: <span class="org-string">"Í"</span>,
<span class="linenr">1318: </span>  <span class=
"org-string">"iacute;"</span>: <span class="org-string">"í"</span>,
<span class="linenr">1319: </span>  <span class=
"org-string">"Igrave;"</span>: <span class="org-string">"Ì"</span>,
<span class="linenr">1320: </span>  <span class=
"org-string">"igrave;"</span>: <span class="org-string">"ì"</span>,
<span class="linenr">1321: </span>  <span class=
"org-string">"iiiint;"</span>: <span class="org-string">"⨌"</span>,
<span class="linenr">1322: </span>  <span class=
"org-string">"iinfin;"</span>: <span class="org-string">"⧜"</span>,
<span class="linenr">1323: </span>  <span class=
"org-string">"incare;"</span>: <span class="org-string">"℅"</span>,
<span class="linenr">1324: </span>  <span class=
"org-string">"inodot;"</span>: <span class="org-string">"ı"</span>,
<span class="linenr">1325: </span>  <span class=
"org-string">"intcal;"</span>: <span class="org-string">"⊺"</span>,
<span class="linenr">1326: </span>  <span class=
"org-string">"iquest;"</span>: <span class="org-string">"¿"</span>,
<span class="linenr">1327: </span>  <span class=
"org-string">"isinsv;"</span>: <span class="org-string">"⋳"</span>,
<span class="linenr">1328: </span>  <span class=
"org-string">"Itilde;"</span>: <span class="org-string">"Ĩ"</span>,
<span class="linenr">1329: </span>  <span class=
"org-string">"itilde;"</span>: <span class="org-string">"ĩ"</span>,
<span class="linenr">1330: </span>  <span class=
"org-string">"Jsercy;"</span>: <span class="org-string">"Ј"</span>,
<span class="linenr">1331: </span>  <span class=
"org-string">"jsercy;"</span>: <span class="org-string">"ј"</span>,
<span class="linenr">1332: </span>  <span class=
"org-string">"kappav;"</span>: <span class="org-string">"ϰ"</span>,
<span class="linenr">1333: </span>  <span class=
"org-string">"Kcedil;"</span>: <span class="org-string">"Ķ"</span>,
<span class="linenr">1334: </span>  <span class=
"org-string">"kcedil;"</span>: <span class="org-string">"ķ"</span>,
<span class="linenr">1335: </span>  <span class=
"org-string">"kgreen;"</span>: <span class="org-string">"ĸ"</span>,
<span class="linenr">1336: </span>  <span class=
"org-string">"Lacute;"</span>: <span class="org-string">"Ĺ"</span>,
<span class="linenr">1337: </span>  <span class=
"org-string">"lacute;"</span>: <span class="org-string">"ĺ"</span>,
<span class="linenr">1338: </span>  <span class=
"org-string">"lagran;"</span>: <span class="org-string">"ℒ"</span>,
<span class="linenr">1339: </span>  <span class=
"org-string">"Lambda;"</span>: <span class="org-string">"Λ"</span>,
<span class="linenr">1340: </span>  <span class=
"org-string">"lambda;"</span>: <span class="org-string">"λ"</span>,
<span class="linenr">1341: </span>  <span class=
"org-string">"langle;"</span>: <span class="org-string">"⟨"</span>,
<span class="linenr">1342: </span>  <span class=
"org-string">"larrfs;"</span>: <span class="org-string">"⤝"</span>,
<span class="linenr">1343: </span>  <span class=
"org-string">"larrhk;"</span>: <span class="org-string">"↩"</span>,
<span class="linenr">1344: </span>  <span class=
"org-string">"larrlp;"</span>: <span class="org-string">"↫"</span>,
<span class="linenr">1345: </span>  <span class=
"org-string">"larrpl;"</span>: <span class="org-string">"⤹"</span>,
<span class="linenr">1346: </span>  <span class=
"org-string">"larrtl;"</span>: <span class="org-string">"↢"</span>,
<span class="linenr">1347: </span>  <span class=
"org-string">"lAtail;"</span>: <span class="org-string">"⤛"</span>,
<span class="linenr">1348: </span>  <span class=
"org-string">"latail;"</span>: <span class="org-string">"⤙"</span>,
<span class="linenr">1349: </span>  <span class=
"org-string">"lbrace;"</span>: <span class="org-string">"{"</span>,
<span class="linenr">1350: </span>  <span class=
"org-string">"lbrack;"</span>: <span class="org-string">"["</span>,
<span class="linenr">1351: </span>  <span class=
"org-string">"Lcaron;"</span>: <span class="org-string">"Ľ"</span>,
<span class="linenr">1352: </span>  <span class=
"org-string">"lcaron;"</span>: <span class="org-string">"ľ"</span>,
<span class="linenr">1353: </span>  <span class=
"org-string">"Lcedil;"</span>: <span class="org-string">"Ļ"</span>,
<span class="linenr">1354: </span>  <span class=
"org-string">"lcedil;"</span>: <span class="org-string">"ļ"</span>,
<span class="linenr">1355: </span>  <span class=
"org-string">"ldquor;"</span>: <span class="org-string">"„"</span>,
<span class="linenr">1356: </span>  <span class=
"org-string">"lesdot;"</span>: <span class="org-string">"⩿"</span>,
<span class="linenr">1357: </span>  <span class=
"org-string">"lesges;"</span>: <span class="org-string">"⪓"</span>,
<span class="linenr">1358: </span>  <span class=
"org-string">"lfisht;"</span>: <span class="org-string">"⥼"</span>,
<span class="linenr">1359: </span>  <span class=
"org-string">"lfloor;"</span>: <span class="org-string">"⌊"</span>,
<span class="linenr">1360: </span>  <span class=
"org-string">"lharul;"</span>: <span class="org-string">"⥪"</span>,
<span class="linenr">1361: </span>  <span class=
"org-string">"llhard;"</span>: <span class="org-string">"⥫"</span>,
<span class="linenr">1362: </span>  <span class=
"org-string">"Lmidot;"</span>: <span class="org-string">"Ŀ"</span>,
<span class="linenr">1363: </span>  <span class=
"org-string">"lmidot;"</span>: <span class="org-string">"ŀ"</span>,
<span class="linenr">1364: </span>  <span class=
"org-string">"lmoust;"</span>: <span class="org-string">"⎰"</span>,
<span class="linenr">1365: </span>  <span class=
"org-string">"loplus;"</span>: <span class="org-string">"⨭"</span>,
<span class="linenr">1366: </span>  <span class=
"org-string">"lowast;"</span>: <span class="org-string">"∗"</span>,
<span class="linenr">1367: </span>  <span class=
"org-string">"lowbar;"</span>: <span class="org-string">"_"</span>,
<span class="linenr">1368: </span>  <span class=
"org-string">"lparlt;"</span>: <span class="org-string">"⦓"</span>,
<span class="linenr">1369: </span>  <span class=
"org-string">"lrhard;"</span>: <span class="org-string">"⥭"</span>,
<span class="linenr">1370: </span>  <span class=
"org-string">"lsaquo;"</span>: <span class="org-string">"‹"</span>,
<span class="linenr">1371: </span>  <span class=
"org-string">"lsquor;"</span>: <span class="org-string">"‚"</span>,
<span class="linenr">1372: </span>  <span class=
"org-string">"Lstrok;"</span>: <span class="org-string">"Ł"</span>,
<span class="linenr">1373: </span>  <span class=
"org-string">"lstrok;"</span>: <span class="org-string">"ł"</span>,
<span class="linenr">1374: </span>  <span class=
"org-string">"lthree;"</span>: <span class="org-string">"⋋"</span>,
<span class="linenr">1375: </span>  <span class=
"org-string">"ltimes;"</span>: <span class="org-string">"⋉"</span>,
<span class="linenr">1376: </span>  <span class=
"org-string">"ltlarr;"</span>: <span class="org-string">"⥶"</span>,
<span class="linenr">1377: </span>  <span class=
"org-string">"ltrPar;"</span>: <span class="org-string">"⦖"</span>,
<span class="linenr">1378: </span>  <span class=
"org-string">"mapsto;"</span>: <span class="org-string">"↦"</span>,
<span class="linenr">1379: </span>  <span class=
"org-string">"marker;"</span>: <span class="org-string">"▮"</span>,
<span class="linenr">1380: </span>  <span class=
"org-string">"mcomma;"</span>: <span class="org-string">"⨩"</span>,
<span class="linenr">1381: </span>  <span class=
"org-string">"midast;"</span>: <span class="org-string">"*"</span>,
<span class="linenr">1382: </span>  <span class=
"org-string">"midcir;"</span>: <span class="org-string">"⫰"</span>,
<span class="linenr">1383: </span>  <span class=
"org-string">"middot;"</span>: <span class="org-string">"·"</span>,
<span class="linenr">1384: </span>  <span class=
"org-string">"minusb;"</span>: <span class="org-string">"⊟"</span>,
<span class="linenr">1385: </span>  <span class=
"org-string">"minusd;"</span>: <span class="org-string">"∸"</span>,
<span class="linenr">1386: </span>  <span class=
"org-string">"mnplus;"</span>: <span class="org-string">"∓"</span>,
<span class="linenr">1387: </span>  <span class=
"org-string">"models;"</span>: <span class="org-string">"⊧"</span>,
<span class="linenr">1388: </span>  <span class=
"org-string">"mstpos;"</span>: <span class="org-string">"∾"</span>,
<span class="linenr">1389: </span>  <span class=
"org-string">"Nacute;"</span>: <span class="org-string">"Ń"</span>,
<span class="linenr">1390: </span>  <span class=
"org-string">"nacute;"</span>: <span class="org-string">"ń"</span>,
<span class="linenr">1391: </span>  <span class=
"org-string">"nbumpe;"</span>: <span class=
"org-string">"≏̸"</span>,
<span class="linenr">1392: </span>  <span class=
"org-string">"Ncaron;"</span>: <span class="org-string">"Ň"</span>,
<span class="linenr">1393: </span>  <span class=
"org-string">"ncaron;"</span>: <span class="org-string">"ň"</span>,
<span class="linenr">1394: </span>  <span class=
"org-string">"Ncedil;"</span>: <span class="org-string">"Ņ"</span>,
<span class="linenr">1395: </span>  <span class=
"org-string">"ncedil;"</span>: <span class="org-string">"ņ"</span>,
<span class="linenr">1396: </span>  <span class=
"org-string">"nearhk;"</span>: <span class="org-string">"⤤"</span>,
<span class="linenr">1397: </span>  <span class=
"org-string">"nequiv;"</span>: <span class="org-string">"≢"</span>,
<span class="linenr">1398: </span>  <span class=
"org-string">"nesear;"</span>: <span class="org-string">"⤨"</span>,
<span class="linenr">1399: </span>  <span class=
"org-string">"nexist;"</span>: <span class="org-string">"∄"</span>,
<span class="linenr">1400: </span>  <span class=
"org-string">"nltrie;"</span>: <span class="org-string">"⋬"</span>,
<span class="linenr">1401: </span>  <span class=
"org-string">"notinE;"</span>: <span class=
"org-string">"⋹̸"</span>,
<span class="linenr">1402: </span>  <span class=
"org-string">"nparsl;"</span>: <span class=
"org-string">"⫽⃥"</span>,
<span class="linenr">1403: </span>  <span class=
"org-string">"nprcue;"</span>: <span class="org-string">"⋠"</span>,
<span class="linenr">1404: </span>  <span class=
"org-string">"nrarrc;"</span>: <span class=
"org-string">"⤳̸"</span>,
<span class="linenr">1405: </span>  <span class=
"org-string">"nrarrw;"</span>: <span class=
"org-string">"↝̸"</span>,
<span class="linenr">1406: </span>  <span class=
"org-string">"nrtrie;"</span>: <span class="org-string">"⋭"</span>,
<span class="linenr">1407: </span>  <span class=
"org-string">"nsccue;"</span>: <span class="org-string">"⋡"</span>,
<span class="linenr">1408: </span>  <span class=
"org-string">"nsimeq;"</span>: <span class="org-string">"≄"</span>,
<span class="linenr">1409: </span>  <span class=
"org-string">"Ntilde;"</span>: <span class="org-string">"Ñ"</span>,
<span class="linenr">1410: </span>  <span class=
"org-string">"ntilde;"</span>: <span class="org-string">"ñ"</span>,
<span class="linenr">1411: </span>  <span class=
"org-string">"numero;"</span>: <span class="org-string">"№"</span>,
<span class="linenr">1412: </span>  <span class=
"org-string">"nVDash;"</span>: <span class="org-string">"⊯"</span>,
<span class="linenr">1413: </span>  <span class=
"org-string">"nVdash;"</span>: <span class="org-string">"⊮"</span>,
<span class="linenr">1414: </span>  <span class=
"org-string">"nvDash;"</span>: <span class="org-string">"⊭"</span>,
<span class="linenr">1415: </span>  <span class=
"org-string">"nvdash;"</span>: <span class="org-string">"⊬"</span>,
<span class="linenr">1416: </span>  <span class=
"org-string">"nvHarr;"</span>: <span class="org-string">"⤄"</span>,
<span class="linenr">1417: </span>  <span class=
"org-string">"nvlArr;"</span>: <span class="org-string">"⤂"</span>,
<span class="linenr">1418: </span>  <span class=
"org-string">"nvrArr;"</span>: <span class="org-string">"⤃"</span>,
<span class="linenr">1419: </span>  <span class=
"org-string">"nwarhk;"</span>: <span class="org-string">"⤣"</span>,
<span class="linenr">1420: </span>  <span class=
"org-string">"nwnear;"</span>: <span class="org-string">"⤧"</span>,
<span class="linenr">1421: </span>  <span class=
"org-string">"Oacute;"</span>: <span class="org-string">"Ó"</span>,
<span class="linenr">1422: </span>  <span class=
"org-string">"oacute;"</span>: <span class="org-string">"ó"</span>,
<span class="linenr">1423: </span>  <span class=
"org-string">"Odblac;"</span>: <span class="org-string">"Ő"</span>,
<span class="linenr">1424: </span>  <span class=
"org-string">"odblac;"</span>: <span class="org-string">"ő"</span>,
<span class="linenr">1425: </span>  <span class=
"org-string">"odsold;"</span>: <span class="org-string">"⦼"</span>,
<span class="linenr">1426: </span>  <span class=
"org-string">"Ograve;"</span>: <span class="org-string">"Ò"</span>,
<span class="linenr">1427: </span>  <span class=
"org-string">"ograve;"</span>: <span class="org-string">"ò"</span>,
<span class="linenr">1428: </span>  <span class=
"org-string">"ominus;"</span>: <span class="org-string">"⊖"</span>,
<span class="linenr">1429: </span>  <span class=
"org-string">"origof;"</span>: <span class="org-string">"⊶"</span>,
<span class="linenr">1430: </span>  <span class=
"org-string">"Oslash;"</span>: <span class="org-string">"Ø"</span>,
<span class="linenr">1431: </span>  <span class=
"org-string">"oslash;"</span>: <span class="org-string">"ø"</span>,
<span class="linenr">1432: </span>  <span class=
"org-string">"Otilde;"</span>: <span class="org-string">"Õ"</span>,
<span class="linenr">1433: </span>  <span class=
"org-string">"otilde;"</span>: <span class="org-string">"õ"</span>,
<span class="linenr">1434: </span>  <span class=
"org-string">"Otimes;"</span>: <span class="org-string">"⨷"</span>,
<span class="linenr">1435: </span>  <span class=
"org-string">"otimes;"</span>: <span class="org-string">"⊗"</span>,
<span class="linenr">1436: </span>  <span class=
"org-string">"parsim;"</span>: <span class="org-string">"⫳"</span>,
<span class="linenr">1437: </span>  <span class=
"org-string">"percnt;"</span>: <span class="org-string">"%"</span>,
<span class="linenr">1438: </span>  <span class=
"org-string">"period;"</span>: <span class="org-string">"."</span>,
<span class="linenr">1439: </span>  <span class=
"org-string">"permil;"</span>: <span class="org-string">"‰"</span>,
<span class="linenr">1440: </span>  <span class=
"org-string">"phmmat;"</span>: <span class="org-string">"ℳ"</span>,
<span class="linenr">1441: </span>  <span class=
"org-string">"planck;"</span>: <span class="org-string">"ℏ"</span>,
<span class="linenr">1442: </span>  <span class=
"org-string">"plankv;"</span>: <span class="org-string">"ℏ"</span>,
<span class="linenr">1443: </span>  <span class=
"org-string">"plusdo;"</span>: <span class="org-string">"∔"</span>,
<span class="linenr">1444: </span>  <span class=
"org-string">"plusdu;"</span>: <span class="org-string">"⨥"</span>,
<span class="linenr">1445: </span>  <span class=
"org-string">"plusmn;"</span>: <span class="org-string">"±"</span>,
<span class="linenr">1446: </span>  <span class=
"org-string">"preceq;"</span>: <span class="org-string">"⪯"</span>,
<span class="linenr">1447: </span>  <span class=
"org-string">"primes;"</span>: <span class="org-string">"ℙ"</span>,
<span class="linenr">1448: </span>  <span class=
"org-string">"prnsim;"</span>: <span class="org-string">"⋨"</span>,
<span class="linenr">1449: </span>  <span class=
"org-string">"propto;"</span>: <span class="org-string">"∝"</span>,
<span class="linenr">1450: </span>  <span class=
"org-string">"prurel;"</span>: <span class="org-string">"⊰"</span>,
<span class="linenr">1451: </span>  <span class=
"org-string">"puncsp;"</span>: <span class="org-string">" "</span>,
<span class="linenr">1452: </span>  <span class=
"org-string">"qprime;"</span>: <span class="org-string">"⁗"</span>,
<span class="linenr">1453: </span>  <span class=
"org-string">"Racute;"</span>: <span class="org-string">"Ŕ"</span>,
<span class="linenr">1454: </span>  <span class=
"org-string">"racute;"</span>: <span class="org-string">"ŕ"</span>,
<span class="linenr">1455: </span>  <span class=
"org-string">"rangle;"</span>: <span class="org-string">"⟩"</span>,
<span class="linenr">1456: </span>  <span class=
"org-string">"rarrap;"</span>: <span class="org-string">"⥵"</span>,
<span class="linenr">1457: </span>  <span class=
"org-string">"rarrfs;"</span>: <span class="org-string">"⤞"</span>,
<span class="linenr">1458: </span>  <span class=
"org-string">"rarrhk;"</span>: <span class="org-string">"↪"</span>,
<span class="linenr">1459: </span>  <span class=
"org-string">"rarrlp;"</span>: <span class="org-string">"↬"</span>,
<span class="linenr">1460: </span>  <span class=
"org-string">"rarrpl;"</span>: <span class="org-string">"⥅"</span>,
<span class="linenr">1461: </span>  <span class=
"org-string">"Rarrtl;"</span>: <span class="org-string">"⤖"</span>,
<span class="linenr">1462: </span>  <span class=
"org-string">"rarrtl;"</span>: <span class="org-string">"↣"</span>,
<span class="linenr">1463: </span>  <span class=
"org-string">"rAtail;"</span>: <span class="org-string">"⤜"</span>,
<span class="linenr">1464: </span>  <span class=
"org-string">"ratail;"</span>: <span class="org-string">"⤚"</span>,
<span class="linenr">1465: </span>  <span class=
"org-string">"rbrace;"</span>: <span class="org-string">"}"</span>,
<span class="linenr">1466: </span>  <span class=
"org-string">"rbrack;"</span>: <span class="org-string">"]"</span>,
<span class="linenr">1467: </span>  <span class=
"org-string">"Rcaron;"</span>: <span class="org-string">"Ř"</span>,
<span class="linenr">1468: </span>  <span class=
"org-string">"rcaron;"</span>: <span class="org-string">"ř"</span>,
<span class="linenr">1469: </span>  <span class=
"org-string">"Rcedil;"</span>: <span class="org-string">"Ŗ"</span>,
<span class="linenr">1470: </span>  <span class=
"org-string">"rcedil;"</span>: <span class="org-string">"ŗ"</span>,
<span class="linenr">1471: </span>  <span class=
"org-string">"rdquor;"</span>: <span class="org-string">"”"</span>,
<span class="linenr">1472: </span>  <span class=
"org-string">"rfisht;"</span>: <span class="org-string">"⥽"</span>,
<span class="linenr">1473: </span>  <span class=
"org-string">"rfloor;"</span>: <span class="org-string">"⌋"</span>,
<span class="linenr">1474: </span>  <span class=
"org-string">"rharul;"</span>: <span class="org-string">"⥬"</span>,
<span class="linenr">1475: </span>  <span class=
"org-string">"rmoust;"</span>: <span class="org-string">"⎱"</span>,
<span class="linenr">1476: </span>  <span class=
"org-string">"roplus;"</span>: <span class="org-string">"⨮"</span>,
<span class="linenr">1477: </span>  <span class=
"org-string">"rpargt;"</span>: <span class="org-string">"⦔"</span>,
<span class="linenr">1478: </span>  <span class=
"org-string">"rsaquo;"</span>: <span class="org-string">"›"</span>,
<span class="linenr">1479: </span>  <span class=
"org-string">"rsquor;"</span>: <span class="org-string">"’"</span>,
<span class="linenr">1480: </span>  <span class=
"org-string">"rthree;"</span>: <span class="org-string">"⋌"</span>,
<span class="linenr">1481: </span>  <span class=
"org-string">"rtimes;"</span>: <span class="org-string">"⋊"</span>,
<span class="linenr">1482: </span>  <span class=
"org-string">"Sacute;"</span>: <span class="org-string">"Ś"</span>,
<span class="linenr">1483: </span>  <span class=
"org-string">"sacute;"</span>: <span class="org-string">"ś"</span>,
<span class="linenr">1484: </span>  <span class=
"org-string">"Scaron;"</span>: <span class="org-string">"Š"</span>,
<span class="linenr">1485: </span>  <span class=
"org-string">"scaron;"</span>: <span class="org-string">"š"</span>,
<span class="linenr">1486: </span>  <span class=
"org-string">"Scedil;"</span>: <span class="org-string">"Ş"</span>,
<span class="linenr">1487: </span>  <span class=
"org-string">"scedil;"</span>: <span class="org-string">"ş"</span>,
<span class="linenr">1488: </span>  <span class=
"org-string">"scnsim;"</span>: <span class="org-string">"⋩"</span>,
<span class="linenr">1489: </span>  <span class=
"org-string">"searhk;"</span>: <span class="org-string">"⤥"</span>,
<span class="linenr">1490: </span>  <span class=
"org-string">"seswar;"</span>: <span class="org-string">"⤩"</span>,
<span class="linenr">1491: </span>  <span class=
"org-string">"sfrown;"</span>: <span class="org-string">"⌢"</span>,
<span class="linenr">1492: </span>  <span class=
"org-string">"SHCHcy;"</span>: <span class="org-string">"Щ"</span>,
<span class="linenr">1493: </span>  <span class=
"org-string">"shchcy;"</span>: <span class="org-string">"щ"</span>,
<span class="linenr">1494: </span>  <span class=
"org-string">"sigmaf;"</span>: <span class="org-string">"ς"</span>,
<span class="linenr">1495: </span>  <span class=
"org-string">"sigmav;"</span>: <span class="org-string">"ς"</span>,
<span class="linenr">1496: </span>  <span class=
"org-string">"simdot;"</span>: <span class="org-string">"⩪"</span>,
<span class="linenr">1497: </span>  <span class=
"org-string">"smashp;"</span>: <span class="org-string">"⨳"</span>,
<span class="linenr">1498: </span>  <span class=
"org-string">"SOFTcy;"</span>: <span class="org-string">"Ь"</span>,
<span class="linenr">1499: </span>  <span class=
"org-string">"softcy;"</span>: <span class="org-string">"ь"</span>,
<span class="linenr">1500: </span>  <span class=
"org-string">"solbar;"</span>: <span class="org-string">"⌿"</span>,
<span class="linenr">1501: </span>  <span class=
"org-string">"spades;"</span>: <span class="org-string">"♠"</span>,
<span class="linenr">1502: </span>  <span class=
"org-string">"sqcaps;"</span>: <span class=
"org-string">"⊓︀"</span>,
<span class="linenr">1503: </span>  <span class=
"org-string">"sqcups;"</span>: <span class=
"org-string">"⊔︀"</span>,
<span class="linenr">1504: </span>  <span class=
"org-string">"sqsube;"</span>: <span class="org-string">"⊑"</span>,
<span class="linenr">1505: </span>  <span class=
"org-string">"sqsupe;"</span>: <span class="org-string">"⊒"</span>,
<span class="linenr">1506: </span>  <span class=
"org-string">"Square;"</span>: <span class="org-string">"□"</span>,
<span class="linenr">1507: </span>  <span class=
"org-string">"square;"</span>: <span class="org-string">"□"</span>,
<span class="linenr">1508: </span>  <span class=
"org-string">"squarf;"</span>: <span class="org-string">"▪"</span>,
<span class="linenr">1509: </span>  <span class=
"org-string">"ssetmn;"</span>: <span class="org-string">"∖"</span>,
<span class="linenr">1510: </span>  <span class=
"org-string">"ssmile;"</span>: <span class="org-string">"⌣"</span>,
<span class="linenr">1511: </span>  <span class=
"org-string">"sstarf;"</span>: <span class="org-string">"⋆"</span>,
<span class="linenr">1512: </span>  <span class=
"org-string">"subdot;"</span>: <span class="org-string">"⪽"</span>,
<span class="linenr">1513: </span>  <span class=
"org-string">"Subset;"</span>: <span class="org-string">"⋐"</span>,
<span class="linenr">1514: </span>  <span class=
"org-string">"subset;"</span>: <span class="org-string">"⊂"</span>,
<span class="linenr">1515: </span>  <span class=
"org-string">"subsim;"</span>: <span class="org-string">"⫇"</span>,
<span class="linenr">1516: </span>  <span class=
"org-string">"subsub;"</span>: <span class="org-string">"⫕"</span>,
<span class="linenr">1517: </span>  <span class=
"org-string">"subsup;"</span>: <span class="org-string">"⫓"</span>,
<span class="linenr">1518: </span>  <span class=
"org-string">"succeq;"</span>: <span class="org-string">"⪰"</span>,
<span class="linenr">1519: </span>  <span class=
"org-string">"supdot;"</span>: <span class="org-string">"⪾"</span>,
<span class="linenr">1520: </span>  <span class=
"org-string">"Supset;"</span>: <span class="org-string">"⋑"</span>,
<span class="linenr">1521: </span>  <span class=
"org-string">"supset;"</span>: <span class="org-string">"⊃"</span>,
<span class="linenr">1522: </span>  <span class=
"org-string">"supsim;"</span>: <span class="org-string">"⫈"</span>,
<span class="linenr">1523: </span>  <span class=
"org-string">"supsub;"</span>: <span class="org-string">"⫔"</span>,
<span class="linenr">1524: </span>  <span class=
"org-string">"supsup;"</span>: <span class="org-string">"⫖"</span>,
<span class="linenr">1525: </span>  <span class=
"org-string">"swarhk;"</span>: <span class="org-string">"⤦"</span>,
<span class="linenr">1526: </span>  <span class=
"org-string">"swnwar;"</span>: <span class="org-string">"⤪"</span>,
<span class="linenr">1527: </span>  <span class=
"org-string">"target;"</span>: <span class="org-string">"⌖"</span>,
<span class="linenr">1528: </span>  <span class=
"org-string">"Tcaron;"</span>: <span class="org-string">"Ť"</span>,
<span class="linenr">1529: </span>  <span class=
"org-string">"tcaron;"</span>: <span class="org-string">"ť"</span>,
<span class="linenr">1530: </span>  <span class=
"org-string">"Tcedil;"</span>: <span class="org-string">"Ţ"</span>,
<span class="linenr">1531: </span>  <span class=
"org-string">"tcedil;"</span>: <span class="org-string">"ţ"</span>,
<span class="linenr">1532: </span>  <span class=
"org-string">"telrec;"</span>: <span class="org-string">"⌕"</span>,
<span class="linenr">1533: </span>  <span class=
"org-string">"there4;"</span>: <span class="org-string">"∴"</span>,
<span class="linenr">1534: </span>  <span class=
"org-string">"thetav;"</span>: <span class="org-string">"ϑ"</span>,
<span class="linenr">1535: </span>  <span class=
"org-string">"thinsp;"</span>: <span class="org-string">" "</span>,
<span class="linenr">1536: </span>  <span class=
"org-string">"thksim;"</span>: <span class="org-string">"∼"</span>,
<span class="linenr">1537: </span>  <span class=
"org-string">"timesb;"</span>: <span class="org-string">"⊠"</span>,
<span class="linenr">1538: </span>  <span class=
"org-string">"timesd;"</span>: <span class="org-string">"⨰"</span>,
<span class="linenr">1539: </span>  <span class=
"org-string">"topbot;"</span>: <span class="org-string">"⌶"</span>,
<span class="linenr">1540: </span>  <span class=
"org-string">"topcir;"</span>: <span class="org-string">"⫱"</span>,
<span class="linenr">1541: </span>  <span class=
"org-string">"tprime;"</span>: <span class="org-string">"‴"</span>,
<span class="linenr">1542: </span>  <span class=
"org-string">"tridot;"</span>: <span class="org-string">"◬"</span>,
<span class="linenr">1543: </span>  <span class=
"org-string">"Tstrok;"</span>: <span class="org-string">"Ŧ"</span>,
<span class="linenr">1544: </span>  <span class=
"org-string">"tstrok;"</span>: <span class="org-string">"ŧ"</span>,
<span class="linenr">1545: </span>  <span class=
"org-string">"Uacute;"</span>: <span class="org-string">"Ú"</span>,
<span class="linenr">1546: </span>  <span class=
"org-string">"uacute;"</span>: <span class="org-string">"ú"</span>,
<span class="linenr">1547: </span>  <span class=
"org-string">"Ubreve;"</span>: <span class="org-string">"Ŭ"</span>,
<span class="linenr">1548: </span>  <span class=
"org-string">"ubreve;"</span>: <span class="org-string">"ŭ"</span>,
<span class="linenr">1549: </span>  <span class=
"org-string">"Udblac;"</span>: <span class="org-string">"Ű"</span>,
<span class="linenr">1550: </span>  <span class=
"org-string">"udblac;"</span>: <span class="org-string">"ű"</span>,
<span class="linenr">1551: </span>  <span class=
"org-string">"ufisht;"</span>: <span class="org-string">"⥾"</span>,
<span class="linenr">1552: </span>  <span class=
"org-string">"Ugrave;"</span>: <span class="org-string">"Ù"</span>,
<span class="linenr">1553: </span>  <span class=
"org-string">"ugrave;"</span>: <span class="org-string">"ù"</span>,
<span class="linenr">1554: </span>  <span class=
"org-string">"ulcorn;"</span>: <span class="org-string">"⌜"</span>,
<span class="linenr">1555: </span>  <span class=
"org-string">"ulcrop;"</span>: <span class="org-string">"⌏"</span>,
<span class="linenr">1556: </span>  <span class=
"org-string">"urcorn;"</span>: <span class="org-string">"⌝"</span>,
<span class="linenr">1557: </span>  <span class=
"org-string">"urcrop;"</span>: <span class="org-string">"⌎"</span>,
<span class="linenr">1558: </span>  <span class=
"org-string">"Utilde;"</span>: <span class="org-string">"Ũ"</span>,
<span class="linenr">1559: </span>  <span class=
"org-string">"utilde;"</span>: <span class="org-string">"ũ"</span>,
<span class="linenr">1560: </span>  <span class=
"org-string">"vangrt;"</span>: <span class="org-string">"⦜"</span>,
<span class="linenr">1561: </span>  <span class=
"org-string">"varphi;"</span>: <span class="org-string">"ϕ"</span>,
<span class="linenr">1562: </span>  <span class=
"org-string">"varrho;"</span>: <span class="org-string">"ϱ"</span>,
<span class="linenr">1563: </span>  <span class=
"org-string">"Vdashl;"</span>: <span class="org-string">"⫦"</span>,
<span class="linenr">1564: </span>  <span class=
"org-string">"veebar;"</span>: <span class="org-string">"⊻"</span>,
<span class="linenr">1565: </span>  <span class=
"org-string">"vellip;"</span>: <span class="org-string">"⋮"</span>,
<span class="linenr">1566: </span>  <span class=
"org-string">"Verbar;"</span>: <span class="org-string">"‖"</span>,
<span class="linenr">1567: </span>  <span class=
"org-string">"verbar;"</span>: <span class="org-string">"|"</span>,
<span class="linenr">1568: </span>  <span class=
"org-string">"vsubnE;"</span>: <span class=
"org-string">"⫋︀"</span>,
<span class="linenr">1569: </span>  <span class=
"org-string">"vsubne;"</span>: <span class=
"org-string">"⊊︀"</span>,
<span class="linenr">1570: </span>  <span class=
"org-string">"vsupnE;"</span>: <span class=
"org-string">"⫌︀"</span>,
<span class="linenr">1571: </span>  <span class=
"org-string">"vsupne;"</span>: <span class=
"org-string">"⊋︀"</span>,
<span class="linenr">1572: </span>  <span class=
"org-string">"Vvdash;"</span>: <span class="org-string">"⊪"</span>,
<span class="linenr">1573: </span>  <span class=
"org-string">"wedbar;"</span>: <span class="org-string">"⩟"</span>,
<span class="linenr">1574: </span>  <span class=
"org-string">"wedgeq;"</span>: <span class="org-string">"≙"</span>,
<span class="linenr">1575: </span>  <span class=
"org-string">"weierp;"</span>: <span class="org-string">"℘"</span>,
<span class="linenr">1576: </span>  <span class=
"org-string">"wreath;"</span>: <span class="org-string">"≀"</span>,
<span class="linenr">1577: </span>  <span class=
"org-string">"xoplus;"</span>: <span class="org-string">"⨁"</span>,
<span class="linenr">1578: </span>  <span class=
"org-string">"xotime;"</span>: <span class="org-string">"⨂"</span>,
<span class="linenr">1579: </span>  <span class=
"org-string">"xsqcup;"</span>: <span class="org-string">"⨆"</span>,
<span class="linenr">1580: </span>  <span class=
"org-string">"xuplus;"</span>: <span class="org-string">"⨄"</span>,
<span class="linenr">1581: </span>  <span class=
"org-string">"xwedge;"</span>: <span class="org-string">"⋀"</span>,
<span class="linenr">1582: </span>  <span class=
"org-string">"Yacute;"</span>: <span class="org-string">"Ý"</span>,
<span class="linenr">1583: </span>  <span class=
"org-string">"yacute;"</span>: <span class="org-string">"ý"</span>,
<span class="linenr">1584: </span>  <span class=
"org-string">"Zacute;"</span>: <span class="org-string">"Ź"</span>,
<span class="linenr">1585: </span>  <span class=
"org-string">"zacute;"</span>: <span class="org-string">"ź"</span>,
<span class="linenr">1586: </span>  <span class=
"org-string">"Zcaron;"</span>: <span class="org-string">"Ž"</span>,
<span class="linenr">1587: </span>  <span class=
"org-string">"zcaron;"</span>: <span class="org-string">"ž"</span>,
<span class="linenr">1588: </span>  <span class=
"org-string">"zeetrf;"</span>: <span class="org-string">"ℨ"</span>,
<span class="linenr">1589: </span>  <span class=
"org-string">"alefsym;"</span>: <span class=
"org-string">"ℵ"</span>,
<span class="linenr">1590: </span>  <span class=
"org-string">"angrtvb;"</span>: <span class=
"org-string">"⊾"</span>,
<span class="linenr">1591: </span>  <span class=
"org-string">"angzarr;"</span>: <span class=
"org-string">"⍼"</span>,
<span class="linenr">1592: </span>  <span class=
"org-string">"asympeq;"</span>: <span class=
"org-string">"≍"</span>,
<span class="linenr">1593: </span>  <span class=
"org-string">"backsim;"</span>: <span class=
"org-string">"∽"</span>,
<span class="linenr">1594: </span>  <span class=
"org-string">"Because;"</span>: <span class=
"org-string">"∵"</span>,
<span class="linenr">1595: </span>  <span class=
"org-string">"because;"</span>: <span class=
"org-string">"∵"</span>,
<span class="linenr">1596: </span>  <span class=
"org-string">"bemptyv;"</span>: <span class=
"org-string">"⦰"</span>,
<span class="linenr">1597: </span>  <span class=
"org-string">"between;"</span>: <span class=
"org-string">"≬"</span>,
<span class="linenr">1598: </span>  <span class=
"org-string">"bigcirc;"</span>: <span class=
"org-string">"◯"</span>,
<span class="linenr">1599: </span>  <span class=
"org-string">"bigodot;"</span>: <span class=
"org-string">"⨀"</span>,
<span class="linenr">1600: </span>  <span class=
"org-string">"bigstar;"</span>: <span class=
"org-string">"★"</span>,
<span class="linenr">1601: </span>  <span class=
"org-string">"bnequiv;"</span>: <span class=
"org-string">"≡⃥"</span>,
<span class="linenr">1602: </span>  <span class=
"org-string">"boxplus;"</span>: <span class=
"org-string">"⊞"</span>,
<span class="linenr">1603: </span>  <span class=
"org-string">"Cayleys;"</span>: <span class=
"org-string">"ℭ"</span>,
<span class="linenr">1604: </span>  <span class=
"org-string">"Cconint;"</span>: <span class=
"org-string">"∰"</span>,
<span class="linenr">1605: </span>  <span class=
"org-string">"ccupssm;"</span>: <span class=
"org-string">"⩐"</span>,
<span class="linenr">1606: </span>  <span class=
"org-string">"Cedilla;"</span>: <span class=
"org-string">"¸"</span>,
<span class="linenr">1607: </span>  <span class=
"org-string">"cemptyv;"</span>: <span class=
"org-string">"⦲"</span>,
<span class="linenr">1608: </span>  <span class=
"org-string">"cirscir;"</span>: <span class=
"org-string">"⧂"</span>,
<span class="linenr">1609: </span>  <span class=
"org-string">"coloneq;"</span>: <span class=
"org-string">"≔"</span>,
<span class="linenr">1610: </span>  <span class=
"org-string">"congdot;"</span>: <span class=
"org-string">"⩭"</span>,
<span class="linenr">1611: </span>  <span class=
"org-string">"cudarrl;"</span>: <span class=
"org-string">"⤸"</span>,
<span class="linenr">1612: </span>  <span class=
"org-string">"cudarrr;"</span>: <span class=
"org-string">"⤵"</span>,
<span class="linenr">1613: </span>  <span class=
"org-string">"cularrp;"</span>: <span class=
"org-string">"⤽"</span>,
<span class="linenr">1614: </span>  <span class=
"org-string">"curarrm;"</span>: <span class=
"org-string">"⤼"</span>,
<span class="linenr">1615: </span>  <span class=
"org-string">"dbkarow;"</span>: <span class=
"org-string">"⤏"</span>,
<span class="linenr">1616: </span>  <span class=
"org-string">"ddagger;"</span>: <span class=
"org-string">"‡"</span>,
<span class="linenr">1617: </span>  <span class=
"org-string">"ddotseq;"</span>: <span class=
"org-string">"⩷"</span>,
<span class="linenr">1618: </span>  <span class=
"org-string">"demptyv;"</span>: <span class=
"org-string">"⦱"</span>,
<span class="linenr">1619: </span>  <span class=
"org-string">"Diamond;"</span>: <span class=
"org-string">"⋄"</span>,
<span class="linenr">1620: </span>  <span class=
"org-string">"diamond;"</span>: <span class=
"org-string">"⋄"</span>,
<span class="linenr">1621: </span>  <span class=
"org-string">"digamma;"</span>: <span class=
"org-string">"ϝ"</span>,
<span class="linenr">1622: </span>  <span class=
"org-string">"dotplus;"</span>: <span class=
"org-string">"∔"</span>,
<span class="linenr">1623: </span>  <span class=
"org-string">"DownTee;"</span>: <span class=
"org-string">"⊤"</span>,
<span class="linenr">1624: </span>  <span class=
"org-string">"dwangle;"</span>: <span class=
"org-string">"⦦"</span>,
<span class="linenr">1625: </span>  <span class=
"org-string">"Element;"</span>: <span class=
"org-string">"∈"</span>,
<span class="linenr">1626: </span>  <span class=
"org-string">"Epsilon;"</span>: <span class=
"org-string">"Ε"</span>,
<span class="linenr">1627: </span>  <span class=
"org-string">"epsilon;"</span>: <span class=
"org-string">"ε"</span>,
<span class="linenr">1628: </span>  <span class=
"org-string">"eqcolon;"</span>: <span class=
"org-string">"≕"</span>,
<span class="linenr">1629: </span>  <span class=
"org-string">"equivDD;"</span>: <span class=
"org-string">"⩸"</span>,
<span class="linenr">1630: </span>  <span class=
"org-string">"gesdoto;"</span>: <span class=
"org-string">"⪂"</span>,
<span class="linenr">1631: </span>  <span class=
"org-string">"gtquest;"</span>: <span class=
"org-string">"⩼"</span>,
<span class="linenr">1632: </span>  <span class=
"org-string">"gtrless;"</span>: <span class=
"org-string">"≷"</span>,
<span class="linenr">1633: </span>  <span class=
"org-string">"harrcir;"</span>: <span class=
"org-string">"⥈"</span>,
<span class="linenr">1634: </span>  <span class=
"org-string">"Implies;"</span>: <span class=
"org-string">"⇒"</span>,
<span class="linenr">1635: </span>  <span class=
"org-string">"intprod;"</span>: <span class=
"org-string">"⨼"</span>,
<span class="linenr">1636: </span>  <span class=
"org-string">"isindot;"</span>: <span class=
"org-string">"⋵"</span>,
<span class="linenr">1637: </span>  <span class=
"org-string">"larrbfs;"</span>: <span class=
"org-string">"⤟"</span>,
<span class="linenr">1638: </span>  <span class=
"org-string">"larrsim;"</span>: <span class=
"org-string">"⥳"</span>,
<span class="linenr">1639: </span>  <span class=
"org-string">"lbrksld;"</span>: <span class=
"org-string">"⦏"</span>,
<span class="linenr">1640: </span>  <span class=
"org-string">"lbrkslu;"</span>: <span class=
"org-string">"⦍"</span>,
<span class="linenr">1641: </span>  <span class=
"org-string">"ldrdhar;"</span>: <span class=
"org-string">"⥧"</span>,
<span class="linenr">1642: </span>  <span class=
"org-string">"LeftTee;"</span>: <span class=
"org-string">"⊣"</span>,
<span class="linenr">1643: </span>  <span class=
"org-string">"lesdoto;"</span>: <span class=
"org-string">"⪁"</span>,
<span class="linenr">1644: </span>  <span class=
"org-string">"lessdot;"</span>: <span class=
"org-string">"⋖"</span>,
<span class="linenr">1645: </span>  <span class=
"org-string">"lessgtr;"</span>: <span class=
"org-string">"≶"</span>,
<span class="linenr">1646: </span>  <span class=
"org-string">"lesssim;"</span>: <span class=
"org-string">"≲"</span>,
<span class="linenr">1647: </span>  <span class=
"org-string">"lotimes;"</span>: <span class=
"org-string">"⨴"</span>,
<span class="linenr">1648: </span>  <span class=
"org-string">"lozenge;"</span>: <span class=
"org-string">"◊"</span>,
<span class="linenr">1649: </span>  <span class=
"org-string">"ltquest;"</span>: <span class=
"org-string">"⩻"</span>,
<span class="linenr">1650: </span>  <span class=
"org-string">"luruhar;"</span>: <span class=
"org-string">"⥦"</span>,
<span class="linenr">1651: </span>  <span class=
"org-string">"maltese;"</span>: <span class=
"org-string">"✠"</span>,
<span class="linenr">1652: </span>  <span class=
"org-string">"minusdu;"</span>: <span class=
"org-string">"⨪"</span>,
<span class="linenr">1653: </span>  <span class=
"org-string">"napprox;"</span>: <span class=
"org-string">"≉"</span>,
<span class="linenr">1654: </span>  <span class=
"org-string">"natural;"</span>: <span class=
"org-string">"♮"</span>,
<span class="linenr">1655: </span>  <span class=
"org-string">"nearrow;"</span>: <span class=
"org-string">"↗"</span>,
<span class="linenr">1656: </span>  <span class=
"org-string">"NewLine;"</span>: <span class=
"org-string">"\n"</span>,
<span class="linenr">1657: </span>  <span class=
"org-string">"nexists;"</span>: <span class=
"org-string">"∄"</span>,
<span class="linenr">1658: </span>  <span class=
"org-string">"NoBreak;"</span>: <span class=
"org-string">"⁠"</span>,
<span class="linenr">1659: </span>  <span class=
"org-string">"notinva;"</span>: <span class=
"org-string">"∉"</span>,
<span class="linenr">1660: </span>  <span class=
"org-string">"notinvb;"</span>: <span class=
"org-string">"⋷"</span>,
<span class="linenr">1661: </span>  <span class=
"org-string">"notinvc;"</span>: <span class=
"org-string">"⋶"</span>,
<span class="linenr">1662: </span>  <span class=
"org-string">"NotLess;"</span>: <span class=
"org-string">"≮"</span>,
<span class="linenr">1663: </span>  <span class=
"org-string">"notniva;"</span>: <span class=
"org-string">"∌"</span>,
<span class="linenr">1664: </span>  <span class=
"org-string">"notnivb;"</span>: <span class=
"org-string">"⋾"</span>,
<span class="linenr">1665: </span>  <span class=
"org-string">"notnivc;"</span>: <span class=
"org-string">"⋽"</span>,
<span class="linenr">1666: </span>  <span class=
"org-string">"npolint;"</span>: <span class=
"org-string">"⨔"</span>,
<span class="linenr">1667: </span>  <span class=
"org-string">"npreceq;"</span>: <span class=
"org-string">"⪯̸"</span>,
<span class="linenr">1668: </span>  <span class=
"org-string">"nsqsube;"</span>: <span class=
"org-string">"⋢"</span>,
<span class="linenr">1669: </span>  <span class=
"org-string">"nsqsupe;"</span>: <span class=
"org-string">"⋣"</span>,
<span class="linenr">1670: </span>  <span class=
"org-string">"nsubset;"</span>: <span class=
"org-string">"⊂⃒"</span>,
<span class="linenr">1671: </span>  <span class=
"org-string">"nsucceq;"</span>: <span class=
"org-string">"⪰̸"</span>,
<span class="linenr">1672: </span>  <span class=
"org-string">"nsupset;"</span>: <span class=
"org-string">"⊃⃒"</span>,
<span class="linenr">1673: </span>  <span class=
"org-string">"nvinfin;"</span>: <span class=
"org-string">"⧞"</span>,
<span class="linenr">1674: </span>  <span class=
"org-string">"nvltrie;"</span>: <span class=
"org-string">"⊴⃒"</span>,
<span class="linenr">1675: </span>  <span class=
"org-string">"nvrtrie;"</span>: <span class=
"org-string">"⊵⃒"</span>,
<span class="linenr">1676: </span>  <span class=
"org-string">"nwarrow;"</span>: <span class=
"org-string">"↖"</span>,
<span class="linenr">1677: </span>  <span class=
"org-string">"olcross;"</span>: <span class=
"org-string">"⦻"</span>,
<span class="linenr">1678: </span>  <span class=
"org-string">"Omicron;"</span>: <span class=
"org-string">"Ο"</span>,
<span class="linenr">1679: </span>  <span class=
"org-string">"omicron;"</span>: <span class=
"org-string">"ο"</span>,
<span class="linenr">1680: </span>  <span class=
"org-string">"orderof;"</span>: <span class=
"org-string">"ℴ"</span>,
<span class="linenr">1681: </span>  <span class=
"org-string">"orslope;"</span>: <span class=
"org-string">"⩗"</span>,
<span class="linenr">1682: </span>  <span class=
"org-string">"OverBar;"</span>: <span class=
"org-string">"‾"</span>,
<span class="linenr">1683: </span>  <span class=
"org-string">"pertenk;"</span>: <span class=
"org-string">"‱"</span>,
<span class="linenr">1684: </span>  <span class=
"org-string">"planckh;"</span>: <span class=
"org-string">"ℎ"</span>,
<span class="linenr">1685: </span>  <span class=
"org-string">"pluscir;"</span>: <span class=
"org-string">"⨢"</span>,
<span class="linenr">1686: </span>  <span class=
"org-string">"plussim;"</span>: <span class=
"org-string">"⨦"</span>,
<span class="linenr">1687: </span>  <span class=
"org-string">"plustwo;"</span>: <span class=
"org-string">"⨧"</span>,
<span class="linenr">1688: </span>  <span class=
"org-string">"precsim;"</span>: <span class=
"org-string">"≾"</span>,
<span class="linenr">1689: </span>  <span class=
"org-string">"Product;"</span>: <span class=
"org-string">"∏"</span>,
<span class="linenr">1690: </span>  <span class=
"org-string">"quatint;"</span>: <span class=
"org-string">"⨖"</span>,
<span class="linenr">1691: </span>  <span class=
"org-string">"questeq;"</span>: <span class=
"org-string">"≟"</span>,
<span class="linenr">1692: </span>  <span class=
"org-string">"rarrbfs;"</span>: <span class=
"org-string">"⤠"</span>,
<span class="linenr">1693: </span>  <span class=
"org-string">"rarrsim;"</span>: <span class=
"org-string">"⥴"</span>,
<span class="linenr">1694: </span>  <span class=
"org-string">"rbrksld;"</span>: <span class=
"org-string">"⦎"</span>,
<span class="linenr">1695: </span>  <span class=
"org-string">"rbrkslu;"</span>: <span class=
"org-string">"⦐"</span>,
<span class="linenr">1696: </span>  <span class=
"org-string">"rdldhar;"</span>: <span class=
"org-string">"⥩"</span>,
<span class="linenr">1697: </span>  <span class=
"org-string">"realine;"</span>: <span class=
"org-string">"ℛ"</span>,
<span class="linenr">1698: </span>  <span class=
"org-string">"rotimes;"</span>: <span class=
"org-string">"⨵"</span>,
<span class="linenr">1699: </span>  <span class=
"org-string">"ruluhar;"</span>: <span class=
"org-string">"⥨"</span>,
<span class="linenr">1700: </span>  <span class=
"org-string">"searrow;"</span>: <span class=
"org-string">"↘"</span>,
<span class="linenr">1701: </span>  <span class=
"org-string">"simplus;"</span>: <span class=
"org-string">"⨤"</span>,
<span class="linenr">1702: </span>  <span class=
"org-string">"simrarr;"</span>: <span class=
"org-string">"⥲"</span>,
<span class="linenr">1703: </span>  <span class=
"org-string">"subedot;"</span>: <span class=
"org-string">"⫃"</span>,
<span class="linenr">1704: </span>  <span class=
"org-string">"submult;"</span>: <span class=
"org-string">"⫁"</span>,
<span class="linenr">1705: </span>  <span class=
"org-string">"subplus;"</span>: <span class=
"org-string">"⪿"</span>,
<span class="linenr">1706: </span>  <span class=
"org-string">"subrarr;"</span>: <span class=
"org-string">"⥹"</span>,
<span class="linenr">1707: </span>  <span class=
"org-string">"succsim;"</span>: <span class=
"org-string">"≿"</span>,
<span class="linenr">1708: </span>  <span class=
"org-string">"supdsub;"</span>: <span class=
"org-string">"⫘"</span>,
<span class="linenr">1709: </span>  <span class=
"org-string">"supedot;"</span>: <span class=
"org-string">"⫄"</span>,
<span class="linenr">1710: </span>  <span class=
"org-string">"suphsol;"</span>: <span class=
"org-string">"⟉"</span>,
<span class="linenr">1711: </span>  <span class=
"org-string">"suphsub;"</span>: <span class=
"org-string">"⫗"</span>,
<span class="linenr">1712: </span>  <span class=
"org-string">"suplarr;"</span>: <span class=
"org-string">"⥻"</span>,
<span class="linenr">1713: </span>  <span class=
"org-string">"supmult;"</span>: <span class=
"org-string">"⫂"</span>,
<span class="linenr">1714: </span>  <span class=
"org-string">"supplus;"</span>: <span class=
"org-string">"⫀"</span>,
<span class="linenr">1715: </span>  <span class=
"org-string">"swarrow;"</span>: <span class=
"org-string">"↙"</span>,
<span class="linenr">1716: </span>  <span class=
"org-string">"topfork;"</span>: <span class=
"org-string">"⫚"</span>,
<span class="linenr">1717: </span>  <span class=
"org-string">"triplus;"</span>: <span class=
"org-string">"⨹"</span>,
<span class="linenr">1718: </span>  <span class=
"org-string">"tritime;"</span>: <span class=
"org-string">"⨻"</span>,
<span class="linenr">1719: </span>  <span class=
"org-string">"UpArrow;"</span>: <span class=
"org-string">"↑"</span>,
<span class="linenr">1720: </span>  <span class=
"org-string">"Uparrow;"</span>: <span class=
"org-string">"⇑"</span>,
<span class="linenr">1721: </span>  <span class=
"org-string">"uparrow;"</span>: <span class=
"org-string">"↑"</span>,
<span class="linenr">1722: </span>  <span class=
"org-string">"Upsilon;"</span>: <span class=
"org-string">"Υ"</span>,
<span class="linenr">1723: </span>  <span class=
"org-string">"upsilon;"</span>: <span class=
"org-string">"υ"</span>,
<span class="linenr">1724: </span>  <span class=
"org-string">"uwangle;"</span>: <span class=
"org-string">"⦧"</span>,
<span class="linenr">1725: </span>  <span class=
"org-string">"vzigzag;"</span>: <span class=
"org-string">"⦚"</span>,
<span class="linenr">1726: </span>  <span class=
"org-string">"zigrarr;"</span>: <span class=
"org-string">"⇝"</span>,
<span class="linenr">1727: </span>  <span class=
"org-string">"andslope;"</span>: <span class=
"org-string">"⩘"</span>,
<span class="linenr">1728: </span>  <span class=
"org-string">"angmsdaa;"</span>: <span class=
"org-string">"⦨"</span>,
<span class="linenr">1729: </span>  <span class=
"org-string">"angmsdab;"</span>: <span class=
"org-string">"⦩"</span>,
<span class="linenr">1730: </span>  <span class=
"org-string">"angmsdac;"</span>: <span class=
"org-string">"⦪"</span>,
<span class="linenr">1731: </span>  <span class=
"org-string">"angmsdad;"</span>: <span class=
"org-string">"⦫"</span>,
<span class="linenr">1732: </span>  <span class=
"org-string">"angmsdae;"</span>: <span class=
"org-string">"⦬"</span>,
<span class="linenr">1733: </span>  <span class=
"org-string">"angmsdaf;"</span>: <span class=
"org-string">"⦭"</span>,
<span class="linenr">1734: </span>  <span class=
"org-string">"angmsdag;"</span>: <span class=
"org-string">"⦮"</span>,
<span class="linenr">1735: </span>  <span class=
"org-string">"angmsdah;"</span>: <span class=
"org-string">"⦯"</span>,
<span class="linenr">1736: </span>  <span class=
"org-string">"angrtvbd;"</span>: <span class=
"org-string">"⦝"</span>,
<span class="linenr">1737: </span>  <span class=
"org-string">"approxeq;"</span>: <span class=
"org-string">"≊"</span>,
<span class="linenr">1738: </span>  <span class=
"org-string">"awconint;"</span>: <span class=
"org-string">"∳"</span>,
<span class="linenr">1739: </span>  <span class=
"org-string">"backcong;"</span>: <span class=
"org-string">"≌"</span>,
<span class="linenr">1740: </span>  <span class=
"org-string">"barwedge;"</span>: <span class=
"org-string">"⌅"</span>,
<span class="linenr">1741: </span>  <span class=
"org-string">"bbrktbrk;"</span>: <span class=
"org-string">"⎶"</span>,
<span class="linenr">1742: </span>  <span class=
"org-string">"bigoplus;"</span>: <span class=
"org-string">"⨁"</span>,
<span class="linenr">1743: </span>  <span class=
"org-string">"bigsqcup;"</span>: <span class=
"org-string">"⨆"</span>,
<span class="linenr">1744: </span>  <span class=
"org-string">"biguplus;"</span>: <span class=
"org-string">"⨄"</span>,
<span class="linenr">1745: </span>  <span class=
"org-string">"bigwedge;"</span>: <span class=
"org-string">"⋀"</span>,
<span class="linenr">1746: </span>  <span class=
"org-string">"boxminus;"</span>: <span class=
"org-string">"⊟"</span>,
<span class="linenr">1747: </span>  <span class=
"org-string">"boxtimes;"</span>: <span class=
"org-string">"⊠"</span>,
<span class="linenr">1748: </span>  <span class=
"org-string">"bsolhsub;"</span>: <span class=
"org-string">"⟈"</span>,
<span class="linenr">1749: </span>  <span class=
"org-string">"capbrcup;"</span>: <span class=
"org-string">"⩉"</span>,
<span class="linenr">1750: </span>  <span class=
"org-string">"circledR;"</span>: <span class=
"org-string">"®"</span>,
<span class="linenr">1751: </span>  <span class=
"org-string">"circledS;"</span>: <span class=
"org-string">"Ⓢ"</span>,
<span class="linenr">1752: </span>  <span class=
"org-string">"cirfnint;"</span>: <span class=
"org-string">"⨐"</span>,
<span class="linenr">1753: </span>  <span class=
"org-string">"clubsuit;"</span>: <span class=
"org-string">"♣"</span>,
<span class="linenr">1754: </span>  <span class=
"org-string">"cupbrcap;"</span>: <span class=
"org-string">"⩈"</span>,
<span class="linenr">1755: </span>  <span class=
"org-string">"curlyvee;"</span>: <span class=
"org-string">"⋎"</span>,
<span class="linenr">1756: </span>  <span class=
"org-string">"cwconint;"</span>: <span class=
"org-string">"∲"</span>,
<span class="linenr">1757: </span>  <span class=
"org-string">"DDotrahd;"</span>: <span class=
"org-string">"⤑"</span>,
<span class="linenr">1758: </span>  <span class=
"org-string">"doteqdot;"</span>: <span class=
"org-string">"≑"</span>,
<span class="linenr">1759: </span>  <span class=
"org-string">"DotEqual;"</span>: <span class=
"org-string">"≐"</span>,
<span class="linenr">1760: </span>  <span class=
"org-string">"dotminus;"</span>: <span class=
"org-string">"∸"</span>,
<span class="linenr">1761: </span>  <span class=
"org-string">"drbkarow;"</span>: <span class=
"org-string">"⤐"</span>,
<span class="linenr">1762: </span>  <span class=
"org-string">"dzigrarr;"</span>: <span class=
"org-string">"⟿"</span>,
<span class="linenr">1763: </span>  <span class=
"org-string">"elinters;"</span>: <span class=
"org-string">"⏧"</span>,
<span class="linenr">1764: </span>  <span class=
"org-string">"emptyset;"</span>: <span class=
"org-string">"∅"</span>,
<span class="linenr">1765: </span>  <span class=
"org-string">"eqvparsl;"</span>: <span class=
"org-string">"⧥"</span>,
<span class="linenr">1766: </span>  <span class=
"org-string">"fpartint;"</span>: <span class=
"org-string">"⨍"</span>,
<span class="linenr">1767: </span>  <span class=
"org-string">"geqslant;"</span>: <span class=
"org-string">"⩾"</span>,
<span class="linenr">1768: </span>  <span class=
"org-string">"gesdotol;"</span>: <span class=
"org-string">"⪄"</span>,
<span class="linenr">1769: </span>  <span class=
"org-string">"gnapprox;"</span>: <span class=
"org-string">"⪊"</span>,
<span class="linenr">1770: </span>  <span class=
"org-string">"hksearow;"</span>: <span class=
"org-string">"⤥"</span>,
<span class="linenr">1771: </span>  <span class=
"org-string">"hkswarow;"</span>: <span class=
"org-string">"⤦"</span>,
<span class="linenr">1772: </span>  <span class=
"org-string">"imagline;"</span>: <span class=
"org-string">"ℐ"</span>,
<span class="linenr">1773: </span>  <span class=
"org-string">"imagpart;"</span>: <span class=
"org-string">"ℑ"</span>,
<span class="linenr">1774: </span>  <span class=
"org-string">"infintie;"</span>: <span class=
"org-string">"⧝"</span>,
<span class="linenr">1775: </span>  <span class=
"org-string">"integers;"</span>: <span class=
"org-string">"ℤ"</span>,
<span class="linenr">1776: </span>  <span class=
"org-string">"Integral;"</span>: <span class=
"org-string">"∫"</span>,
<span class="linenr">1777: </span>  <span class=
"org-string">"intercal;"</span>: <span class=
"org-string">"⊺"</span>,
<span class="linenr">1778: </span>  <span class=
"org-string">"intlarhk;"</span>: <span class=
"org-string">"⨗"</span>,
<span class="linenr">1779: </span>  <span class=
"org-string">"laemptyv;"</span>: <span class=
"org-string">"⦴"</span>,
<span class="linenr">1780: </span>  <span class=
"org-string">"ldrushar;"</span>: <span class=
"org-string">"⥋"</span>,
<span class="linenr">1781: </span>  <span class=
"org-string">"leqslant;"</span>: <span class=
"org-string">"⩽"</span>,
<span class="linenr">1782: </span>  <span class=
"org-string">"lesdotor;"</span>: <span class=
"org-string">"⪃"</span>,
<span class="linenr">1783: </span>  <span class=
"org-string">"LessLess;"</span>: <span class=
"org-string">"⪡"</span>,
<span class="linenr">1784: </span>  <span class=
"org-string">"llcorner;"</span>: <span class=
"org-string">"⌞"</span>,
<span class="linenr">1785: </span>  <span class=
"org-string">"lnapprox;"</span>: <span class=
"org-string">"⪉"</span>,
<span class="linenr">1786: </span>  <span class=
"org-string">"lrcorner;"</span>: <span class=
"org-string">"⌟"</span>,
<span class="linenr">1787: </span>  <span class=
"org-string">"lurdshar;"</span>: <span class=
"org-string">"⥊"</span>,
<span class="linenr">1788: </span>  <span class=
"org-string">"mapstoup;"</span>: <span class=
"org-string">"↥"</span>,
<span class="linenr">1789: </span>  <span class=
"org-string">"multimap;"</span>: <span class=
"org-string">"⊸"</span>,
<span class="linenr">1790: </span>  <span class=
"org-string">"naturals;"</span>: <span class=
"org-string">"ℕ"</span>,
<span class="linenr">1791: </span>  <span class=
"org-string">"ncongdot;"</span>: <span class=
"org-string">"⩭̸"</span>,
<span class="linenr">1792: </span>  <span class=
"org-string">"NotEqual;"</span>: <span class=
"org-string">"≠"</span>,
<span class="linenr">1793: </span>  <span class=
"org-string">"notindot;"</span>: <span class=
"org-string">"⋵̸"</span>,
<span class="linenr">1794: </span>  <span class=
"org-string">"NotTilde;"</span>: <span class=
"org-string">"≁"</span>,
<span class="linenr">1795: </span>  <span class=
"org-string">"otimesas;"</span>: <span class=
"org-string">"⨶"</span>,
<span class="linenr">1796: </span>  <span class=
"org-string">"parallel;"</span>: <span class=
"org-string">"∥"</span>,
<span class="linenr">1797: </span>  <span class=
"org-string">"PartialD;"</span>: <span class=
"org-string">"∂"</span>,
<span class="linenr">1798: </span>  <span class=
"org-string">"plusacir;"</span>: <span class=
"org-string">"⨣"</span>,
<span class="linenr">1799: </span>  <span class=
"org-string">"pointint;"</span>: <span class=
"org-string">"⨕"</span>,
<span class="linenr">1800: </span>  <span class=
"org-string">"Precedes;"</span>: <span class=
"org-string">"≺"</span>,
<span class="linenr">1801: </span>  <span class=
"org-string">"precneqq;"</span>: <span class=
"org-string">"⪵"</span>,
<span class="linenr">1802: </span>  <span class=
"org-string">"precnsim;"</span>: <span class=
"org-string">"⋨"</span>,
<span class="linenr">1803: </span>  <span class=
"org-string">"profalar;"</span>: <span class=
"org-string">"⌮"</span>,
<span class="linenr">1804: </span>  <span class=
"org-string">"profline;"</span>: <span class=
"org-string">"⌒"</span>,
<span class="linenr">1805: </span>  <span class=
"org-string">"profsurf;"</span>: <span class=
"org-string">"⌓"</span>,
<span class="linenr">1806: </span>  <span class=
"org-string">"raemptyv;"</span>: <span class=
"org-string">"⦳"</span>,
<span class="linenr">1807: </span>  <span class=
"org-string">"realpart;"</span>: <span class=
"org-string">"ℜ"</span>,
<span class="linenr">1808: </span>  <span class=
"org-string">"RightTee;"</span>: <span class=
"org-string">"⊢"</span>,
<span class="linenr">1809: </span>  <span class=
"org-string">"rppolint;"</span>: <span class=
"org-string">"⨒"</span>,
<span class="linenr">1810: </span>  <span class=
"org-string">"rtriltri;"</span>: <span class=
"org-string">"⧎"</span>,
<span class="linenr">1811: </span>  <span class=
"org-string">"scpolint;"</span>: <span class=
"org-string">"⨓"</span>,
<span class="linenr">1812: </span>  <span class=
"org-string">"setminus;"</span>: <span class=
"org-string">"∖"</span>,
<span class="linenr">1813: </span>  <span class=
"org-string">"shortmid;"</span>: <span class=
"org-string">"∣"</span>,
<span class="linenr">1814: </span>  <span class=
"org-string">"smeparsl;"</span>: <span class=
"org-string">"⧤"</span>,
<span class="linenr">1815: </span>  <span class=
"org-string">"sqsubset;"</span>: <span class=
"org-string">"⊏"</span>,
<span class="linenr">1816: </span>  <span class=
"org-string">"sqsupset;"</span>: <span class=
"org-string">"⊐"</span>,
<span class="linenr">1817: </span>  <span class=
"org-string">"subseteq;"</span>: <span class=
"org-string">"⊆"</span>,
<span class="linenr">1818: </span>  <span class=
"org-string">"Succeeds;"</span>: <span class=
"org-string">"≻"</span>,
<span class="linenr">1819: </span>  <span class=
"org-string">"succneqq;"</span>: <span class=
"org-string">"⪶"</span>,
<span class="linenr">1820: </span>  <span class=
"org-string">"succnsim;"</span>: <span class=
"org-string">"⋩"</span>,
<span class="linenr">1821: </span>  <span class=
"org-string">"SuchThat;"</span>: <span class=
"org-string">"∋"</span>,
<span class="linenr">1822: </span>  <span class=
"org-string">"Superset;"</span>: <span class=
"org-string">"⊃"</span>,
<span class="linenr">1823: </span>  <span class=
"org-string">"supseteq;"</span>: <span class=
"org-string">"⊇"</span>,
<span class="linenr">1824: </span>  <span class=
"org-string">"thetasym;"</span>: <span class=
"org-string">"ϑ"</span>,
<span class="linenr">1825: </span>  <span class=
"org-string">"thicksim;"</span>: <span class=
"org-string">"∼"</span>,
<span class="linenr">1826: </span>  <span class=
"org-string">"timesbar;"</span>: <span class=
"org-string">"⨱"</span>,
<span class="linenr">1827: </span>  <span class=
"org-string">"triangle;"</span>: <span class=
"org-string">"▵"</span>,
<span class="linenr">1828: </span>  <span class=
"org-string">"triminus;"</span>: <span class=
"org-string">"⨺"</span>,
<span class="linenr">1829: </span>  <span class=
"org-string">"trpezium;"</span>: <span class=
"org-string">"⏢"</span>,
<span class="linenr">1830: </span>  <span class=
"org-string">"Uarrocir;"</span>: <span class=
"org-string">"⥉"</span>,
<span class="linenr">1831: </span>  <span class=
"org-string">"ulcorner;"</span>: <span class=
"org-string">"⌜"</span>,
<span class="linenr">1832: </span>  <span class=
"org-string">"UnderBar;"</span>: <span class=
"org-string">"_"</span>,
<span class="linenr">1833: </span>  <span class=
"org-string">"urcorner;"</span>: <span class=
"org-string">"⌝"</span>,
<span class="linenr">1834: </span>  <span class=
"org-string">"varkappa;"</span>: <span class=
"org-string">"ϰ"</span>,
<span class="linenr">1835: </span>  <span class=
"org-string">"varsigma;"</span>: <span class=
"org-string">"ς"</span>,
<span class="linenr">1836: </span>  <span class=
"org-string">"vartheta;"</span>: <span class=
"org-string">"ϑ"</span>,
<span class="linenr">1837: </span>  <span class=
"org-string">"backprime;"</span>: <span class=
"org-string">"‵"</span>,
<span class="linenr">1838: </span>  <span class=
"org-string">"backsimeq;"</span>: <span class=
"org-string">"⋍"</span>,
<span class="linenr">1839: </span>  <span class=
"org-string">"Backslash;"</span>: <span class=
"org-string">"∖"</span>,
<span class="linenr">1840: </span>  <span class=
"org-string">"bigotimes;"</span>: <span class=
"org-string">"⨂"</span>,
<span class="linenr">1841: </span>  <span class=
"org-string">"CenterDot;"</span>: <span class=
"org-string">"·"</span>,
<span class="linenr">1842: </span>  <span class=
"org-string">"centerdot;"</span>: <span class=
"org-string">"·"</span>,
<span class="linenr">1843: </span>  <span class=
"org-string">"checkmark;"</span>: <span class=
"org-string">"✓"</span>,
<span class="linenr">1844: </span>  <span class=
"org-string">"CircleDot;"</span>: <span class=
"org-string">"⊙"</span>,
<span class="linenr">1845: </span>  <span class=
"org-string">"complexes;"</span>: <span class=
"org-string">"ℂ"</span>,
<span class="linenr">1846: </span>  <span class=
"org-string">"Congruent;"</span>: <span class=
"org-string">"≡"</span>,
<span class="linenr">1847: </span>  <span class=
"org-string">"Coproduct;"</span>: <span class=
"org-string">"∐"</span>,
<span class="linenr">1848: </span>  <span class=
"org-string">"dotsquare;"</span>: <span class=
"org-string">"⊡"</span>,
<span class="linenr">1849: </span>  <span class=
"org-string">"DoubleDot;"</span>: <span class=
"org-string">"¨"</span>,
<span class="linenr">1850: </span>  <span class=
"org-string">"DownArrow;"</span>: <span class=
"org-string">"↓"</span>,
<span class="linenr">1851: </span>  <span class=
"org-string">"Downarrow;"</span>: <span class=
"org-string">"⇓"</span>,
<span class="linenr">1852: </span>  <span class=
"org-string">"downarrow;"</span>: <span class=
"org-string">"↓"</span>,
<span class="linenr">1853: </span>  <span class=
"org-string">"DownBreve;"</span>: <span class=
"org-string">"̑"</span>,
<span class="linenr">1854: </span>  <span class=
"org-string">"gtrapprox;"</span>: <span class=
"org-string">"⪆"</span>,
<span class="linenr">1855: </span>  <span class=
"org-string">"gtreqless;"</span>: <span class=
"org-string">"⋛"</span>,
<span class="linenr">1856: </span>  <span class=
"org-string">"gvertneqq;"</span>: <span class=
"org-string">"≩︀"</span>,
<span class="linenr">1857: </span>  <span class=
"org-string">"heartsuit;"</span>: <span class=
"org-string">"♥"</span>,
<span class="linenr">1858: </span>  <span class=
"org-string">"HumpEqual;"</span>: <span class=
"org-string">"≏"</span>,
<span class="linenr">1859: </span>  <span class=
"org-string">"LeftArrow;"</span>: <span class=
"org-string">"←"</span>,
<span class="linenr">1860: </span>  <span class=
"org-string">"Leftarrow;"</span>: <span class=
"org-string">"⇐"</span>,
<span class="linenr">1861: </span>  <span class=
"org-string">"leftarrow;"</span>: <span class=
"org-string">"←"</span>,
<span class="linenr">1862: </span>  <span class=
"org-string">"LeftFloor;"</span>: <span class=
"org-string">"⌊"</span>,
<span class="linenr">1863: </span>  <span class=
"org-string">"lesseqgtr;"</span>: <span class=
"org-string">"⋚"</span>,
<span class="linenr">1864: </span>  <span class=
"org-string">"LessTilde;"</span>: <span class=
"org-string">"≲"</span>,
<span class="linenr">1865: </span>  <span class=
"org-string">"lvertneqq;"</span>: <span class=
"org-string">"≨︀"</span>,
<span class="linenr">1866: </span>  <span class=
"org-string">"Mellintrf;"</span>: <span class=
"org-string">"ℳ"</span>,
<span class="linenr">1867: </span>  <span class=
"org-string">"MinusPlus;"</span>: <span class=
"org-string">"∓"</span>,
<span class="linenr">1868: </span>  <span class=
"org-string">"ngeqslant;"</span>: <span class=
"org-string">"⩾̸"</span>,
<span class="linenr">1869: </span>  <span class=
"org-string">"nleqslant;"</span>: <span class=
"org-string">"⩽̸"</span>,
<span class="linenr">1870: </span>  <span class=
"org-string">"NotCupCap;"</span>: <span class=
"org-string">"≭"</span>,
<span class="linenr">1871: </span>  <span class=
"org-string">"NotExists;"</span>: <span class=
"org-string">"∄"</span>,
<span class="linenr">1872: </span>  <span class=
"org-string">"NotSubset;"</span>: <span class=
"org-string">"⊂⃒"</span>,
<span class="linenr">1873: </span>  <span class=
"org-string">"nparallel;"</span>: <span class=
"org-string">"∦"</span>,
<span class="linenr">1874: </span>  <span class=
"org-string">"nshortmid;"</span>: <span class=
"org-string">"∤"</span>,
<span class="linenr">1875: </span>  <span class=
"org-string">"nsubseteq;"</span>: <span class=
"org-string">"⊈"</span>,
<span class="linenr">1876: </span>  <span class=
"org-string">"nsupseteq;"</span>: <span class=
"org-string">"⊉"</span>,
<span class="linenr">1877: </span>  <span class=
"org-string">"OverBrace;"</span>: <span class=
"org-string">"⏞"</span>,
<span class="linenr">1878: </span>  <span class=
"org-string">"pitchfork;"</span>: <span class=
"org-string">"⋔"</span>,
<span class="linenr">1879: </span>  <span class=
"org-string">"PlusMinus;"</span>: <span class=
"org-string">"±"</span>,
<span class="linenr">1880: </span>  <span class=
"org-string">"rationals;"</span>: <span class=
"org-string">"ℚ"</span>,
<span class="linenr">1881: </span>  <span class=
"org-string">"spadesuit;"</span>: <span class=
"org-string">"♠"</span>,
<span class="linenr">1882: </span>  <span class=
"org-string">"subseteqq;"</span>: <span class=
"org-string">"⫅"</span>,
<span class="linenr">1883: </span>  <span class=
"org-string">"subsetneq;"</span>: <span class=
"org-string">"⊊"</span>,
<span class="linenr">1884: </span>  <span class=
"org-string">"supseteqq;"</span>: <span class=
"org-string">"⫆"</span>,
<span class="linenr">1885: </span>  <span class=
"org-string">"supsetneq;"</span>: <span class=
"org-string">"⊋"</span>,
<span class="linenr">1886: </span>  <span class=
"org-string">"Therefore;"</span>: <span class=
"org-string">"∴"</span>,
<span class="linenr">1887: </span>  <span class=
"org-string">"therefore;"</span>: <span class=
"org-string">"∴"</span>,
<span class="linenr">1888: </span>  <span class=
"org-string">"ThinSpace;"</span>: <span class=
"org-string">" "</span>,
<span class="linenr">1889: </span>  <span class=
"org-string">"triangleq;"</span>: <span class=
"org-string">"≜"</span>,
<span class="linenr">1890: </span>  <span class=
"org-string">"TripleDot;"</span>: <span class=
"org-string">"⃛"</span>,
<span class="linenr">1891: </span>  <span class=
"org-string">"UnionPlus;"</span>: <span class=
"org-string">"⊎"</span>,
<span class="linenr">1892: </span>  <span class=
"org-string">"varpropto;"</span>: <span class=
"org-string">"∝"</span>,
<span class="linenr">1893: </span>  <span class=
"org-string">"Bernoullis;"</span>: <span class=
"org-string">"ℬ"</span>,
<span class="linenr">1894: </span>  <span class=
"org-string">"circledast;"</span>: <span class=
"org-string">"⊛"</span>,
<span class="linenr">1895: </span>  <span class=
"org-string">"CirclePlus;"</span>: <span class=
"org-string">"⊕"</span>,
<span class="linenr">1896: </span>  <span class=
"org-string">"complement;"</span>: <span class=
"org-string">"∁"</span>,
<span class="linenr">1897: </span>  <span class=
"org-string">"curlywedge;"</span>: <span class=
"org-string">"⋏"</span>,
<span class="linenr">1898: </span>  <span class=
"org-string">"eqslantgtr;"</span>: <span class=
"org-string">"⪖"</span>,
<span class="linenr">1899: </span>  <span class=
"org-string">"EqualTilde;"</span>: <span class=
"org-string">"≂"</span>,
<span class="linenr">1900: </span>  <span class=
"org-string">"Fouriertrf;"</span>: <span class=
"org-string">"ℱ"</span>,
<span class="linenr">1901: </span>  <span class=
"org-string">"gtreqqless;"</span>: <span class=
"org-string">"⪌"</span>,
<span class="linenr">1902: </span>  <span class=
"org-string">"ImaginaryI;"</span>: <span class=
"org-string">"ⅈ"</span>,
<span class="linenr">1903: </span>  <span class=
"org-string">"Laplacetrf;"</span>: <span class=
"org-string">"ℒ"</span>,
<span class="linenr">1904: </span>  <span class=
"org-string">"LeftVector;"</span>: <span class=
"org-string">"↼"</span>,
<span class="linenr">1905: </span>  <span class=
"org-string">"lessapprox;"</span>: <span class=
"org-string">"⪅"</span>,
<span class="linenr">1906: </span>  <span class=
"org-string">"lesseqqgtr;"</span>: <span class=
"org-string">"⪋"</span>,
<span class="linenr">1907: </span>  <span class=
"org-string">"Lleftarrow;"</span>: <span class=
"org-string">"⇚"</span>,
<span class="linenr">1908: </span>  <span class=
"org-string">"lmoustache;"</span>: <span class=
"org-string">"⎰"</span>,
<span class="linenr">1909: </span>  <span class=
"org-string">"longmapsto;"</span>: <span class=
"org-string">"⟼"</span>,
<span class="linenr">1910: </span>  <span class=
"org-string">"mapstodown;"</span>: <span class=
"org-string">"↧"</span>,
<span class="linenr">1911: </span>  <span class=
"org-string">"mapstoleft;"</span>: <span class=
"org-string">"↤"</span>,
<span class="linenr">1912: </span>  <span class=
"org-string">"nLeftarrow;"</span>: <span class=
"org-string">"⇍"</span>,
<span class="linenr">1913: </span>  <span class=
"org-string">"nleftarrow;"</span>: <span class=
"org-string">"↚"</span>,
<span class="linenr">1914: </span>  <span class=
"org-string">"NotElement;"</span>: <span class=
"org-string">"∉"</span>,
<span class="linenr">1915: </span>  <span class=
"org-string">"NotGreater;"</span>: <span class=
"org-string">"≯"</span>,
<span class="linenr">1916: </span>  <span class=
"org-string">"nsubseteqq;"</span>: <span class=
"org-string">"⫅̸"</span>,
<span class="linenr">1917: </span>  <span class=
"org-string">"nsupseteqq;"</span>: <span class=
"org-string">"⫆̸"</span>,
<span class="linenr">1918: </span>  <span class=
"org-string">"precapprox;"</span>: <span class=
"org-string">"⪷"</span>,
<span class="linenr">1919: </span>  <span class=
"org-string">"Proportion;"</span>: <span class=
"org-string">"∷"</span>,
<span class="linenr">1920: </span>  <span class=
"org-string">"RightArrow;"</span>: <span class=
"org-string">"→"</span>,
<span class="linenr">1921: </span>  <span class=
"org-string">"Rightarrow;"</span>: <span class=
"org-string">"⇒"</span>,
<span class="linenr">1922: </span>  <span class=
"org-string">"rightarrow;"</span>: <span class=
"org-string">"→"</span>,
<span class="linenr">1923: </span>  <span class=
"org-string">"RightFloor;"</span>: <span class=
"org-string">"⌋"</span>,
<span class="linenr">1924: </span>  <span class=
"org-string">"rmoustache;"</span>: <span class=
"org-string">"⎱"</span>,
<span class="linenr">1925: </span>  <span class=
"org-string">"sqsubseteq;"</span>: <span class=
"org-string">"⊑"</span>,
<span class="linenr">1926: </span>  <span class=
"org-string">"sqsupseteq;"</span>: <span class=
"org-string">"⊒"</span>,
<span class="linenr">1927: </span>  <span class=
"org-string">"subsetneqq;"</span>: <span class=
"org-string">"⫋"</span>,
<span class="linenr">1928: </span>  <span class=
"org-string">"succapprox;"</span>: <span class=
"org-string">"⪸"</span>,
<span class="linenr">1929: </span>  <span class=
"org-string">"supsetneqq;"</span>: <span class=
"org-string">"⫌"</span>,
<span class="linenr">1930: </span>  <span class=
"org-string">"ThickSpace;"</span>: <span class=
"org-string">"  "</span>,
<span class="linenr">1931: </span>  <span class=
"org-string">"TildeEqual;"</span>: <span class=
"org-string">"≃"</span>,
<span class="linenr">1932: </span>  <span class=
"org-string">"TildeTilde;"</span>: <span class=
"org-string">"≈"</span>,
<span class="linenr">1933: </span>  <span class=
"org-string">"UnderBrace;"</span>: <span class=
"org-string">"⏟"</span>,
<span class="linenr">1934: </span>  <span class=
"org-string">"UpArrowBar;"</span>: <span class=
"org-string">"⤒"</span>,
<span class="linenr">1935: </span>  <span class=
"org-string">"UpTeeArrow;"</span>: <span class=
"org-string">"↥"</span>,
<span class="linenr">1936: </span>  <span class=
"org-string">"upuparrows;"</span>: <span class=
"org-string">"⇈"</span>,
<span class="linenr">1937: </span>  <span class=
"org-string">"varepsilon;"</span>: <span class=
"org-string">"ϵ"</span>,
<span class="linenr">1938: </span>  <span class=
"org-string">"varnothing;"</span>: <span class=
"org-string">"∅"</span>,
<span class="linenr">1939: </span>  <span class=
"org-string">"backepsilon;"</span>: <span class=
"org-string">"϶"</span>,
<span class="linenr">1940: </span>  <span class=
"org-string">"blacksquare;"</span>: <span class=
"org-string">"▪"</span>,
<span class="linenr">1941: </span>  <span class=
"org-string">"circledcirc;"</span>: <span class=
"org-string">"⊚"</span>,
<span class="linenr">1942: </span>  <span class=
"org-string">"circleddash;"</span>: <span class=
"org-string">"⊝"</span>,
<span class="linenr">1943: </span>  <span class=
"org-string">"CircleMinus;"</span>: <span class=
"org-string">"⊖"</span>,
<span class="linenr">1944: </span>  <span class=
"org-string">"CircleTimes;"</span>: <span class=
"org-string">"⊗"</span>,
<span class="linenr">1945: </span>  <span class=
"org-string">"curlyeqprec;"</span>: <span class=
"org-string">"⋞"</span>,
<span class="linenr">1946: </span>  <span class=
"org-string">"curlyeqsucc;"</span>: <span class=
"org-string">"⋟"</span>,
<span class="linenr">1947: </span>  <span class=
"org-string">"diamondsuit;"</span>: <span class=
"org-string">"♦"</span>,
<span class="linenr">1948: </span>  <span class=
"org-string">"eqslantless;"</span>: <span class=
"org-string">"⪕"</span>,
<span class="linenr">1949: </span>  <span class=
"org-string">"Equilibrium;"</span>: <span class=
"org-string">"⇌"</span>,
<span class="linenr">1950: </span>  <span class=
"org-string">"expectation;"</span>: <span class=
"org-string">"ℰ"</span>,
<span class="linenr">1951: </span>  <span class=
"org-string">"GreaterLess;"</span>: <span class=
"org-string">"≷"</span>,
<span class="linenr">1952: </span>  <span class=
"org-string">"LeftCeiling;"</span>: <span class=
"org-string">"⌈"</span>,
<span class="linenr">1953: </span>  <span class=
"org-string">"LessGreater;"</span>: <span class=
"org-string">"≶"</span>,
<span class="linenr">1954: </span>  <span class=
"org-string">"MediumSpace;"</span>: <span class=
"org-string">" "</span>,
<span class="linenr">1955: </span>  <span class=
"org-string">"NotLessLess;"</span>: <span class=
"org-string">"≪̸"</span>,
<span class="linenr">1956: </span>  <span class=
"org-string">"NotPrecedes;"</span>: <span class=
"org-string">"⊀"</span>,
<span class="linenr">1957: </span>  <span class=
"org-string">"NotSucceeds;"</span>: <span class=
"org-string">"⊁"</span>,
<span class="linenr">1958: </span>  <span class=
"org-string">"NotSuperset;"</span>: <span class=
"org-string">"⊃⃒"</span>,
<span class="linenr">1959: </span>  <span class=
"org-string">"nRightarrow;"</span>: <span class=
"org-string">"⇏"</span>,
<span class="linenr">1960: </span>  <span class=
"org-string">"nrightarrow;"</span>: <span class=
"org-string">"↛"</span>,
<span class="linenr">1961: </span>  <span class=
"org-string">"OverBracket;"</span>: <span class=
"org-string">"⎴"</span>,
<span class="linenr">1962: </span>  <span class=
"org-string">"preccurlyeq;"</span>: <span class=
"org-string">"≼"</span>,
<span class="linenr">1963: </span>  <span class=
"org-string">"precnapprox;"</span>: <span class=
"org-string">"⪹"</span>,
<span class="linenr">1964: </span>  <span class=
"org-string">"quaternions;"</span>: <span class=
"org-string">"ℍ"</span>,
<span class="linenr">1965: </span>  <span class=
"org-string">"RightVector;"</span>: <span class=
"org-string">"⇀"</span>,
<span class="linenr">1966: </span>  <span class=
"org-string">"Rrightarrow;"</span>: <span class=
"org-string">"⇛"</span>,
<span class="linenr">1967: </span>  <span class=
"org-string">"RuleDelayed;"</span>: <span class=
"org-string">"⧴"</span>,
<span class="linenr">1968: </span>  <span class=
"org-string">"SmallCircle;"</span>: <span class=
"org-string">"∘"</span>,
<span class="linenr">1969: </span>  <span class=
"org-string">"SquareUnion;"</span>: <span class=
"org-string">"⊔"</span>,
<span class="linenr">1970: </span>  <span class=
"org-string">"straightphi;"</span>: <span class=
"org-string">"ϕ"</span>,
<span class="linenr">1971: </span>  <span class=
"org-string">"SubsetEqual;"</span>: <span class=
"org-string">"⊆"</span>,
<span class="linenr">1972: </span>  <span class=
"org-string">"succcurlyeq;"</span>: <span class=
"org-string">"≽"</span>,
<span class="linenr">1973: </span>  <span class=
"org-string">"succnapprox;"</span>: <span class=
"org-string">"⪺"</span>,
<span class="linenr">1974: </span>  <span class=
"org-string">"thickapprox;"</span>: <span class=
"org-string">"≈"</span>,
<span class="linenr">1975: </span>  <span class=
"org-string">"UpDownArrow;"</span>: <span class=
"org-string">"↕"</span>,
<span class="linenr">1976: </span>  <span class=
"org-string">"Updownarrow;"</span>: <span class=
"org-string">"⇕"</span>,
<span class="linenr">1977: </span>  <span class=
"org-string">"updownarrow;"</span>: <span class=
"org-string">"↕"</span>,
<span class="linenr">1978: </span>  <span class=
"org-string">"VerticalBar;"</span>: <span class=
"org-string">"∣"</span>,
<span class="linenr">1979: </span>  <span class=
"org-string">"blacklozenge;"</span>: <span class=
"org-string">"⧫"</span>,
<span class="linenr">1980: </span>  <span class=
"org-string">"DownArrowBar;"</span>: <span class=
"org-string">"⤓"</span>,
<span class="linenr">1981: </span>  <span class=
"org-string">"DownTeeArrow;"</span>: <span class=
"org-string">"↧"</span>,
<span class="linenr">1982: </span>  <span class=
"org-string">"ExponentialE;"</span>: <span class=
"org-string">"ⅇ"</span>,
<span class="linenr">1983: </span>  <span class=
"org-string">"exponentiale;"</span>: <span class=
"org-string">"ⅇ"</span>,
<span class="linenr">1984: </span>  <span class=
"org-string">"GreaterEqual;"</span>: <span class=
"org-string">"≥"</span>,
<span class="linenr">1985: </span>  <span class=
"org-string">"GreaterTilde;"</span>: <span class=
"org-string">"≳"</span>,
<span class="linenr">1986: </span>  <span class=
"org-string">"HilbertSpace;"</span>: <span class=
"org-string">"ℋ"</span>,
<span class="linenr">1987: </span>  <span class=
"org-string">"HumpDownHump;"</span>: <span class=
"org-string">"≎"</span>,
<span class="linenr">1988: </span>  <span class=
"org-string">"Intersection;"</span>: <span class=
"org-string">"⋂"</span>,
<span class="linenr">1989: </span>  <span class=
"org-string">"LeftArrowBar;"</span>: <span class=
"org-string">"⇤"</span>,
<span class="linenr">1990: </span>  <span class=
"org-string">"LeftTeeArrow;"</span>: <span class=
"org-string">"↤"</span>,
<span class="linenr">1991: </span>  <span class=
"org-string">"LeftTriangle;"</span>: <span class=
"org-string">"⊲"</span>,
<span class="linenr">1992: </span>  <span class=
"org-string">"LeftUpVector;"</span>: <span class=
"org-string">"↿"</span>,
<span class="linenr">1993: </span>  <span class=
"org-string">"NotCongruent;"</span>: <span class=
"org-string">"≢"</span>,
<span class="linenr">1994: </span>  <span class=
"org-string">"NotHumpEqual;"</span>: <span class=
"org-string">"≏̸"</span>,
<span class="linenr">1995: </span>  <span class=
"org-string">"NotLessEqual;"</span>: <span class=
"org-string">"≰"</span>,
<span class="linenr">1996: </span>  <span class=
"org-string">"NotLessTilde;"</span>: <span class=
"org-string">"≴"</span>,
<span class="linenr">1997: </span>  <span class=
"org-string">"Proportional;"</span>: <span class=
"org-string">"∝"</span>,
<span class="linenr">1998: </span>  <span class=
"org-string">"RightCeiling;"</span>: <span class=
"org-string">"⌉"</span>,
<span class="linenr">1999: </span>  <span class=
"org-string">"risingdotseq;"</span>: <span class=
"org-string">"≓"</span>,
<span class="linenr">2000: </span>  <span class=
"org-string">"RoundImplies;"</span>: <span class=
"org-string">"⥰"</span>,
<span class="linenr">2001: </span>  <span class=
"org-string">"ShortUpArrow;"</span>: <span class=
"org-string">"↑"</span>,
<span class="linenr">2002: </span>  <span class=
"org-string">"SquareSubset;"</span>: <span class=
"org-string">"⊏"</span>,
<span class="linenr">2003: </span>  <span class=
"org-string">"triangledown;"</span>: <span class=
"org-string">"▿"</span>,
<span class="linenr">2004: </span>  <span class=
"org-string">"triangleleft;"</span>: <span class=
"org-string">"◃"</span>,
<span class="linenr">2005: </span>  <span class=
"org-string">"UnderBracket;"</span>: <span class=
"org-string">"⎵"</span>,
<span class="linenr">2006: </span>  <span class=
"org-string">"varsubsetneq;"</span>: <span class=
"org-string">"⊊︀"</span>,
<span class="linenr">2007: </span>  <span class=
"org-string">"varsupsetneq;"</span>: <span class=
"org-string">"⊋︀"</span>,
<span class="linenr">2008: </span>  <span class=
"org-string">"VerticalLine;"</span>: <span class=
"org-string">"|"</span>,
<span class="linenr">2009: </span>  <span class=
"org-string">"ApplyFunction;"</span>: <span class=
"org-string">"⁡"</span>,
<span class="linenr">2010: </span>  <span class=
"org-string">"bigtriangleup;"</span>: <span class=
"org-string">"△"</span>,
<span class="linenr">2011: </span>  <span class=
"org-string">"blacktriangle;"</span>: <span class=
"org-string">"▴"</span>,
<span class="linenr">2012: </span>  <span class=
"org-string">"DifferentialD;"</span>: <span class=
"org-string">"ⅆ"</span>,
<span class="linenr">2013: </span>  <span class=
"org-string">"divideontimes;"</span>: <span class=
"org-string">"⋇"</span>,
<span class="linenr">2014: </span>  <span class=
"org-string">"DoubleLeftTee;"</span>: <span class=
"org-string">"⫤"</span>,
<span class="linenr">2015: </span>  <span class=
"org-string">"DoubleUpArrow;"</span>: <span class=
"org-string">"⇑"</span>,
<span class="linenr">2016: </span>  <span class=
"org-string">"fallingdotseq;"</span>: <span class=
"org-string">"≒"</span>,
<span class="linenr">2017: </span>  <span class=
"org-string">"hookleftarrow;"</span>: <span class=
"org-string">"↩"</span>,
<span class="linenr">2018: </span>  <span class=
"org-string">"leftarrowtail;"</span>: <span class=
"org-string">"↢"</span>,
<span class="linenr">2019: </span>  <span class=
"org-string">"leftharpoonup;"</span>: <span class=
"org-string">"↼"</span>,
<span class="linenr">2020: </span>  <span class=
"org-string">"LeftTeeVector;"</span>: <span class=
"org-string">"⥚"</span>,
<span class="linenr">2021: </span>  <span class=
"org-string">"LeftVectorBar;"</span>: <span class=
"org-string">"⥒"</span>,
<span class="linenr">2022: </span>  <span class=
"org-string">"LessFullEqual;"</span>: <span class=
"org-string">"≦"</span>,
<span class="linenr">2023: </span>  <span class=
"org-string">"LongLeftArrow;"</span>: <span class=
"org-string">"⟵"</span>,
<span class="linenr">2024: </span>  <span class=
"org-string">"Longleftarrow;"</span>: <span class=
"org-string">"⟸"</span>,
<span class="linenr">2025: </span>  <span class=
"org-string">"longleftarrow;"</span>: <span class=
"org-string">"⟵"</span>,
<span class="linenr">2026: </span>  <span class=
"org-string">"looparrowleft;"</span>: <span class=
"org-string">"↫"</span>,
<span class="linenr">2027: </span>  <span class=
"org-string">"measuredangle;"</span>: <span class=
"org-string">"∡"</span>,
<span class="linenr">2028: </span>  <span class=
"org-string">"NotEqualTilde;"</span>: <span class=
"org-string">"≂̸"</span>,
<span class="linenr">2029: </span>  <span class=
"org-string">"NotTildeEqual;"</span>: <span class=
"org-string">"≄"</span>,
<span class="linenr">2030: </span>  <span class=
"org-string">"NotTildeTilde;"</span>: <span class=
"org-string">"≉"</span>,
<span class="linenr">2031: </span>  <span class=
"org-string">"ntriangleleft;"</span>: <span class=
"org-string">"⋪"</span>,
<span class="linenr">2032: </span>  <span class=
"org-string">"Poincareplane;"</span>: <span class=
"org-string">"ℌ"</span>,
<span class="linenr">2033: </span>  <span class=
"org-string">"PrecedesEqual;"</span>: <span class=
"org-string">"⪯"</span>,
<span class="linenr">2034: </span>  <span class=
"org-string">"PrecedesTilde;"</span>: <span class=
"org-string">"≾"</span>,
<span class="linenr">2035: </span>  <span class=
"org-string">"RightArrowBar;"</span>: <span class=
"org-string">"⇥"</span>,
<span class="linenr">2036: </span>  <span class=
"org-string">"RightTeeArrow;"</span>: <span class=
"org-string">"↦"</span>,
<span class="linenr">2037: </span>  <span class=
"org-string">"RightTriangle;"</span>: <span class=
"org-string">"⊳"</span>,
<span class="linenr">2038: </span>  <span class=
"org-string">"RightUpVector;"</span>: <span class=
"org-string">"↾"</span>,
<span class="linenr">2039: </span>  <span class=
"org-string">"shortparallel;"</span>: <span class=
"org-string">"∥"</span>,
<span class="linenr">2040: </span>  <span class=
"org-string">"smallsetminus;"</span>: <span class=
"org-string">"∖"</span>,
<span class="linenr">2041: </span>  <span class=
"org-string">"SucceedsEqual;"</span>: <span class=
"org-string">"⪰"</span>,
<span class="linenr">2042: </span>  <span class=
"org-string">"SucceedsTilde;"</span>: <span class=
"org-string">"≿"</span>,
<span class="linenr">2043: </span>  <span class=
"org-string">"SupersetEqual;"</span>: <span class=
"org-string">"⊇"</span>,
<span class="linenr">2044: </span>  <span class=
"org-string">"triangleright;"</span>: <span class=
"org-string">"▹"</span>,
<span class="linenr">2045: </span>  <span class=
"org-string">"UpEquilibrium;"</span>: <span class=
"org-string">"⥮"</span>,
<span class="linenr">2046: </span>  <span class=
"org-string">"upharpoonleft;"</span>: <span class=
"org-string">"↿"</span>,
<span class="linenr">2047: </span>  <span class=
"org-string">"varsubsetneqq;"</span>: <span class=
"org-string">"⫋︀"</span>,
<span class="linenr">2048: </span>  <span class=
"org-string">"varsupsetneqq;"</span>: <span class=
"org-string">"⫌︀"</span>,
<span class="linenr">2049: </span>  <span class=
"org-string">"VerticalTilde;"</span>: <span class=
"org-string">"≀"</span>,
<span class="linenr">2050: </span>  <span class=
"org-string">"VeryThinSpace;"</span>: <span class=
"org-string">" "</span>,
<span class="linenr">2051: </span>  <span class=
"org-string">"curvearrowleft;"</span>: <span class=
"org-string">"↶"</span>,
<span class="linenr">2052: </span>  <span class=
"org-string">"DiacriticalDot;"</span>: <span class=
"org-string">"˙"</span>,
<span class="linenr">2053: </span>  <span class=
"org-string">"doublebarwedge;"</span>: <span class=
"org-string">"⌆"</span>,
<span class="linenr">2054: </span>  <span class=
"org-string">"DoubleRightTee;"</span>: <span class=
"org-string">"⊨"</span>,
<span class="linenr">2055: </span>  <span class=
"org-string">"downdownarrows;"</span>: <span class=
"org-string">"⇊"</span>,
<span class="linenr">2056: </span>  <span class=
"org-string">"DownLeftVector;"</span>: <span class=
"org-string">"↽"</span>,
<span class="linenr">2057: </span>  <span class=
"org-string">"GreaterGreater;"</span>: <span class=
"org-string">"⪢"</span>,
<span class="linenr">2058: </span>  <span class=
"org-string">"hookrightarrow;"</span>: <span class=
"org-string">"↪"</span>,
<span class="linenr">2059: </span>  <span class=
"org-string">"HorizontalLine;"</span>: <span class=
"org-string">"─"</span>,
<span class="linenr">2060: </span>  <span class=
"org-string">"InvisibleComma;"</span>: <span class=
"org-string">"⁣"</span>,
<span class="linenr">2061: </span>  <span class=
"org-string">"InvisibleTimes;"</span>: <span class=
"org-string">"⁢"</span>,
<span class="linenr">2062: </span>  <span class=
"org-string">"LeftDownVector;"</span>: <span class=
"org-string">"⇃"</span>,
<span class="linenr">2063: </span>  <span class=
"org-string">"leftleftarrows;"</span>: <span class=
"org-string">"⇇"</span>,
<span class="linenr">2064: </span>  <span class=
"org-string">"LeftRightArrow;"</span>: <span class=
"org-string">"↔"</span>,
<span class="linenr">2065: </span>  <span class=
"org-string">"Leftrightarrow;"</span>: <span class=
"org-string">"⇔"</span>,
<span class="linenr">2066: </span>  <span class=
"org-string">"leftrightarrow;"</span>: <span class=
"org-string">"↔"</span>,
<span class="linenr">2067: </span>  <span class=
"org-string">"leftthreetimes;"</span>: <span class=
"org-string">"⋋"</span>,
<span class="linenr">2068: </span>  <span class=
"org-string">"LessSlantEqual;"</span>: <span class=
"org-string">"⩽"</span>,
<span class="linenr">2069: </span>  <span class=
"org-string">"LongRightArrow;"</span>: <span class=
"org-string">"⟶"</span>,
<span class="linenr">2070: </span>  <span class=
"org-string">"Longrightarrow;"</span>: <span class=
"org-string">"⟹"</span>,
<span class="linenr">2071: </span>  <span class=
"org-string">"longrightarrow;"</span>: <span class=
"org-string">"⟶"</span>,
<span class="linenr">2072: </span>  <span class=
"org-string">"looparrowright;"</span>: <span class=
"org-string">"↬"</span>,
<span class="linenr">2073: </span>  <span class=
"org-string">"LowerLeftArrow;"</span>: <span class=
"org-string">"↙"</span>,
<span class="linenr">2074: </span>  <span class=
"org-string">"NestedLessLess;"</span>: <span class=
"org-string">"≪"</span>,
<span class="linenr">2075: </span>  <span class=
"org-string">"NotGreaterLess;"</span>: <span class=
"org-string">"≹"</span>,
<span class="linenr">2076: </span>  <span class=
"org-string">"NotLessGreater;"</span>: <span class=
"org-string">"≸"</span>,
<span class="linenr">2077: </span>  <span class=
"org-string">"NotSubsetEqual;"</span>: <span class=
"org-string">"⊈"</span>,
<span class="linenr">2078: </span>  <span class=
"org-string">"NotVerticalBar;"</span>: <span class=
"org-string">"∤"</span>,
<span class="linenr">2079: </span>  <span class=
"org-string">"nshortparallel;"</span>: <span class=
"org-string">"∦"</span>,
<span class="linenr">2080: </span>  <span class=
"org-string">"ntriangleright;"</span>: <span class=
"org-string">"⋫"</span>,
<span class="linenr">2081: </span>  <span class=
"org-string">"OpenCurlyQuote;"</span>: <span class=
"org-string">"‘"</span>,
<span class="linenr">2082: </span>  <span class=
"org-string">"ReverseElement;"</span>: <span class=
"org-string">"∋"</span>,
<span class="linenr">2083: </span>  <span class=
"org-string">"rightarrowtail;"</span>: <span class=
"org-string">"↣"</span>,
<span class="linenr">2084: </span>  <span class=
"org-string">"rightharpoonup;"</span>: <span class=
"org-string">"⇀"</span>,
<span class="linenr">2085: </span>  <span class=
"org-string">"RightTeeVector;"</span>: <span class=
"org-string">"⥛"</span>,
<span class="linenr">2086: </span>  <span class=
"org-string">"RightVectorBar;"</span>: <span class=
"org-string">"⥓"</span>,
<span class="linenr">2087: </span>  <span class=
"org-string">"ShortDownArrow;"</span>: <span class=
"org-string">"↓"</span>,
<span class="linenr">2088: </span>  <span class=
"org-string">"ShortLeftArrow;"</span>: <span class=
"org-string">"←"</span>,
<span class="linenr">2089: </span>  <span class=
"org-string">"SquareSuperset;"</span>: <span class=
"org-string">"⊐"</span>,
<span class="linenr">2090: </span>  <span class=
"org-string">"TildeFullEqual;"</span>: <span class=
"org-string">"≅"</span>,
<span class="linenr">2091: </span>  <span class=
"org-string">"trianglelefteq;"</span>: <span class=
"org-string">"⊴"</span>,
<span class="linenr">2092: </span>  <span class=
"org-string">"upharpoonright;"</span>: <span class=
"org-string">"↾"</span>,
<span class="linenr">2093: </span>  <span class=
"org-string">"UpperLeftArrow;"</span>: <span class=
"org-string">"↖"</span>,
<span class="linenr">2094: </span>  <span class=
"org-string">"ZeroWidthSpace;"</span>: <span class=
"org-string">"​"</span>,
<span class="linenr">2095: </span>  <span class=
"org-string">"bigtriangledown;"</span>: <span class=
"org-string">"▽"</span>,
<span class="linenr">2096: </span>  <span class=
"org-string">"circlearrowleft;"</span>: <span class=
"org-string">"↺"</span>,
<span class="linenr">2097: </span>  <span class=
"org-string">"CloseCurlyQuote;"</span>: <span class=
"org-string">"’"</span>,
<span class="linenr">2098: </span>  <span class=
"org-string">"ContourIntegral;"</span>: <span class=
"org-string">"∮"</span>,
<span class="linenr">2099: </span>  <span class=
"org-string">"curvearrowright;"</span>: <span class=
"org-string">"↷"</span>,
<span class="linenr">2100: </span>  <span class=
"org-string">"DoubleDownArrow;"</span>: <span class=
"org-string">"⇓"</span>,
<span class="linenr">2101: </span>  <span class=
"org-string">"DoubleLeftArrow;"</span>: <span class=
"org-string">"⇐"</span>,
<span class="linenr">2102: </span>  <span class=
"org-string">"downharpoonleft;"</span>: <span class=
"org-string">"⇃"</span>,
<span class="linenr">2103: </span>  <span class=
"org-string">"DownRightVector;"</span>: <span class=
"org-string">"⇁"</span>,
<span class="linenr">2104: </span>  <span class=
"org-string">"leftharpoondown;"</span>: <span class=
"org-string">"↽"</span>,
<span class="linenr">2105: </span>  <span class=
"org-string">"leftrightarrows;"</span>: <span class=
"org-string">"⇆"</span>,
<span class="linenr">2106: </span>  <span class=
"org-string">"LeftRightVector;"</span>: <span class=
"org-string">"⥎"</span>,
<span class="linenr">2107: </span>  <span class=
"org-string">"LeftTriangleBar;"</span>: <span class=
"org-string">"⧏"</span>,
<span class="linenr">2108: </span>  <span class=
"org-string">"LeftUpTeeVector;"</span>: <span class=
"org-string">"⥠"</span>,
<span class="linenr">2109: </span>  <span class=
"org-string">"LeftUpVectorBar;"</span>: <span class=
"org-string">"⥘"</span>,
<span class="linenr">2110: </span>  <span class=
"org-string">"LowerRightArrow;"</span>: <span class=
"org-string">"↘"</span>,
<span class="linenr">2111: </span>  <span class=
"org-string">"nLeftrightarrow;"</span>: <span class=
"org-string">"⇎"</span>,
<span class="linenr">2112: </span>  <span class=
"org-string">"nleftrightarrow;"</span>: <span class=
"org-string">"↮"</span>,
<span class="linenr">2113: </span>  <span class=
"org-string">"NotGreaterEqual;"</span>: <span class=
"org-string">"≱"</span>,
<span class="linenr">2114: </span>  <span class=
"org-string">"NotGreaterTilde;"</span>: <span class=
"org-string">"≵"</span>,
<span class="linenr">2115: </span>  <span class=
"org-string">"NotHumpDownHump;"</span>: <span class=
"org-string">"≎̸"</span>,
<span class="linenr">2116: </span>  <span class=
"org-string">"NotLeftTriangle;"</span>: <span class=
"org-string">"⋪"</span>,
<span class="linenr">2117: </span>  <span class=
"org-string">"NotSquareSubset;"</span>: <span class=
"org-string">"⊏̸"</span>,
<span class="linenr">2118: </span>  <span class=
"org-string">"ntrianglelefteq;"</span>: <span class=
"org-string">"⋬"</span>,
<span class="linenr">2119: </span>  <span class=
"org-string">"OverParenthesis;"</span>: <span class=
"org-string">"⏜"</span>,
<span class="linenr">2120: </span>  <span class=
"org-string">"RightDownVector;"</span>: <span class=
"org-string">"⇂"</span>,
<span class="linenr">2121: </span>  <span class=
"org-string">"rightleftarrows;"</span>: <span class=
"org-string">"⇄"</span>,
<span class="linenr">2122: </span>  <span class=
"org-string">"rightsquigarrow;"</span>: <span class=
"org-string">"↝"</span>,
<span class="linenr">2123: </span>  <span class=
"org-string">"rightthreetimes;"</span>: <span class=
"org-string">"⋌"</span>,
<span class="linenr">2124: </span>  <span class=
"org-string">"ShortRightArrow;"</span>: <span class=
"org-string">"→"</span>,
<span class="linenr">2125: </span>  <span class=
"org-string">"straightepsilon;"</span>: <span class=
"org-string">"ϵ"</span>,
<span class="linenr">2126: </span>  <span class=
"org-string">"trianglerighteq;"</span>: <span class=
"org-string">"⊵"</span>,
<span class="linenr">2127: </span>  <span class=
"org-string">"UpperRightArrow;"</span>: <span class=
"org-string">"↗"</span>,
<span class="linenr">2128: </span>  <span class=
"org-string">"vartriangleleft;"</span>: <span class=
"org-string">"⊲"</span>,
<span class="linenr">2129: </span>  <span class=
"org-string">"circlearrowright;"</span>: <span class=
"org-string">"↻"</span>,
<span class="linenr">2130: </span>  <span class=
"org-string">"DiacriticalAcute;"</span>: <span class=
"org-string">"´"</span>,
<span class="linenr">2131: </span>  <span class=
"org-string">"DiacriticalGrave;"</span>: <span class=
"org-string">"`"</span>,
<span class="linenr">2132: </span>  <span class=
"org-string">"DiacriticalTilde;"</span>: <span class=
"org-string">"˜"</span>,
<span class="linenr">2133: </span>  <span class=
"org-string">"DoubleRightArrow;"</span>: <span class=
"org-string">"⇒"</span>,
<span class="linenr">2134: </span>  <span class=
"org-string">"DownArrowUpArrow;"</span>: <span class=
"org-string">"⇵"</span>,
<span class="linenr">2135: </span>  <span class=
"org-string">"downharpoonright;"</span>: <span class=
"org-string">"⇂"</span>,
<span class="linenr">2136: </span>  <span class=
"org-string">"EmptySmallSquare;"</span>: <span class=
"org-string">"◻"</span>,
<span class="linenr">2137: </span>  <span class=
"org-string">"GreaterEqualLess;"</span>: <span class=
"org-string">"⋛"</span>,
<span class="linenr">2138: </span>  <span class=
"org-string">"GreaterFullEqual;"</span>: <span class=
"org-string">"≧"</span>,
<span class="linenr">2139: </span>  <span class=
"org-string">"LeftAngleBracket;"</span>: <span class=
"org-string">"⟨"</span>,
<span class="linenr">2140: </span>  <span class=
"org-string">"LeftUpDownVector;"</span>: <span class=
"org-string">"⥑"</span>,
<span class="linenr">2141: </span>  <span class=
"org-string">"LessEqualGreater;"</span>: <span class=
"org-string">"⋚"</span>,
<span class="linenr">2142: </span>  <span class=
"org-string">"NonBreakingSpace;"</span>: <span class=
"org-string">" "</span>,
<span class="linenr">2143: </span>  <span class=
"org-string">"NotPrecedesEqual;"</span>: <span class=
"org-string">"⪯̸"</span>,
<span class="linenr">2144: </span>  <span class=
"org-string">"NotRightTriangle;"</span>: <span class=
"org-string">"⋫"</span>,
<span class="linenr">2145: </span>  <span class=
"org-string">"NotSucceedsEqual;"</span>: <span class=
"org-string">"⪰̸"</span>,
<span class="linenr">2146: </span>  <span class=
"org-string">"NotSucceedsTilde;"</span>: <span class=
"org-string">"≿̸"</span>,
<span class="linenr">2147: </span>  <span class=
"org-string">"NotSupersetEqual;"</span>: <span class=
"org-string">"⊉"</span>,
<span class="linenr">2148: </span>  <span class=
"org-string">"ntrianglerighteq;"</span>: <span class=
"org-string">"⋭"</span>,
<span class="linenr">2149: </span>  <span class=
"org-string">"rightharpoondown;"</span>: <span class=
"org-string">"⇁"</span>,
<span class="linenr">2150: </span>  <span class=
"org-string">"rightrightarrows;"</span>: <span class=
"org-string">"⇉"</span>,
<span class="linenr">2151: </span>  <span class=
"org-string">"RightTriangleBar;"</span>: <span class=
"org-string">"⧐"</span>,
<span class="linenr">2152: </span>  <span class=
"org-string">"RightUpTeeVector;"</span>: <span class=
"org-string">"⥜"</span>,
<span class="linenr">2153: </span>  <span class=
"org-string">"RightUpVectorBar;"</span>: <span class=
"org-string">"⥔"</span>,
<span class="linenr">2154: </span>  <span class=
"org-string">"twoheadleftarrow;"</span>: <span class=
"org-string">"↞"</span>,
<span class="linenr">2155: </span>  <span class=
"org-string">"UnderParenthesis;"</span>: <span class=
"org-string">"⏝"</span>,
<span class="linenr">2156: </span>  <span class=
"org-string">"UpArrowDownArrow;"</span>: <span class=
"org-string">"⇅"</span>,
<span class="linenr">2157: </span>  <span class=
"org-string">"vartriangleright;"</span>: <span class=
"org-string">"⊳"</span>,
<span class="linenr">2158: </span>  <span class=
"org-string">"blacktriangledown;"</span>: <span class=
"org-string">"▾"</span>,
<span class="linenr">2159: </span>  <span class=
"org-string">"blacktriangleleft;"</span>: <span class=
"org-string">"◂"</span>,
<span class="linenr">2160: </span>  <span class=
"org-string">"DoubleUpDownArrow;"</span>: <span class=
"org-string">"⇕"</span>,
<span class="linenr">2161: </span>  <span class=
"org-string">"DoubleVerticalBar;"</span>: <span class=
"org-string">"∥"</span>,
<span class="linenr">2162: </span>  <span class=
"org-string">"DownLeftTeeVector;"</span>: <span class=
"org-string">"⥞"</span>,
<span class="linenr">2163: </span>  <span class=
"org-string">"DownLeftVectorBar;"</span>: <span class=
"org-string">"⥖"</span>,
<span class="linenr">2164: </span>  <span class=
"org-string">"FilledSmallSquare;"</span>: <span class=
"org-string">"◼"</span>,
<span class="linenr">2165: </span>  <span class=
"org-string">"GreaterSlantEqual;"</span>: <span class=
"org-string">"⩾"</span>,
<span class="linenr">2166: </span>  <span class=
"org-string">"LeftDoubleBracket;"</span>: <span class=
"org-string">"⟦"</span>,
<span class="linenr">2167: </span>  <span class=
"org-string">"LeftDownTeeVector;"</span>: <span class=
"org-string">"⥡"</span>,
<span class="linenr">2168: </span>  <span class=
"org-string">"LeftDownVectorBar;"</span>: <span class=
"org-string">"⥙"</span>,
<span class="linenr">2169: </span>  <span class=
"org-string">"leftrightharpoons;"</span>: <span class=
"org-string">"⇋"</span>,
<span class="linenr">2170: </span>  <span class=
"org-string">"LeftTriangleEqual;"</span>: <span class=
"org-string">"⊴"</span>,
<span class="linenr">2171: </span>  <span class=
"org-string">"NegativeThinSpace;"</span>: <span class=
"org-string">"​"</span>,
<span class="linenr">2172: </span>  <span class=
"org-string">"NotGreaterGreater;"</span>: <span class=
"org-string">"≫̸"</span>,
<span class="linenr">2173: </span>  <span class=
"org-string">"NotLessSlantEqual;"</span>: <span class=
"org-string">"⩽̸"</span>,
<span class="linenr">2174: </span>  <span class=
"org-string">"NotNestedLessLess;"</span>: <span class=
"org-string">"⪡̸"</span>,
<span class="linenr">2175: </span>  <span class=
"org-string">"NotReverseElement;"</span>: <span class=
"org-string">"∌"</span>,
<span class="linenr">2176: </span>  <span class=
"org-string">"NotSquareSuperset;"</span>: <span class=
"org-string">"⊐̸"</span>,
<span class="linenr">2177: </span>  <span class=
"org-string">"NotTildeFullEqual;"</span>: <span class=
"org-string">"≇"</span>,
<span class="linenr">2178: </span>  <span class=
"org-string">"RightAngleBracket;"</span>: <span class=
"org-string">"⟩"</span>,
<span class="linenr">2179: </span>  <span class=
"org-string">"rightleftharpoons;"</span>: <span class=
"org-string">"⇌"</span>,
<span class="linenr">2180: </span>  <span class=
"org-string">"RightUpDownVector;"</span>: <span class=
"org-string">"⥏"</span>,
<span class="linenr">2181: </span>  <span class=
"org-string">"SquareSubsetEqual;"</span>: <span class=
"org-string">"⊑"</span>,
<span class="linenr">2182: </span>  <span class=
"org-string">"twoheadrightarrow;"</span>: <span class=
"org-string">"↠"</span>,
<span class="linenr">2183: </span>  <span class=
"org-string">"VerticalSeparator;"</span>: <span class=
"org-string">"❘"</span>,
<span class="linenr">2184: </span>  <span class=
"org-string">"blacktriangleright;"</span>: <span class=
"org-string">"▸"</span>,
<span class="linenr">2185: </span>  <span class=
"org-string">"DownRightTeeVector;"</span>: <span class=
"org-string">"⥟"</span>,
<span class="linenr">2186: </span>  <span class=
"org-string">"DownRightVectorBar;"</span>: <span class=
"org-string">"⥗"</span>,
<span class="linenr">2187: </span>  <span class=
"org-string">"LongLeftRightArrow;"</span>: <span class=
"org-string">"⟷"</span>,
<span class="linenr">2188: </span>  <span class=
"org-string">"Longleftrightarrow;"</span>: <span class=
"org-string">"⟺"</span>,
<span class="linenr">2189: </span>  <span class=
"org-string">"longleftrightarrow;"</span>: <span class=
"org-string">"⟷"</span>,
<span class="linenr">2190: </span>  <span class=
"org-string">"NegativeThickSpace;"</span>: <span class=
"org-string">"​"</span>,
<span class="linenr">2191: </span>  <span class=
"org-string">"NotLeftTriangleBar;"</span>: <span class=
"org-string">"⧏̸"</span>,
<span class="linenr">2192: </span>  <span class=
"org-string">"PrecedesSlantEqual;"</span>: <span class=
"org-string">"≼"</span>,
<span class="linenr">2193: </span>  <span class=
"org-string">"ReverseEquilibrium;"</span>: <span class=
"org-string">"⇋"</span>,
<span class="linenr">2194: </span>  <span class=
"org-string">"RightDoubleBracket;"</span>: <span class=
"org-string">"⟧"</span>,
<span class="linenr">2195: </span>  <span class=
"org-string">"RightDownTeeVector;"</span>: <span class=
"org-string">"⥝"</span>,
<span class="linenr">2196: </span>  <span class=
"org-string">"RightDownVectorBar;"</span>: <span class=
"org-string">"⥕"</span>,
<span class="linenr">2197: </span>  <span class=
"org-string">"RightTriangleEqual;"</span>: <span class=
"org-string">"⊵"</span>,
<span class="linenr">2198: </span>  <span class=
"org-string">"SquareIntersection;"</span>: <span class=
"org-string">"⊓"</span>,
<span class="linenr">2199: </span>  <span class=
"org-string">"SucceedsSlantEqual;"</span>: <span class=
"org-string">"≽"</span>,
<span class="linenr">2200: </span>  <span class=
"org-string">"DoubleLongLeftArrow;"</span>: <span class=
"org-string">"⟸"</span>,
<span class="linenr">2201: </span>  <span class=
"org-string">"DownLeftRightVector;"</span>: <span class=
"org-string">"⥐"</span>,
<span class="linenr">2202: </span>  <span class=
"org-string">"LeftArrowRightArrow;"</span>: <span class=
"org-string">"⇆"</span>,
<span class="linenr">2203: </span>  <span class=
"org-string">"leftrightsquigarrow;"</span>: <span class=
"org-string">"↭"</span>,
<span class="linenr">2204: </span>  <span class=
"org-string">"NegativeMediumSpace;"</span>: <span class=
"org-string">"​"</span>,
<span class="linenr">2205: </span>  <span class=
"org-string">"NotGreaterFullEqual;"</span>: <span class=
"org-string">"≧̸"</span>,
<span class="linenr">2206: </span>  <span class=
"org-string">"NotRightTriangleBar;"</span>: <span class=
"org-string">"⧐̸"</span>,
<span class="linenr">2207: </span>  <span class=
"org-string">"RightArrowLeftArrow;"</span>: <span class=
"org-string">"⇄"</span>,
<span class="linenr">2208: </span>  <span class=
"org-string">"SquareSupersetEqual;"</span>: <span class=
"org-string">"⊒"</span>,
<span class="linenr">2209: </span>  <span class=
"org-string">"CapitalDifferentialD;"</span>: <span class=
"org-string">"ⅅ"</span>,
<span class="linenr">2210: </span>  <span class=
"org-string">"DoubleLeftRightArrow;"</span>: <span class=
"org-string">"⇔"</span>,
<span class="linenr">2211: </span>  <span class=
"org-string">"DoubleLongRightArrow;"</span>: <span class=
"org-string">"⟹"</span>,
<span class="linenr">2212: </span>  <span class=
"org-string">"EmptyVerySmallSquare;"</span>: <span class=
"org-string">"▫"</span>,
<span class="linenr">2213: </span>  <span class=
"org-string">"NestedGreaterGreater;"</span>: <span class=
"org-string">"≫"</span>,
<span class="linenr">2214: </span>  <span class=
"org-string">"NotDoubleVerticalBar;"</span>: <span class=
"org-string">"∦"</span>,
<span class="linenr">2215: </span>  <span class=
"org-string">"NotGreaterSlantEqual;"</span>: <span class=
"org-string">"⩾̸"</span>,
<span class="linenr">2216: </span>  <span class=
"org-string">"NotLeftTriangleEqual;"</span>: <span class=
"org-string">"⋬"</span>,
<span class="linenr">2217: </span>  <span class=
"org-string">"NotSquareSubsetEqual;"</span>: <span class=
"org-string">"⋢"</span>,
<span class="linenr">2218: </span>  <span class=
"org-string">"OpenCurlyDoubleQuote;"</span>: <span class=
"org-string">"“"</span>,
<span class="linenr">2219: </span>  <span class=
"org-string">"ReverseUpEquilibrium;"</span>: <span class=
"org-string">"⥯"</span>,
<span class="linenr">2220: </span>  <span class=
"org-string">"CloseCurlyDoubleQuote;"</span>: <span class=
"org-string">"”"</span>,
<span class="linenr">2221: </span>  <span class=
"org-string">"DoubleContourIntegral;"</span>: <span class=
"org-string">"∯"</span>,
<span class="linenr">2222: </span>  <span class=
"org-string">"FilledVerySmallSquare;"</span>: <span class=
"org-string">"▪"</span>,
<span class="linenr">2223: </span>  <span class=
"org-string">"NegativeVeryThinSpace;"</span>: <span class=
"org-string">"​"</span>,
<span class="linenr">2224: </span>  <span class=
"org-string">"NotPrecedesSlantEqual;"</span>: <span class=
"org-string">"⋠"</span>,
<span class="linenr">2225: </span>  <span class=
"org-string">"NotRightTriangleEqual;"</span>: <span class=
"org-string">"⋭"</span>,
<span class="linenr">2226: </span>  <span class=
"org-string">"NotSucceedsSlantEqual;"</span>: <span class=
"org-string">"⋡"</span>,
<span class="linenr">2227: </span>  <span class=
"org-string">"DiacriticalDoubleAcute;"</span>: <span class=
"org-string">"˝"</span>,
<span class="linenr">2228: </span>  <span class=
"org-string">"NotSquareSupersetEqual;"</span>: <span class=
"org-string">"⋣"</span>,
<span class="linenr">2229: </span>  <span class=
"org-string">"NotNestedGreaterGreater;"</span>: <span class=
"org-string">"⪢̸"</span>,
<span class="linenr">2230: </span>  <span class=
"org-string">"ClockwiseContourIntegral;"</span>: <span class=
"org-string">"∲"</span>,
<span class="linenr">2231: </span>  <span class=
"org-string">"DoubleLongLeftRightArrow;"</span>: <span class=
"org-string">"⟺"</span>,
<span class="linenr">2232: </span>  <span class=
"org-string">"CounterClockwiseContourIntegral;"</span>: <span class="org-string">"∳"</span>
<span class="linenr">2233: </span>}
<span class="linenr">2234: </span>
<span class="linenr">2235: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">decodeHtml</span> = (rawText, asAttr) =&gt; {
<span class="linenr">2236: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">offset</span> = <span class=
"org-highlight-numbers-number">0</span>
<span class="linenr">2237: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">end</span> = rawText.length
<span class="linenr">2238: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">decodedText</span> = <span class=
"org-string">''</span>
<span class="linenr">2239: </span>
<span class="linenr">2240: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">advance</span>(<span class=
"org-variable-name">length</span>) {
<span class="linenr">2241: </span>    offset += length
<span class=
"linenr">2242: </span>    rawText = rawText.slice(length)
<span class="linenr">2243: </span>  }
<span class="linenr">2244: </span>
<span class="linenr">2245: </span>  <span class=
"org-keyword">while</span> (offset &lt; end) {
<span class="linenr">2246: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">head</span> = <span class=
"org-string">/&amp;(?:#x?)?/</span>i.exec(rawText)
<span class="linenr">2247: </span>    <span class=
"org-keyword">if</span> (!head || offset + head.index &gt;= end) {
<span class="linenr">2248: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">remaining</span> = end - offset
<span class=
"linenr">2249: </span>      decodedText += rawText.slice(<span class="org-highlight-numbers-number">0</span>, remaining)
<span class="linenr">2250: </span>      advance(remaining)
<span class="linenr">2251: </span>      <span class=
"org-keyword">break</span>
<span class="linenr">2252: </span>    }
<span class="linenr">2253: </span>
<span class="linenr">2254: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">Advance to the "&amp;".</span>
<span class=
"linenr">2255: </span>    decodedText += rawText.slice(<span class=
"org-highlight-numbers-number">0</span>, head.index)
<span class="linenr">2256: </span>    advance(head.index)
<span class="linenr">2257: </span>
<span class="linenr">2258: </span>    <span class=
"org-keyword">if</span> (head[<span class=
"org-highlight-numbers-number">0</span>] === <span class=
"org-string">'&amp;'</span>) {
<span class="linenr">2259: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">Named character reference.</span>
<span class="linenr">2260: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">name</span> = <span class=
"org-string">''</span>
<span class="linenr">2261: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">value</span> = <span class=
"org-constant">undefined</span>
<span class="linenr">2262: </span>      <span class=
"org-keyword">if</span> (<span class=
"org-string">/[0-9a-z]/</span>i.test(rawText[<span class=
"org-highlight-numbers-number">1</span>])) {
<span class="linenr">2263: </span>        <span class=
"org-keyword">if</span> (!maxCRNameLength) {
<span class=
"linenr">2264: </span>          maxCRNameLength = Object.keys(namedCharacterReferences).reduce(
<span class=
"linenr">2265: </span>            (max, name) =&gt; Math.max(max, name.length),
<span class="linenr">2266: </span>            <span class=
"org-highlight-numbers-number">0</span>
<span class="linenr">2267: </span>          )
<span class="linenr">2268: </span>        }
<span class="linenr">2269: </span>        <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">length</span> = maxCRNameLength; !value &amp;& length &gt; <span class="org-highlight-numbers-number">0</span>; --length) {
<span class=
"linenr">2270: </span>          name = rawText.slice(<span class=
"org-highlight-numbers-number">1</span>, <span class=
"org-highlight-numbers-number">1</span> + length)
<span class=
"linenr">2271: </span>          value = namedCharacterReferences[name]
<span class="linenr">2272: </span>        }
<span class="linenr">2273: </span>        <span class=
"org-keyword">if</span> (value) {
<span class="linenr">2274: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">semi</span> = name.endsWith(<span class=
"org-string">';'</span>)
<span class="linenr">2275: </span>          <span class=
"org-keyword">if</span> (
<span class="linenr">2276: </span>            asAttr &amp;&
<span class="linenr">2277: </span>            !semi &amp;&
<span class="linenr">2278: </span>            /[=a-z0-<span class=
"org-highlight-numbers-number">9</span>]/i.test(rawText[name.length + <span class="org-highlight-numbers-number">1</span>] || <span class="org-string">''</span>)
<span class="linenr">2279: </span>          ) {
<span class=
"linenr">2280: </span>            decodedText += <span class=
"org-string">'&amp;'</span> + name
<span class="linenr">2281: </span>            advance(<span class=
"org-highlight-numbers-number">1</span> + name.length)
<span class="linenr">2282: </span>          } <span class=
"org-keyword">else</span> {
<span class="linenr">2283: </span>            decodedText += value
<span class="linenr">2284: </span>            advance(<span class=
"org-highlight-numbers-number">1</span> + name.length)
<span class="linenr">2285: </span>          }
<span class="linenr">2286: </span>        } <span class=
"org-keyword">else</span> {
<span class=
"linenr">2287: </span>          decodedText += <span class=
"org-string">'&amp;'</span> + name
<span class="linenr">2288: </span>          advance(<span class=
"org-highlight-numbers-number">1</span> + name.length)
<span class="linenr">2289: </span>        }
<span class="linenr">2290: </span>      } <span class=
"org-keyword">else</span> {
<span class=
"linenr">2291: </span>        decodedText += <span class=
"org-string">'&amp;'</span>
<span class="linenr">2292: </span>        advance(<span class=
"org-highlight-numbers-number">1</span>)
<span class="linenr">2293: </span>      }
<span class="linenr">2294: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr">2295: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">Numeric character reference.</span>
<span class="linenr">2296: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">hex</span> = head[<span class=
"org-highlight-numbers-number">0</span>] === <span class=
"org-string">'&amp;#x'</span>
<span class="linenr">2297: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">pattern</span> = hex ? /^&amp;#x([<span class=
"org-highlight-numbers-number">0</span>-9a-f]+);?/i : <span class=
"org-string">/^&amp;#([0-9]+);?/</span>
<span class="linenr">2298: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">body</span> = pattern.exec(rawText)
<span class="linenr">2299: </span>      <span class=
"org-keyword">if</span> (!body) {
<span class=
"linenr">2300: </span>        decodedText += head[<span class=
"org-highlight-numbers-number">0</span>]
<span class="linenr">2301: </span>        advance(head[<span class=
"org-highlight-numbers-number">0</span>].length)
<span class="linenr">2302: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr">2303: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state</span>
<span class="linenr">2304: </span>        <span class=
"org-keyword">let</span> <span class=
"org-variable-name">cp</span> = Number.parseInt(body[<span class=
"org-highlight-numbers-number">1</span>], hex ? <span class=
"org-highlight-numbers-number">16</span> : <span class=
"org-highlight-numbers-number">10</span>)
<span class="linenr">2305: </span>        <span class=
"org-keyword">if</span> (cp === <span class=
"org-highlight-numbers-number">0</span>) {
<span class="linenr">2306: </span>          cp = 0xfffd
<span class="linenr">2307: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (cp &gt; 0x10ffff) {
<span class="linenr">2308: </span>          cp = 0xfffd
<span class="linenr">2309: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (cp &gt;= 0xd800 &amp;& cp &lt;= 0xdfff) {
<span class="linenr">2310: </span>          cp = 0xfffd
<span class="linenr">2311: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> ((cp &gt;= 0xfdd0 &amp;& cp &lt;= 0xfdef) || (cp & 0xfffe) === 0xfffe) {
<span class="linenr">2312: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">noop</span>
<span class="linenr">2313: </span>        } <span class=
"org-keyword">else</span> <span class="org-keyword">if</span> (
<span class=
"linenr">2314: </span>          (cp &gt;= 0x01 &amp;& cp &lt;= 0x08) ||
<span class="linenr">2315: </span>          cp === 0x0b ||
<span class=
"linenr">2316: </span>          (cp &gt;= 0x0d &amp;& cp &lt;= 0x1f) ||
<span class=
"linenr">2317: </span>          (cp &gt;= 0x7f &amp;& cp &lt;= 0x9f)
<span class="linenr">2318: </span>        ) {
<span class=
"linenr">2319: </span>          cp = CCR_REPLACEMENTS[cp] || cp
<span class="linenr">2320: </span>        }
<span class=
"linenr">2321: </span>        decodedText += String.fromCodePoint(cp)
<span class="linenr">2322: </span>        advance(body[<span class=
"org-highlight-numbers-number">0</span>].length)
<span class="linenr">2323: </span>      }
<span class="linenr">2324: </span>    }
<span class="linenr">2325: </span>  }
<span class="linenr">2326: </span>  <span class=
"org-keyword">return</span> decodedText
<span class="linenr">2327: </span>}
<span class="linenr">2328: </span>
<span class="linenr">2329: </span><span class=
"org-comment-delimiter">// </span><span class=
"org-comment">https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state</span>
<span class="linenr">2330: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">CCR_REPLACEMENTS</span> = {
<span class="linenr">2331: </span>  0x80: 0x20ac,
<span class="linenr">2332: </span>  0x82: 0x201a,
<span class="linenr">2333: </span>  0x83: 0x0192,
<span class="linenr">2334: </span>  0x84: 0x201e,
<span class="linenr">2335: </span>  0x85: 0x2026,
<span class="linenr">2336: </span>  0x86: 0x2020,
<span class="linenr">2337: </span>  0x87: 0x2021,
<span class="linenr">2338: </span>  0x88: 0x02c6,
<span class="linenr">2339: </span>  0x89: 0x2030,
<span class="linenr">2340: </span>  0x8a: 0x0160,
<span class="linenr">2341: </span>  0x8b: 0x2039,
<span class="linenr">2342: </span>  0x8c: 0x0152,
<span class="linenr">2343: </span>  0x8e: 0x017d,
<span class="linenr">2344: </span>  0x91: 0x2018,
<span class="linenr">2345: </span>  0x92: 0x2019,
<span class="linenr">2346: </span>  0x93: 0x201c,
<span class="linenr">2347: </span>  0x94: 0x201d,
<span class="linenr">2348: </span>  0x95: 0x2022,
<span class="linenr">2349: </span>  0x96: 0x2013,
<span class="linenr">2350: </span>  0x97: 0x2014,
<span class="linenr">2351: </span>  0x98: 0x02dc,
<span class="linenr">2352: </span>  0x99: 0x2122,
<span class="linenr">2353: </span>  0x9a: 0x0161,
<span class="linenr">2354: </span>  0x9b: 0x203a,
<span class="linenr">2355: </span>  0x9c: 0x0153,
<span class="linenr">2356: </span>  0x9e: 0x017e,
<span class="linenr">2357: </span>  0x9f: 0x0178
<span class="linenr">2358: </span>}
<span class="linenr">2359: </span>
<span class="linenr">2360: </span><span class=
"org-keyword">let</span> <span class=
"org-variable-name">decoder</span>
<span class="linenr">2361: </span>
<span class="linenr">2362: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">decodeHtmlBrowser</span>(<span class=
"org-variable-name">raw</span>, <span class=
"org-variable-name">asAttr</span> = <span class=
"org-constant">false</span>) {
<span class="linenr">2363: </span>  <span class=
"org-keyword">if</span> (!decoder) {
<span class=
"linenr">2364: </span>    decoder = document.createElement(<span class="org-string">'div'</span>)
<span class="linenr">2365: </span>  }
<span class="linenr">2366: </span>  <span class=
"org-keyword">if</span> (asAttr) {
<span class=
"linenr">2367: </span>    decoder.innerHTML = <span class=
"org-string">`&lt;div foo="${raw.replace(/"/g, '&amp;quot;')}"&gt;`</span>
<span class="linenr">2368: </span>    <span class=
"org-keyword">return</span> decoder.children[<span class=
"org-highlight-numbers-number">0</span>].getAttribute(<span class=
"org-string">'foo'</span>)
<span class="linenr">2369: </span>  } <span class=
"org-keyword">else</span> {
<span class="linenr">2370: </span>    decoder.innerHTML = raw
<span class="linenr">2371: </span>    <span class=
"org-keyword">return</span> decoder.textContent
<span class="linenr">2372: </span>  }
<span class="linenr">2373: </span>}
<span class="linenr">2374: </span>
<span class="linenr">2375: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">V_MODEL_RADIO</span> = Symbol(__DEV__ ? <span class="org-string">`vModelRadio`</span> : <span class="org-string">``</span>)
<span class="linenr">2376: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">V_MODEL_CHECKBOX</span> = Symbol(__DEV__ ? <span class="org-string">`vModelCheckbox`</span> : <span class="org-string">``</span>)
<span class="linenr">2377: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">V_MODEL_TEXT</span> = Symbol(__DEV__ ? <span class="org-string">`vModelText`</span> : <span class="org-string">``</span>)
<span class="linenr">2378: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">V_MODEL_SELECT</span> = Symbol(__DEV__ ? <span class="org-string">`vModelSelect`</span> : <span class="org-string">``</span>)
<span class="linenr">2379: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">V_MODEL_DYNAMIC</span> = Symbol(__DEV__ ? <span class="org-string">`vModelDynamic`</span> : <span class="org-string">``</span>)
<span class="linenr">2380: </span>
<span class="linenr">2381: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">V_ON_WITH_MODIFIERS</span> = Symbol(__DEV__ ? <span class="org-string">`vOnModifiersGuard`</span> : <span class="org-string">``</span>)
<span class="linenr">2382: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">V_ON_WITH_KEYS</span> = Symbol(__DEV__ ? <span class="org-string">`vOnKeysGuard`</span> : <span class="org-string">``</span>)
<span class="linenr">2383: </span>
<span class="linenr">2384: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">V_SHOW</span> = Symbol(__DEV__ ? <span class=
"org-string">`vShow`</span> : <span class="org-string">``</span>)
<span class="linenr">2385: </span>
<span class="linenr">2386: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">TRANSITION</span> = Symbol(__DEV__ ? <span class="org-string">`Transition`</span> : <span class="org-string">``</span>)
<span class="linenr">2387: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">TRANSITION_GROUP</span> = Symbol(__DEV__ ? <span class="org-string">`TransitionGroup`</span> : <span class="org-string">``</span>)
<span class="linenr">2388: </span>
<span class="linenr">2389: </span>registerRuntimeHelpers({
<span class="linenr">2390: </span>  [V_MODEL_RADIO]: <span class=
"org-string">`vModelRadio`</span>,
<span class=
"linenr">2391: </span>  [V_MODEL_CHECKBOX]: <span class="org-string">`vModelCheckbox`</span>,
<span class="linenr">2392: </span>  [V_MODEL_TEXT]: <span class=
"org-string">`vModelText`</span>,
<span class="linenr">2393: </span>  [V_MODEL_SELECT]: <span class=
"org-string">`vModelSelect`</span>,
<span class="linenr">2394: </span>  [V_MODEL_DYNAMIC]: <span class=
"org-string">`vModelDynamic`</span>,
<span class=
"linenr">2395: </span>  [V_ON_WITH_MODIFIERS]: <span class=
"org-string">`withModifiers`</span>,
<span class="linenr">2396: </span>  [V_ON_WITH_KEYS]: <span class=
"org-string">`withKeys`</span>,
<span class="linenr">2397: </span>  [V_SHOW]: <span class=
"org-string">`vShow`</span>,
<span class="linenr">2398: </span>  [TRANSITION]: <span class=
"org-string">`Transition`</span>,
<span class=
"linenr">2399: </span>  [TRANSITION_GROUP]: <span class="org-string">`TransitionGroup`</span>
<span class="linenr">2400: </span>})
<span class="linenr">2401: </span>
<span class="linenr">2402: </span>
<span class="linenr">2403: </span><span class="org-doc">/**</span>
<span class="linenr">2404: </span><span class=
"org-doc"> * On the client we only need to offer special cases for boolean attributes that</span>
<span class="linenr">2405: </span><span class=
"org-doc"> * have different names from their corresponding dom properties:</span>
<span class="linenr">2406: </span><span class=
"org-doc"> * - itemscope -&gt; N/A</span>
<span class="linenr">2407: </span><span class=
"org-doc"> * - allowfullscreen -&gt; allowFullscreen</span>
<span class="linenr">2408: </span><span class=
"org-doc"> * - formnovalidate -&gt; formNoValidate</span>
<span class="linenr">2409: </span><span class=
"org-doc"> * - ismap -&gt; isMap</span>
<span class="linenr">2410: </span><span class=
"org-doc"> * - nomodule -&gt; noModule</span>
<span class="linenr">2411: </span><span class=
"org-doc"> * - novalidate -&gt; noValidate</span>
<span class="linenr">2412: </span><span class=
"org-doc"> * - readonly -&gt; readOnly</span>
<span class="linenr">2413: </span><span class="org-doc"> */</span>
<span class="linenr">2414: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">specialBooleanAttrs</span> = <span class=
"org-string">`itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`</span>
<span class="linenr">2415: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">isSpecialBooleanAttr</span> = <span class=
"org-comment-delimiter">/*</span><span class=
"org-comment">#__PURE__</span><span class=
"org-comment-delimiter">*/</span> makeMap(specialBooleanAttrs)
<span class="linenr">2416: </span>
<span class="linenr">2417: </span><span class="org-doc">/**</span>
<span class="linenr">2418: </span><span class=
"org-doc"> * The full list is needed during SSR to produce the correct initial markup.</span>
<span class="linenr">2419: </span><span class="org-doc"> */</span>
<span class="linenr">2420: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">isBooleanAttr</span> = <span class=
"org-comment-delimiter">/*</span><span class=
"org-comment">#__PURE__</span><span class=
"org-comment-delimiter">*/</span> makeMap(
<span class="linenr">2421: </span>  specialBooleanAttrs +
<span class="linenr">2422: </span>    <span class=
"org-string">`,async,autofocus,autoplay,controls,default,defer,disabled,hidden,`</span> +
<span class="linenr">2423: </span>    <span class=
"org-string">`loop,open,required,reversed,scoped,seamless,`</span> +
<span class="linenr">2424: </span>    <span class=
"org-string">`checked,muted,multiple,selected`</span>
<span class="linenr">2425: </span>)
<span class="linenr">2426: </span>
<span class="linenr">2427: </span><span class="org-doc">/**</span>
<span class="linenr">2428: </span><span class=
"org-doc"> * Boolean attributes should be included if the value is truthy or ''.</span>
<span class="linenr">2429: </span><span class=
"org-doc"> * e.g. `&lt;select multiple&gt;` compiles to `{ multiple: '' }`</span>
<span class="linenr">2430: </span><span class="org-doc"> */</span>
<span class="linenr">2431: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">includeBooleanAttr</span>(<span class=
"org-variable-name">value</span>) {
<span class="linenr">2432: </span>  <span class=
"org-keyword">return</span> !!value || value === <span class=
"org-string">''</span>
<span class="linenr">2433: </span>}
<span class="linenr">2434: </span>
<span class="linenr">2435: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">unsafeAttrCharRE</span> = <span class=
"org-string">/[&gt;/="'\u0009\u000a\u000c\u0020]/</span>
<span class="linenr">2436: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">attrValidationCache</span> = {}
<span class="linenr">2437: </span>
<span class="linenr">2438: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">isSSRSafeAttrName</span>(<span class=
"org-variable-name">name</span>) {
<span class="linenr">2439: </span>  <span class=
"org-keyword">if</span> (attrValidationCache.hasOwnProperty(name)) {
<span class="linenr">2440: </span>    <span class=
"org-keyword">return</span> attrValidationCache[name]
<span class="linenr">2441: </span>  }
<span class="linenr">2442: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isUnsafe</span> = unsafeAttrCharRE.test(name)
<span class="linenr">2443: </span>  <span class=
"org-keyword">if</span> (isUnsafe) {
<span class="linenr">2444: </span>    console.error(<span class=
"org-string">`unsafe attribute name: ${name}`</span>)
<span class="linenr">2445: </span>  }
<span class="linenr">2446: </span>  <span class=
"org-keyword">return</span> (attrValidationCache[name] = !isUnsafe)
<span class="linenr">2447: </span>}
<span class="linenr">2448: </span>
<span class="linenr">2449: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">propsToAttrMap</span> = {
<span class="linenr">2450: </span>  acceptCharset: <span class=
"org-string">'accept-charset'</span>,
<span class="linenr">2451: </span>  className: <span class=
"org-string">'class'</span>,
<span class="linenr">2452: </span>  htmlFor: <span class=
"org-string">'for'</span>,
<span class="linenr">2453: </span>  httpEquiv: <span class=
"org-string">'http-equiv'</span>
<span class="linenr">2454: </span>}
<span class="linenr">2455: </span>
<span class="linenr">2456: </span><span class="org-doc">/**</span>
<span class="linenr">2457: </span><span class=
"org-doc"> * CSS properties that accept plain numbers</span>
<span class="linenr">2458: </span><span class="org-doc"> */</span>
<span class="linenr">2459: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">isNoUnitNumericStyleProp</span> = <span class=
"org-comment-delimiter">/*</span><span class=
"org-comment">#__PURE__</span><span class=
"org-comment-delimiter">*/</span> makeMap(
<span class="linenr">2460: </span>  <span class=
"org-string">`animation-iteration-count,border-image-outset,border-image-slice,`</span> +
<span class="linenr">2461: </span>    <span class=
"org-string">`border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,`</span> +
<span class="linenr">2462: </span>    <span class=
"org-string">`columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,`</span> +
<span class="linenr">2463: </span>    <span class=
"org-string">`grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,`</span> +
<span class="linenr">2464: </span>    <span class=
"org-string">`grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,`</span> +
<span class="linenr">2465: </span>    <span class=
"org-string">`line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,`</span> +
<span class="linenr">2466: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">SVG</span>
<span class="linenr">2467: </span>    <span class=
"org-string">`fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,`</span> +
<span class="linenr">2468: </span>    <span class=
"org-string">`stroke-miterlimit,stroke-opacity,stroke-width`</span>
<span class="linenr">2469: </span>)
<span class="linenr">2470: </span>
<span class="linenr">2471: </span><span class="org-doc">/**</span>
<span class="linenr">2472: </span><span class=
"org-doc"> * Known attributes, this is used for stringification of runtime static nodes</span>
<span class="linenr">2473: </span><span class=
"org-doc"> * so that we don't stringify bindings that cannot be set from HTML.</span>
<span class="linenr">2474: </span><span class=
"org-doc"> * Don't also forget to allow `data-*` and `aria-*`!</span>
<span class="linenr">2475: </span><span class=
"org-doc"> * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes</span>
<span class="linenr">2476: </span><span class="org-doc"> */</span>
<span class="linenr">2477: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">isKnownHtmlAttr</span> = <span class=
"org-comment-delimiter">/*</span><span class=
"org-comment">#__PURE__</span><span class=
"org-comment-delimiter">*/</span> makeMap(
<span class="linenr">2478: </span>  <span class=
"org-string">`accept,accept-charset,accesskey,action,align,allow,alt,async,`</span> +
<span class="linenr">2479: </span>    <span class=
"org-string">`autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,`</span> +
<span class="linenr">2480: </span>    <span class=
"org-string">`border,buffered,capture,challenge,charset,checked,cite,class,code,`</span> +
<span class="linenr">2481: </span>    <span class=
"org-string">`codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,`</span> +
<span class="linenr">2482: </span>    <span class=
"org-string">`coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,`</span> +
<span class="linenr">2483: </span>    <span class=
"org-string">`disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,`</span> +
<span class="linenr">2484: </span>    <span class=
"org-string">`formaction,formenctype,formmethod,formnovalidate,formtarget,headers,`</span> +
<span class="linenr">2485: </span>    <span class=
"org-string">`height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,`</span> +
<span class="linenr">2486: </span>    <span class=
"org-string">`ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,`</span> +
<span class="linenr">2487: </span>    <span class=
"org-string">`manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,`</span> +
<span class="linenr">2488: </span>    <span class=
"org-string">`open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,`</span> +
<span class="linenr">2489: </span>    <span class=
"org-string">`referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,`</span> +
<span class="linenr">2490: </span>    <span class=
"org-string">`selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,`</span> +
<span class="linenr">2491: </span>    <span class=
"org-string">`start,step,style,summary,tabindex,target,title,translate,type,usemap,`</span> +
<span class="linenr">2492: </span>    <span class=
"org-string">`value,width,wrap`</span>
<span class="linenr">2493: </span>)
<span class="linenr">2494: </span>
<span class="linenr">2495: </span><span class="org-doc">/**</span>
<span class="linenr">2496: </span><span class=
"org-doc"> * Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute</span>
<span class="linenr">2497: </span><span class="org-doc"> */</span>
<span class="linenr">2498: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">isKnownSvgAttr</span> = <span class=
"org-comment-delimiter">/*</span><span class=
"org-comment">#__PURE__</span><span class=
"org-comment-delimiter">*/</span> makeMap(
<span class="linenr">2499: </span>  <span class=
"org-string">`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,`</span> +
<span class="linenr">2500: </span>    <span class=
"org-string">`arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,`</span> +
<span class="linenr">2501: </span>    <span class=
"org-string">`baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,`</span> +
<span class="linenr">2502: </span>    <span class=
"org-string">`clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,`</span> +
<span class="linenr">2503: </span>    <span class=
"org-string">`color-interpolation-filters,color-profile,color-rendering,`</span> +
<span class="linenr">2504: </span>    <span class=
"org-string">`contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,`</span> +
<span class="linenr">2505: </span>    <span class=
"org-string">`descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,`</span> +
<span class="linenr">2506: </span>    <span class=
"org-string">`dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,`</span> +
<span class="linenr">2507: </span>    <span class=
"org-string">`fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,`</span> +
<span class="linenr">2508: </span>    <span class=
"org-string">`font-family,font-size,font-size-adjust,font-stretch,font-style,`</span> +
<span class="linenr">2509: </span>    <span class=
"org-string">`font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,`</span> +
<span class="linenr">2510: </span>    <span class=
"org-string">`glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,`</span> +
<span class="linenr">2511: </span>    <span class=
"org-string">`gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,`</span> +
<span class="linenr">2512: </span>    <span class=
"org-string">`horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,`</span> +
<span class="linenr">2513: </span>    <span class=
"org-string">`k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,`</span> +
<span class="linenr">2514: </span>    <span class=
"org-string">`lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,`</span> +
<span class="linenr">2515: </span>    <span class=
"org-string">`marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,`</span> +
<span class="linenr">2516: </span>    <span class=
"org-string">`mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,`</span> +
<span class="linenr">2517: </span>    <span class=
"org-string">`name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,`</span> +
<span class="linenr">2518: </span>    <span class=
"org-string">`overflow,overline-position,overline-thickness,panose-1,paint-order,path,`</span> +
<span class="linenr">2519: </span>    <span class=
"org-string">`pathLength,patternContentUnits,patternTransform,patternUnits,ping,`</span> +
<span class="linenr">2520: </span>    <span class=
"org-string">`pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,`</span> +
<span class="linenr">2521: </span>    <span class=
"org-string">`preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,`</span> +
<span class="linenr">2522: </span>    <span class=
"org-string">`rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,`</span> +
<span class="linenr">2523: </span>    <span class=
"org-string">`restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,`</span> +
<span class="linenr">2524: </span>    <span class=
"org-string">`specularConstant,specularExponent,speed,spreadMethod,startOffset,`</span> +
<span class="linenr">2525: </span>    <span class=
"org-string">`stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,`</span> +
<span class="linenr">2526: </span>    <span class=
"org-string">`strikethrough-position,strikethrough-thickness,string,stroke,`</span> +
<span class="linenr">2527: </span>    <span class=
"org-string">`stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,`</span> +
<span class="linenr">2528: </span>    <span class=
"org-string">`stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,`</span> +
<span class="linenr">2529: </span>    <span class=
"org-string">`systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,`</span> +
<span class="linenr">2530: </span>    <span class=
"org-string">`text-decoration,text-rendering,textLength,to,transform,transform-origin,`</span> +
<span class="linenr">2531: </span>    <span class=
"org-string">`type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,`</span> +
<span class="linenr">2532: </span>    <span class=
"org-string">`unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,`</span> +
<span class="linenr">2533: </span>    <span class=
"org-string">`v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,`</span> +
<span class="linenr">2534: </span>    <span class=
"org-string">`vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,`</span> +
<span class="linenr">2535: </span>    <span class=
"org-string">`writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,`</span> +
<span class="linenr">2536: </span>    <span class=
"org-string">`xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,`</span> +
<span class="linenr">2537: </span>    <span class=
"org-string">`xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`</span>
<span class="linenr">2538: </span>)
<span class="linenr">2539: </span>
<span class="linenr">2540: </span><span class=
"org-comment-delimiter">// </span><span class=
"org-comment">https://developer.mozilla.org/en-US/docs/Web/HTML/Element</span>
<span class="linenr">2541: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">HTML_TAGS</span> =
<span class="linenr">2542: </span>  <span class=
"org-string">'html,body,base,head,link,meta,style,title,address,article,aside,footer,'</span> +
<span class="linenr">2543: </span>  <span class=
"org-string">'header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,'</span> +
<span class="linenr">2544: </span>  <span class=
"org-string">'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,'</span> +
<span class="linenr">2545: </span>  <span class=
"org-string">'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,'</span> +
<span class="linenr">2546: </span>  <span class=
"org-string">'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,'</span> +
<span class="linenr">2547: </span>  <span class=
"org-string">'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,'</span> +
<span class="linenr">2548: </span>  <span class=
"org-string">'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,'</span> +
<span class="linenr">2549: </span>  <span class=
"org-string">'option,output,progress,select,textarea,details,dialog,menu,'</span> +
<span class="linenr">2550: </span>  <span class=
"org-string">'summary,template,blockquote,iframe,tfoot'</span>
<span class="linenr">2551: </span>
<span class="linenr">2552: </span><span class=
"org-comment-delimiter">// </span><span class=
"org-comment">https://developer.mozilla.org/en-US/docs/Web/SVG/Element</span>
<span class="linenr">2553: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">SVG_TAGS</span> =
<span class="linenr">2554: </span>  <span class=
"org-string">'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,'</span> +
<span class="linenr">2555: </span>  <span class=
"org-string">'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,'</span> +
<span class="linenr">2556: </span>  <span class=
"org-string">'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,'</span> +
<span class="linenr">2557: </span>  <span class=
"org-string">'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,'</span> +
<span class="linenr">2558: </span>  <span class=
"org-string">'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,'</span> +
<span class="linenr">2559: </span>  <span class=
"org-string">'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,'</span> +
<span class="linenr">2560: </span>  <span class=
"org-string">'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,'</span> +
<span class="linenr">2561: </span>  <span class=
"org-string">'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,'</span> +
<span class="linenr">2562: </span>  <span class=
"org-string">'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,'</span> +
<span class="linenr">2563: </span>  <span class=
"org-string">'text,textPath,title,tspan,unknown,use,view'</span>
<span class="linenr">2564: </span>
<span class="linenr">2565: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">VOID_TAGS</span> =
<span class="linenr">2566: </span>  <span class=
"org-string">'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr'</span>
<span class="linenr">2567: </span>
<span class="linenr">2568: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">isHTMLTag</span> = <span class=
"org-comment-delimiter">/*</span><span class=
"org-comment">#__PURE__</span><span class=
"org-comment-delimiter">*/</span> makeMap(HTML_TAGS)
<span class="linenr">2569: </span><span class="org-doc">/**</span>
<span class="linenr">2570: </span><span class=
"org-doc"> * Compiler only.</span>
<span class="linenr">2571: </span><span class=
"org-doc"> * Do NOT use in runtime code paths unless behind `__DEV__` flag.</span>
<span class="linenr">2572: </span><span class="org-doc"> */</span>
<span class="linenr">2573: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">isSVGTag</span> = <span class=
"org-comment-delimiter">/*</span><span class=
"org-comment">#__PURE__</span><span class=
"org-comment-delimiter">*/</span> makeMap(SVG_TAGS)
<span class="linenr">2574: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">isVoidTag</span> = <span class=
"org-comment-delimiter">/*</span><span class=
"org-comment">#__PURE__</span><span class=
"org-comment-delimiter">*/</span> makeMap(VOID_TAGS)
<span class="linenr">2575: </span>
<span class="linenr">2576: </span>
<span id="coderef-normalizeStyle" class="coderef-off"><span class=
"linenr">2577: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">normalizeStyle</span>(<span class=
"org-variable-name">value</span>) { <span class=
"org-comment-delimiter">//</span></span>
<span class="linenr">2578: </span>  <span class=
"org-keyword">if</span> (isArray(value)) {
<span class="linenr">2579: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">res</span> = {}
<span class="linenr">2580: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; value.length; i++) {
<span class="linenr">2581: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">item</span> = value[i]
<span class="linenr">2582: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">normalized</span> = isString(item)
<span class="linenr">2583: </span>        ? parseStringStyle(item)
<span class="linenr">2584: </span>        : normalizeStyle(item)
<span class="linenr">2585: </span>      <span class=
"org-keyword">if</span> (normalized) {
<span class="linenr">2586: </span>        <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">in</span> normalized) {
<span class=
"linenr">2587: </span>          res[key] = normalized[key]
<span class="linenr">2588: </span>        }
<span class="linenr">2589: </span>      }
<span class="linenr">2590: </span>    }
<span class="linenr">2591: </span>    <span class=
"org-keyword">return</span> res
<span class="linenr">2592: </span>  } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (isString(value)) {
<span class="linenr">2593: </span>    <span class=
"org-keyword">return</span> value
<span class="linenr">2594: </span>  } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (isObject(value)) {
<span class="linenr">2595: </span>    <span class=
"org-keyword">return</span> value
<span class="linenr">2596: </span>  }
<span class="linenr">2597: </span>}
<span class="linenr">2598: </span>
<span class="linenr">2599: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">listDelimiterRE</span> = <span class=
"org-string">/;(?![^(]*\))/</span>g
<span class="linenr">2600: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">propertyDelimiterRE</span> = <span class=
"org-string">/:(.+)/</span>
<span class="linenr">2601: </span>
<span id="coderef-parseStringStyle" class=
"coderef-off"><span class="linenr">2602: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">parseStringStyle</span>(<span class=
"org-variable-name">cssText</span>) { <span class=
"org-comment-delimiter">//</span></span>
<span class="linenr">2603: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">ret</span> = {}
<span class=
"linenr">2604: </span>  cssText.split(listDelimiterRE).forEach(item =&gt; {
<span class="linenr">2605: </span>    <span class=
"org-keyword">if</span> (item) {
<span class="linenr">2606: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">tmp</span> = item.split(propertyDelimiterRE)
<span class=
"linenr">2607: </span>      tmp.length &gt; <span class="org-highlight-numbers-number">1</span> &amp;& (ret[tmp[<span class="org-highlight-numbers-number">0</span>].trim()] = tmp[<span class="org-highlight-numbers-number">1</span>].trim())
<span class="linenr">2608: </span>    }
<span class="linenr">2609: </span>  })
<span class="linenr">2610: </span>  <span class=
"org-keyword">return</span> ret
<span class="linenr">2611: </span>}
<span class="linenr">2612: </span>
<span id="coderef-stringifyStyle" class="coderef-off"><span class=
"linenr">2613: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">stringifyStyle</span>(<span class=
"org-variable-name">styles</span>) { <span class=
"org-comment-delimiter">//</span></span>
<span class="linenr">2614: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">ret</span> = <span class="org-string">''</span>
<span class="linenr">2615: </span>  <span class=
"org-keyword">if</span> (!styles || isString(styles)) {
<span class="linenr">2616: </span>    <span class=
"org-keyword">return</span> ret
<span class="linenr">2617: </span>  }
<span class="linenr">2618: </span>  <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">in</span> styles) {
<span class="linenr">2619: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">value</span> = styles[key]
<span class="linenr">2620: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">normalizedKey</span> = key.startsWith(<span class="org-string">`--`</span>) ? key : hyphenate(key)
<span class="linenr">2621: </span>    <span class=
"org-keyword">if</span> (
<span class="linenr">2622: </span>      isString(value) ||
<span class="linenr">2623: </span>      (<span class=
"org-keyword">typeof</span> value === <span class=
"org-string">'number'</span> &amp;& isNoUnitNumericStyleProp(normalizedKey))
<span class="linenr">2624: </span>    ) {
<span class="linenr">2625: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">only render valid values</span>
<span class="linenr">2626: </span>      ret += <span class=
"org-string">`${normalizedKey}:${value};`</span>
<span class="linenr">2627: </span>    }
<span class="linenr">2628: </span>  }
<span class="linenr">2629: </span>  <span class=
"org-keyword">return</span> ret
<span class="linenr">2630: </span>}
<span class="linenr">2631: </span>
<span id="coderef-normalizeClass" class="coderef-off"><span class=
"linenr">2632: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">normalizeClass</span>(<span class=
"org-variable-name">value</span>) { <span class=
"org-comment-delimiter">//</span></span>
<span class="linenr">2633: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">res</span> = <span class="org-string">''</span>
<span class="linenr">2634: </span>  <span class=
"org-keyword">if</span> (isString(value)) {
<span class="linenr">2635: </span>    res = value
<span class="linenr">2636: </span>  } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (isArray(value)) {
<span class="linenr">2637: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; value.length; i++) {
<span class="linenr">2638: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">normalized</span> = normalizeClass(value[i])
<span class="linenr">2639: </span>      <span class=
"org-keyword">if</span> (normalized) {
<span class=
"linenr">2640: </span>        res += normalized + <span class=
"org-string">' '</span>
<span class="linenr">2641: </span>      }
<span class="linenr">2642: </span>    }
<span class="linenr">2643: </span>  } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (isObject(value)) {
<span class="linenr">2644: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">name</span> <span class=
"org-keyword">in</span> value) {
<span class="linenr">2645: </span>      <span class=
"org-keyword">if</span> (value[name]) {
<span class=
"linenr">2646: </span>        res += name + <span class="org-string">' '</span>
<span class="linenr">2647: </span>      }
<span class="linenr">2648: </span>    }
<span class="linenr">2649: </span>  }
<span class="linenr">2650: </span>  <span class=
"org-keyword">return</span> res.trim()
<span class="linenr">2651: </span>}
<span class="linenr">2652: </span>
<span id="coderef-normalizeProps" class="coderef-off"><span class=
"linenr">2653: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">normalizeProps</span>(<span class=
"org-variable-name">props</span>) { <span class=
"org-comment-delimiter">//</span></span>
<span class="linenr">2654: </span>  <span class=
"org-keyword">if</span> (!props) <span class=
"org-keyword">return</span> <span class="org-constant">null</span>
<span class="linenr">2655: </span>  <span class=
"org-keyword">let</span> { <span class=
"org-keyword">class</span>: klass, style } = props
<span class="linenr">2656: </span>  <span class=
"org-keyword">if</span> (klass &amp;& !isString(klass)) {
<span class="linenr">2657: </span>    props.<span class=
"org-keyword">class</span> = normalizeClass(klass)
<span class="linenr">2658: </span>  }
<span class="linenr">2659: </span>  <span class=
"org-keyword">if</span> (style) {
<span class=
"linenr">2660: </span>    props.style = normalizeStyle(style)
<span class="linenr">2661: </span>  }
<span class="linenr">2662: </span>  <span class=
"org-keyword">return</span> props
<span class="linenr">2663: </span>}
<span class="linenr">2664: </span>
<span class="linenr">2665: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">escapeRE</span> = <span class=
"org-string">/["'&amp;&lt;&gt;]/</span>
<span class="linenr">2666: </span>
<span class="linenr">2667: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">escapeHtml</span>(<span class=
"org-variable-name">string</span>) {
<span class="linenr">2668: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">str</span> = <span class=
"org-string">''</span> + string
<span class="linenr">2669: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">match</span> = escapeRE.exec(str)
<span class="linenr">2670: </span>
<span class="linenr">2671: </span>  <span class=
"org-keyword">if</span> (!match) {
<span class="linenr">2672: </span>    <span class=
"org-keyword">return</span> str
<span class="linenr">2673: </span>  }
<span class="linenr">2674: </span>
<span class="linenr">2675: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">html</span> = <span class=
"org-string">''</span>
<span class="linenr">2676: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">escaped</span>
<span class="linenr">2677: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">index</span>
<span class="linenr">2678: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">lastIndex</span> = <span class=
"org-highlight-numbers-number">0</span>
<span class="linenr">2679: </span>  <span class=
"org-keyword">for</span> (index = match.index; index &lt; str.length; index++) {
<span class="linenr">2680: </span>    <span class=
"org-keyword">switch</span> (str.charCodeAt(index)) {
<span class="linenr">2681: </span>      <span class=
"org-keyword">case</span> <span class=
"org-highlight-numbers-number">34</span>: <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">"</span>
<span class="linenr">2682: </span>        escaped = <span class=
"org-string">'&amp;quot;'</span>
<span class="linenr">2683: </span>        <span class=
"org-keyword">break</span>
<span class="linenr">2684: </span>      <span class=
"org-keyword">case</span> <span class=
"org-highlight-numbers-number">38</span>: <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">&</span>
<span class="linenr">2685: </span>        escaped = <span class=
"org-string">'&amp;amp;'</span>
<span class="linenr">2686: </span>        <span class=
"org-keyword">break</span>
<span class="linenr">2687: </span>      <span class=
"org-keyword">case</span> <span class=
"org-highlight-numbers-number">39</span>: <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">'</span>
<span class="linenr">2688: </span>        escaped = <span class=
"org-string">'&amp;#39;'</span>
<span class="linenr">2689: </span>        <span class=
"org-keyword">break</span>
<span class="linenr">2690: </span>      <span class=
"org-keyword">case</span> <span class=
"org-highlight-numbers-number">60</span>: <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">&lt;</span>
<span class="linenr">2691: </span>        escaped = <span class=
"org-string">'&amp;lt;'</span>
<span class="linenr">2692: </span>        <span class=
"org-keyword">break</span>
<span class="linenr">2693: </span>      <span class=
"org-keyword">case</span> <span class=
"org-highlight-numbers-number">62</span>: <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">&gt;</span>
<span class="linenr">2694: </span>        escaped = <span class=
"org-string">'&amp;gt;'</span>
<span class="linenr">2695: </span>        <span class=
"org-keyword">break</span>
<span class="linenr">2696: </span>      <span class=
"org-keyword">default</span>:
<span class="linenr">2697: </span>        <span class=
"org-keyword">continue</span>
<span class="linenr">2698: </span>    }
<span class="linenr">2699: </span>
<span class="linenr">2700: </span>    <span class=
"org-keyword">if</span> (lastIndex !== index) {
<span class=
"linenr">2701: </span>      html += str.slice(lastIndex, index)
<span class="linenr">2702: </span>    }
<span class="linenr">2703: </span>
<span class=
"linenr">2704: </span>    lastIndex = index + <span class=
"org-highlight-numbers-number">1</span>
<span class="linenr">2705: </span>    html += escaped
<span class="linenr">2706: </span>  }
<span class="linenr">2707: </span>
<span class="linenr">2708: </span>  <span class=
"org-keyword">return</span> lastIndex !== index ? html + str.slice(lastIndex, index) : html
<span class="linenr">2709: </span>}
<span class="linenr">2710: </span>
<span class="linenr">2711: </span><span class=
"org-comment-delimiter">// </span><span class=
"org-comment">https://www.w3.org/TR/html52/syntax.html#comments</span>
<span class="linenr">2712: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">commentStripRE</span> = <span class=
"org-string">/^-?&gt;|&lt;!--|--&gt;|--!&gt;|&lt;!-$/</span>g
<span class="linenr">2713: </span>
<span class="linenr">2714: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">escapeHtmlComment</span>(<span class=
"org-variable-name">src</span>) {
<span class="linenr">2715: </span>  <span class=
"org-keyword">return</span> src.replace(commentStripRE, <span class="org-string">''</span>)
<span class="linenr">2716: </span>}
<span class="linenr">2717: </span>
<span class="linenr">2718: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">toDisplayString</span> = (val) =&gt; {
<span class="linenr">2719: </span>  <span class=
"org-keyword">return</span> isString(val)
<span class="linenr">2720: </span>    ? val
<span class="linenr">2721: </span>    : val == <span class=
"org-constant">null</span>
<span class="linenr">2722: </span>    ? <span class=
"org-string">''</span>
<span class="linenr">2723: </span>    : isArray(val) ||
<span class="linenr">2724: </span>      (isObject(val) &amp;&
<span class=
"linenr">2725: </span>        (val.toString === objectToString || !isFunction(val.toString)))
<span class=
"linenr">2726: </span>    ? JSON.stringify(val, replacer, <span class="org-highlight-numbers-number">2</span>)
<span class="linenr">2727: </span>    : String(val)
<span class="linenr">2728: </span>}
<span class="linenr">2729: </span>
<span class="linenr">2730: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">replacer</span> = (_key, val) =&gt; {
<span class="linenr">2731: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">can't use isRef here since @vue/shared has no deps</span>
<span class="linenr">2732: </span>  <span class=
"org-keyword">if</span> (val &amp;& val.__v_isRef) {
<span class="linenr">2733: </span>    <span class=
"org-keyword">return</span> replacer(_key, val.value)
<span class="linenr">2734: </span>  } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (isMap(val)) {
<span class="linenr">2735: </span>    <span class=
"org-keyword">return</span> {
<span class="linenr">2736: </span>      [<span class=
"org-string">`Map(${val.size})`</span>]: [...val.entries()].reduce((entries, [key, val]) =&gt; {
<span class="linenr">2737: </span>        ;entries[<span class=
"org-string">`${key} =&gt;`</span>] = val
<span class="linenr">2738: </span>        <span class=
"org-keyword">return</span> entries
<span class="linenr">2739: </span>      }, {})
<span class="linenr">2740: </span>    }
<span class="linenr">2741: </span>  } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (isSet(val)) {
<span class="linenr">2742: </span>    <span class=
"org-keyword">return</span> {
<span class="linenr">2743: </span>      [<span class=
"org-string">`Set(${val.size})`</span>]: [...val.values()]
<span class="linenr">2744: </span>    }
<span class="linenr">2745: </span>  } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (isObject(val) &amp;& !isArray(val) &amp;& !isPlainObject(val)) {
<span class="linenr">2746: </span>    <span class=
"org-keyword">return</span> String(val)
<span class="linenr">2747: </span>  }
<span class="linenr">2748: </span>  <span class=
"org-keyword">return</span> val
<span class="linenr">2749: </span>}
<span class="linenr">2750: </span>
<span class="linenr">2751: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">noopDirectiveTransform</span> = () =&gt; ({ props: [] })
<span class="linenr">2752: </span>
<span class="linenr">2753: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">isRawTextContainer</span> = <span class=
"org-comment-delimiter">/*</span><span class=
"org-comment">#__PURE__</span><span class=
"org-comment-delimiter">*/</span> makeMap(
<span class="linenr">2754: </span>  <span class=
"org-string">'style,iframe,script,noscript'</span>,
<span class="linenr">2755: </span>  <span class=
"org-constant">true</span>
<span class="linenr">2756: </span>)
<span class="linenr">2757: </span>
<span class="linenr">2758: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">DOMNamespaces</span> = {
<span class="linenr">2759: </span>  HTML: Namespaces.HTML,
<span class="linenr">2760: </span>  SVG: <span class=
"org-highlight-numbers-number">1</span>,
<span class="linenr">2761: </span>  MATH_ML: <span class=
"org-highlight-numbers-number">2</span>
<span class="linenr">2762: </span>}
<span class="linenr">2763: </span>
<span class="linenr">2764: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">parserOptions</span> = {
<span class="linenr">2765: </span>  isVoidTag,
<span class=
"linenr">2766: </span>  isNativeTag: tag =&gt; isHTMLTag(tag) || isSVGTag(tag),
<span class=
"linenr">2767: </span>  isPreTag: tag =&gt; tag === <span class=
"org-string">'pre'</span>,
<span class=
"linenr">2768: </span>  decodeEntities: __BROWSER__ ? decodeHtmlBrowser : decodeHtml,
<span class="linenr">2769: </span>
<span class="linenr">2770: </span>  isBuiltInComponent: tag =&gt; {
<span class="linenr">2771: </span>    <span class=
"org-keyword">if</span> (isBuiltInType(tag, <span class=
"org-string">`Transition`</span>)) {
<span class="linenr">2772: </span>      <span class=
"org-keyword">return</span> TRANSITION
<span class="linenr">2773: </span>    } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (isBuiltInType(tag, <span class=
"org-string">`TransitionGroup`</span>)) {
<span class="linenr">2774: </span>      <span class=
"org-keyword">return</span> TRANSITION_GROUP
<span class="linenr">2775: </span>    }
<span class="linenr">2776: </span>  },
<span class="linenr">2777: </span>
<span class="linenr">2778: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher</span>
<span class="linenr">2779: </span>  getNamespace(tag, parent) {
<span class="linenr">2780: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">ns</span> = parent ? parent.ns : DOMNamespaces.HTML
<span class="linenr">2781: </span>
<span class="linenr">2782: </span>    <span class=
"org-keyword">if</span> (parent &amp;& ns === DOMNamespaces.MATH_ML) {
<span class="linenr">2783: </span>      <span class=
"org-keyword">if</span> (parent.tag === <span class=
"org-string">'annotation-xml'</span>) {
<span class="linenr">2784: </span>        <span class=
"org-keyword">if</span> (tag === <span class=
"org-string">'svg'</span>) {
<span class="linenr">2785: </span>          <span class=
"org-keyword">return</span> DOMNamespaces.SVG
<span class="linenr">2786: </span>        }
<span class="linenr">2787: </span>        <span class=
"org-keyword">if</span> (
<span class="linenr">2788: </span>          parent.props.some(
<span class="linenr">2789: </span>            a =&gt;
<span class=
"linenr">2790: </span>              a.type === NodeTypes.ATTRIBUTE &amp;&
<span class=
"linenr">2791: </span>              a.name === <span class=
"org-string">'encoding'</span> &amp;&
<span class=
"linenr">2792: </span>              a.value != <span class=
"org-constant">null</span> &amp;&
<span class=
"linenr">2793: </span>              (a.value.content === <span class="org-string">'text/html'</span> ||
<span class=
"linenr">2794: </span>                a.value.content === <span class="org-string">'application/xhtml+xml'</span>)
<span class="linenr">2795: </span>          )
<span class="linenr">2796: </span>        ) {
<span class="linenr">2797: </span>          ns = DOMNamespaces.HTML
<span class="linenr">2798: </span>        }
<span class="linenr">2799: </span>      } <span class=
"org-keyword">else</span> <span class="org-keyword">if</span> (
<span class="linenr">2800: </span>        <span class=
"org-string">/^m(?:[ions]|text)$/</span>.test(parent.tag) &amp;&
<span class="linenr">2801: </span>        tag !== <span class=
"org-string">'mglyph'</span> &amp;&
<span class="linenr">2802: </span>        tag !== <span class=
"org-string">'malignmark'</span>
<span class="linenr">2803: </span>      ) {
<span class="linenr">2804: </span>        ns = DOMNamespaces.HTML
<span class="linenr">2805: </span>      }
<span class="linenr">2806: </span>    } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (parent &amp;& ns === DOMNamespaces.SVG) {
<span class="linenr">2807: </span>      <span class=
"org-keyword">if</span> (
<span class=
"linenr">2808: </span>        parent.tag === <span class=
"org-string">'foreignObject'</span> ||
<span class=
"linenr">2809: </span>        parent.tag === <span class=
"org-string">'desc'</span> ||
<span class=
"linenr">2810: </span>        parent.tag === <span class=
"org-string">'title'</span>
<span class="linenr">2811: </span>      ) {
<span class="linenr">2812: </span>        ns = DOMNamespaces.HTML
<span class="linenr">2813: </span>      }
<span class="linenr">2814: </span>    }
<span class="linenr">2815: </span>
<span class="linenr">2816: </span>    <span class=
"org-keyword">if</span> (ns === DOMNamespaces.HTML) {
<span class="linenr">2817: </span>      <span class=
"org-keyword">if</span> (tag === <span class=
"org-string">'svg'</span>) {
<span class="linenr">2818: </span>        <span class=
"org-keyword">return</span> DOMNamespaces.SVG
<span class="linenr">2819: </span>      }
<span class="linenr">2820: </span>      <span class=
"org-keyword">if</span> (tag === <span class=
"org-string">'math'</span>) {
<span class="linenr">2821: </span>        <span class=
"org-keyword">return</span> DOMNamespaces.MATH_ML
<span class="linenr">2822: </span>      }
<span class="linenr">2823: </span>    }
<span class="linenr">2824: </span>    <span class=
"org-keyword">return</span> ns
<span class="linenr">2825: </span>  },
<span class="linenr">2826: </span>
<span class="linenr">2827: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments</span>
<span class="linenr">2828: </span>  getTextMode({ tag, ns }) {
<span class="linenr">2829: </span>    <span class=
"org-keyword">if</span> (ns === DOMNamespaces.HTML) {
<span class="linenr">2830: </span>      <span class=
"org-keyword">if</span> (tag === <span class=
"org-string">'textarea'</span> || tag === <span class=
"org-string">'title'</span>) {
<span class="linenr">2831: </span>        <span class=
"org-keyword">return</span> TextModes.RCDATA
<span class="linenr">2832: </span>      }
<span class="linenr">2833: </span>      <span class=
"org-keyword">if</span> (isRawTextContainer(tag)) {
<span class="linenr">2834: </span>        <span class=
"org-keyword">return</span> TextModes.RAWTEXT
<span class="linenr">2835: </span>      }
<span class="linenr">2836: </span>    }
<span class="linenr">2837: </span>    <span class=
"org-keyword">return</span> TextModes.DATA
<span class="linenr">2838: </span>  }
<span class="linenr">2839: </span>}
<span class="linenr">2840: </span>
<span class="linenr">2841: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">hasDynamicKeyVBind</span>(<span class=
"org-variable-name">node</span>) {
<span class="linenr">2842: </span>  <span class=
"org-keyword">return</span> node.props.some(
<span class="linenr">2843: </span>    p =&gt;
<span class=
"linenr">2844: </span>      p.type === NodeTypes.DIRECTIVE &amp;&
<span class="linenr">2845: </span>      p.name === <span class=
"org-string">'bind'</span> &amp;&
<span class="linenr">2846: </span>      (!p.arg || <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">v-bind="obj"</span>
<span class=
"linenr">2847: </span>        p.arg.type !== NodeTypes.SIMPLE_EXPRESSION || <span class="org-comment-delimiter">// </span><span class="org-comment">v-bind:[_ctx.foo]</span>
<span class=
"linenr">2848: </span>        !p.arg.isStatic) <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">v-bind:[foo]</span>
<span class="linenr">2849: </span>  )
<span class="linenr">2850: </span>}
<span class="linenr">2851: </span>
<span class="linenr">2852: </span>
<span class="linenr">2853: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">hasMultipleChildren</span>(<span class=
"org-variable-name">node</span>) {
<span class="linenr">2854: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">#1352 filter out potential comment nodes.</span>
<span class="linenr">2855: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">children</span> = (node.children = node.children.filter(
<span class="linenr">2856: </span>    c =&gt;
<span class=
"linenr">2857: </span>      c.type !== NodeTypes.COMMENT &amp;&
<span class=
"linenr">2858: </span>      !(c.type === NodeTypes.TEXT &amp;& !c.content.trim())
<span class="linenr">2859: </span>  ))
<span class="linenr">2860: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">child</span> = children[<span class=
"org-highlight-numbers-number">0</span>]
<span class="linenr">2861: </span>  <span class=
"org-keyword">return</span> (
<span class=
"linenr">2862: </span>    children.length !== <span class=
"org-highlight-numbers-number">1</span> ||
<span class=
"linenr">2863: </span>    child.type === NodeTypes.FOR ||
<span class=
"linenr">2864: </span>    (child.type === NodeTypes.IF &amp;& child.branches.some(hasMultipleChildren))
<span class="linenr">2865: </span>  )
<span class="linenr">2866: </span>}
<span class="linenr">2867: </span>
<span class="linenr">2868: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">warnTransitionChildren</span> = (node, context) =&gt; {
<span class="linenr">2869: </span>  <span class=
"org-keyword">if</span> (
<span class=
"linenr">2870: </span>    node.type === NodeTypes.ELEMENT &amp;&
<span class=
"linenr">2871: </span>    node.tagType === ElementTypes.COMPONENT
<span class="linenr">2872: </span>  ) {
<span class="linenr">2873: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">component</span> = context.isBuiltInComponent(node.tag)
<span class="linenr">2874: </span>    <span class=
"org-keyword">if</span> (component === TRANSITION) {
<span class="linenr">2875: </span>      <span class=
"org-keyword">return</span> () =&gt; {
<span class="linenr">2876: </span>        <span class=
"org-keyword">if</span> (node.children.length &amp;& hasMultipleChildren(node)) {
<span class=
"linenr">2877: </span>          console.warn(<span class=
"org-string">`X_TRANSITION_INVALID_CHILDREN`</span>, node)
<span class="linenr">2878: </span>        }
<span class="linenr">2879: </span>      }
<span class="linenr">2880: </span>    }
<span class="linenr">2881: </span>  }
<span class="linenr">2882: </span>}
<span class="linenr">2883: </span>
<span class="linenr">2884: </span>
<span class="linenr">2885: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">ignoreSideEffectTags</span> = (node, context) =&gt; {
<span class="linenr">2886: </span>  <span class=
"org-keyword">if</span> (
<span class=
"linenr">2887: </span>    node.type === NodeTypes.ELEMENT &amp;&
<span class=
"linenr">2888: </span>    node.tagType === ElementTypes.ELEMENT &amp;&
<span class="linenr">2889: </span>    (node.tag === <span class=
"org-string">'script'</span> || node.tag === <span class=
"org-string">'style'</span>)
<span class="linenr">2890: </span>  ) {
<span class="linenr">2891: </span>    console.warn(<span class=
"org-string">`X_IGNORED_SIDE_EFFECT_TAG`</span>)
<span class="linenr">2892: </span>    context.removeNode()
<span class="linenr">2893: </span>  }
<span class="linenr">2894: </span>}
</pre>
      </div>
      <div class="org-src-container">
        <pre class="src src-js" id="org3f24966"><span class=
        "linenr">   1: </span>  <span class=
        "org-keyword">function</span> <span class=
        "org-function-name">createParserContext</span>(<span class=
        "org-variable-name">content</span>, <span class=
        "org-variable-name">rawOptions</span>) {
<span class="linenr">   2: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">options</span> = extend({}, defaultParserOptions)
<span class="linenr">   3: </span>  
<span class="linenr">   4: </span>    <span class=
"org-keyword">let</span> <span class="org-variable-name">key</span>
<span class="linenr">   5: </span>    <span class=
"org-keyword">for</span> (key <span class=
"org-keyword">in</span> rawOptions) {
<span class="linenr">   6: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">@ts-ignore</span>
<span class="linenr">   7: </span>      options[key] =
<span class=
"linenr">   8: </span>        rawOptions[key] === <span class=
"org-constant">undefined</span>
<span class=
"linenr">   9: </span>          ? defaultParserOptions[key]
<span class="linenr">  10: </span>          : rawOptions[key]
<span class="linenr">  11: </span>    }
<span class="linenr">  12: </span>    <span class=
"org-keyword">return</span> {
<span class="linenr">  13: </span>      options,
<span class="linenr">  14: </span>      column: <span class=
"org-highlight-numbers-number">1</span>,
<span class="linenr">  15: </span>      line: <span class=
"org-highlight-numbers-number">1</span>,
<span class="linenr">  16: </span>      offset: <span class=
"org-highlight-numbers-number">0</span>,
<span class="linenr">  17: </span>      originalSource: content,
<span class="linenr">  18: </span>      source: content,
<span class="linenr">  19: </span>      inPre: <span class=
"org-constant">false</span>,
<span class="linenr">  20: </span>      inVPre: <span class=
"org-constant">false</span>,
<span class="linenr">  21: </span>      onWarn: options.onWarn
<span class="linenr">  22: </span>    }
<span class="linenr">  23: </span>  }
<span class="linenr">  24: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">createRoot</span>(<span class=
"org-variable-name">children</span>, <span class=
"org-variable-name">loc</span> = <span class=
"org-variable-name">locStub</span>) {
<span class="linenr">  25: </span>    <span class=
"org-keyword">return</span> {
<span class="linenr">  26: </span>      type: NodeTypes.ROOT,
<span class="linenr">  27: </span>      children,
<span class="linenr">  28: </span>      helpers: [],
<span class="linenr">  29: </span>      components: [],
<span class="linenr">  30: </span>      directives: [],
<span class="linenr">  31: </span>      hoists: [],
<span class="linenr">  32: </span>      imports: [],
<span class="linenr">  33: </span>      cached: <span class=
"org-highlight-numbers-number">0</span>,
<span class="linenr">  34: </span>      temps: <span class=
"org-highlight-numbers-number">0</span>,
<span class="linenr">  35: </span>      codegenNode: <span class=
"org-constant">undefined</span>,
<span class="linenr">  36: </span>      loc
<span class="linenr">  37: </span>    }
<span class="linenr">  38: </span>  }
<span class="linenr">  39: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">parseChildren</span>(<span class=
"org-variable-name">context</span>, <span class=
"org-variable-name">mode</span>, <span class=
"org-variable-name">ancestors</span>) {
<span class="linenr">  40: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">parent</span> = last(ancestors)
<span class="linenr">  41: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">ns</span> = parent ? parent.ns : Namespaces.HTML
<span class="linenr">  42: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">nodes</span> = [] <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">-&gt; ancestors</span>
<span class="linenr">  43: </span>  
<span class="linenr">  44: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">1. while -&gt; isEnd ? 游标不断往前走直接所以 source 都解析完成</span>
<span class="linenr">  45: </span>    <span class=
"org-keyword">while</span> (!isEnd(context, mode, ancestors)) {
<span class="linenr">  46: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">s</span> = context.source
<span class="linenr">  47: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">node</span> = <span class=
"org-constant">undefined</span>
<span class="linenr">  48: </span>  
<span class="linenr">  49: </span>      <span class=
"org-keyword">if</span> (mode === TextModes.DATA || mode === TextModes.RCDATA) {
<span class="linenr">  50: </span>        <span class=
"org-keyword">if</span> (!context.inVPre &amp;& startsWith(s, context.options.delimiters[<span class="org-highlight-numbers-number">0</span>])) {
<span class="linenr">  51: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">'{{' 插值开始</span>
<span class=
"linenr">  52: </span>          node = parseInterpolation(context, mode)
<span class="linenr">  53: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (mode === TextModes.DATA &amp;& s[<span class="org-highlight-numbers-number">0</span>] === <span class="org-string">'&lt;'</span>) {
<span class="linenr">  54: </span>          <span class=
"org-keyword">if</span> (s[<span class=
"org-highlight-numbers-number">1</span>] === <span class=
"org-string">'/'</span>) {
<span class="linenr">  55: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">结束标签</span>
<span class="linenr">  56: </span>            <span class=
"org-keyword">if</span> (<span class=
"org-string">/[a-z]/</span>i.test(s[<span class=
"org-highlight-numbers-number">2</span>])) {
<span class="linenr">  57: </span>              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">异常结束，如：`&lt;div&gt;some text&lt;a`</span>
<span class=
"linenr">  58: </span>              emitError(context, <span class=
"org-string">'X_INVALID_END_TAG'</span>)
<span class=
"linenr">  59: </span>              parseTag(context, TagType.End, parent)
<span class="linenr">  60: </span>              <span class=
"org-keyword">continue</span>
<span class="linenr">  61: </span>            }
<span class="linenr">  62: </span>          } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (<span class=
"org-string">/[a-z]/</span>i.test(s[<span class=
"org-highlight-numbers-number">1</span>])) {
<span class="linenr">  63: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">正常的开始标签</span>
<span class=
"linenr">  64: </span>            node = parseElement(context, ancestors)
<span class="linenr">  65: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">2.x &lt;template&gt; 无指令兼容，这里就不实现了，重点关注 3.x 的代码</span>
<span class="linenr">  66: </span>          }
<span class="linenr">  67: </span>        }
<span class="linenr">  68: </span>      }
<span class="linenr">  69: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">以上都不是，说明应该是纯文本节点</span>
<span class="linenr">  70: </span>      <span class=
"org-keyword">if</span> (!node) {
<span class=
"linenr">  71: </span>        node = parseText(context, mode)
<span class="linenr">  72: </span>      }
<span class="linenr">  73: </span>  
<span class="linenr">  74: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">用 pushNode 在其中合并相邻的文本节点</span>
<span class="linenr">  75: </span>      <span class=
"org-keyword">if</span> (isArray(node)) {
<span class="linenr">  76: </span>        <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; node.length; i++) {
<span class=
"linenr">  77: </span>          pushNode(nodes, node[i])
<span class="linenr">  78: </span>        }
<span class="linenr">  79: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr">  80: </span>        pushNode(nodes, node)
<span class="linenr">  81: </span>      }
<span class="linenr">  82: </span>    }
<span class="linenr">  83: </span>  
<span class="linenr">  84: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">2. 合并相邻文本节点，空格处理，会将多个空格合并成一个空格</span>
<span class="linenr">  85: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">removedWhitespace</span> = <span class=
"org-constant">false</span>
<span class="linenr">  86: </span>    <span class=
"org-keyword">if</span> (mode !== TextModes.RAWTEXT &amp;& mode !== TextModes.RCDATA) {
<span class=
"linenr">  87: </span>      removedWhitespace = _removeWhitespace(nodes, context)
<span class="linenr">  88: </span>    }
<span class="linenr">  89: </span>  
<span class="linenr">  90: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">3. 最后返回解析后的节点树</span>
<span class="linenr">  91: </span>    <span class=
"org-keyword">return</span> removedWhitespace ? nodes.filter(Boolean) : nodes
<span class="linenr">  92: </span>  }
<span class="linenr">  93: </span>  
<span class="linenr">  94: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">_removeWhitespace</span>(<span class=
"org-variable-name">nodes</span>, <span class=
"org-variable-name">context</span>) {
<span class="linenr">  95: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">removedWhitespace</span> = <span class=
"org-constant">false</span>
<span class="linenr">  96: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">可以通过选项来指定是不是保留空格，否则多余的会合并成一个</span>
<span class="linenr">  97: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">shouldCondense</span> = context.options.whitespace !== <span class="org-string">'preserve'</span>
<span class="linenr">  98: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; nodes.length; i++) {
<span class="linenr">  99: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">node</span> = nodes[i]
<span class="linenr"> 100: </span>      <span class=
"org-keyword">if</span> (!context.inPre &amp;& node.type === NodeTypes.TEXT) {
<span class="linenr"> 101: </span>        <span class=
"org-keyword">if</span> (!<span class=
"org-string">/[^\t\r\n\f]/</span>.test(node.content)) {
<span class="linenr"> 102: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">prev</span> = nodes[i - <span class=
"org-highlight-numbers-number">1</span>]
<span class="linenr"> 103: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">next</span> = nodes[i + <span class=
"org-highlight-numbers-number">1</span>]
<span class="linenr"> 104: </span>  
<span class="linenr"> 105: </span>          <span class=
"org-keyword">if</span> (
<span class="linenr"> 106: </span>            !prev ||
<span class="linenr"> 107: </span>              !next ||
<span class=
"linenr"> 108: </span>              (shouldCondense &amp;& (
<span class=
"linenr"> 109: </span>                prev.type === NodeTypes.COMMENT || next.type === NodeTypes.COMMENT || (
<span class=
"linenr"> 110: </span>                  prev.type === NodeTypes.ELEMENT &amp;& next.type === NodeTypes.ELEMENT &amp;& <span class="org-string">/[\r\n]/</span>.test(node.content)
<span class="linenr"> 111: </span>                )
<span class="linenr"> 112: </span>              ))
<span class="linenr"> 113: </span>          ) {
<span class=
"linenr"> 114: </span>            removedWhitespace = <span class=
"org-constant">true</span>
<span class=
"linenr"> 115: </span>            nodes[i] = <span class=
"org-constant">null</span>
<span class="linenr"> 116: </span>          } <span class=
"org-keyword">else</span> {
<span class="linenr"> 117: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">合并成一个</span>
<span class=
"linenr"> 118: </span>            node.content = <span class=
"org-string">' '</span>
<span class="linenr"> 119: </span>          }
<span class="linenr"> 120: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (shouldCondense) {
<span class="linenr"> 121: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">保留空格</span>
<span class=
"linenr"> 122: </span>          node.content = node.content.replace(<span class="org-string">/[\t\r\n\f]+/</span>g, <span class="org-string">' '</span>)
<span class="linenr"> 123: </span>        }
<span class="linenr"> 124: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (node.type === NodeTypes.COMMENT &amp;& !context.options.comments) {
<span class="linenr"> 125: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">可以通过配置删除注释节点</span>
<span class=
"linenr"> 126: </span>        removedWhitespace = <span class=
"org-constant">true</span>
<span class="linenr"> 127: </span>        nodes[i] = <span class=
"org-constant">null</span>
<span class="linenr"> 128: </span>      }
<span class="linenr"> 129: </span>    }
<span class="linenr"> 130: </span>  
<span class="linenr"> 131: </span>    <span class=
"org-keyword">if</span> (context.inPre &amp;& parent &amp;& context.options.isPreTag(parent.tag)) {
<span class="linenr"> 132: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">删除 &lt;pre&gt; 中的第一行的空行</span>
<span class="linenr"> 133: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">first</span> = nodes[<span class=
"org-highlight-numbers-number">0</span>]
<span class="linenr"> 134: </span>      <span class=
"org-keyword">if</span> (first &amp;& first.type === NodeTypes.TEXT) {
<span class=
"linenr"> 135: </span>        first.content = first.content.replace(<span class="org-string">/^\r?\n/</span>, <span class="org-string">''</span>)
<span class="linenr"> 136: </span>      }
<span class="linenr"> 137: </span>    }
<span class="linenr"> 138: </span>  
<span class="linenr"> 139: </span>    <span class=
"org-keyword">return</span> removedWhitespace
<span class="linenr"> 140: </span>  }
<span class="linenr"> 141: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">parseElement</span>(<span class=
"org-variable-name">context</span>, <span class=
"org-variable-name">ancestors</span>) {
<span class="linenr"> 142: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">parent</span> = last(ancestors)
<span class="linenr"> 143: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">1. 解析出开始标签</span>
<span class="linenr"> 144: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">element</span> = parseTag(context, TagType.Start, parent)
<span class="linenr"> 145: </span>  
<span class="linenr"> 146: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">自闭合的标签： &lt;div/&gt;</span>
<span class="linenr"> 147: </span>    <span class=
"org-keyword">if</span> (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
<span class="linenr"> 148: </span>      <span class=
"org-keyword">return</span> element
<span class="linenr"> 149: </span>    }
<span class="linenr"> 150: </span>  
<span class="linenr"> 151: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">children</span>
<span class="linenr"> 152: </span>    ancestors.push(element)
<span class="linenr"> 153: </span>  
<span class="linenr"> 154: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">mode</span> = context.options.getTextMode(element, parent)
<span class="linenr"> 155: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">递归解析子节点</span>
<span class="linenr"> 156: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">children</span> = parseChildren(context, mode, ancestors)
<span class="linenr"> 157: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">解析完出栈 [root, parent1, parent2, ...] 代表层级</span>
<span class="linenr"> 158: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">&lt;root&gt;&lt;parent1&gt;&lt;parent2&gt;&lt;/parent&gt;&lt;parent1&gt;&lt;/root&gt; -&gt; 解析过程中通过</span>
<span class="linenr"> 159: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">ancestors 来维护这个层级关系</span>
<span class="linenr"> 160: </span>    ancestors.pop()
<span class="linenr"> 161: </span>  
<span class="linenr"> 162: </span>    element.children = children
<span class="linenr"> 163: </span>  
<span class="linenr"> 164: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">2. 解析结束标签</span>
<span class="linenr"> 165: </span>    <span class=
"org-keyword">if</span> (startsWithEndTagOpen(context.source, element.tag)) {
<span class=
"linenr"> 166: </span>      parseTag(context, TagType.End, parent)
<span class="linenr"> 167: </span>    }
<span class="linenr"> 168: </span>  
<span class="linenr"> 169: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">更新解析后节点在源码中的位置信息</span>
<span class=
"linenr"> 170: </span>    element.loc = getSelection(context, element.loc.start)
<span class="linenr"> 171: </span>  
<span class="linenr"> 172: </span>    <span class=
"org-keyword">return</span> element
<span class="linenr"> 173: </span>  }
<span class="linenr"> 174: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">parseTag</span>(<span class=
"org-variable-name">context</span>, <span class=
"org-variable-name">type</span>, <span class=
"org-variable-name">parent</span>) {
<span class="linenr"> 175: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">1. 开始标签</span>
<span class="linenr"> 176: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">start</span> = getCursor(context)
<span class="linenr"> 177: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">合法标签的正则匹配</span>
<span class="linenr"> 178: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">match</span> = <span class=
"org-string">/^&lt;\/?([a-z][^\t\r\n\f /&gt;]*)/</span>i.exec(context.source)
<span class="linenr"> 179: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">tag</span> = match[<span class=
"org-highlight-numbers-number">1</span>]
<span class="linenr"> 180: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">ns</span> = context.options.getNamespace(tag, parent)
<span class="linenr"> 181: </span>  
<span class="linenr"> 182: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">游标前进标签名长度的位置，如： &lt;div id="foo"&gt; -&gt; ` id="foo"&gt;`</span>
<span class=
"linenr"> 183: </span>    advanceBy(context, match[<span class=
"org-highlight-numbers-number">0</span>].length)
<span class="linenr"> 184: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">空格处理</span>
<span class="linenr"> 185: </span>    advanceSpaces(context)
<span class="linenr"> 186: </span>  
<span class="linenr"> 187: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">parse attributes</span>
<span class="linenr"> 188: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">props</span> = parseAttributes(context, type)
<span class="linenr"> 189: </span>  
<span class="linenr"> 190: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment"><span class="org-bold"><span class=
"org-warning">TODO</span></span></span><span class=
"org-comment"> v-pre 检测</span>
<span class="linenr"> 191: </span>  
<span class="linenr"> 192: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">2. 闭合标签</span>
<span class="linenr"> 193: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">isSelfClosing</span> = <span class=
"org-constant">false</span>
<span class="linenr"> 194: </span>    <span class=
"org-keyword">if</span> (context.source.length === <span class=
"org-highlight-numbers-number">0</span>) {
<span class="linenr"> 195: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">非法情况, ignore</span>
<span class="linenr"> 196: </span>    } <span class=
"org-keyword">else</span> {
<span class=
"linenr"> 197: </span>      isSelfClosing = startsWith(context.source, <span class="org-string">'/&gt;'</span>)
<span class=
"linenr"> 198: </span>      advanceBy(context, isSelfClosing ? <span class="org-highlight-numbers-number">2</span> : <span class="org-highlight-numbers-number">1</span>)
<span class="linenr"> 199: </span>    }
<span class="linenr"> 200: </span>  
<span class="linenr"> 201: </span>    <span class=
"org-keyword">if</span> (type === TagType.End) {
<span class="linenr"> 202: </span>      <span class=
"org-keyword">return</span>
<span class="linenr"> 203: </span>    }
<span class="linenr"> 204: </span>  
<span class="linenr"> 205: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">3. 分析出标签的类型</span>
<span class="linenr"> 206: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">tagType</span> = ElementTypes.ELEMENT
<span class="linenr"> 207: </span>    <span class=
"org-keyword">if</span> (!context.inVPre) {
<span class="linenr"> 208: </span>      <span class=
"org-keyword">if</span> (tag === <span class=
"org-string">'slot'</span>) {
<span class=
"linenr"> 209: </span>        tagType = ElementTypes.SLOT
<span class="linenr"> 210: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (tag === <span class=
"org-string">'template'</span>) {
<span class="linenr"> 211: </span>        <span class=
"org-keyword">if</span> (props.some(p =&gt; p.type === NodeTypes.DIRECTIVE &amp;& isSpecialTemplateDirective(p.name))) {
<span class=
"linenr"> 212: </span>          tagType = ElementTypes.TEMPLATE
<span class="linenr"> 213: </span>        }
<span class="linenr"> 214: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (isComponent(tag, props, context)) {
<span class=
"linenr"> 215: </span>        tagType = ElementTypes.COMPONENT
<span class="linenr"> 216: </span>      }
<span class="linenr"> 217: </span>    }
<span class="linenr"> 218: </span>  
<span class="linenr"> 219: </span>    <span class=
"org-keyword">return</span> {
<span class="linenr"> 220: </span>      type: NodeTypes.ELEMENT,
<span class="linenr"> 221: </span>      ns,
<span class="linenr"> 222: </span>      tag,
<span class="linenr"> 223: </span>      tagType,
<span class="linenr"> 224: </span>      props,
<span class="linenr"> 225: </span>      isSelfClosing,
<span class="linenr"> 226: </span>      children: [],
<span class=
"linenr"> 227: </span>      loc: getSelection(context, start),
<span class="linenr"> 228: </span>      codegenNode: <span class=
"org-constant">undefined</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">在 transform 阶段生成的产物</span>
<span class="linenr"> 229: </span>    }
<span class="linenr"> 230: </span>  }
<span class="linenr"> 231: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">parseText</span>(<span class=
"org-variable-name">context</span>, <span class=
"org-variable-name">mode</span>) {
<span class="linenr"> 232: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">endTokens</span> = mode === TextModes.CDATA ? [<span class="org-string">']]&gt;'</span>] : [<span class="org-string">'&lt;'</span>, context.options.delimiters[<span class="org-highlight-numbers-number">0</span>]]
<span class="linenr"> 233: </span>  
<span class="linenr"> 234: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">endIndex</span> = context.source.length
<span class="linenr"> 235: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; endTokens.length; i++) {
<span class="linenr"> 236: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">index</span> = context.source.indexOf(endTokens[i], <span class="org-highlight-numbers-number">1</span>)
<span class="linenr"> 237: </span>      <span class=
"org-keyword">if</span> (index !== -<span class=
"org-highlight-numbers-number">1</span> &amp;& endIndex &gt; index) {
<span class="linenr"> 238: </span>        endIndex = index
<span class="linenr"> 239: </span>      }
<span class="linenr"> 240: </span>    }
<span class="linenr"> 241: </span>  
<span class="linenr"> 242: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">start</span> = getCursor(context)
<span class="linenr"> 243: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">content</span> = parseTextData(context, endIndex, mode)
<span class="linenr"> 244: </span>  
<span class="linenr"> 245: </span>    <span class=
"org-keyword">return</span> {
<span class="linenr"> 246: </span>      type: NodeTypes.TEXT,
<span class="linenr"> 247: </span>      content,
<span class=
"linenr"> 248: </span>      loc: getSelection(context, start)
<span class="linenr"> 249: </span>    }
<span class="linenr"> 250: </span>  }
<span class="linenr"> 251: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">parseTextData</span>(<span class=
"org-variable-name">context</span>, <span class=
"org-variable-name">length</span>, <span class=
"org-variable-name">mode</span>) {
<span class="linenr"> 252: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">rawText</span> = context.source.slice(<span class="org-highlight-numbers-number">0</span>, length)
<span class="linenr"> 253: </span>    advanceBy(context, length)
<span class="linenr"> 254: </span>  
<span class="linenr"> 255: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">不含HTML entities</span>
<span class="linenr"> 256: </span>    <span class=
"org-keyword">if</span> (mode === TextModes.RAWTEXT || mode === TextModes.CDATA || !rawText.includes(<span class="org-string">'&amp;'</span>)) {
<span class="linenr"> 257: </span>      <span class=
"org-keyword">return</span> rawText
<span class="linenr"> 258: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr"> 259: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">将 &amp;gt; -&gt; `&gt;`, &amp;lt; -&gt; `&lt;`, &amp;amp; -&gt; `&amp;`, &amp;apos; -&gt; `'`, &amp;quot; -&gt; `"`</span>
<span class="linenr"> 260: </span>      <span class=
"org-keyword">return</span> context.options.decodeEntities(rawText, mode === TextModes.ATTRIBUTE_VALUE)
<span class="linenr"> 261: </span>    }
<span class="linenr"> 262: </span>  }
<span class="linenr"> 263: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">parseInterpolation</span>(<span class=
"org-variable-name">context</span>, <span class=
"org-variable-name">mode</span>) {
<span class="linenr"> 264: </span>    <span class=
"org-keyword">const</span> [<span class=
"org-variable-name">open</span>, <span class=
"org-variable-name">close</span>] = context.options.delimiters
<span class="linenr"> 265: </span>  
<span class="linenr"> 266: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">如： source = "{{ a + b }}"</span>
<span class="linenr"> 267: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">closeIndex = indexOf("}}", "{{".length) = 9</span>
<span class="linenr"> 268: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">closeIndex</span> = context.source.indexOf(close, open.length)
<span class="linenr"> 269: </span>    <span class=
"org-keyword">if</span> (closeIndex === -<span class=
"org-highlight-numbers-number">1</span>) {
<span class=
"linenr"> 270: </span>      emitError(context, <span class=
"org-string">'X_MISSING_INTERPOLATION_END'</span>)
<span class="linenr"> 271: </span>      <span class=
"org-keyword">return</span> <span class=
"org-constant">undefined</span>
<span class="linenr"> 272: </span>    }
<span class="linenr"> 273: </span>  
<span class="linenr"> 274: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">start</span> = getCursor(context)
<span class="linenr"> 275: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">&gt;&gt; 2 -&gt; " a + b }}"</span>
<span class=
"linenr"> 276: </span>    advanceBy(context, open.length)
<span class="linenr"> 277: </span>  
<span class="linenr"> 278: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">{ line, column, offset }</span>
<span class="linenr"> 279: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">innerStart</span> = getCursor(context)
<span class="linenr"> 280: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">innerEnd</span> = getCursor(context)
<span class="linenr"> 281: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">9 - '{{'.length = 7</span>
<span class="linenr"> 282: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">rawContentLength</span> = closeIndex - open.length
<span class="linenr"> 283: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">" a + b }}".slice(0, 7) =&gt; " a + b "</span>
<span class="linenr"> 284: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">rawContent</span> = context.source.slice(<span class="org-highlight-numbers-number">0</span>, rawContentLength)
<span class="linenr"> 285: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">preTrimContent</span> = parseTextData(context, rawContentLength, mode)
<span class="linenr"> 286: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">" a + b " =&gt; "a + b"</span>
<span class="linenr"> 287: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">content</span> = preTrimContent.trim()
<span class="linenr"> 288: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">startOffset</span> = preTrimContent.indexOf(content)
<span class="linenr"> 289: </span>    <span class=
"org-keyword">if</span> (startOffset &gt; <span class=
"org-highlight-numbers-number">0</span>) {
<span class="linenr"> 290: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">处理换行问题</span>
<span class=
"linenr"> 291: </span>      advancePositionWithMutation(innerStart, rawContent, startOffset)
<span class="linenr"> 292: </span>    }
<span class="linenr"> 293: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">endOffset</span> = rawContentLength - (preTrimContent.length - content.length - startOffset)
<span class=
"linenr"> 294: </span>    advancePositionWithMutation(innerEnd, rawContent, endOffset)
<span class=
"linenr"> 295: </span>    advanceBy(context, close.length)
<span class="linenr"> 296: </span>  
<span class="linenr"> 297: </span>    <span class=
"org-keyword">return</span> {
<span class=
"linenr"> 298: </span>      type: NodeTypes.INTERPOLATION,
<span class="linenr"> 299: </span>      content: {
<span class=
"linenr"> 300: </span>        type: NodeTypes.SIMPLE_EXPRESSION,
<span class="linenr"> 301: </span>        isStatic: <span class=
"org-constant">false</span>,
<span class="linenr"> 302: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">Set `isConstant` to false by default and will decide in transformExpression</span>
<span class=
"linenr"> 303: </span>        constType: ConstantTypes.NOT_CONSTANT,
<span class="linenr"> 304: </span>        content,
<span class=
"linenr"> 305: </span>        loc: getSelection(context, innerStart, innerEnd)
<span class="linenr"> 306: </span>      },
<span class=
"linenr"> 307: </span>      loc: getSelection(context, start)
<span class="linenr"> 308: </span>    }
<span class="linenr"> 309: </span>  }
<span class="linenr"> 310: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">parseAttributes</span>(<span class=
"org-variable-name">context</span>, <span class=
"org-variable-name">type</span>) {
<span class="linenr"> 311: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">props</span> = []
<span class="linenr"> 312: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">用 set 避免重复属性</span>
<span class="linenr"> 313: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">attributeNames</span> = <span class=
"org-keyword">new</span> <span class="org-type">Set</span>()
<span class="linenr"> 314: </span>    <span class=
"org-keyword">while</span> (
<span class=
"linenr"> 315: </span>      context.source.length &gt; <span class=
"org-highlight-numbers-number">0</span> &amp;&
<span class=
"linenr"> 316: </span>        !startsWith(context.source, <span class="org-string">'&gt;'</span>) &amp;&
<span class=
"linenr"> 317: </span>        !startsWith(context.source, <span class="org-string">'/&gt;'</span>)
<span class="linenr"> 318: </span>    ) {
<span class="linenr"> 319: </span>  
<span class="linenr"> 320: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">一些非法检测, ignore</span>
<span class="linenr"> 321: </span>  
<span class="linenr"> 322: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">attr</span> = parseAttribute(context, attributeNames)
<span class="linenr"> 323: </span>  
<span class="linenr"> 324: </span>      logg(<span class=
"org-string">'ATTR'</span>, attr)
<span class="linenr"> 325: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">去掉 class 之间多余的空格，如： `foo   bar  ` -&gt; `foo bar`</span>
<span class="linenr"> 326: </span>      <span class=
"org-keyword">if</span> (attr.type === NodeTypes.ATTRIBUTE &amp;&
<span class=
"linenr"> 327: </span>         attr.value &amp;& attr.name === <span class="org-string">'class'</span>) {
<span class=
"linenr"> 328: </span>        attr.value.content = attr.value.content.replace(<span class="org-string">/\s+/</span>g, <span class="org-string">' '</span>).trim()
<span class="linenr"> 329: </span>      }
<span class="linenr"> 330: </span>  
<span class="linenr"> 331: </span>      <span class=
"org-keyword">if</span> (type === TagType.Start) {
<span class="linenr"> 332: </span>        props.push(attr)
<span class="linenr"> 333: </span>      }
<span class="linenr"> 334: </span>  
<span class="linenr"> 335: </span>      advanceSpaces(context)
<span class="linenr"> 336: </span>    }
<span class="linenr"> 337: </span>  
<span class="linenr"> 338: </span>    <span class=
"org-keyword">return</span> props
<span class="linenr"> 339: </span>  }
<span class="linenr"> 340: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">parseAttribute</span>(<span class=
"org-variable-name">context</span>, <span class=
"org-variable-name">nameSet</span>) {
<span class="linenr"> 341: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">start</span> = getCursor(context)
<span class="linenr"> 342: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">match</span> = <span class=
"org-string">/^[^\t\r\n\f /&gt;][^\t\r\n\f /&gt;=]*/</span>.exec(context.source)
<span class="linenr"> 343: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">name</span> = match[<span class=
"org-highlight-numbers-number">0</span>]
<span class="linenr"> 344: </span>  
<span class="linenr"> 345: </span>    nameSet.add(name)
<span class="linenr"> 346: </span>  
<span class=
"linenr"> 347: </span>    advanceBy(context, name.length)
<span class="linenr"> 348: </span>  
<span class="linenr"> 349: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">value</span> = <span class=
"org-constant">undefined</span>
<span class="linenr"> 350: </span>  
<span class="linenr"> 351: </span>    <span class=
"org-keyword">if</span> (<span class=
"org-string">/^[\t\r\n\f ]*=/</span>.test(context.source)) {
<span class="linenr"> 352: </span>      advanceSpaces(context)
<span class=
"linenr"> 353: </span>      advanceBy(context, <span class=
"org-highlight-numbers-number">1</span>)
<span class="linenr"> 354: </span>      advanceSpaces(context)
<span class=
"linenr"> 355: </span>      value = parseAttributeValue(context)
<span class="linenr"> 356: </span>    }
<span class="linenr"> 357: </span>  
<span class="linenr"> 358: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">loc</span> = getSelection(context, start)
<span class="linenr"> 359: </span>  
<span class="linenr"> 360: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">v-on(@), v-bind(:), v-if, v-else, v-slot(#) 指令</span>
<span class="linenr"> 361: </span>    <span class=
"org-keyword">if</span> (!context.inVPre &amp;& <span class=
"org-string">/^(v-[A-Za-z0-9-]|:|\.|@|#)/</span>.test(name)) {
<span class="linenr"> 362: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">match</span> = <span class=
"org-string">/(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/</span>i.exec(name)
<span class="linenr"> 363: </span>  
<span class="linenr"> 364: </span>      log(<span class=
"org-string">`parseAttribute| match=${match}`</span>)
<span class="linenr"> 365: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">isPropShorthand</span> = startsWith(name, <span class="org-string">'.'</span>)
<span class="linenr"> 366: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">dirName</span> =
<span class="linenr"> 367: </span>          match[<span class=
"org-highlight-numbers-number">1</span>] ||
<span class=
"linenr"> 368: </span>          (isPropShorthand || startsWith(name, <span class="org-string">':'</span>)
<span class="linenr"> 369: </span>           ? <span class=
"org-string">'bind'</span>
<span class=
"linenr"> 370: </span>           : startsWith(name, <span class=
"org-string">'@'</span>)
<span class="linenr"> 371: </span>          ? <span class=
"org-string">'on'</span>
<span class="linenr"> 372: </span>          : <span class=
"org-string">'slot'</span>)
<span class="linenr"> 373: </span>      <span class=
"org-keyword">let</span> <span class="org-variable-name">arg</span>
<span class="linenr"> 374: </span>  
<span class="linenr"> 375: </span>      <span class=
"org-keyword">if</span> (match[<span class=
"org-highlight-numbers-number">2</span>]) {
<span class="linenr"> 376: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isSlot</span> = dirName === <span class=
"org-string">'slot'</span>
<span class="linenr"> 377: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">startOffset</span> = name.lastIndexOf(match[<span class="org-highlight-numbers-number">2</span>])
<span class="linenr"> 378: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">loc</span> = getSelection(
<span class="linenr"> 379: </span>          context,
<span class=
"linenr"> 380: </span>          getNewPosition(context, start, startOffset),
<span class="linenr"> 381: </span>          getNewPosition(
<span class="linenr"> 382: </span>            context,
<span class="linenr"> 383: </span>            start,
<span class=
"linenr"> 384: </span>            startOffset + match[<span class=
"org-highlight-numbers-number">2</span>].length + ((isSlot &amp;& match[<span class="org-highlight-numbers-number">3</span>]) || <span class="org-string">''</span>).length
<span class="linenr"> 385: </span>          )
<span class="linenr"> 386: </span>        )
<span class="linenr"> 387: </span>  
<span class="linenr"> 388: </span>        <span class=
"org-keyword">let</span> <span class=
"org-variable-name">content</span> = match[<span class=
"org-highlight-numbers-number">2</span>]
<span class="linenr"> 389: </span>        <span class=
"org-keyword">let</span> <span class=
"org-variable-name">isStatic</span> = <span class=
"org-constant">true</span>
<span class="linenr"> 390: </span>  
<span class="linenr"> 391: </span>        <span class=
"org-keyword">if</span> (content.startsWith(<span class=
"org-string">'['</span>)) {
<span class="linenr"> 392: </span>          isStatic = <span class=
"org-constant">false</span>
<span class="linenr"> 393: </span>  
<span class=
"linenr"> 394: </span>          content = content.slice(<span class="org-highlight-numbers-number">1</span>, content.length - <span class="org-highlight-numbers-number">1</span>)
<span class="linenr"> 395: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (isSlot){
<span class=
"linenr"> 396: </span>          content += match[<span class=
"org-highlight-numbers-number">3</span>] || <span class=
"org-string">''</span>
<span class="linenr"> 397: </span>        }
<span class="linenr"> 398: </span>  
<span class="linenr"> 399: </span>        arg = {
<span class=
"linenr"> 400: </span>          type: NodeTypes.SIMPLE_EXPRESSION,
<span class="linenr"> 401: </span>          content,
<span class="linenr"> 402: </span>          isStatic,
<span class="linenr"> 403: </span>          constType: isStatic
<span class=
"linenr"> 404: </span>            ? ConstantTypes.CAN_STRINGIFY
<span class=
"linenr"> 405: </span>            : ConstantTypes.NOT_CONSTANT,
<span class="linenr"> 406: </span>          loc
<span class="linenr"> 407: </span>        }
<span class="linenr"> 408: </span>      }
<span class="linenr"> 409: </span>  
<span class="linenr"> 410: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">quoted: `foo="bar"`, not quoted: `foo=bar`</span>
<span class="linenr"> 411: </span>      <span class=
"org-keyword">if</span> (value &amp;& value.isQuoted) {
<span class="linenr"> 412: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">valueLoc</span> = value.loc
<span class="linenr"> 413: </span>        valueLoc.start.offset++
<span class="linenr"> 414: </span>        valueLoc.start.column++
<span class=
"linenr"> 415: </span>        valueLoc.end = advancePositionWithClone(valueLoc.start, value.content)
<span class=
"linenr"> 416: </span>        valueLoc.source = valueLoc.source.slice(<span class="org-highlight-numbers-number">1</span>, -<span class="org-highlight-numbers-number">1</span>)
<span class="linenr"> 417: </span>      }
<span class="linenr"> 418: </span>  
<span class="linenr"> 419: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">修饰符 v-bind.number="foo" =&gt; '.number' =&gt; ['number']</span>
<span class="linenr"> 420: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">modifiers</span> = match[<span class=
"org-highlight-numbers-number">3</span>] ? match[<span class=
"org-highlight-numbers-number">3</span>].slice(<span class=
"org-highlight-numbers-number">1</span>).split(<span class=
"org-string">'.'</span>) : []
<span class="linenr"> 421: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">`&lt;div foo.prop="bar"&gt;` 如果不加 `.prop` 这个会被解析到 `$attrs` 中</span>
<span class="linenr"> 422: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">如果加了 `.prop` 则会被解析到 `$props` 中去</span>
<span class="linenr"> 423: </span>      <span class=
"org-keyword">if</span> (isPropShorthand) {
<span class=
"linenr"> 424: </span>        modifiers.push(<span class=
"org-string">'prop'</span>)
<span class="linenr"> 425: </span>      }
<span class="linenr"> 426: </span>  
<span class="linenr"> 427: </span>      <span class=
"org-keyword">return</span> {
<span class=
"linenr"> 428: </span>        type: NodeTypes.DIRECTIVE,
<span class="linenr"> 429: </span>        name: dirName,
<span class="linenr"> 430: </span>        exp: value &amp;& {
<span class=
"linenr"> 431: </span>          type: NodeTypes.SIMPLE_EXPRESSION,
<span class="linenr"> 432: </span>          content: value.content,
<span class="linenr"> 433: </span>          isStatic: <span class=
"org-constant">false</span>,
<span class="linenr"> 434: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">Treat as non-constant by default. This can be potentially set to</span>
<span class="linenr"> 435: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">other values by `transformExpression` to make it eligible for hoisting.</span>
<span class=
"linenr"> 436: </span>          constType: ConstantTypes.NOT_CONSTANT,
<span class="linenr"> 437: </span>          loc: value.loc
<span class="linenr"> 438: </span>        },
<span class="linenr"> 439: </span>        arg,
<span class="linenr"> 440: </span>        modifiers,
<span class="linenr"> 441: </span>        loc
<span class="linenr"> 442: </span>      }
<span class="linenr"> 443: </span>    }
<span class="linenr"> 444: </span>  
<span class="linenr"> 445: </span>    <span class=
"org-keyword">return</span> {
<span class="linenr"> 446: </span>      type: NodeTypes.ATTRIBUTE,
<span class="linenr"> 447: </span>      name,
<span class="linenr"> 448: </span>      value: value &amp;& {
<span class="linenr"> 449: </span>        type: NodeTypes.TEXT,
<span class="linenr"> 450: </span>        content: value.content,
<span class="linenr"> 451: </span>        loc: value.loc
<span class="linenr"> 452: </span>      },
<span class="linenr"> 453: </span>      loc
<span class="linenr"> 454: </span>    }
<span class="linenr"> 455: </span>  }
<span class="linenr"> 456: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">parseAttributeValue</span>(<span class=
"org-variable-name">context</span>) {
<span class="linenr"> 457: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">start</span> = getCursor(context)
<span class="linenr"> 458: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">content</span>
<span class="linenr"> 459: </span>  
<span class="linenr"> 460: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">quote</span> = context.source[<span class=
"org-highlight-numbers-number">0</span>]
<span class="linenr"> 461: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">value 分两种情况，可以用引号包起来也可以不使用引号</span>
<span class="linenr"> 462: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">`&lt;div foo="value"&gt;` 或 `&lt;div foo=value&gt;`</span>
<span class="linenr"> 463: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isQuoted</span> = quote === <span class=
"org-string">`"`</span> || quote === <span class=
"org-string">`'`</span>
<span class="linenr"> 464: </span>    <span class=
"org-keyword">if</span> (isQuoted) {
<span class="linenr"> 465: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">Quoted value.</span>
<span class=
"linenr"> 466: </span>      advanceBy(context, <span class=
"org-highlight-numbers-number">1</span>)
<span class="linenr"> 467: </span>  
<span class="linenr"> 468: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">endIndex</span> = context.source.indexOf(quote)
<span class="linenr"> 469: </span>      <span class=
"org-keyword">if</span> (endIndex === -<span class=
"org-highlight-numbers-number">1</span>) {
<span class="linenr"> 470: </span>        content = parseTextData(
<span class="linenr"> 471: </span>          context,
<span class="linenr"> 472: </span>          context.source.length,
<span class=
"linenr"> 473: </span>          TextModes.ATTRIBUTE_VALUE
<span class="linenr"> 474: </span>        )
<span class="linenr"> 475: </span>      } <span class=
"org-keyword">else</span> {
<span class=
"linenr"> 476: </span>        content = parseTextData(context, endIndex, TextModes.ATTRIBUTE_VALUE)
<span class=
"linenr"> 477: </span>        advanceBy(context, <span class=
"org-highlight-numbers-number">1</span>)
<span class="linenr"> 478: </span>      }
<span class="linenr"> 479: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr"> 480: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">Unquoted</span>
<span class="linenr"> 481: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">match</span> = <span class=
"org-string">/^[^\t\r\n\f &gt;]+/</span>.exec(context.source)
<span class="linenr"> 482: </span>      <span class=
"org-keyword">if</span> (!match) {
<span class="linenr"> 483: </span>        <span class=
"org-keyword">return</span> <span class=
"org-constant">undefined</span>
<span class="linenr"> 484: </span>      }
<span class=
"linenr"> 485: </span>      content = parseTextData(context, match[<span class="org-highlight-numbers-number">0</span>].length, TextModes.ATTRIBUTE_VALUE)
<span class="linenr"> 486: </span>    }
<span class="linenr"> 487: </span>  
<span class="linenr"> 488: </span>    <span class=
"org-keyword">return</span> { content, isQuoted, loc: getSelection(context, start) }
<span class="linenr"> 489: </span>  }
<span class="linenr"> 490: </span>  
<span class="linenr"> 491: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">baseParse</span>(<span class=
"org-variable-name">content</span>, <span class=
"org-variable-name">options</span> = {}) {
<span class="linenr"> 492: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">context</span> = createParserContext(content, options)
<span class="linenr"> 493: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">start</span> = getCursor(context)
<span class="linenr"> 494: </span>    <span class=
"org-keyword">return</span> createRoot(
<span class=
"linenr"> 495: </span>      parseChildren(context, TextModes.DATA, []),
<span class=
"linenr"> 496: </span>      getSelection(context, start)
<span class="linenr"> 497: </span>    )
<span class="linenr"> 498: </span>  }
<span class="linenr"> 499: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">createTransformContext</span>(
<span class="linenr"> 500: </span>    <span class=
"org-variable-name">root</span>,
<span class="linenr"> 501: </span>    {
<span class="linenr"> 502: </span>      filename = <span class=
"org-string">''</span>,
<span class=
"linenr"> 503: </span>      prefixIdentifiers = <span class=
"org-constant">false</span>,
<span class="linenr"> 504: </span>      hoistStatic = <span class=
"org-constant">false</span>,
<span class=
"linenr"> 505: </span>      cacheHandlers = <span class="org-constant">false</span>,
<span class="linenr"> 506: </span>      nodeTransforms = [],
<span class="linenr"> 507: </span>      directiveTransforms = {},
<span class=
"linenr"> 508: </span>      transformHoist = <span class=
"org-constant">null</span>,
<span class="linenr"> 509: </span>      isBuiltInComponent = NOOP,
<span class="linenr"> 510: </span>      isCustomElement = NOOP,
<span class="linenr"> 511: </span>      expressionPlugins = [],
<span class="linenr"> 512: </span>      scopeId = <span class=
"org-constant">null</span>,
<span class="linenr"> 513: </span>      slotted = <span class=
"org-constant">true</span>,
<span class="linenr"> 514: </span>      ssr = <span class=
"org-constant">false</span>,
<span class="linenr"> 515: </span>      inSSR = <span class=
"org-constant">false</span>,
<span class="linenr"> 516: </span>      ssrCssVars = <span class=
"org-string">``</span>,
<span class=
"linenr"> 517: </span>      bindingMetadata = EMPTY_OBJ,
<span class="linenr"> 518: </span>      inline = <span class=
"org-constant">false</span>,
<span class="linenr"> 519: </span>      isTS = <span class=
"org-constant">false</span>,
<span class="linenr"> 520: </span>      onError = defaultOnError,
<span class="linenr"> 521: </span>      onWarn = defaultOnWarn,
<span class="linenr"> 522: </span>      compatConfig
<span class="linenr"> 523: </span>    }
<span class="linenr"> 524: </span>  ) {
<span class="linenr"> 525: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">nameMatch</span> = filename.replace(<span class="org-string">/\?.*$/</span>, <span class="org-string">''</span>).match(<span class="org-string">/([^/\\]+)\.\w+$/</span>)
<span class="linenr"> 526: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">context</span> = {
<span class="linenr"> 527: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">options</span>
<span class=
"linenr"> 528: </span>      selfName: nameMatch &amp;& capitalize(camelize(nameMatch[<span class="org-highlight-numbers-number">1</span>])),
<span class="linenr"> 529: </span>      prefixIdentifiers,
<span class="linenr"> 530: </span>      hoistStatic,
<span class="linenr"> 531: </span>      cacheHandlers,
<span class="linenr"> 532: </span>      nodeTransforms,
<span class="linenr"> 533: </span>      directiveTransforms,
<span class="linenr"> 534: </span>      transformHoist,
<span class="linenr"> 535: </span>      isBuiltInComponent,
<span class="linenr"> 536: </span>      isCustomElement,
<span class="linenr"> 537: </span>      expressionPlugins,
<span class="linenr"> 538: </span>      scopeId,
<span class="linenr"> 539: </span>      slotted,
<span class="linenr"> 540: </span>      ssr,
<span class="linenr"> 541: </span>      inSSR,
<span class="linenr"> 542: </span>      ssrCssVars,
<span class="linenr"> 543: </span>      bindingMetadata,
<span class="linenr"> 544: </span>      inline,
<span class="linenr"> 545: </span>      isTS,
<span class="linenr"> 546: </span>      onError,
<span class="linenr"> 547: </span>      onWarn,
<span class="linenr"> 548: </span>      compatConfig,
<span class="linenr"> 549: </span>  
<span class="linenr"> 550: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">state</span>
<span class="linenr"> 551: </span>      root,
<span class="linenr"> 552: </span>      helpers: <span class=
"org-keyword">new</span> <span class="org-type">Map</span>(),
<span class="linenr"> 553: </span>      components: <span class=
"org-keyword">new</span> <span class="org-type">Set</span>(),
<span class="linenr"> 554: </span>      directives: <span class=
"org-keyword">new</span> <span class="org-type">Set</span>(),
<span class="linenr"> 555: </span>      hoists: [],
<span class="linenr"> 556: </span>      imports: [],
<span class="linenr"> 557: </span>      constantCache: <span class=
"org-keyword">new</span> <span class="org-type">Map</span>(),
<span class="linenr"> 558: </span>      temps: <span class=
"org-highlight-numbers-number">0</span>,
<span class="linenr"> 559: </span>      cached: <span class=
"org-highlight-numbers-number">0</span>,
<span class=
"linenr"> 560: </span>      identifiers: Object.create(<span class=
"org-constant">null</span>),
<span class="linenr"> 561: </span>      scopes: { <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">记录下面四个指令的嵌套层次</span>
<span class="linenr"> 562: </span>        vFor: <span class=
"org-highlight-numbers-number">0</span>,
<span class="linenr"> 563: </span>        vSlot: <span class=
"org-highlight-numbers-number">0</span>,
<span class="linenr"> 564: </span>        vPre: <span class=
"org-highlight-numbers-number">0</span>,
<span class="linenr"> 565: </span>        vOnce: <span class=
"org-highlight-numbers-number">0</span>
<span class="linenr"> 566: </span>      },
<span class="linenr"> 567: </span>      parent: <span class=
"org-constant">null</span>,
<span class="linenr"> 568: </span>      currentNode: root,
<span class="linenr"> 569: </span>      childIndex: <span class=
"org-highlight-numbers-number">0</span>,
<span class="linenr"> 570: </span>      inVOnce: <span class=
"org-constant">false</span>,
<span class="linenr"> 571: </span>  
<span class="linenr"> 572: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">methods</span>
<span class="linenr"> 573: </span>      helper(name) {
<span class="linenr"> 574: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">count</span> = context.helpers.get(name) || <span class="org-highlight-numbers-number">0</span>
<span class=
"linenr"> 575: </span>        context.helpers.set(name, count + <span class="org-highlight-numbers-number">1</span>)
<span class="linenr"> 576: </span>        <span class=
"org-keyword">return</span> name
<span class="linenr"> 577: </span>      },
<span class="linenr"> 578: </span>      removeHelper(name) {
<span class="linenr"> 579: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">count</span> = context.helpers.get(name)
<span class="linenr"> 580: </span>        <span class=
"org-keyword">if</span> (count) {
<span class="linenr"> 581: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">currentCount</span> = count - <span class=
"org-highlight-numbers-number">1</span>
<span class="linenr"> 582: </span>          <span class=
"org-keyword">if</span> (!currentCount) {
<span class=
"linenr"> 583: </span>            context.helpers.<span class=
"org-keyword">delete</span>(name)
<span class="linenr"> 584: </span>          } <span class=
"org-keyword">else</span> {
<span class=
"linenr"> 585: </span>            context.helpers.set(name, currentCount)
<span class="linenr"> 586: </span>          }
<span class="linenr"> 587: </span>        }
<span class="linenr"> 588: </span>      },
<span class="linenr"> 589: </span>      helperString(name) {
<span class="linenr"> 590: </span>        <span class=
"org-keyword">return</span> <span class=
"org-string">`_${helperNameMap[context.helper(name)]}`</span>
<span class="linenr"> 591: </span>      },
<span class="linenr"> 592: </span>      replaceNode(node) {
<span class=
"linenr"> 593: </span>        context.parent.children[context.childIndex] = context.currentNode = node
<span class="linenr"> 594: </span>      },
<span class="linenr"> 595: </span>      removeNode(node) {
<span class="linenr"> 596: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">list</span> = context.parent.children
<span class="linenr"> 597: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">removalIndex</span> = node
<span class="linenr"> 598: </span>          ? list.indexOf(node)
<span class="linenr"> 599: </span>          : context.currentNode
<span class="linenr"> 600: </span>          ? context.childIndex
<span class="linenr"> 601: </span>          : -<span class=
"org-highlight-numbers-number">1</span>
<span class="linenr"> 602: </span>  
<span class="linenr"> 603: </span>        <span class=
"org-keyword">if</span> (!node || node === context.currentNode) {
<span class="linenr"> 604: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">current node removed</span>
<span class=
"linenr"> 605: </span>          context.currentNode = <span class=
"org-constant">null</span>
<span class="linenr"> 606: </span>          context.onNodeRemoved()
<span class="linenr"> 607: </span>        } <span class=
"org-keyword">else</span> {
<span class="linenr"> 608: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">sibling node removed</span>
<span class="linenr"> 609: </span>          <span class=
"org-keyword">if</span> (context.childIndex &gt; removalIndex) {
<span class="linenr"> 610: </span>            context.childIndex--
<span class=
"linenr"> 611: </span>            context.onNodeRemoved()
<span class="linenr"> 612: </span>          }
<span class="linenr"> 613: </span>        }
<span class=
"linenr"> 614: </span>        context.parent.children.splice(removalIndex, <span class="org-highlight-numbers-number">1</span>)
<span class="linenr"> 615: </span>      },
<span class="linenr"> 616: </span>      onNodeRemoved: () =&gt; {},
<span class="linenr"> 617: </span>      addIdentifiers(exp) {
<span class="linenr"> 618: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">identifier tracking only happens in non-browser builds.</span>
<span class="linenr"> 619: </span>        <span class=
"org-keyword">if</span> (!__BROWSER__) {
<span class="linenr"> 620: </span>          <span class=
"org-keyword">if</span> (isString(exp)) {
<span class="linenr"> 621: </span>            addId(exp)
<span class="linenr"> 622: </span>          } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (exp.identifiers) {
<span class=
"linenr"> 623: </span>            exp.identifiers.forEach(addId)
<span class="linenr"> 624: </span>          } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (exp.type === NodeTypes.SIMPLE_EXPRESSION) {
<span class="linenr"> 625: </span>            addId(exp.content)
<span class="linenr"> 626: </span>          }
<span class="linenr"> 627: </span>        }
<span class="linenr"> 628: </span>      },
<span class="linenr"> 629: </span>      removeIdentifiers(exp) {
<span class="linenr"> 630: </span>        <span class=
"org-keyword">if</span> (!__BROWSER__) {
<span class="linenr"> 631: </span>          <span class=
"org-keyword">if</span> (isString(exp)) {
<span class="linenr"> 632: </span>            removeId(exp)
<span class="linenr"> 633: </span>          } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (exp.identifiers) {
<span class=
"linenr"> 634: </span>            exp.identifiers.forEach(removeId)
<span class="linenr"> 635: </span>          } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (exp.type === NodeTypes.SIMPLE_EXPRESSION) {
<span class="linenr"> 636: </span>            removeId(exp.content)
<span class="linenr"> 637: </span>          }
<span class="linenr"> 638: </span>        }
<span class="linenr"> 639: </span>      },
<span class="linenr"> 640: </span>      hoist(exp) {
<span class="linenr"> 641: </span>        <span class=
"org-keyword">if</span> (isString(exp)) exp = createSimpleExpression(exp)
<span class="linenr"> 642: </span>        context.hoists.push(exp)
<span class="linenr"> 643: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">identifier</span> = createSimpleExpression(
<span class="linenr"> 644: </span>          <span class=
"org-string">`_hoisted_${context.hoists.length}`</span>,
<span class="linenr"> 645: </span>          <span class=
"org-constant">false</span>,
<span class="linenr"> 646: </span>          exp.loc,
<span class="linenr"> 647: </span>          ConstantTypes.CAN_HOIST
<span class="linenr"> 648: </span>        )
<span class="linenr"> 649: </span>        identifier.hoisted = exp
<span class="linenr"> 650: </span>        <span class=
"org-keyword">return</span> identifier
<span class="linenr"> 651: </span>      },
<span class=
"linenr"> 652: </span>      cache(exp, isVNode = <span class=
"org-constant">false</span>) {
<span class="linenr"> 653: </span>        <span class=
"org-keyword">return</span> createCacheExpression(context.cached++, exp, isVNode)
<span class="linenr"> 654: </span>      }
<span class="linenr"> 655: </span>    }
<span class="linenr"> 656: </span>  
<span class="linenr"> 657: </span>    <span class=
"org-keyword">function</span> <span class=
"org-function-name">addId</span>(<span class=
"org-variable-name">id</span>) {
<span class="linenr"> 658: </span>      <span class=
"org-keyword">const</span> { identifiers } = context
<span class="linenr"> 659: </span>      <span class=
"org-keyword">if</span> (identifiers[id] === <span class=
"org-constant">undefined</span>) {
<span class=
"linenr"> 660: </span>        identifiers[id] = <span class=
"org-highlight-numbers-number">0</span>
<span class="linenr"> 661: </span>      }
<span class="linenr"> 662: </span>      identifiers[id]++
<span class="linenr"> 663: </span>    }
<span class="linenr"> 664: </span>  
<span class="linenr"> 665: </span>    <span class=
"org-keyword">function</span> <span class=
"org-function-name">removeId</span>(<span class=
"org-variable-name">id</span>) {
<span class="linenr"> 666: </span>      context.identifiers[id]--
<span class="linenr"> 667: </span>    }
<span class="linenr"> 668: </span>  
<span class="linenr"> 669: </span>    <span class=
"org-keyword">return</span> context
<span class="linenr"> 670: </span>  }
<span class="linenr"> 671: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">traverseNode</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
<span class="linenr"> 672: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">记录当前正在处理的节点</span>
<span class="linenr"> 673: </span>    context.currentNode = node
<span class="linenr"> 674: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">对节点转换时使用到的插件(外部可通过这个来修改某个指令)</span>
<span class="linenr"> 675: </span>    <span class=
"org-keyword">const</span> { nodeTransforms } = context
<span class="linenr"> 676: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">递归遍历结束，回溯时调用的函数列表</span>
<span class="linenr"> 677: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">也就是这个函数最后执行的函数，当一颗树遍历完成执行的函数</span>
<span class="linenr"> 678: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">随后的 for 循环是用来收集这些函数的</span>
<span class="linenr"> 679: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">exitFns</span> = []
<span class="linenr"> 680: </span>  
<span class="linenr"> 681: </span>    logg(<span class=
"org-string">'traverseNode'</span>, node)
<span class="linenr"> 682: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; nodeTransforms.length; i++) {
<span class="linenr"> 683: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">onExit</span> = nodeTransforms[i](node, context)
<span class="linenr"> 684: </span>      <span class=
"org-keyword">if</span> (onExit) {
<span class="linenr"> 685: </span>        <span class=
"org-keyword">if</span> (isArray(onExit)) {
<span class="linenr"> 686: </span>          exitFns.push(...onExit)
<span class="linenr"> 687: </span>        } <span class=
"org-keyword">else</span> {
<span class="linenr"> 688: </span>          exitFns.push(onExit)
<span class="linenr"> 689: </span>        }
<span class="linenr"> 690: </span>      }
<span class="linenr"> 691: </span>      <span class=
"org-keyword">if</span> (!context.currentNode) {
<span class="linenr"> 692: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">node was removed</span>
<span class="linenr"> 693: </span>        <span class=
"org-keyword">return</span>
<span class="linenr"> 694: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr"> 695: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">node may have been replaced</span>
<span class=
"linenr"> 696: </span>        node = context.currentNode
<span class="linenr"> 697: </span>      }
<span class="linenr"> 698: </span>    }
<span class="linenr"> 699: </span>  
<span class="linenr"> 700: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">根据节点类型来分别处理，这里忽略注释</span>
<span class="linenr"> 701: </span>    <span class=
"org-keyword">switch</span> (node.type) {
<span class="linenr"> 702: </span>      <span class=
"org-keyword">case</span> NodeTypes.INTERPOLATION:
<span class="linenr"> 703: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no need to traverse, but we need to inject toString helper</span>
<span class="linenr"> 704: </span>        <span class=
"org-keyword">if</span> (!context.ssr) {
<span class=
"linenr"> 705: </span>          context.helper(TO_DISPLAY_STRING)
<span class="linenr"> 706: </span>        }
<span class="linenr"> 707: </span>        <span class=
"org-keyword">break</span>
<span class="linenr"> 708: </span>  
<span class="linenr"> 709: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">for container types, further traverse downwards</span>
<span class="linenr"> 710: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">处理 if...else if...else 分支</span>
<span class="linenr"> 711: </span>      <span class=
"org-keyword">case</span> NodeTypes.IF:
<span class="linenr"> 712: </span>        <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; node.branches.length; i++) {
<span class=
"linenr"> 713: </span>          traverseNode(node.branches[i], context)
<span class="linenr"> 714: </span>        }
<span class="linenr"> 715: </span>        <span class=
"org-keyword">break</span>
<span class="linenr"> 716: </span>      <span class=
"org-keyword">case</span> NodeTypes.IF_BRANCH: <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">else..if</span>
<span class="linenr"> 717: </span>      <span class=
"org-keyword">case</span> NodeTypes.FOR: <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">for</span>
<span class="linenr"> 718: </span>      <span class=
"org-keyword">case</span> NodeTypes.ELEMENT:
<span class="linenr"> 719: </span>      <span class=
"org-keyword">case</span> NodeTypes.ROOT:
<span class=
"linenr"> 720: </span>        traverseChildren(node, context)
<span class="linenr"> 721: </span>        <span class=
"org-keyword">break</span>
<span class="linenr"> 722: </span>    }
<span class="linenr"> 723: </span>  
<span class="linenr"> 724: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">收集完成，执行这些收集到的函数，作用到当前节点上</span>
<span class="linenr"> 725: </span>    context.currentNode = node
<span class="linenr"> 726: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = exitFns.length
<span class="linenr"> 727: </span>    <span class=
"org-keyword">while</span> (i--) {
<span class="linenr"> 728: </span>      exitFns[i]()
<span class="linenr"> 729: </span>    }
<span class="linenr"> 730: </span>  }
<span class="linenr"> 731: </span>  
<span class="linenr"> 732: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">traverseChildren</span>(<span class=
"org-variable-name">parent</span>, <span class=
"org-variable-name">context</span>) {
<span class="linenr"> 733: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>
<span class="linenr"> 734: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">nodeRemoved</span> = () =&gt; {
<span class="linenr"> 735: </span>      i--
<span class="linenr"> 736: </span>    }
<span class="linenr"> 737: </span>    <span class=
"org-keyword">for</span> (; i &lt; parent.children.length; i++) {
<span class="linenr"> 738: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">child</span> = parent.children[i]
<span class="linenr"> 739: </span>      <span class=
"org-keyword">if</span> (isString(child)) <span class=
"org-keyword">continue</span>
<span class="linenr"> 740: </span>      context.parent = parent
<span class="linenr"> 741: </span>      context.childIndex = i
<span class=
"linenr"> 742: </span>      context.onNodeRemoved = nodeRemoved
<span class=
"linenr"> 743: </span>      traverseNode(child, context)
<span class="linenr"> 744: </span>    }
<span class="linenr"> 745: </span>  }
<span class="linenr"> 746: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">hoistStatic</span>(<span class=
"org-variable-name">root</span>, <span class=
"org-variable-name">context</span>) {
<span class="linenr"> 747: </span>    _walk(
<span class="linenr"> 748: </span>      root,
<span class="linenr"> 749: </span>      context,
<span class="linenr"> 750: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">Root node is unfortunately non-hoistable due to potential parent</span>
<span class="linenr"> 751: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">fallthrough attributes.</span>
<span class=
"linenr"> 752: </span>      isSingleElementRoot(root, root.children[<span class="org-highlight-numbers-number">0</span>])
<span class="linenr"> 753: </span>    )
<span class="linenr"> 754: </span>  }
<span class="linenr"> 755: </span>  
<span class="linenr"> 756: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">isSingleElementRoot</span>(
<span class="linenr"> 757: </span>    <span class=
"org-variable-name">root</span>,
<span class="linenr"> 758: </span>    child
<span class="linenr"> 759: </span>  ) {
<span class="linenr"> 760: </span>    <span class=
"org-keyword">const</span> { children } = root
<span class="linenr"> 761: </span>    <span class=
"org-keyword">return</span> (
<span class=
"linenr"> 762: </span>      children.length === <span class=
"org-highlight-numbers-number">1</span> &amp;&
<span class=
"linenr"> 763: </span>      child.type === NodeTypes.ELEMENT &amp;&
<span class="linenr"> 764: </span>      !isSlotOutlet(child)
<span class="linenr"> 765: </span>    )
<span class="linenr"> 766: </span>  }
<span class="linenr"> 767: </span>  
<span class="linenr"> 768: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">_walk</span>(
<span class="linenr"> 769: </span>    <span class=
"org-variable-name">node</span>,
<span class="linenr"> 770: </span>    <span class=
"org-variable-name">context</span>,
<span class="linenr"> 771: </span>    doNotHoistNode = <span class=
"org-constant">false</span>
<span class="linenr"> 772: </span>  ) {
<span class="linenr"> 773: </span>    <span class=
"org-keyword">const</span> { children } = node
<span class="linenr"> 774: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">originalCount</span> = children.length
<span class="linenr"> 775: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">hoistedCount</span> = <span class=
"org-highlight-numbers-number">0</span>
<span class="linenr"> 776: </span>  
<span class="linenr"> 777: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; children.length; i++) {
<span class="linenr"> 778: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">child</span> = children[i]
<span class="linenr"> 779: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">only plain elements & text calls are eligible for hoisting.</span>
<span class="linenr"> 780: </span>      <span class=
"org-keyword">if</span> (
<span class=
"linenr"> 781: </span>        child.type === NodeTypes.ELEMENT &amp;&
<span class=
"linenr"> 782: </span>        child.tagType === ElementTypes.ELEMENT
<span class="linenr"> 783: </span>      ) {
<span class="linenr"> 784: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">constantType</span> = doNotHoistNode
<span class=
"linenr"> 785: </span>          ? ConstantTypes.NOT_CONSTANT
<span class=
"linenr"> 786: </span>          : getConstantType(child, context)
<span class="linenr"> 787: </span>        <span class=
"org-keyword">if</span> (constantType &gt; ConstantTypes.NOT_CONSTANT) {
<span class="linenr"> 788: </span>          <span class=
"org-keyword">if</span> (constantType &gt;= ConstantTypes.CAN_HOIST) {
<span class=
"linenr"> 789: </span>            child.codegenNode.patchFlag =
<span class=
"linenr"> 790: </span>              PatchFlags.HOISTED + (__DEV__ ? <span class="org-string">` /* HOISTED */`</span> : <span class="org-string">``</span>)
<span class=
"linenr"> 791: </span>            child.codegenNode = context.hoist(child.codegenNode)
<span class="linenr"> 792: </span>            hoistedCount++
<span class="linenr"> 793: </span>            <span class=
"org-keyword">continue</span>
<span class="linenr"> 794: </span>          }
<span class="linenr"> 795: </span>        } <span class=
"org-keyword">else</span> {
<span class="linenr"> 796: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">node may contain dynamic children, but its props may be eligible for</span>
<span class="linenr"> 797: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">hoisting.</span>
<span class="linenr"> 798: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">codegenNode</span> = child.codegenNode
<span class="linenr"> 799: </span>          <span class=
"org-keyword">if</span> (codegenNode.type === NodeTypes.VNODE_CALL) {
<span class="linenr"> 800: </span>            <span class=
"org-keyword">const</span> <span class=
"org-variable-name">flag</span> = getPatchFlag(codegenNode)
<span class="linenr"> 801: </span>            <span class=
"org-keyword">if</span> (
<span class="linenr"> 802: </span>              (!flag ||
<span class=
"linenr"> 803: </span>                flag === PatchFlags.NEED_PATCH ||
<span class=
"linenr"> 804: </span>                flag === PatchFlags.TEXT) &amp;&
<span class=
"linenr"> 805: </span>              getGeneratedPropsConstantType(child, context) &gt;=
<span class=
"linenr"> 806: </span>                ConstantTypes.CAN_HOIST
<span class="linenr"> 807: </span>            ) {
<span class="linenr"> 808: </span>              <span class=
"org-keyword">const</span> <span class=
"org-variable-name">props</span> = getNodeProps(child)
<span class="linenr"> 809: </span>              <span class=
"org-keyword">if</span> (props) {
<span class=
"linenr"> 810: </span>                codegenNode.props = context.hoist(props)
<span class="linenr"> 811: </span>              }
<span class="linenr"> 812: </span>            }
<span class="linenr"> 813: </span>            <span class=
"org-keyword">if</span> (codegenNode.dynamicProps) {
<span class=
"linenr"> 814: </span>              codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps)
<span class="linenr"> 815: </span>            }
<span class="linenr"> 816: </span>          }
<span class="linenr"> 817: </span>        }
<span class="linenr"> 818: </span>      } <span class=
"org-keyword">else</span> <span class="org-keyword">if</span> (
<span class=
"linenr"> 819: </span>        child.type === NodeTypes.TEXT_CALL &amp;&
<span class=
"linenr"> 820: </span>        getConstantType(child.content, context) &gt;= ConstantTypes.CAN_HOIST
<span class="linenr"> 821: </span>      ) {
<span class=
"linenr"> 822: </span>        child.codegenNode = context.hoist(child.codegenNode)
<span class="linenr"> 823: </span>        hoistedCount++
<span class="linenr"> 824: </span>      }
<span class="linenr"> 825: </span>  
<span class="linenr"> 826: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">walk further</span>
<span class="linenr"> 827: </span>      <span class=
"org-keyword">if</span> (child.type === NodeTypes.ELEMENT) {
<span class="linenr"> 828: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isComponent</span> = child.tagType === ElementTypes.COMPONENT
<span class="linenr"> 829: </span>        <span class=
"org-keyword">if</span> (isComponent) {
<span class="linenr"> 830: </span>          context.scopes.vSlot++
<span class="linenr"> 831: </span>        }
<span class="linenr"> 832: </span>        _walk(child, context)
<span class="linenr"> 833: </span>        <span class=
"org-keyword">if</span> (isComponent) {
<span class="linenr"> 834: </span>          context.scopes.vSlot--
<span class="linenr"> 835: </span>        }
<span class="linenr"> 836: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (child.type === NodeTypes.FOR) {
<span class="linenr"> 837: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">Do not hoist v-for single child because it has to be a block</span>
<span class=
"linenr"> 838: </span>        _walk(child, context, child.children.length === <span class="org-highlight-numbers-number">1</span>)
<span class="linenr"> 839: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (child.type === NodeTypes.IF) {
<span class="linenr"> 840: </span>        <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; child.branches.length; i++) {
<span class="linenr"> 841: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">Do not hoist v-if single child because it has to be a block</span>
<span class="linenr"> 842: </span>          _walk(
<span class="linenr"> 843: </span>            child.branches[i],
<span class="linenr"> 844: </span>            context,
<span class=
"linenr"> 845: </span>            child.branches[i].children.length === <span class="org-highlight-numbers-number">1</span>
<span class="linenr"> 846: </span>          )
<span class="linenr"> 847: </span>        }
<span class="linenr"> 848: </span>      }
<span class="linenr"> 849: </span>    }
<span class="linenr"> 850: </span>  
<span class="linenr"> 851: </span>    <span class=
"org-keyword">if</span> (hoistedCount &amp;& context.transformHoist) {
<span class="linenr"> 852: </span>      logg(<span class=
"org-string">`hoist walk -&gt; transformHoist, hoistedCount = ${hoistedCount}`</span>)
<span class=
"linenr"> 853: </span>      context.transformHoist(children, context, node)
<span class="linenr"> 854: </span>    }
<span class="linenr"> 855: </span>  
<span class="linenr"> 856: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">all children were hoisted - the entire children array is hoistable.</span>
<span class="linenr"> 857: </span>    <span class=
"org-keyword">if</span> (
<span class="linenr"> 858: </span>      hoistedCount &amp;&
<span class=
"linenr"> 859: </span>      hoistedCount === originalCount &amp;&
<span class=
"linenr"> 860: </span>      node.type === NodeTypes.ELEMENT &amp;&
<span class=
"linenr"> 861: </span>      node.tagType === ElementTypes.ELEMENT &amp;&
<span class="linenr"> 862: </span>      node.codegenNode &amp;&
<span class=
"linenr"> 863: </span>      node.codegenNode.type === NodeTypes.VNODE_CALL &amp;&
<span class=
"linenr"> 864: </span>      isArray(node.codegenNode.children)
<span class="linenr"> 865: </span>    ) {
<span class=
"linenr"> 866: </span>      node.codegenNode.children = context.hoist(
<span class=
"linenr"> 867: </span>        createArrayExpression(node.codegenNode.children)
<span class="linenr"> 868: </span>      )
<span class="linenr"> 869: </span>    }
<span class="linenr"> 870: </span>  }
<span class="linenr"> 871: </span>  
<span class="linenr"> 872: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">getConstantType</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
<span class="linenr"> 873: </span>    <span class=
"org-keyword">const</span> { constantCache } = context
<span class="linenr"> 874: </span>    <span class=
"org-keyword">switch</span> (node.type) {
<span class="linenr"> 875: </span>      <span class=
"org-keyword">case</span> NodeTypes.ELEMENT:
<span class="linenr"> 876: </span>        <span class=
"org-keyword">if</span> (node.tagType !== ElementTypes.ELEMENT) {
<span class="linenr"> 877: </span>          <span class=
"org-keyword">return</span> ConstantTypes.NOT_CONSTANT
<span class="linenr"> 878: </span>        }
<span class="linenr"> 879: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">cached</span> = constantCache.get(node)
<span class="linenr"> 880: </span>        <span class=
"org-keyword">if</span> (cached !== <span class=
"org-constant">undefined</span>) {
<span class="linenr"> 881: </span>          <span class=
"org-keyword">return</span> cached
<span class="linenr"> 882: </span>        }
<span class="linenr"> 883: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">codegenNode</span> = node.codegenNode
<span class="linenr"> 884: </span>        <span class=
"org-keyword">if</span> (codegenNode.type !== NodeTypes.VNODE_CALL) {
<span class="linenr"> 885: </span>          <span class=
"org-keyword">return</span> ConstantTypes.NOT_CONSTANT
<span class="linenr"> 886: </span>        }
<span class="linenr"> 887: </span>        <span class=
"org-keyword">if</span> (
<span class=
"linenr"> 888: </span>          codegenNode.isBlock &amp;&
<span class=
"linenr"> 889: </span>          node.tag !== <span class=
"org-string">'svg'</span> &amp;&
<span class=
"linenr"> 890: </span>          node.tag !== <span class=
"org-string">'foreignObject'</span>
<span class="linenr"> 891: </span>        ) {
<span class="linenr"> 892: </span>          <span class=
"org-keyword">return</span> ConstantTypes.NOT_CONSTANT
<span class="linenr"> 893: </span>        }
<span class="linenr"> 894: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">flag</span> = getPatchFlag(codegenNode)
<span class="linenr"> 895: </span>        <span class=
"org-keyword">if</span> (!flag) {
<span class="linenr"> 896: </span>          <span class=
"org-keyword">let</span> <span class=
"org-variable-name">returnType</span> = ConstantTypes.CAN_STRINGIFY
<span class="linenr"> 897: </span>  
<span class="linenr"> 898: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">Element itself has no patch flag. However we still need to check:</span>
<span class="linenr"> 899: </span>  
<span class="linenr"> 900: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">1. Even for a node with no patch flag, it is possible for it to contain</span>
<span class="linenr"> 901: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">non-hoistable expressions that refers to scope variables, e.g. compiler</span>
<span class="linenr"> 902: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">injected keys or cached event handlers. Therefore we need to always</span>
<span class="linenr"> 903: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">check the codegenNode's props to be sure.</span>
<span class="linenr"> 904: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">generatedPropsType</span> = getGeneratedPropsConstantType(node, context)
<span class="linenr"> 905: </span>          <span class=
"org-keyword">if</span> (generatedPropsType === ConstantTypes.NOT_CONSTANT) {
<span class=
"linenr"> 906: </span>            constantCache.set(node, ConstantTypes.NOT_CONSTANT)
<span class="linenr"> 907: </span>            <span class=
"org-keyword">return</span> ConstantTypes.NOT_CONSTANT
<span class="linenr"> 908: </span>          }
<span class="linenr"> 909: </span>          <span class=
"org-keyword">if</span> (generatedPropsType &lt; returnType) {
<span class=
"linenr"> 910: </span>            returnType = generatedPropsType
<span class="linenr"> 911: </span>          }
<span class="linenr"> 912: </span>  
<span class="linenr"> 913: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">2. its children.</span>
<span class="linenr"> 914: </span>          <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; node.children.length; i++) {
<span class="linenr"> 915: </span>            <span class=
"org-keyword">const</span> <span class=
"org-variable-name">childType</span> = getConstantType(node.children[i], context)
<span class="linenr"> 916: </span>            <span class=
"org-keyword">if</span> (childType === ConstantTypes.NOT_CONSTANT) {
<span class=
"linenr"> 917: </span>              constantCache.set(node, ConstantTypes.NOT_CONSTANT)
<span class="linenr"> 918: </span>              <span class=
"org-keyword">return</span> ConstantTypes.NOT_CONSTANT
<span class="linenr"> 919: </span>            }
<span class="linenr"> 920: </span>            <span class=
"org-keyword">if</span> (childType &lt; returnType) {
<span class=
"linenr"> 921: </span>              returnType = childType
<span class="linenr"> 922: </span>            }
<span class="linenr"> 923: </span>          }
<span class="linenr"> 924: </span>  
<span class="linenr"> 925: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">3. if the type is not already CAN_SKIP_PATCH which is the lowest non-0</span>
<span class="linenr"> 926: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">type, check if any of the props can cause the type to be lowered</span>
<span class="linenr"> 927: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">we can skip can_patch because it's guaranteed by the absence of a</span>
<span class="linenr"> 928: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">patchFlag.</span>
<span class="linenr"> 929: </span>          <span class=
"org-keyword">if</span> (returnType &gt; ConstantTypes.CAN_SKIP_PATCH) {
<span class="linenr"> 930: </span>            <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; node.props.length; i++) {
<span class="linenr"> 931: </span>              <span class=
"org-keyword">const</span> <span class=
"org-variable-name">p</span> = node.props[i]
<span class="linenr"> 932: </span>              <span class=
"org-keyword">if</span> (p.type === NodeTypes.DIRECTIVE &amp;& p.name === <span class="org-string">'bind'</span> &amp;& p.exp) {
<span class="linenr"> 933: </span>                <span class=
"org-keyword">const</span> <span class=
"org-variable-name">expType</span> = getConstantType(p.exp, context)
<span class="linenr"> 934: </span>                <span class=
"org-keyword">if</span> (expType === ConstantTypes.NOT_CONSTANT) {
<span class=
"linenr"> 935: </span>                  constantCache.set(node, ConstantTypes.NOT_CONSTANT)
<span class="linenr"> 936: </span>                  <span class=
"org-keyword">return</span> ConstantTypes.NOT_CONSTANT
<span class="linenr"> 937: </span>                }
<span class="linenr"> 938: </span>                <span class=
"org-keyword">if</span> (expType &lt; returnType) {
<span class=
"linenr"> 939: </span>                  returnType = expType
<span class="linenr"> 940: </span>                }
<span class="linenr"> 941: </span>              }
<span class="linenr"> 942: </span>            }
<span class="linenr"> 943: </span>          }
<span class="linenr"> 944: </span>  
<span class="linenr"> 945: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">only svg/foreignObject could be block here, however if they are</span>
<span class="linenr"> 946: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">static then they don't need to be blocks since there will be no</span>
<span class="linenr"> 947: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">nested updates.</span>
<span class="linenr"> 948: </span>          <span class=
"org-keyword">if</span> (codegenNode.isBlock) {
<span class=
"linenr"> 949: </span>            context.removeHelper(OPEN_BLOCK)
<span class="linenr"> 950: </span>            context.removeHelper(
<span class=
"linenr"> 951: </span>              getVNodeBlockHelper(context.inSSR, codegenNode.isComponent)
<span class="linenr"> 952: </span>            )
<span class=
"linenr"> 953: </span>            codegenNode.isBlock = <span class="org-constant">false</span>
<span class=
"linenr"> 954: </span>            context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent))
<span class="linenr"> 955: </span>          }
<span class="linenr"> 956: </span>  
<span class=
"linenr"> 957: </span>          constantCache.set(node, returnType)
<span class="linenr"> 958: </span>          <span class=
"org-keyword">return</span> returnType
<span class="linenr"> 959: </span>        } <span class=
"org-keyword">else</span> {
<span class=
"linenr"> 960: </span>          constantCache.set(node, ConstantTypes.NOT_CONSTANT)
<span class="linenr"> 961: </span>          <span class=
"org-keyword">return</span> ConstantTypes.NOT_CONSTANT
<span class="linenr"> 962: </span>        }
<span class="linenr"> 963: </span>      <span class=
"org-keyword">case</span> NodeTypes.TEXT:
<span class="linenr"> 964: </span>      <span class=
"org-keyword">case</span> NodeTypes.COMMENT:
<span class="linenr"> 965: </span>        <span class=
"org-keyword">return</span> ConstantTypes.CAN_STRINGIFY
<span class="linenr"> 966: </span>      <span class=
"org-keyword">case</span> NodeTypes.IF:
<span class="linenr"> 967: </span>      <span class=
"org-keyword">case</span> NodeTypes.FOR:
<span class="linenr"> 968: </span>      <span class=
"org-keyword">case</span> NodeTypes.IF_BRANCH:
<span class="linenr"> 969: </span>        <span class=
"org-keyword">return</span> ConstantTypes.NOT_CONSTANT
<span class="linenr"> 970: </span>      <span class=
"org-keyword">case</span> NodeTypes.INTERPOLATION:
<span class="linenr"> 971: </span>      <span class=
"org-keyword">case</span> NodeTypes.TEXT_CALL:
<span class="linenr"> 972: </span>        <span class=
"org-keyword">return</span> getConstantType(node.content, context)
<span class="linenr"> 973: </span>      <span class=
"org-keyword">case</span> NodeTypes.SIMPLE_EXPRESSION:
<span class="linenr"> 974: </span>        <span class=
"org-keyword">return</span> node.constType
<span class="linenr"> 975: </span>      <span class=
"org-keyword">case</span> NodeTypes.COMPOUND_EXPRESSION:
<span class="linenr"> 976: </span>        <span class=
"org-keyword">let</span> <span class=
"org-variable-name">returnType</span> = ConstantTypes.CAN_STRINGIFY
<span class="linenr"> 977: </span>        <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; node.children.length; i++) {
<span class="linenr"> 978: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">child</span> = node.children[i]
<span class="linenr"> 979: </span>          <span class=
"org-keyword">if</span> (isString(child) || isSymbol(child)) {
<span class="linenr"> 980: </span>            <span class=
"org-keyword">continue</span>
<span class="linenr"> 981: </span>          }
<span class="linenr"> 982: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">childType</span> = getConstantType(child, context)
<span class="linenr"> 983: </span>          <span class=
"org-keyword">if</span> (childType === ConstantTypes.NOT_CONSTANT) {
<span class="linenr"> 984: </span>            <span class=
"org-keyword">return</span> ConstantTypes.NOT_CONSTANT
<span class="linenr"> 985: </span>          } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (childType &lt; returnType) {
<span class=
"linenr"> 986: </span>            returnType = childType
<span class="linenr"> 987: </span>          }
<span class="linenr"> 988: </span>        }
<span class="linenr"> 989: </span>        <span class=
"org-keyword">return</span> returnType
<span class="linenr"> 990: </span>      <span class=
"org-keyword">default</span>:
<span class="linenr"> 991: </span>        <span class=
"org-keyword">return</span> ConstantTypes.NOT_CONSTANT
<span class="linenr"> 992: </span>    }
<span class="linenr"> 993: </span>  }
<span class="linenr"> 994: </span>  
<span class="linenr"> 995: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">allowHoistedHelperSet</span> = <span class=
"org-keyword">new</span> <span class="org-type">Set</span>([
<span class="linenr"> 996: </span>    NORMALIZE_CLASS,
<span class="linenr"> 997: </span>    NORMALIZE_STYLE,
<span class="linenr"> 998: </span>    NORMALIZE_PROPS,
<span class="linenr"> 999: </span>    GUARD_REACTIVE_PROPS
<span class="linenr">1000: </span>  ])
<span class="linenr">1001: </span>  
<span class="linenr">1002: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">getConstantTypeOfHelperCall</span>(<span class=
"org-variable-name">value</span>, <span class=
"org-variable-name">context</span>){
<span class="linenr">1003: </span>    <span class=
"org-keyword">if</span> (
<span class=
"linenr">1004: </span>      value.type === NodeTypes.JS_CALL_EXPRESSION &amp;&
<span class=
"linenr">1005: </span>      !isString(value.callee) &amp;&
<span class=
"linenr">1006: </span>      allowHoistedHelperSet.has(value.callee)
<span class="linenr">1007: </span>    ) {
<span class="linenr">1008: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">arg</span> = value.<span class=
"org-constant">arguments</span>[<span class=
"org-highlight-numbers-number">0</span>]
<span class="linenr">1009: </span>      <span class=
"org-keyword">if</span> (arg.type === NodeTypes.SIMPLE_EXPRESSION) {
<span class="linenr">1010: </span>        <span class=
"org-keyword">return</span> getConstantType(arg, context)
<span class="linenr">1011: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (arg.type === NodeTypes.JS_CALL_EXPRESSION) {
<span class="linenr">1012: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(exp))`</span>
<span class="linenr">1013: </span>        <span class=
"org-keyword">return</span> getConstantTypeOfHelperCall(arg, context)
<span class="linenr">1014: </span>      }
<span class="linenr">1015: </span>    }
<span class="linenr">1016: </span>    <span class=
"org-keyword">return</span> ConstantTypes.NOT_CONSTANT
<span class="linenr">1017: </span>  }
<span class="linenr">1018: </span>  
<span class="linenr">1019: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">getGeneratedPropsConstantType</span>(<span class="org-variable-name">node</span>, <span class="org-variable-name">context</span>) {
<span class="linenr">1020: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">returnType</span> = ConstantTypes.CAN_STRINGIFY
<span class="linenr">1021: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">props</span> = getNodeProps(node)
<span class="linenr">1022: </span>    <span class=
"org-keyword">if</span> (props &amp;& props.type === NodeTypes.JS_OBJECT_EXPRESSION) {
<span class="linenr">1023: </span>      <span class=
"org-keyword">const</span> { properties } = props
<span class="linenr">1024: </span>      <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; properties.length; i++) {
<span class="linenr">1025: </span>        <span class=
"org-keyword">const</span> { key, value } = properties[i]
<span class="linenr">1026: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">keyType</span> = getConstantType(key, context)
<span class="linenr">1027: </span>        <span class=
"org-keyword">if</span> (keyType === ConstantTypes.NOT_CONSTANT) {
<span class="linenr">1028: </span>          <span class=
"org-keyword">return</span> keyType
<span class="linenr">1029: </span>        }
<span class="linenr">1030: </span>        <span class=
"org-keyword">if</span> (keyType &lt; returnType) {
<span class="linenr">1031: </span>          returnType = keyType
<span class="linenr">1032: </span>        }
<span class="linenr">1033: </span>        <span class=
"org-keyword">let</span> <span class=
"org-variable-name">valueType</span>
<span class="linenr">1034: </span>        <span class=
"org-keyword">if</span> (value.type === NodeTypes.SIMPLE_EXPRESSION) {
<span class=
"linenr">1035: </span>          valueType = getConstantType(value, context)
<span class="linenr">1036: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (value.type === NodeTypes.JS_CALL_EXPRESSION) {
<span class="linenr">1037: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">some helper calls can be hoisted,</span>
<span class="linenr">1038: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">such as the `normalizeProps` generated by the compiler for pre-normalize class,</span>
<span class="linenr">1039: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">in this case we need to respect the ConstantType of the helper's arguments</span>
<span class=
"linenr">1040: </span>          valueType = getConstantTypeOfHelperCall(value, context)
<span class="linenr">1041: </span>        } <span class=
"org-keyword">else</span> {
<span class=
"linenr">1042: </span>          valueType = ConstantTypes.NOT_CONSTANT
<span class="linenr">1043: </span>        }
<span class="linenr">1044: </span>        <span class=
"org-keyword">if</span> (valueType === ConstantTypes.NOT_CONSTANT) {
<span class="linenr">1045: </span>          <span class=
"org-keyword">return</span> valueType
<span class="linenr">1046: </span>        }
<span class="linenr">1047: </span>        <span class=
"org-keyword">if</span> (valueType &lt; returnType) {
<span class="linenr">1048: </span>          returnType = valueType
<span class="linenr">1049: </span>        }
<span class="linenr">1050: </span>      }
<span class="linenr">1051: </span>    }
<span class="linenr">1052: </span>    <span class=
"org-keyword">return</span> returnType
<span class="linenr">1053: </span>  }
<span class="linenr">1054: </span>  
<span class="linenr">1055: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">getNodeProps</span>(<span class=
"org-variable-name">node</span>) {
<span class="linenr">1056: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">codegenNode</span> = node.codegenNode
<span class="linenr">1057: </span>    <span class=
"org-keyword">if</span> (codegenNode.type === NodeTypes.VNODE_CALL) {
<span class="linenr">1058: </span>      <span class=
"org-keyword">return</span> codegenNode.props
<span class="linenr">1059: </span>    }
<span class="linenr">1060: </span>  }
<span class="linenr">1061: </span>  
<span class="linenr">1062: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">getPatchFlag</span>(<span class=
"org-variable-name">node</span>) {
<span class="linenr">1063: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">flag</span> = node.patchFlag
<span class="linenr">1064: </span>    <span class=
"org-keyword">return</span> flag ? parseInt(flag, <span class=
"org-highlight-numbers-number">10</span>) : <span class=
"org-constant">undefined</span>
<span class="linenr">1065: </span>  }
<span class="linenr">1066: </span>  
<span class="linenr">1067: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">createRootCodegen</span>(<span class=
"org-variable-name">root</span>, <span class=
"org-variable-name">context</span>) {
<span class="linenr">1068: </span>    <span class=
"org-keyword">const</span> { helper } = context
<span class="linenr">1069: </span>    <span class=
"org-keyword">const</span> { children } = root
<span class="linenr">1070: </span>    logg(<span class=
"org-string">'createRootCodegen'</span>, <span class=
"org-string">`children=${children.length}, 只有一个用 block, 多个用Fragment`</span>)
<span class="linenr">1071: </span>    <span class=
"org-keyword">if</span> (children.length === <span class=
"org-highlight-numbers-number">1</span>) {
<span class="linenr">1072: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">child</span> = children[<span class=
"org-highlight-numbers-number">0</span>]
<span class="linenr">1073: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">if the single child is an element, turn it into a block.</span>
<span class="linenr">1074: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">如果只有一个根元素，如： &lt;template&gt;&lt;div&gt;...&lt;/div&gt;&lt;/template&gt;</span>
<span class="linenr">1075: </span>      <span class=
"org-keyword">if</span> (isSingleElementRoot(root, child) &amp;& child.codegenNode) {
<span class="linenr">1076: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">single element root is never hoisted so codegenNode will never be</span>
<span class="linenr">1077: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">SimpleExpressionNode</span>
<span class="linenr">1078: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">codegenNode</span> = child.codegenNode
<span class="linenr">1079: </span>        <span class=
"org-keyword">if</span> (codegenNode.type === NodeTypes.VNODE_CALL) {
<span class=
"linenr">1080: </span>          makeBlock(codegenNode, context)
<span class="linenr">1081: </span>        }
<span class=
"linenr">1082: </span>        root.codegenNode = codegenNode
<span class="linenr">1083: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr">1084: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">- single &lt;slot/&gt;, IfNode, ForNode: already blocks.</span>
<span class="linenr">1085: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">- single text node: always patched.</span>
<span class="linenr">1086: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">root codegen falls through via genNode()</span>
<span class="linenr">1087: </span>        root.codegenNode = child
<span class="linenr">1088: </span>      }
<span class="linenr">1089: </span>    } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (children.length &gt; <span class=
"org-highlight-numbers-number">1</span>) {
<span class="linenr">1090: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">root 下有多个节点时，使用 fragment block，3.x 特性，2.x中是不支持多个元素的</span>
<span class="linenr">1091: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">patchFlag</span> = PatchFlags.STABLE_FRAGMENT
<span class="linenr">1092: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">patchFlagText</span> = PatchFlagNames[PatchFlags.STABLE_FRAGMENT]
<span class="linenr">1093: </span>  
<span class=
"linenr">1094: </span>      root.codegenNode = createVNodeCall(
<span class="linenr">1095: </span>        context,
<span class="linenr">1096: </span>        helper(FRAGMENT),
<span class="linenr">1097: </span>        <span class=
"org-constant">undefined</span>,
<span class="linenr">1098: </span>        root.children,
<span class=
"linenr">1099: </span>        patchFlag + (__DEV__ ? <span class=
"org-string">` /* ${patchFlagText} */`</span> : <span class=
"org-string">``</span>),
<span class="linenr">1100: </span>        <span class=
"org-constant">undefined</span>,
<span class="linenr">1101: </span>        <span class=
"org-constant">undefined</span>,
<span class="linenr">1102: </span>        <span class=
"org-constant">true</span>,
<span class="linenr">1103: </span>        <span class=
"org-constant">undefined</span>,
<span class="linenr">1104: </span>        <span class=
"org-constant">false</span> <span class=
"org-comment-delimiter">/* </span><span class=
"org-comment">isComponent</span><span class=
"org-comment-delimiter"> */</span>
<span class="linenr">1105: </span>      )
<span class="linenr">1106: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr">1107: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no children = noop. codegen will return null.</span>
<span class="linenr">1108: </span>    }
<span class="linenr">1109: </span>  }
<span class="linenr">1110: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">createStructuralDirectiveTransform</span>(<span class="org-variable-name">name</span>, <span class="org-variable-name">fn</span>) {
<span class="linenr">1111: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">正则就用 test 方法，字符串直接比较</span>
<span class="linenr">1112: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">matches</span> = isString(name)
<span class="linenr">1113: </span>      ? (n) =&gt; n === name
<span class="linenr">1114: </span>      : (n) =&gt; name.test(n)
<span class="linenr">1115: </span>  
<span class="linenr">1116: </span>    logg(<span class=
"org-string">'createStructuralDirectiveTransform'</span>, <span class="org-string">`name=${name}, matches=${matches}`</span>)
<span class="linenr">1117: </span>    <span class=
"org-keyword">return</span> (node, context) =&gt; {
<span class="linenr">1118: </span>      <span class=
"org-keyword">if</span> (node.type === NodeTypes.ELEMENT) {
<span class="linenr">1119: </span>        <span class=
"org-keyword">const</span> { props } = node
<span class="linenr">1120: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">v-slot 指令特殊处理，代码在 vSlot.ts 中，所以这里跳过它</span>
<span class="linenr">1121: </span>        <span class=
"org-keyword">if</span> (node.tagType === ElementTypes.TEMPLATE &amp;& props.some(isVSlot)) {
<span class="linenr">1122: </span>          <span class=
"org-keyword">return</span>
<span class="linenr">1123: </span>        }
<span class="linenr">1124: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">exitFns</span> = []
<span class="linenr">1125: </span>        <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; props.length; i++) {
<span class="linenr">1126: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">prop</span> = props[i]
<span class="linenr">1127: </span>          <span class=
"org-keyword">if</span> (prop.type === NodeTypes.DIRECTIVE &amp;& matches(prop.name)) {
<span class="linenr">1128: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">structural directives are removed to avoid infinite recursion</span>
<span class="linenr">1129: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">also we remove them *before* applying so that it can further</span>
<span class="linenr">1130: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">traverse itself in case it moves the node around</span>
<span class=
"linenr">1131: </span>            props.splice(i, <span class=
"org-highlight-numbers-number">1</span>)
<span class="linenr">1132: </span>            i--
<span class="linenr">1133: </span>            <span class=
"org-keyword">const</span> <span class=
"org-variable-name">onExit</span> = fn(node, prop, context)
<span class="linenr">1134: </span>            <span class=
"org-keyword">if</span> (onExit) exitFns.push(onExit)
<span class="linenr">1135: </span>          }
<span class="linenr">1136: </span>        }
<span class="linenr">1137: </span>        <span class=
"org-keyword">return</span> exitFns
<span class="linenr">1138: </span>      }
<span class="linenr">1139: </span>    }
<span class="linenr">1140: </span>  }
<span class="linenr">1141: </span>  
<span class="linenr">1142: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">getBaseTransformPreset</span>(<span class=
"org-variable-name">prefixIdentifiers</span>) {
<span class="linenr">1143: </span>    <span class=
"org-keyword">return</span> [
<span class="linenr">1144: </span>      [
<span class="linenr">1145: </span>        transformOnce,
<span class="linenr">1146: </span>        transformIf,
<span class="linenr">1147: </span>        transformMemo,
<span class="linenr">1148: </span>        transformFor,
<span class=
"linenr">1149: </span>        ...(!__BROWSER__ &amp;& prefixIdentifiers
<span class="linenr">1150: </span>          ? [
<span class="linenr">1151: </span>              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">order is important</span>
<span class=
"linenr">1152: </span>              trackVForSlotScopes,
<span class="linenr">1153: </span>              transformExpression
<span class="linenr">1154: </span>            ]
<span class=
"linenr">1155: </span>          : __BROWSER__ &amp;& __DEV__
<span class="linenr">1156: </span>          ? [transformExpression]
<span class="linenr">1157: </span>          : []),
<span class="linenr">1158: </span>        transformSlotOutlet,
<span class="linenr">1159: </span>        transformElement,
<span class="linenr">1160: </span>        trackSlotScopes,
<span class="linenr">1161: </span>        transformText
<span class="linenr">1162: </span>      ],
<span class="linenr">1163: </span>      {
<span class="linenr">1164: </span>        on: transformOn,
<span class="linenr">1165: </span>        bind: transformBind,
<span class="linenr">1166: </span>        model: transformModel
<span class="linenr">1167: </span>      }
<span class="linenr">1168: </span>    ]
<span class="linenr">1169: </span>  }
<span class="linenr">1170: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">makeBlock</span>(<span class=
"org-variable-name">node</span>, { <span class=
"org-variable-name">helper</span>, <span class=
"org-variable-name">removeHelper</span>, <span class=
"org-variable-name">inSSR</span> }) {
<span class="linenr">1171: </span>    <span class=
"org-keyword">if</span> (!node.isBlock) {
<span class="linenr">1172: </span>      node.isBlock = <span class=
"org-constant">true</span>
<span class=
"linenr">1173: </span>      removeHelper(getVNodeHelper(inSSR, node.isComponent))
<span class="linenr">1174: </span>      helper(OPEN_BLOCK)
<span class=
"linenr">1175: </span>      helper(getVNodeBlockHelper(inSSR, node.isComponent))
<span class="linenr">1176: </span>    }
<span class="linenr">1177: </span>  }
<span class="linenr">1178: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">defaultFallback</span> = createSimpleExpression(<span class="org-string">`undefined`</span>, <span class="org-constant">false</span>)
<span class="linenr">1179: </span>  
<span class="linenr">1180: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">A NodeTransform that:</span>
<span class="linenr">1181: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">1. Tracks scope identifiers for scoped slots so that they don't get prefixed</span>
<span class="linenr">1182: </span>  <span class=
"org-comment-delimiter">//    </span><span class=
"org-comment">by transformExpression. This is only applied in non-browser builds with</span>
<span class="linenr">1183: </span>  <span class=
"org-comment-delimiter">//    </span><span class=
"org-comment">{ prefixIdentifiers: true }.</span>
<span class="linenr">1184: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">2. Track v-slot depths so that we know a slot is inside another slot.</span>
<span class="linenr">1185: </span>  <span class=
"org-comment-delimiter">//    </span><span class=
"org-comment">Note the exit callback is executed before buildSlots() on the same node,</span>
<span class="linenr">1186: </span>  <span class=
"org-comment-delimiter">//    </span><span class=
"org-comment">so only nested slots see positive numbers.</span>
<span class="linenr">1187: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">trackSlotScopes</span> = (node, context) =&gt; {
<span class="linenr">1188: </span>    <span class=
"org-keyword">if</span> (
<span class=
"linenr">1189: </span>      node.type === NodeTypes.ELEMENT &amp;&
<span class=
"linenr">1190: </span>      (node.tagType === ElementTypes.COMPONENT ||
<span class=
"linenr">1191: </span>        node.tagType === ElementTypes.TEMPLATE)
<span class="linenr">1192: </span>    ) {
<span class="linenr">1193: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">We are only checking non-empty v-slot here</span>
<span class="linenr">1194: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">since we only care about slots that introduce scope variables.</span>
<span class="linenr">1195: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">vSlot</span> = findDir(node, <span class=
"org-string">'slot'</span>)
<span class="linenr">1196: </span>      <span class=
"org-keyword">if</span> (vSlot) {
<span class="linenr">1197: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">slotProps</span> = vSlot.exp
<span class="linenr">1198: </span>        <span class=
"org-keyword">if</span> (!__BROWSER__ &amp;& context.prefixIdentifiers) {
<span class=
"linenr">1199: </span>          slotProps &amp;& context.addIdentifiers(slotProps)
<span class="linenr">1200: </span>        }
<span class="linenr">1201: </span>        context.scopes.vSlot++
<span class="linenr">1202: </span>        <span class=
"org-keyword">return</span> () =&gt; {
<span class="linenr">1203: </span>          <span class=
"org-keyword">if</span> (!__BROWSER__ &amp;& context.prefixIdentifiers) {
<span class=
"linenr">1204: </span>            slotProps &amp;& context.removeIdentifiers(slotProps)
<span class="linenr">1205: </span>          }
<span class="linenr">1206: </span>          context.scopes.vSlot--
<span class="linenr">1207: </span>        }
<span class="linenr">1208: </span>      }
<span class="linenr">1209: </span>    }
<span class="linenr">1210: </span>  }
<span class="linenr">1211: </span>  
<span class="linenr">1212: </span>  
<span class="linenr">1213: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">A NodeTransform that tracks scope identifiers for scoped slots with v-for.</span>
<span class="linenr">1214: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">This transform is only applied in non-browser builds with { prefixIdentifiers: true }</span>
<span class="linenr">1215: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">trackVForSlotScopes</span> = (node, context) =&gt; {
<span class="linenr">1216: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">vFor</span>
<span class="linenr">1217: </span>    <span class=
"org-keyword">if</span> (
<span class="linenr">1218: </span>      isTemplateNode(node) &amp;&
<span class=
"linenr">1219: </span>      node.props.some(isVSlot) &amp;&
<span class=
"linenr">1220: </span>      (vFor = findDir(node, <span class=
"org-string">'for'</span>))
<span class="linenr">1221: </span>    ) {
<span class="linenr">1222: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">result</span> = (vFor.parseResult = parseForExpression(
<span class="linenr">1223: </span>        vFor.exp,
<span class="linenr">1224: </span>        context
<span class="linenr">1225: </span>      ))
<span class="linenr">1226: </span>      <span class=
"org-keyword">if</span> (result) {
<span class="linenr">1227: </span>        <span class=
"org-keyword">const</span> { value, key, index } = result
<span class="linenr">1228: </span>        <span class=
"org-keyword">const</span> { addIdentifiers, removeIdentifiers } = context
<span class=
"linenr">1229: </span>        value &amp;& addIdentifiers(value)
<span class=
"linenr">1230: </span>        key &amp;& addIdentifiers(key)
<span class=
"linenr">1231: </span>        index &amp;& addIdentifiers(index)
<span class="linenr">1232: </span>  
<span class="linenr">1233: </span>        <span class=
"org-keyword">return</span> () =&gt; {
<span class=
"linenr">1234: </span>          value &amp;& removeIdentifiers(value)
<span class=
"linenr">1235: </span>          key &amp;& removeIdentifiers(key)
<span class=
"linenr">1236: </span>          index &amp;& removeIdentifiers(index)
<span class="linenr">1237: </span>        }
<span class="linenr">1238: </span>      }
<span class="linenr">1239: </span>    }
<span class="linenr">1240: </span>  }
<span class="linenr">1241: </span>  
<span class="linenr">1242: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">buildClientSlotFn</span> = (props, children, loc) =&gt;
<span class="linenr">1243: </span>    createFunctionExpression(
<span class="linenr">1244: </span>      props,
<span class="linenr">1245: </span>      children,
<span class="linenr">1246: </span>      <span class=
"org-constant">false</span> <span class=
"org-comment-delimiter">/* </span><span class=
"org-comment">newline</span><span class=
"org-comment-delimiter"> */</span>,
<span class="linenr">1247: </span>      <span class=
"org-constant">true</span> <span class=
"org-comment-delimiter">/* </span><span class=
"org-comment">isSlot</span><span class=
"org-comment-delimiter"> */</span>,
<span class=
"linenr">1248: </span>      children.length ? children[<span class=
"org-highlight-numbers-number">0</span>].loc : loc
<span class="linenr">1249: </span>    )
<span class="linenr">1250: </span>  
<span class="linenr">1251: </span>  
<span class="linenr">1252: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">Instead of being a DirectiveTransform, v-slot processing is called during</span>
<span class="linenr">1253: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">transformElement to build the slots object for a component.</span>
<span class="linenr">1254: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">buildSlots</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>, <span class=
"org-variable-name">buildSlotFn</span>= <span class=
"org-variable-name">buildClientSlotFn</span>) {
<span class="linenr">1255: </span>    context.helper(WITH_CTX)
<span class="linenr">1256: </span>  
<span class="linenr">1257: </span>    <span class=
"org-keyword">const</span> { children, loc } = node
<span class="linenr">1258: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">slotsProperties</span> = []
<span class="linenr">1259: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">dynamicSlots</span>= []
<span class="linenr">1260: </span>  
<span class="linenr">1261: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">If the slot is inside a v-for or another v-slot, force it to be dynamic</span>
<span class="linenr">1262: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">since it likely uses a scope variable.</span>
<span class="linenr">1263: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">hasDynamicSlots</span> = context.scopes.vSlot &gt; <span class="org-highlight-numbers-number">0</span> || context.scopes.vFor &gt; <span class="org-highlight-numbers-number">0</span>
<span class="linenr">1264: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">with `prefixIdentifiers: true`, this can be further optimized to make</span>
<span class="linenr">1265: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">it dynamic only when the slot actually uses the scope variables.</span>
<span class="linenr">1266: </span>    <span class=
"org-keyword">if</span> (!__BROWSER__ &amp;& !context.ssr &amp;& context.prefixIdentifiers) {
<span class=
"linenr">1267: </span>      hasDynamicSlots = hasScopeRef(node, context.identifiers)
<span class="linenr">1268: </span>    }
<span class="linenr">1269: </span>  
<span class="linenr">1270: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">1. Check for slot with slotProps on component itself.</span>
<span class="linenr">1271: </span>    <span class=
"org-comment-delimiter">//    </span><span class=
"org-comment">&lt;Comp v-slot="{ prop }"/&gt;</span>
<span class="linenr">1272: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">onComponentSlot</span> = findDir(node, <span class="org-string">'slot'</span>, <span class="org-constant">true</span>)
<span class="linenr">1273: </span>    <span class=
"org-keyword">if</span> (onComponentSlot) {
<span class="linenr">1274: </span>      <span class=
"org-keyword">const</span> { arg, exp } = onComponentSlot
<span class="linenr">1275: </span>      <span class=
"org-keyword">if</span> (arg &amp;& !isStaticExp(arg)) {
<span class=
"linenr">1276: </span>        hasDynamicSlots = <span class=
"org-constant">true</span>
<span class="linenr">1277: </span>      }
<span class="linenr">1278: </span>      slotsProperties.push(
<span class="linenr">1279: </span>        createObjectProperty(
<span class=
"linenr">1280: </span>          arg || createSimpleExpression(<span class="org-string">'default'</span>, <span class="org-constant">true</span>),
<span class=
"linenr">1281: </span>          buildSlotFn(exp, children, loc)
<span class="linenr">1282: </span>        )
<span class="linenr">1283: </span>      )
<span class="linenr">1284: </span>    }
<span class="linenr">1285: </span>  
<span class="linenr">1286: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">2. Iterate through children and check for template slots</span>
<span class="linenr">1287: </span>    <span class=
"org-comment-delimiter">//    </span><span class=
"org-comment">&lt;template v-slot:foo="{ prop }"&gt;</span>
<span class="linenr">1288: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">hasTemplateSlots</span> = <span class=
"org-constant">false</span>
<span class="linenr">1289: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">hasNamedDefaultSlot</span> = <span class=
"org-constant">false</span>
<span class="linenr">1290: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">implicitDefaultChildren</span> = []
<span class="linenr">1291: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">seenSlotNames</span> = <span class=
"org-keyword">new</span> <span class="org-type">Set</span>()
<span class="linenr">1292: </span>  
<span class="linenr">1293: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; children.length; i++) {
<span class="linenr">1294: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">slotElement</span> = children[i]
<span class="linenr">1295: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">slotDir</span>
<span class="linenr">1296: </span>  
<span class="linenr">1297: </span>      <span class=
"org-keyword">if</span> (
<span class=
"linenr">1298: </span>        !isTemplateNode(slotElement) ||
<span class=
"linenr">1299: </span>        !(slotDir = findDir(slotElement, <span class="org-string">'slot'</span>, <span class="org-constant">true</span>))
<span class="linenr">1300: </span>      ) { <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">收集不在 template v-slot 中的元素/组件，这些都会合并到默认插槽中去</span>
<span class="linenr">1301: </span>        <span class=
"org-keyword">if</span> (slotElement.type !== NodeTypes.COMMENT) {
<span class=
"linenr">1302: </span>          implicitDefaultChildren.push(slotElement)
<span class="linenr">1303: </span>        }
<span class="linenr">1304: </span>        <span class=
"org-keyword">continue</span>
<span class="linenr">1305: </span>      }
<span class="linenr">1306: </span>  
<span class="linenr">1307: </span>      <span class=
"org-keyword">if</span> (onComponentSlot) {
<span class="linenr">1308: </span>        logg(<span class=
"org-string">`buildSlots already has on-component slot - this is incorrect usage`</span>)
<span class="linenr">1309: </span>        <span class=
"org-keyword">break</span>
<span class="linenr">1310: </span>      }
<span class="linenr">1311: </span>  
<span class=
"linenr">1312: </span>      hasTemplateSlots = <span class=
"org-constant">true</span>
<span class="linenr">1313: </span>      <span class=
"org-keyword">const</span> { children: <span class=
"org-variable-name">slotChildren</span>, loc: <span class=
"org-variable-name">slotLoc</span> } = slotElement
<span class="linenr">1314: </span>      <span class=
"org-keyword">const</span> {
<span class=
"linenr">1315: </span>        arg: slotName = createSimpleExpression(<span class="org-string">`default`</span>, <span class="org-constant">true</span>),
<span class="linenr">1316: </span>        exp: slotProps,
<span class="linenr">1317: </span>        loc: dirLoc
<span class="linenr">1318: </span>      } = slotDir
<span class="linenr">1319: </span>  
<span class="linenr">1320: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">check if name is dynamic.</span>
<span class="linenr">1321: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">staticSlotName</span>
<span class="linenr">1322: </span>      <span class=
"org-keyword">if</span> (isStaticExp(slotName)) {
<span class=
"linenr">1323: </span>        staticSlotName = slotName ? slotName.content : <span class="org-string">`default`</span>
<span class="linenr">1324: </span>      } <span class=
"org-keyword">else</span> {
<span class=
"linenr">1325: </span>        hasDynamicSlots = <span class=
"org-constant">true</span>
<span class="linenr">1326: </span>      }
<span class="linenr">1327: </span>  
<span class="linenr">1328: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">slotFunction</span> = buildSlotFn(slotProps, slotChildren, slotLoc)
<span class="linenr">1329: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">check if this slot is conditional (v-if/v-for)</span>
<span class="linenr">1330: </span>      <span class=
"org-keyword">let</span> <span class="org-variable-name">vIf</span>
<span class="linenr">1331: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">vElse</span>
<span class="linenr">1332: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">vFor</span>
<span class="linenr">1333: </span>      <span class=
"org-keyword">if</span> ((vIf = findDir(slotElement, <span class=
"org-string">'if'</span>))) {
<span class=
"linenr">1334: </span>        hasDynamicSlots = <span class=
"org-constant">true</span>
<span class="linenr">1335: </span>        dynamicSlots.push(
<span class=
"linenr">1336: </span>          createConditionalExpression(
<span class="linenr">1337: </span>            vIf.exp,
<span class=
"linenr">1338: </span>            buildDynamicSlot(slotName, slotFunction),
<span class="linenr">1339: </span>            defaultFallback
<span class="linenr">1340: </span>          )
<span class="linenr">1341: </span>        )
<span class="linenr">1342: </span>      } <span class=
"org-keyword">else</span> <span class="org-keyword">if</span> (
<span class=
"linenr">1343: </span>        (vElse = findDir(slotElement, <span class="org-string">/^else(-if)?$/</span>, <span class="org-constant">true</span> <span class="org-comment-delimiter">/* </span><span class="org-comment">allowEmpty</span><span class="org-comment-delimiter"> */</span>))
<span class="linenr">1344: </span>      ) {
<span class="linenr">1345: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">find adjacent v-if</span>
<span class="linenr">1346: </span>        <span class=
"org-keyword">let</span> <span class=
"org-variable-name">j</span> = i
<span class="linenr">1347: </span>        <span class=
"org-keyword">let</span> <span class=
"org-variable-name">prev</span>
<span class="linenr">1348: </span>        <span class=
"org-keyword">while</span> (j--) {
<span class="linenr">1349: </span>          prev = children[j]
<span class="linenr">1350: </span>          <span class=
"org-keyword">if</span> (prev.type !== NodeTypes.COMMENT) {
<span class="linenr">1351: </span>            <span class=
"org-keyword">break</span>
<span class="linenr">1352: </span>          }
<span class="linenr">1353: </span>        }
<span class="linenr">1354: </span>        <span class=
"org-keyword">if</span> (prev &amp;& isTemplateNode(prev) &amp;& findDir(prev, <span class="org-string">'if'</span>)) {
<span class="linenr">1355: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">remove node</span>
<span class=
"linenr">1356: </span>          children.splice(i, <span class=
"org-highlight-numbers-number">1</span>)
<span class="linenr">1357: </span>          i--
<span class="linenr">1358: </span>  
<span class="linenr">1359: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">attach this slot to previous conditional</span>
<span class="linenr">1360: </span>          <span class=
"org-keyword">let</span> <span class=
"org-variable-name">conditional</span> = dynamicSlots[
<span class=
"linenr">1361: </span>            dynamicSlots.length - <span class="org-highlight-numbers-number">1</span>
<span class="linenr">1362: </span>          ]
<span class="linenr">1363: </span>          <span class=
"org-keyword">while</span> (
<span class=
"linenr">1364: </span>            conditional.alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION
<span class="linenr">1365: </span>          ) {
<span class=
"linenr">1366: </span>            conditional = conditional.alternate
<span class="linenr">1367: </span>          }
<span class=
"linenr">1368: </span>          conditional.alternate = vElse.exp
<span class=
"linenr">1369: </span>            ? createConditionalExpression(
<span class="linenr">1370: </span>                vElse.exp,
<span class=
"linenr">1371: </span>                buildDynamicSlot(slotName, slotFunction),
<span class="linenr">1372: </span>                defaultFallback
<span class="linenr">1373: </span>              )
<span class=
"linenr">1374: </span>            : buildDynamicSlot(slotName, slotFunction)
<span class="linenr">1375: </span>        }
<span class="linenr">1376: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> ((vFor = findDir(slotElement, <span class=
"org-string">'for'</span>))) {
<span class=
"linenr">1377: </span>        hasDynamicSlots = <span class=
"org-constant">true</span>
<span class="linenr">1378: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">parseResult</span> =
<span class="linenr">1379: </span>          vFor.parseResult ||
<span class=
"linenr">1380: </span>          parseForExpression(vFor.exp , context)
<span class="linenr">1381: </span>        <span class=
"org-keyword">if</span> (parseResult) {
<span class="linenr">1382: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">Render the dynamic slots as an array and add it to the createSlot()</span>
<span class="linenr">1383: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">args. The runtime knows how to handle it appropriately.</span>
<span class="linenr">1384: </span>          dynamicSlots.push(
<span class=
"linenr">1385: </span>            createCallExpression(context.helper(RENDER_LIST), [
<span class="linenr">1386: </span>              parseResult.source,
<span class=
"linenr">1387: </span>              createFunctionExpression(
<span class=
"linenr">1388: </span>                createForLoopParams(parseResult),
<span class=
"linenr">1389: </span>                buildDynamicSlot(slotName, slotFunction),
<span class="linenr">1390: </span>                <span class=
"org-constant">true</span> <span class=
"org-comment-delimiter">/* </span><span class=
"org-comment">force newline</span><span class=
"org-comment-delimiter"> */</span>
<span class="linenr">1391: </span>              )
<span class="linenr">1392: </span>            ])
<span class="linenr">1393: </span>          )
<span class="linenr">1394: </span>        }
<span class="linenr">1395: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr">1396: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">check duplicate static names</span>
<span class="linenr">1397: </span>        <span class=
"org-keyword">if</span> (staticSlotName) {
<span class="linenr">1398: </span>          <span class=
"org-keyword">if</span> (seenSlotNames.has(staticSlotName)) {
<span class="linenr">1399: </span>            logg(<span class=
"org-string">`buildSlots seenSlotNames has slot name`</span>)
<span class="linenr">1400: </span>            <span class=
"org-keyword">continue</span>
<span class="linenr">1401: </span>          }
<span class=
"linenr">1402: </span>          seenSlotNames.add(staticSlotName)
<span class="linenr">1403: </span>          <span class=
"org-keyword">if</span> (staticSlotName === <span class=
"org-string">'default'</span>) {
<span class=
"linenr">1404: </span>            hasNamedDefaultSlot = <span class="org-constant">true</span>
<span class="linenr">1405: </span>          }
<span class="linenr">1406: </span>        }
<span class=
"linenr">1407: </span>        slotsProperties.push(createObjectProperty(slotName, slotFunction))
<span class="linenr">1408: </span>      }
<span class="linenr">1409: </span>    }
<span class="linenr">1410: </span>  
<span class="linenr">1411: </span>    <span class=
"org-keyword">if</span> (!onComponentSlot) {
<span class="linenr">1412: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">buildDefaultSlotProperty</span> = (props, children) =&gt; {
<span class="linenr">1413: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">fn</span> = buildSlotFn(props, children, loc)
<span class="linenr">1414: </span>  
<span class="linenr">1415: </span>        <span class=
"org-keyword">return</span> createObjectProperty(<span class=
"org-string">`default`</span>, fn)
<span class="linenr">1416: </span>      }
<span class="linenr">1417: </span>  
<span class="linenr">1418: </span>      <span class=
"org-keyword">if</span> (!hasTemplateSlots) {
<span class="linenr">1419: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">implicit default slot (on component)</span>
<span class=
"linenr">1420: </span>        slotsProperties.push(buildDefaultSlotProperty(<span class="org-constant">undefined</span>, children))
<span class="linenr">1421: </span>      } <span class=
"org-keyword">else</span> <span class="org-keyword">if</span> (
<span class=
"linenr">1422: </span>        implicitDefaultChildren.length &amp;&
<span class="linenr">1423: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">#3766</span>
<span class="linenr">1424: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">with whitespace: 'preserve', whitespaces between slots will end up in</span>
<span class="linenr">1425: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">implicitDefaultChildren. Ignore if all implicit children are whitespaces.</span>
<span class=
"linenr">1426: </span>        implicitDefaultChildren.some(node =&gt; isNonWhitespaceContent(node))
<span class="linenr">1427: </span>      ) {
<span class="linenr">1428: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">implicit default slot (mixed with named slots)</span>
<span class="linenr">1429: </span>        <span class=
"org-keyword">if</span> (hasNamedDefaultSlot) {
<span class="linenr">1430: </span>          logg(<span class=
"org-string">`buildSlots hasNamedDefaultSlot`</span>)
<span class="linenr">1431: </span>        } <span class=
"org-keyword">else</span> {
<span class="linenr">1432: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">合并到默认插槽</span>
<span class="linenr">1433: </span>          slotsProperties.push(
<span class=
"linenr">1434: </span>            buildDefaultSlotProperty(<span class="org-constant">undefined</span>, implicitDefaultChildren)
<span class="linenr">1435: </span>          )
<span class="linenr">1436: </span>        }
<span class="linenr">1437: </span>      }
<span class="linenr">1438: </span>    }
<span class="linenr">1439: </span>  
<span class="linenr">1440: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">slotFlag</span> = hasDynamicSlots
<span class="linenr">1441: </span>      ? SlotFlags.DYNAMIC
<span class=
"linenr">1442: </span>      : hasForwardedSlots(node.children)
<span class="linenr">1443: </span>      ? SlotFlags.FORWARDED
<span class="linenr">1444: </span>      : SlotFlags.STABLE
<span class="linenr">1445: </span>  
<span class="linenr">1446: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">slots</span> = createObjectExpression(
<span class="linenr">1447: </span>      slotsProperties.concat(
<span class="linenr">1448: </span>        createObjectProperty(
<span class="linenr">1449: </span>          <span class=
"org-string">`_`</span>,
<span class="linenr">1450: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">2 = compiled but dynamic = can skip normalization, but must run diff</span>
<span class="linenr">1451: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">1 = compiled and static = can skip normalization AND diff as optimized</span>
<span class="linenr">1452: </span>          createSimpleExpression(
<span class=
"linenr">1453: </span>            slotFlag + (__DEV__ ? <span class="org-string">` /* ${slotFlagsText[slotFlag]} */`</span> : <span class="org-string">``</span>),
<span class="linenr">1454: </span>            <span class=
"org-constant">false</span>
<span class="linenr">1455: </span>          )
<span class="linenr">1456: </span>        )
<span class="linenr">1457: </span>      ),
<span class="linenr">1458: </span>      loc
<span class="linenr">1459: </span>    )
<span class="linenr">1460: </span>    <span class=
"org-keyword">if</span> (dynamicSlots.length) {
<span class=
"linenr">1461: </span>      slots = createCallExpression(context.helper(CREATE_SLOTS), [
<span class="linenr">1462: </span>        slots,
<span class=
"linenr">1463: </span>        createArrayExpression(dynamicSlots)
<span class="linenr">1464: </span>      ])
<span class="linenr">1465: </span>    }
<span class="linenr">1466: </span>  
<span class="linenr">1467: </span>    <span class=
"org-keyword">return</span> {
<span class="linenr">1468: </span>      slots,
<span class="linenr">1469: </span>      hasDynamicSlots
<span class="linenr">1470: </span>    }
<span class="linenr">1471: </span>  }
<span class="linenr">1472: </span>  
<span class="linenr">1473: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">buildDynamicSlot</span>(<span class=
"org-variable-name">name</span>, <span class=
"org-variable-name">fn</span>) {
<span class="linenr">1474: </span>    <span class=
"org-keyword">return</span> createObjectExpression([
<span class=
"linenr">1475: </span>      createObjectProperty(<span class=
"org-string">`name`</span>, name),
<span class=
"linenr">1476: </span>      createObjectProperty(<span class=
"org-string">`fn`</span>, fn)
<span class="linenr">1477: </span>    ])
<span class="linenr">1478: </span>  }
<span class="linenr">1479: </span>  
<span class="linenr">1480: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">hasForwardedSlots</span>(<span class=
"org-variable-name">children</span>) {
<span class="linenr">1481: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; children.length; i++) {
<span class="linenr">1482: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">child</span> = children[i]
<span class="linenr">1483: </span>      <span class=
"org-keyword">switch</span> (child.type) {
<span class="linenr">1484: </span>        <span class=
"org-keyword">case</span> NodeTypes.ELEMENT:
<span class="linenr">1485: </span>          <span class=
"org-keyword">if</span> (
<span class=
"linenr">1486: </span>            child.tagType === ElementTypes.SLOT ||
<span class=
"linenr">1487: </span>            hasForwardedSlots(child.children)
<span class="linenr">1488: </span>          ) {
<span class="linenr">1489: </span>            <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr">1490: </span>          }
<span class="linenr">1491: </span>          <span class=
"org-keyword">break</span>
<span class="linenr">1492: </span>        <span class=
"org-keyword">case</span> NodeTypes.IF:
<span class="linenr">1493: </span>          <span class=
"org-keyword">if</span> (hasForwardedSlots(child.branches)) <span class="org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr">1494: </span>          <span class=
"org-keyword">break</span>
<span class="linenr">1495: </span>        <span class=
"org-keyword">case</span> NodeTypes.IF_BRANCH:
<span class="linenr">1496: </span>        <span class=
"org-keyword">case</span> NodeTypes.FOR:
<span class="linenr">1497: </span>          <span class=
"org-keyword">if</span> (hasForwardedSlots(child.children)) <span class="org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr">1498: </span>          <span class=
"org-keyword">break</span>
<span class="linenr">1499: </span>        <span class=
"org-keyword">default</span>:
<span class="linenr">1500: </span>          <span class=
"org-keyword">break</span>
<span class="linenr">1501: </span>      }
<span class="linenr">1502: </span>    }
<span class="linenr">1503: </span>    <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">1504: </span>  }
<span class="linenr">1505: </span>  
<span class="linenr">1506: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">isNonWhitespaceContent</span>(<span class=
"org-variable-name">node</span>){
<span class="linenr">1507: </span>    <span class=
"org-keyword">if</span> (node.type !== NodeTypes.TEXT &amp;& node.type !== NodeTypes.TEXT_CALL)
<span class="linenr">1508: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr">1509: </span>    <span class=
"org-keyword">return</span> node.type === NodeTypes.TEXT
<span class="linenr">1510: </span>      ? !!node.content.trim()
<span class=
"linenr">1511: </span>      : isNonWhitespaceContent(node.content)
<span class="linenr">1512: </span>  }
<span class="linenr">1513: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">some directive transforms (e.g. v-model) may return a symbol for runtime</span>
<span class="linenr">1514: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">import, which should be used instead of a resolveDirective call.</span>
<span class="linenr">1515: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">directiveImportMap</span> = <span class=
"org-keyword">new</span> <span class="org-type">WeakMap</span>()
<span class="linenr">1516: </span>  
<span class="linenr">1517: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">generate a JavaScript AST for this element's codegen</span>
<span class="linenr">1518: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">transformElement</span> = (node, context) =&gt; {
<span class="linenr">1519: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">perform the work on exit, after all child expressions have been</span>
<span class="linenr">1520: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">processed and merged.</span>
<span class="linenr">1521: </span>    <span class=
"org-keyword">return</span> <span class=
"org-keyword">function</span> postTransformElement() {
<span class="linenr">1522: </span>      node = context.currentNode
<span class="linenr">1523: </span>  
<span class="linenr">1524: </span>      <span class=
"org-keyword">if</span> (
<span class="linenr">1525: </span>        !(
<span class=
"linenr">1526: </span>          node.type === NodeTypes.ELEMENT &amp;&
<span class=
"linenr">1527: </span>          (node.tagType === ElementTypes.ELEMENT ||
<span class=
"linenr">1528: </span>            node.tagType === ElementTypes.COMPONENT)
<span class="linenr">1529: </span>        )
<span class="linenr">1530: </span>      ) {
<span class="linenr">1531: </span>        <span class=
"org-keyword">return</span>
<span class="linenr">1532: </span>      }
<span class="linenr">1533: </span>  
<span class="linenr">1534: </span>      <span class=
"org-keyword">const</span> { tag, props } = node
<span class="linenr">1535: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isComponent</span> = node.tagType === ElementTypes.COMPONENT
<span class="linenr">1536: </span>  
<span class="linenr">1537: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">The goal of the transform is to create a codegenNode implementing the</span>
<span class="linenr">1538: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">VNodeCall interface.</span>
<span class="linenr">1539: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">vnodeTag</span> = isComponent
<span class=
"linenr">1540: </span>        ? resolveComponentType(node, context)
<span class="linenr">1541: </span>        : <span class=
"org-string">`"${tag}"`</span>
<span class="linenr">1542: </span>  
<span class="linenr">1543: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isDynamicComponent</span> =
<span class=
"linenr">1544: </span>        isObject(vnodeTag) &amp;& vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT
<span class="linenr">1545: </span>  
<span class="linenr">1546: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">vnodeProps</span>
<span class="linenr">1547: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">vnodeChildren</span>
<span class="linenr">1548: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">vnodePatchFlag</span>
<span class="linenr">1549: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">patchFlag</span> = <span class=
"org-highlight-numbers-number">0</span>
<span class="linenr">1550: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">vnodeDynamicProps</span>
<span class="linenr">1551: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">dynamicPropNames</span>
<span class="linenr">1552: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">vnodeDirectives</span>
<span class="linenr">1553: </span>  
<span class="linenr">1554: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">shouldUseBlock</span> =
<span class="linenr">1555: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">dynamic component may resolve to plain elements</span>
<span class="linenr">1556: </span>        isDynamicComponent ||
<span class="linenr">1557: </span>        vnodeTag === TELEPORT ||
<span class="linenr">1558: </span>        vnodeTag === SUSPENSE ||
<span class="linenr">1559: </span>        (!isComponent &amp;&
<span class="linenr">1560: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">&lt;svg&gt; and &lt;foreignObject&gt; must be forced into blocks so that block</span>
<span class="linenr">1561: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">updates inside get proper isSVG flag at runtime. (#639, #643)</span>
<span class="linenr">1562: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">This is technically web-specific, but splitting the logic out of core</span>
<span class="linenr">1563: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">leads to too much unnecessary complexity.</span>
<span class="linenr">1564: </span>          (tag === <span class=
"org-string">'svg'</span> || tag === <span class=
"org-string">'foreignObject'</span>))
<span class="linenr">1565: </span>  
<span class="linenr">1566: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">props</span>
<span class="linenr">1567: </span>      <span class=
"org-keyword">if</span> (props.length &gt; <span class=
"org-highlight-numbers-number">0</span>) {
<span class="linenr">1568: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">propsBuildResult</span> = buildProps(node, context)
<span class=
"linenr">1569: </span>        vnodeProps = propsBuildResult.props
<span class=
"linenr">1570: </span>        patchFlag = propsBuildResult.patchFlag
<span class=
"linenr">1571: </span>        dynamicPropNames = propsBuildResult.dynamicPropNames
<span class="linenr">1572: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">directives</span> = propsBuildResult.directives
<span class="linenr">1573: </span>        vnodeDirectives =
<span class=
"linenr">1574: </span>          directives &amp;& directives.length
<span class=
"linenr">1575: </span>            ? (createArrayExpression(
<span class=
"linenr">1576: </span>                directives.map(dir =&gt; buildDirectiveArgs(dir, context))
<span class="linenr">1577: </span>              ))
<span class="linenr">1578: </span>            : <span class=
"org-constant">undefined</span>
<span class="linenr">1579: </span>  
<span class="linenr">1580: </span>        <span class=
"org-keyword">if</span> (propsBuildResult.shouldUseBlock) {
<span class=
"linenr">1581: </span>          shouldUseBlock = <span class=
"org-constant">true</span>
<span class="linenr">1582: </span>        }
<span class="linenr">1583: </span>      }
<span class="linenr">1584: </span>  
<span class="linenr">1585: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">children</span>
<span class="linenr">1586: </span>      <span class=
"org-keyword">if</span> (node.children.length &gt; <span class=
"org-highlight-numbers-number">0</span>) {
<span class="linenr">1587: </span>        <span class=
"org-keyword">if</span> (vnodeTag === KEEP_ALIVE) {
<span class="linenr">1588: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">Although a built-in component, we compile KeepAlive with raw children</span>
<span class="linenr">1589: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">instead of slot functions so that it can be used inside Transition</span>
<span class="linenr">1590: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">or other Transition-wrapping HOCs.</span>
<span class="linenr">1591: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">To ensure correct updates with block optimizations, we need to:</span>
<span class="linenr">1592: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">1. Force keep-alive into a block. This avoids its children being</span>
<span class="linenr">1593: </span>          <span class=
"org-comment-delimiter">//    </span><span class=
"org-comment">collected by a parent block.</span>
<span class=
"linenr">1594: </span>          shouldUseBlock = <span class=
"org-constant">true</span>
<span class="linenr">1595: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">2. Force keep-alive to always be updated, since it uses raw children.</span>
<span class=
"linenr">1596: </span>          patchFlag |= PatchFlags.DYNAMIC_SLOTS
<span class="linenr">1597: </span>        }
<span class="linenr">1598: </span>  
<span class="linenr">1599: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">shouldBuildAsSlots</span> =
<span class="linenr">1600: </span>          isComponent &amp;&
<span class="linenr">1601: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">Teleport is not a real component and has dedicated runtime handling</span>
<span class=
"linenr">1602: </span>          vnodeTag !== TELEPORT &amp;&
<span class="linenr">1603: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">explained above.</span>
<span class="linenr">1604: </span>          vnodeTag !== KEEP_ALIVE
<span class="linenr">1605: </span>  
<span class="linenr">1606: </span>        <span class=
"org-keyword">if</span> (shouldBuildAsSlots) {
<span class="linenr">1607: </span>          <span class=
"org-keyword">const</span> { slots, hasDynamicSlots } = buildSlots(node, context)
<span class="linenr">1608: </span>          vnodeChildren = slots
<span class="linenr">1609: </span>          <span class=
"org-keyword">if</span> (hasDynamicSlots) {
<span class=
"linenr">1610: </span>            patchFlag |= PatchFlags.DYNAMIC_SLOTS
<span class="linenr">1611: </span>          }
<span class="linenr">1612: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (node.children.length === <span class=
"org-highlight-numbers-number">1</span> &amp;& vnodeTag !== TELEPORT) {
<span class="linenr">1613: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">child</span> = node.children[<span class=
"org-highlight-numbers-number">0</span>]
<span class="linenr">1614: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">type</span> = child.type
<span class="linenr">1615: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">check for dynamic text children</span>
<span class="linenr">1616: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">hasDynamicTextChild</span> =
<span class=
"linenr">1617: </span>            type === NodeTypes.INTERPOLATION ||
<span class=
"linenr">1618: </span>            type === NodeTypes.COMPOUND_EXPRESSION
<span class="linenr">1619: </span>          <span class=
"org-keyword">if</span> (
<span class=
"linenr">1620: </span>            hasDynamicTextChild &amp;&
<span class=
"linenr">1621: </span>            getConstantType(child, context) === ConstantTypes.NOT_CONSTANT
<span class="linenr">1622: </span>          ) {
<span class=
"linenr">1623: </span>            patchFlag |= PatchFlags.TEXT
<span class="linenr">1624: </span>          }
<span class="linenr">1625: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">pass directly if the only child is a text node</span>
<span class="linenr">1626: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">(plain / interpolation / expression)</span>
<span class="linenr">1627: </span>          <span class=
"org-keyword">if</span> (hasDynamicTextChild || type === NodeTypes.TEXT) {
<span class="linenr">1628: </span>            vnodeChildren = child
<span class="linenr">1629: </span>          } <span class=
"org-keyword">else</span> {
<span class=
"linenr">1630: </span>            vnodeChildren = node.children
<span class="linenr">1631: </span>          }
<span class="linenr">1632: </span>        } <span class=
"org-keyword">else</span> {
<span class=
"linenr">1633: </span>          vnodeChildren = node.children
<span class="linenr">1634: </span>        }
<span class="linenr">1635: </span>      }
<span class="linenr">1636: </span>  
<span class="linenr">1637: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">patchFlag & dynamicPropNames</span>
<span class="linenr">1638: </span>      <span class=
"org-keyword">if</span> (patchFlag !== <span class=
"org-highlight-numbers-number">0</span>) {
<span class=
"linenr">1639: </span>        vnodePatchFlag = String(patchFlag)
<span class="linenr">1640: </span>        <span class=
"org-keyword">if</span> (dynamicPropNames &amp;& dynamicPropNames.length) {
<span class=
"linenr">1641: </span>          vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames)
<span class="linenr">1642: </span>        }
<span class="linenr">1643: </span>      }
<span class="linenr">1644: </span>  
<span class=
"linenr">1645: </span>      node.codegenNode = createVNodeCall(
<span class="linenr">1646: </span>        context,
<span class="linenr">1647: </span>        vnodeTag,
<span class="linenr">1648: </span>        vnodeProps,
<span class="linenr">1649: </span>        vnodeChildren,
<span class="linenr">1650: </span>        vnodePatchFlag,
<span class="linenr">1651: </span>        vnodeDynamicProps,
<span class="linenr">1652: </span>        vnodeDirectives,
<span class="linenr">1653: </span>        !!shouldUseBlock,
<span class="linenr">1654: </span>        <span class=
"org-constant">false</span> <span class=
"org-comment-delimiter">/* </span><span class=
"org-comment">disableTracking</span><span class=
"org-comment-delimiter"> */</span>,
<span class="linenr">1655: </span>        isComponent,
<span class="linenr">1656: </span>        node.loc
<span class="linenr">1657: </span>      )
<span class="linenr">1658: </span>    }
<span class="linenr">1659: </span>  }
<span class="linenr">1660: </span>  
<span class="linenr">1661: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">resolveComponentType</span>(
<span class="linenr">1662: </span>    <span class=
"org-variable-name">node</span>,
<span class="linenr">1663: </span>    <span class=
"org-variable-name">context</span>,
<span class="linenr">1664: </span>    ssr = <span class=
"org-constant">false</span>
<span class="linenr">1665: </span>  ) {
<span class="linenr">1666: </span>    <span class=
"org-keyword">let</span> { tag } = node
<span class="linenr">1667: </span>  
<span class="linenr">1668: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">1. dynamic component</span>
<span class="linenr">1669: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isExplicitDynamic</span> = isComponentTag(tag)
<span class="linenr">1670: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isProp</span> = findProp(node, <span class=
"org-string">'is'</span>)
<span class="linenr">1671: </span>    <span class=
"org-keyword">if</span> (isProp) {
<span class="linenr">1672: </span>      <span class=
"org-keyword">if</span> (isExplicitDynamic ) {
<span class="linenr">1673: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">exp</span> =
<span class=
"linenr">1674: </span>          isProp.type === NodeTypes.ATTRIBUTE
<span class=
"linenr">1675: </span>            ? isProp.value &amp;& createSimpleExpression(isProp.value.content, <span class="org-constant">true</span>)
<span class="linenr">1676: </span>            : isProp.exp
<span class="linenr">1677: </span>        <span class=
"org-keyword">if</span> (exp) {
<span class="linenr">1678: </span>          <span class=
"org-keyword">return</span> createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
<span class="linenr">1679: </span>            exp
<span class="linenr">1680: </span>          ])
<span class="linenr">1681: </span>        }
<span class="linenr">1682: </span>      } <span class=
"org-keyword">else</span> <span class="org-keyword">if</span> (
<span class=
"linenr">1683: </span>        isProp.type === NodeTypes.ATTRIBUTE &amp;&
<span class=
"linenr">1684: </span>        isProp.value.content.startsWith(<span class="org-string">'vue:'</span>)
<span class="linenr">1685: </span>      ) {
<span class="linenr">1686: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">&lt;button is="vue:xxx"&gt;</span>
<span class="linenr">1687: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">if not &lt;component&gt;, only is value that starts with "vue:" will be</span>
<span class="linenr">1688: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">treated as component by the parse phase and reach here, unless it's</span>
<span class="linenr">1689: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">compat mode where all is values are considered components</span>
<span class=
"linenr">1690: </span>        tag = isProp.value.content.slice(<span class="org-highlight-numbers-number">4</span>)
<span class="linenr">1691: </span>      }
<span class="linenr">1692: </span>    }
<span class="linenr">1693: </span>  
<span class="linenr">1694: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">1.5 v-is (</span><span class=
"org-comment"><span class="org-bold"><span class=
"org-warning">TODO:</span></span></span><span class=
"org-comment"> Deprecate)</span>
<span class="linenr">1695: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isDir</span> = !isExplicitDynamic &amp;& findDir(node, <span class="org-string">'is'</span>)
<span class="linenr">1696: </span>    <span class=
"org-keyword">if</span> (isDir &amp;& isDir.exp) {
<span class="linenr">1697: </span>      <span class=
"org-keyword">return</span> createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
<span class="linenr">1698: </span>        isDir.exp
<span class="linenr">1699: </span>      ])
<span class="linenr">1700: </span>    }
<span class="linenr">1701: </span>  
<span class="linenr">1702: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">2. built-in components (Teleport, Transition, KeepAlive, Suspense...)</span>
<span class="linenr">1703: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">builtIn</span> = isCoreComponent(tag) || context.isBuiltInComponent(tag)
<span class="linenr">1704: </span>    <span class=
"org-keyword">if</span> (builtIn) {
<span class="linenr">1705: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">built-ins are simply fallthroughs / have special handling during ssr</span>
<span class="linenr">1706: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">so we don't need to import their runtime equivalents</span>
<span class="linenr">1707: </span>      <span class=
"org-keyword">if</span> (!ssr) context.helper(builtIn)
<span class="linenr">1708: </span>      <span class=
"org-keyword">return</span> builtIn
<span class="linenr">1709: </span>    }
<span class="linenr">1710: </span>  
<span class="linenr">1711: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">3. user component (from setup bindings)</span>
<span class="linenr">1712: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">this is skipped in browser build since browser builds do not perform</span>
<span class="linenr">1713: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">binding analysis.</span>
<span class="linenr">1714: </span>    <span class=
"org-keyword">if</span> (!__BROWSER__) {
<span class="linenr">1715: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">fromSetup</span> = resolveSetupReference(tag, context)
<span class="linenr">1716: </span>      <span class=
"org-keyword">if</span> (fromSetup) {
<span class="linenr">1717: </span>        <span class=
"org-keyword">return</span> fromSetup
<span class="linenr">1718: </span>      }
<span class="linenr">1719: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">dotIndex</span> = tag.indexOf(<span class=
"org-string">'.'</span>)
<span class="linenr">1720: </span>      <span class=
"org-keyword">if</span> (dotIndex &gt; <span class=
"org-highlight-numbers-number">0</span>) {
<span class="linenr">1721: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">ns</span> = resolveSetupReference(tag.slice(<span class="org-highlight-numbers-number">0</span>, dotIndex), context)
<span class="linenr">1722: </span>        <span class=
"org-keyword">if</span> (ns) {
<span class="linenr">1723: </span>          <span class=
"org-keyword">return</span> ns + tag.slice(dotIndex)
<span class="linenr">1724: </span>        }
<span class="linenr">1725: </span>      }
<span class="linenr">1726: </span>    }
<span class="linenr">1727: </span>  
<span class="linenr">1728: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">4. Self referencing component (inferred from filename)</span>
<span class="linenr">1729: </span>    <span class=
"org-keyword">if</span> (
<span class="linenr">1730: </span>      !__BROWSER__ &amp;&
<span class="linenr">1731: </span>      context.selfName &amp;&
<span class=
"linenr">1732: </span>      capitalize(camelize(tag)) === context.selfName
<span class="linenr">1733: </span>    ) {
<span class=
"linenr">1734: </span>      context.helper(RESOLVE_COMPONENT)
<span class="linenr">1735: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">codegen.ts has special check for __self postfix when generating</span>
<span class="linenr">1736: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">component imports, which will pass additional `maybeSelfReference` flag</span>
<span class="linenr">1737: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">to `resolveComponent`.</span>
<span class=
"linenr">1738: </span>      context.components.add(tag + <span class="org-string">`__self`</span>)
<span class="linenr">1739: </span>      <span class=
"org-keyword">return</span> toValidAssetId(tag, <span class=
"org-string">`component`</span>)
<span class="linenr">1740: </span>    }
<span class="linenr">1741: </span>  
<span class="linenr">1742: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">5. user component (resolve)</span>
<span class=
"linenr">1743: </span>    context.helper(RESOLVE_COMPONENT)
<span class="linenr">1744: </span>    context.components.add(tag)
<span class="linenr">1745: </span>    <span class=
"org-keyword">return</span> toValidAssetId(tag, <span class=
"org-string">`component`</span>)
<span class="linenr">1746: </span>  }
<span class="linenr">1747: </span>  
<span class="linenr">1748: </span>  
<span class="linenr">1749: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">resolveSetupReference</span>(<span class=
"org-variable-name">name</span>, <span class=
"org-variable-name">context</span>) {
<span class="linenr">1750: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">bindings</span> = context.bindingMetadata
<span class="linenr">1751: </span>    <span class=
"org-keyword">if</span> (!bindings || bindings.__isScriptSetup === <span class="org-constant">false</span>) {
<span class="linenr">1752: </span>      <span class=
"org-keyword">return</span>
<span class="linenr">1753: </span>    }
<span class="linenr">1754: </span>  
<span class="linenr">1755: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">camelName</span> = camelize(name)
<span class="linenr">1756: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">PascalName</span> = capitalize(camelName)
<span class="linenr">1757: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">checkType</span> = (type) =&gt; {
<span class="linenr">1758: </span>      <span class=
"org-keyword">if</span> (bindings[name] === type) {
<span class="linenr">1759: </span>        <span class=
"org-keyword">return</span> name
<span class="linenr">1760: </span>      }
<span class="linenr">1761: </span>      <span class=
"org-keyword">if</span> (bindings[camelName] === type) {
<span class="linenr">1762: </span>        <span class=
"org-keyword">return</span> camelName
<span class="linenr">1763: </span>      }
<span class="linenr">1764: </span>      <span class=
"org-keyword">if</span> (bindings[PascalName] === type) {
<span class="linenr">1765: </span>        <span class=
"org-keyword">return</span> PascalName
<span class="linenr">1766: </span>      }
<span class="linenr">1767: </span>    }
<span class="linenr">1768: </span>  
<span class="linenr">1769: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">fromConst</span> = checkType(BindingTypes.SETUP_CONST)
<span class="linenr">1770: </span>    <span class=
"org-keyword">if</span> (fromConst) {
<span class="linenr">1771: </span>      <span class=
"org-keyword">return</span> context.inline
<span class="linenr">1772: </span>        ? <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">in inline mode, const setup bindings (e.g. imports) can be used as-is</span>
<span class="linenr">1773: </span>          fromConst
<span class="linenr">1774: </span>        : <span class=
"org-string">`$setup[${JSON.stringify(fromConst)}]`</span>
<span class="linenr">1775: </span>    }
<span class="linenr">1776: </span>  
<span class="linenr">1777: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">fromMaybeRef</span> =
<span class=
"linenr">1778: </span>      checkType(BindingTypes.SETUP_LET) ||
<span class=
"linenr">1779: </span>      checkType(BindingTypes.SETUP_REF) ||
<span class=
"linenr">1780: </span>      checkType(BindingTypes.SETUP_MAYBE_REF)
<span class="linenr">1781: </span>    <span class=
"org-keyword">if</span> (fromMaybeRef) {
<span class="linenr">1782: </span>      <span class=
"org-keyword">return</span> context.inline
<span class="linenr">1783: </span>        ? <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">setup scope bindings that may be refs need to be unrefed</span>
<span class="linenr">1784: </span>          <span class=
"org-string">`${context.helperString(UNREF)}(${fromMaybeRef})`</span>
<span class="linenr">1785: </span>        : <span class=
"org-string">`$setup[${JSON.stringify(fromMaybeRef)}]`</span>
<span class="linenr">1786: </span>    }
<span class="linenr">1787: </span>  }
<span class="linenr">1788: </span>  
<span class="linenr">1789: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">buildProps</span>(
<span class="linenr">1790: </span>    <span class=
"org-variable-name">node</span>,
<span class="linenr">1791: </span>    <span class=
"org-variable-name">context</span>,
<span class="linenr">1792: </span>    props = node.props,
<span class="linenr">1793: </span>    ssr = <span class=
"org-constant">false</span>
<span class="linenr">1794: </span>  ) {
<span class="linenr">1795: </span>    <span class=
"org-keyword">const</span> { tag, loc: elementLoc, children } = node
<span class="linenr">1796: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isComponent</span> = node.tagType === ElementTypes.COMPONENT
<span class="linenr">1797: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">properties</span> = []
<span class="linenr">1798: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">mergeArgs</span> = []
<span class="linenr">1799: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">runtimeDirectives</span> = []
<span class="linenr">1800: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">hasChildren</span> = children.length &gt; <span class="org-highlight-numbers-number">0</span>
<span class="linenr">1801: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">shouldUseBlock</span> = <span class=
"org-constant">false</span>
<span class="linenr">1802: </span>  
<span class="linenr">1803: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">patchFlag analysis</span>
<span class="linenr">1804: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">patchFlag</span> = <span class=
"org-highlight-numbers-number">0</span>
<span class="linenr">1805: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">hasRef</span> = <span class=
"org-constant">false</span>
<span class="linenr">1806: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">hasClassBinding</span> = <span class=
"org-constant">false</span>
<span class="linenr">1807: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">hasStyleBinding</span> = <span class=
"org-constant">false</span>
<span class="linenr">1808: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">hasHydrationEventBinding</span> = <span class=
"org-constant">false</span>
<span class="linenr">1809: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">hasDynamicKeys</span> = <span class=
"org-constant">false</span>
<span class="linenr">1810: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">hasVnodeHook</span> = <span class=
"org-constant">false</span>
<span class="linenr">1811: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">dynamicPropNames</span> = []
<span class="linenr">1812: </span>  
<span class="linenr">1813: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">analyzePatchFlag</span> = ({ key, value }) =&gt; {
<span class="linenr">1814: </span>      <span class=
"org-keyword">if</span> (isStaticExp(key)) {
<span class="linenr">1815: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">name</span> = key.content
<span class="linenr">1816: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isEventHandler</span> = isOn(name)
<span class="linenr">1817: </span>        <span class=
"org-keyword">if</span> (
<span class="linenr">1818: </span>          !isComponent &amp;&
<span class="linenr">1819: </span>          isEventHandler &amp;&
<span class="linenr">1820: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">omit the flag for click handlers because hydration gives click</span>
<span class="linenr">1821: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">dedicated fast path.</span>
<span class=
"linenr">1822: </span>          name.toLowerCase() !== <span class=
"org-string">'onclick'</span> &amp;&
<span class="linenr">1823: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">omit v-model handlers</span>
<span class="linenr">1824: </span>          name !== <span class=
"org-string">'onUpdate:modelValue'</span> &amp;&
<span class="linenr">1825: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">omit onVnodeXXX hooks</span>
<span class="linenr">1826: </span>          !isReservedProp(name)
<span class="linenr">1827: </span>        ) {
<span class=
"linenr">1828: </span>          hasHydrationEventBinding = <span class="org-constant">true</span>
<span class="linenr">1829: </span>        }
<span class="linenr">1830: </span>  
<span class="linenr">1831: </span>        <span class=
"org-keyword">if</span> (isEventHandler &amp;& isReservedProp(name)) {
<span class=
"linenr">1832: </span>          hasVnodeHook = <span class=
"org-constant">true</span>
<span class="linenr">1833: </span>        }
<span class="linenr">1834: </span>  
<span class="linenr">1835: </span>        <span class=
"org-keyword">if</span> (
<span class=
"linenr">1836: </span>          value.type === NodeTypes.JS_CACHE_EXPRESSION ||
<span class=
"linenr">1837: </span>          ((value.type === NodeTypes.SIMPLE_EXPRESSION ||
<span class=
"linenr">1838: </span>            value.type === NodeTypes.COMPOUND_EXPRESSION) &amp;&
<span class=
"linenr">1839: </span>            getConstantType(value, context) &gt; <span class="org-highlight-numbers-number">0</span>)
<span class="linenr">1840: </span>        ) {
<span class="linenr">1841: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">skip if the prop is a cached handler or has constant value</span>
<span class="linenr">1842: </span>          <span class=
"org-keyword">return</span>
<span class="linenr">1843: </span>        }
<span class="linenr">1844: </span>  
<span class="linenr">1845: </span>        <span class=
"org-keyword">if</span> (name === <span class=
"org-string">'ref'</span>) {
<span class="linenr">1846: </span>          hasRef = <span class=
"org-constant">true</span>
<span class="linenr">1847: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (name === <span class=
"org-string">'class'</span>) {
<span class=
"linenr">1848: </span>          hasClassBinding = <span class=
"org-constant">true</span>
<span class="linenr">1849: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (name === <span class=
"org-string">'style'</span>) {
<span class=
"linenr">1850: </span>          hasStyleBinding = <span class=
"org-constant">true</span>
<span class="linenr">1851: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (name !== <span class=
"org-string">'key'</span> &amp;& !dynamicPropNames.includes(name)) {
<span class=
"linenr">1852: </span>          dynamicPropNames.push(name)
<span class="linenr">1853: </span>        }
<span class="linenr">1854: </span>  
<span class="linenr">1855: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">treat the dynamic class and style binding of the component as dynamic props</span>
<span class="linenr">1856: </span>        <span class=
"org-keyword">if</span> (
<span class="linenr">1857: </span>          isComponent &amp;&
<span class="linenr">1858: </span>          (name === <span class=
"org-string">'class'</span> || name === <span class=
"org-string">'style'</span>) &amp;&
<span class=
"linenr">1859: </span>          !dynamicPropNames.includes(name)
<span class="linenr">1860: </span>        ) {
<span class=
"linenr">1861: </span>          dynamicPropNames.push(name)
<span class="linenr">1862: </span>        }
<span class="linenr">1863: </span>      } <span class=
"org-keyword">else</span> {
<span class=
"linenr">1864: </span>        hasDynamicKeys = <span class=
"org-constant">true</span>
<span class="linenr">1865: </span>      }
<span class="linenr">1866: </span>    }
<span class="linenr">1867: </span>  
<span class="linenr">1868: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; props.length; i++) {
<span class="linenr">1869: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">static attribute</span>
<span class="linenr">1870: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">prop</span> = props[i]
<span class="linenr">1871: </span>      <span class=
"org-keyword">if</span> (prop.type === NodeTypes.ATTRIBUTE) {
<span class="linenr">1872: </span>        <span class=
"org-keyword">const</span> { loc, name, value } = prop
<span class="linenr">1873: </span>        <span class=
"org-keyword">let</span> <span class=
"org-variable-name">isStatic</span> = <span class=
"org-constant">true</span>
<span class="linenr">1874: </span>        <span class=
"org-keyword">if</span> (name === <span class=
"org-string">'ref'</span>) {
<span class="linenr">1875: </span>          hasRef = <span class=
"org-constant">true</span>
<span class="linenr">1876: </span>          <span class=
"org-keyword">if</span> (context.scopes.vFor &gt; <span class=
"org-highlight-numbers-number">0</span>) {
<span class="linenr">1877: </span>            properties.push(
<span class=
"linenr">1878: </span>              createObjectProperty(
<span class=
"linenr">1879: </span>                createSimpleExpression(<span class="org-string">'ref_for'</span>, <span class="org-constant">true</span>),
<span class=
"linenr">1880: </span>                createSimpleExpression(<span class="org-string">'true'</span>)
<span class="linenr">1881: </span>              )
<span class="linenr">1882: </span>            )
<span class="linenr">1883: </span>          }
<span class="linenr">1884: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">in inline mode there is no setupState object, so we can't use string</span>
<span class="linenr">1885: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">keys to set the ref. Instead, we need to transform it to pass the</span>
<span class="linenr">1886: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">actual ref instead.</span>
<span class="linenr">1887: </span>          <span class=
"org-keyword">if</span> (
<span class="linenr">1888: </span>            !__BROWSER__ &amp;&
<span class="linenr">1889: </span>            value &amp;&
<span class="linenr">1890: </span>            context.inline &amp;&
<span class=
"linenr">1891: </span>            context.bindingMetadata[value.content]
<span class="linenr">1892: </span>          ) {
<span class=
"linenr">1893: </span>            isStatic = <span class=
"org-constant">false</span>
<span class="linenr">1894: </span>            properties.push(
<span class=
"linenr">1895: </span>              createObjectProperty(
<span class=
"linenr">1896: </span>                createSimpleExpression(<span class="org-string">'ref_key'</span>, <span class="org-constant">true</span>),
<span class=
"linenr">1897: </span>                createSimpleExpression(value.content, <span class="org-constant">true</span>, value.loc)
<span class="linenr">1898: </span>              )
<span class="linenr">1899: </span>            )
<span class="linenr">1900: </span>          }
<span class="linenr">1901: </span>        }
<span class="linenr">1902: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">skip is on &lt;component&gt;, or is="vue:xxx"</span>
<span class="linenr">1903: </span>        <span class=
"org-keyword">if</span> (
<span class="linenr">1904: </span>          name === <span class=
"org-string">'is'</span> &amp;&
<span class="linenr">1905: </span>          (isComponentTag(tag) ||
<span class=
"linenr">1906: </span>            (value &amp;& value.content.startsWith(<span class="org-string">'vue:'</span>)))
<span class="linenr">1907: </span>        ) {
<span class="linenr">1908: </span>          <span class=
"org-keyword">continue</span>
<span class="linenr">1909: </span>        }
<span class="linenr">1910: </span>        properties.push(
<span class="linenr">1911: </span>          createObjectProperty(
<span class=
"linenr">1912: </span>            createSimpleExpression(
<span class="linenr">1913: </span>              name,
<span class="linenr">1914: </span>              <span class=
"org-constant">true</span>,
<span class=
"linenr">1915: </span>              getInnerRange(loc, <span class=
"org-highlight-numbers-number">0</span>, name.length)
<span class="linenr">1916: </span>            ),
<span class=
"linenr">1917: </span>            createSimpleExpression(
<span class=
"linenr">1918: </span>              value ? value.content : <span class="org-string">''</span>,
<span class="linenr">1919: </span>              isStatic,
<span class=
"linenr">1920: </span>              value ? value.loc : loc
<span class="linenr">1921: </span>            )
<span class="linenr">1922: </span>          )
<span class="linenr">1923: </span>        )
<span class="linenr">1924: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr">1925: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">directives</span>
<span class="linenr">1926: </span>        <span class=
"org-keyword">const</span> { name, arg, exp, loc } = prop
<span class="linenr">1927: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isVBind</span> = name === <span class=
"org-string">'bind'</span>
<span class="linenr">1928: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isVOn</span> = name === <span class=
"org-string">'on'</span>
<span class="linenr">1929: </span>  
<span class="linenr">1930: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">skip v-slot - it is handled by its dedicated transform.</span>
<span class="linenr">1931: </span>        <span class=
"org-keyword">if</span> (name === <span class=
"org-string">'slot'</span>) {
<span class="linenr">1932: </span>          <span class=
"org-keyword">continue</span>
<span class="linenr">1933: </span>        }
<span class="linenr">1934: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">skip v-once/v-memo - they are handled by dedicated transforms.</span>
<span class="linenr">1935: </span>        <span class=
"org-keyword">if</span> (name === <span class=
"org-string">'once'</span> || name === <span class=
"org-string">'memo'</span>) {
<span class="linenr">1936: </span>          <span class=
"org-keyword">continue</span>
<span class="linenr">1937: </span>        }
<span class="linenr">1938: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">skip v-is and :is on &lt;component&gt;</span>
<span class="linenr">1939: </span>        <span class=
"org-keyword">if</span> (
<span class="linenr">1940: </span>          name === <span class=
"org-string">'is'</span> ||
<span class="linenr">1941: </span>          (isVBind &amp;&
<span class=
"linenr">1942: </span>            isStaticArgOf(arg, <span class=
"org-string">'is'</span>) &amp;&
<span class="linenr">1943: </span>            isComponentTag(tag))
<span class="linenr">1944: </span>        ) {
<span class="linenr">1945: </span>          <span class=
"org-keyword">continue</span>
<span class="linenr">1946: </span>        }
<span class="linenr">1947: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">skip v-on in SSR compilation</span>
<span class="linenr">1948: </span>        <span class=
"org-keyword">if</span> (isVOn &amp;& ssr) {
<span class="linenr">1949: </span>          <span class=
"org-keyword">continue</span>
<span class="linenr">1950: </span>        }
<span class="linenr">1951: </span>  
<span class="linenr">1952: </span>        <span class=
"org-keyword">if</span> (
<span class="linenr">1953: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">#938: elements with dynamic keys should be forced into blocks</span>
<span class=
"linenr">1954: </span>          (isVBind &amp;& isStaticArgOf(arg, <span class="org-string">'key'</span>)) ||
<span class="linenr">1955: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">inline before-update hooks need to force block so that it is invoked</span>
<span class="linenr">1956: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">before children</span>
<span class=
"linenr">1957: </span>          (isVOn &amp;& hasChildren &amp;& isStaticArgOf(arg, <span class="org-string">'vue:before-update'</span>))
<span class="linenr">1958: </span>        ) {
<span class=
"linenr">1959: </span>          shouldUseBlock = <span class=
"org-constant">true</span>
<span class="linenr">1960: </span>        }
<span class="linenr">1961: </span>  
<span class="linenr">1962: </span>        <span class=
"org-keyword">if</span> (isVBind &amp;& isStaticArgOf(arg, <span class="org-string">'ref'</span>) &amp;& context.scopes.vFor &gt; <span class="org-highlight-numbers-number">0</span>) {
<span class="linenr">1963: </span>          properties.push(
<span class="linenr">1964: </span>            createObjectProperty(
<span class=
"linenr">1965: </span>              createSimpleExpression(<span class="org-string">'ref_for'</span>, <span class="org-constant">true</span>),
<span class=
"linenr">1966: </span>              createSimpleExpression(<span class="org-string">'true'</span>)
<span class="linenr">1967: </span>            )
<span class="linenr">1968: </span>          )
<span class="linenr">1969: </span>        }
<span class="linenr">1970: </span>  
<span class="linenr">1971: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">special case for v-bind and v-on with no argument</span>
<span class="linenr">1972: </span>        <span class=
"org-keyword">if</span> (!arg &amp;& (isVBind || isVOn)) {
<span class=
"linenr">1973: </span>          hasDynamicKeys = <span class=
"org-constant">true</span>
<span class="linenr">1974: </span>          <span class=
"org-keyword">if</span> (exp) {
<span class="linenr">1975: </span>            <span class=
"org-keyword">if</span> (properties.length) {
<span class="linenr">1976: </span>              mergeArgs.push(
<span class=
"linenr">1977: </span>                createObjectExpression(dedupeProperties(properties), elementLoc)
<span class="linenr">1978: </span>              )
<span class="linenr">1979: </span>              properties = []
<span class="linenr">1980: </span>            }
<span class="linenr">1981: </span>            <span class=
"org-keyword">if</span> (isVBind) {
<span class="linenr">1982: </span>              mergeArgs.push(exp)
<span class="linenr">1983: </span>            } <span class=
"org-keyword">else</span> {
<span class="linenr">1984: </span>              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">v-on="obj" -&gt; toHandlers(obj)</span>
<span class="linenr">1985: </span>              mergeArgs.push({
<span class=
"linenr">1986: </span>                type: NodeTypes.JS_CALL_EXPRESSION,
<span class="linenr">1987: </span>                loc,
<span class=
"linenr">1988: </span>                callee: context.helper(TO_HANDLERS),
<span class="linenr">1989: </span>                <span class=
"org-constant">arguments</span>: [exp]
<span class="linenr">1990: </span>              })
<span class="linenr">1991: </span>            }
<span class="linenr">1992: </span>          }
<span class="linenr">1993: </span>          <span class=
"org-keyword">continue</span>
<span class="linenr">1994: </span>        }
<span class="linenr">1995: </span>  
<span class="linenr">1996: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">directiveTransform</span> = context.directiveTransforms[name]
<span class="linenr">1997: </span>        <span class=
"org-keyword">if</span> (directiveTransform) {
<span class="linenr">1998: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">has built-in directive transform.</span>
<span class="linenr">1999: </span>          <span class=
"org-keyword">const</span> { props, needRuntime } = directiveTransform(prop, node, context)
<span class=
"linenr">2000: </span>          !ssr &amp;& props.forEach(analyzePatchFlag)
<span class=
"linenr">2001: </span>          properties.push(...props)
<span class="linenr">2002: </span>          <span class=
"org-keyword">if</span> (needRuntime) {
<span class=
"linenr">2003: </span>            runtimeDirectives.push(prop)
<span class="linenr">2004: </span>            <span class=
"org-keyword">if</span> (isSymbol(needRuntime)) {
<span class=
"linenr">2005: </span>              directiveImportMap.set(prop, needRuntime)
<span class="linenr">2006: </span>            }
<span class="linenr">2007: </span>          }
<span class="linenr">2008: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (!isBuiltInDirective(name)) {
<span class="linenr">2009: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no built-in transform, this is a user custom directive.</span>
<span class=
"linenr">2010: </span>          runtimeDirectives.push(prop)
<span class="linenr">2011: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">custom dirs may use beforeUpdate so they need to force blocks</span>
<span class="linenr">2012: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">to ensure before-update gets called before children update</span>
<span class="linenr">2013: </span>          <span class=
"org-keyword">if</span> (hasChildren) {
<span class=
"linenr">2014: </span>            shouldUseBlock = <span class=
"org-constant">true</span>
<span class="linenr">2015: </span>          }
<span class="linenr">2016: </span>        }
<span class="linenr">2017: </span>      }
<span class="linenr">2018: </span>    }
<span class="linenr">2019: </span>  
<span class="linenr">2020: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">propsExpression</span> = <span class=
"org-constant">undefined</span>
<span class="linenr">2021: </span>  
<span class="linenr">2022: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">has v-bind="object" or v-on="object", wrap with mergeProps</span>
<span class="linenr">2023: </span>    <span class=
"org-keyword">if</span> (mergeArgs.length) {
<span class="linenr">2024: </span>      <span class=
"org-keyword">if</span> (properties.length) {
<span class="linenr">2025: </span>        mergeArgs.push(
<span class=
"linenr">2026: </span>          createObjectExpression(dedupeProperties(properties), elementLoc)
<span class="linenr">2027: </span>        )
<span class="linenr">2028: </span>      }
<span class="linenr">2029: </span>      <span class=
"org-keyword">if</span> (mergeArgs.length &gt; <span class=
"org-highlight-numbers-number">1</span>) {
<span class=
"linenr">2030: </span>        propsExpression = createCallExpression(
<span class=
"linenr">2031: </span>          context.helper(MERGE_PROPS),
<span class="linenr">2032: </span>          mergeArgs,
<span class="linenr">2033: </span>          elementLoc
<span class="linenr">2034: </span>        )
<span class="linenr">2035: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr">2036: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">single v-bind with nothing else - no need for a mergeProps call</span>
<span class=
"linenr">2037: </span>        propsExpression = mergeArgs[<span class="org-highlight-numbers-number">0</span>]
<span class="linenr">2038: </span>      }
<span class="linenr">2039: </span>    } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (properties.length) {
<span class=
"linenr">2040: </span>      propsExpression = createObjectExpression(
<span class=
"linenr">2041: </span>        dedupeProperties(properties),
<span class="linenr">2042: </span>        elementLoc
<span class="linenr">2043: </span>      )
<span class="linenr">2044: </span>    }
<span class="linenr">2045: </span>  
<span class="linenr">2046: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">patchFlag analysis</span>
<span class="linenr">2047: </span>    <span class=
"org-keyword">if</span> (hasDynamicKeys) {
<span class=
"linenr">2048: </span>      patchFlag |= PatchFlags.FULL_PROPS
<span class="linenr">2049: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr">2050: </span>      <span class=
"org-keyword">if</span> (hasClassBinding &amp;& !isComponent) {
<span class=
"linenr">2051: </span>        patchFlag |= PatchFlags.CLASS
<span class="linenr">2052: </span>      }
<span class="linenr">2053: </span>      <span class=
"org-keyword">if</span> (hasStyleBinding &amp;& !isComponent) {
<span class=
"linenr">2054: </span>        patchFlag |= PatchFlags.STYLE
<span class="linenr">2055: </span>      }
<span class="linenr">2056: </span>      <span class=
"org-keyword">if</span> (dynamicPropNames.length) {
<span class=
"linenr">2057: </span>        patchFlag |= PatchFlags.PROPS
<span class="linenr">2058: </span>      }
<span class="linenr">2059: </span>      <span class=
"org-keyword">if</span> (hasHydrationEventBinding) {
<span class=
"linenr">2060: </span>        patchFlag |= PatchFlags.HYDRATE_EVENTS
<span class="linenr">2061: </span>      }
<span class="linenr">2062: </span>    }
<span class="linenr">2063: </span>    <span class=
"org-keyword">if</span> (
<span class="linenr">2064: </span>      !shouldUseBlock &amp;&
<span class="linenr">2065: </span>      (patchFlag === <span class=
"org-highlight-numbers-number">0</span> || patchFlag === PatchFlags.HYDRATE_EVENTS) &amp;&
<span class=
"linenr">2066: </span>      (hasRef || hasVnodeHook || runtimeDirectives.length &gt; <span class="org-highlight-numbers-number">0</span>)
<span class="linenr">2067: </span>    ) {
<span class=
"linenr">2068: </span>      patchFlag |= PatchFlags.NEED_PATCH
<span class="linenr">2069: </span>    }
<span class="linenr">2070: </span>  
<span class="linenr">2071: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">pre-normalize props, SSR is skipped for now</span>
<span class="linenr">2072: </span>    <span class=
"org-keyword">if</span> (!context.inSSR &amp;& propsExpression) {
<span class="linenr">2073: </span>      <span class=
"org-keyword">switch</span> (propsExpression.type) {
<span class="linenr">2074: </span>        <span class=
"org-keyword">case</span> NodeTypes.JS_OBJECT_EXPRESSION:
<span class="linenr">2075: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">means that there is no v-bind,</span>
<span class="linenr">2076: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">but still need to deal with dynamic key binding</span>
<span class="linenr">2077: </span>          <span class=
"org-keyword">let</span> <span class=
"org-variable-name">classKeyIndex</span> = -<span class=
"org-highlight-numbers-number">1</span>
<span class="linenr">2078: </span>          <span class=
"org-keyword">let</span> <span class=
"org-variable-name">styleKeyIndex</span> = -<span class=
"org-highlight-numbers-number">1</span>
<span class="linenr">2079: </span>          <span class=
"org-keyword">let</span> <span class=
"org-variable-name">hasDynamicKey</span> = <span class=
"org-constant">false</span>
<span class="linenr">2080: </span>  
<span class="linenr">2081: </span>          <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; propsExpression.properties.length; i++) {
<span class="linenr">2082: </span>            <span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> = propsExpression.properties[i].key
<span class="linenr">2083: </span>            <span class=
"org-keyword">if</span> (isStaticExp(key)) {
<span class="linenr">2084: </span>              <span class=
"org-keyword">if</span> (key.content === <span class=
"org-string">'class'</span>) {
<span class="linenr">2085: </span>                classKeyIndex = i
<span class="linenr">2086: </span>              } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (key.content === <span class=
"org-string">'style'</span>) {
<span class="linenr">2087: </span>                styleKeyIndex = i
<span class="linenr">2088: </span>              }
<span class="linenr">2089: </span>            } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (!key.isHandlerKey) {
<span class=
"linenr">2090: </span>              hasDynamicKey = <span class=
"org-constant">true</span>
<span class="linenr">2091: </span>            }
<span class="linenr">2092: </span>          }
<span class="linenr">2093: </span>  
<span class="linenr">2094: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">classProp</span> = propsExpression.properties[classKeyIndex]
<span class="linenr">2095: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">styleProp</span> = propsExpression.properties[styleKeyIndex]
<span class="linenr">2096: </span>  
<span class="linenr">2097: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no dynamic key</span>
<span class="linenr">2098: </span>          <span class=
"org-keyword">if</span> (!hasDynamicKey) {
<span class="linenr">2099: </span>            <span class=
"org-keyword">if</span> (classProp &amp;& !isStaticExp(classProp.value)) {
<span class=
"linenr">2100: </span>              classProp.value = createCallExpression(
<span class=
"linenr">2101: </span>                context.helper(NORMALIZE_CLASS),
<span class="linenr">2102: </span>                [classProp.value]
<span class="linenr">2103: </span>              )
<span class="linenr">2104: </span>            }
<span class="linenr">2105: </span>            <span class=
"org-keyword">if</span> (
<span class="linenr">2106: </span>              styleProp &amp;&
<span class=
"linenr">2107: </span>              !isStaticExp(styleProp.value) &amp;&
<span class="linenr">2108: </span>              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">the static style is compiled into an object,</span>
<span class="linenr">2109: </span>              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">so use `hasStyleBinding` to ensure that it is a dynamic style binding</span>
<span class="linenr">2110: </span>              (hasStyleBinding ||
<span class="linenr">2111: </span>                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">v-bind:style and style both exist,</span>
<span class="linenr">2112: </span>                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">v-bind:style with static literal object</span>
<span class=
"linenr">2113: </span>                styleProp.value.type === NodeTypes.JS_ARRAY_EXPRESSION)
<span class="linenr">2114: </span>            ) {
<span class=
"linenr">2115: </span>              styleProp.value = createCallExpression(
<span class=
"linenr">2116: </span>                context.helper(NORMALIZE_STYLE),
<span class="linenr">2117: </span>                [styleProp.value]
<span class="linenr">2118: </span>              )
<span class="linenr">2119: </span>            }
<span class="linenr">2120: </span>          } <span class=
"org-keyword">else</span> {
<span class="linenr">2121: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">dynamic key binding, wrap with `normalizeProps`</span>
<span class=
"linenr">2122: </span>            propsExpression = createCallExpression(
<span class=
"linenr">2123: </span>              context.helper(NORMALIZE_PROPS),
<span class="linenr">2124: </span>              [propsExpression]
<span class="linenr">2125: </span>            )
<span class="linenr">2126: </span>          }
<span class="linenr">2127: </span>          <span class=
"org-keyword">break</span>
<span class="linenr">2128: </span>        <span class=
"org-keyword">case</span> NodeTypes.JS_CALL_EXPRESSION:
<span class="linenr">2129: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">mergeProps call, do nothing</span>
<span class="linenr">2130: </span>          <span class=
"org-keyword">break</span>
<span class="linenr">2131: </span>        <span class=
"org-keyword">default</span>:
<span class="linenr">2132: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">single v-bind</span>
<span class=
"linenr">2133: </span>          propsExpression = createCallExpression(
<span class=
"linenr">2134: </span>            context.helper(NORMALIZE_PROPS),
<span class="linenr">2135: </span>            [
<span class=
"linenr">2136: </span>              createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
<span class="linenr">2137: </span>                propsExpression
<span class="linenr">2138: </span>              ])
<span class="linenr">2139: </span>            ]
<span class="linenr">2140: </span>          )
<span class="linenr">2141: </span>          <span class=
"org-keyword">break</span>
<span class="linenr">2142: </span>      }
<span class="linenr">2143: </span>    }
<span class="linenr">2144: </span>  
<span class="linenr">2145: </span>    <span class=
"org-keyword">return</span> {
<span class="linenr">2146: </span>      props: propsExpression,
<span class=
"linenr">2147: </span>      directives: runtimeDirectives,
<span class="linenr">2148: </span>      patchFlag,
<span class="linenr">2149: </span>      dynamicPropNames,
<span class="linenr">2150: </span>      shouldUseBlock
<span class="linenr">2151: </span>    }
<span class="linenr">2152: </span>  }
<span class="linenr">2153: </span>  
<span class="linenr">2154: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">Dedupe props in an object literal.</span>
<span class="linenr">2155: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">Literal duplicated attributes would have been warned during the parse phase,</span>
<span class="linenr">2156: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">however, it's possible to encounter duplicated `onXXX` handlers with different</span>
<span class="linenr">2157: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">modifiers. We also need to merge static and dynamic class / style attributes.</span>
<span class="linenr">2158: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">- onXXX handlers / style: merge into array</span>
<span class="linenr">2159: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">- class: merge into single expression with concatenation</span>
<span class="linenr">2160: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">dedupeProperties</span>(<span class=
"org-variable-name">properties</span>) {
<span class="linenr">2161: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">knownProps</span> = <span class=
"org-keyword">new</span> <span class="org-type">Map</span>()
<span class="linenr">2162: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">deduped</span> = []
<span class="linenr">2163: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; properties.length; i++) {
<span class="linenr">2164: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">prop</span> = properties[i]
<span class="linenr">2165: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">dynamic keys are always allowed</span>
<span class="linenr">2166: </span>      <span class=
"org-keyword">if</span> (prop.key.type === NodeTypes.COMPOUND_EXPRESSION || !prop.key.isStatic) {
<span class="linenr">2167: </span>        deduped.push(prop)
<span class="linenr">2168: </span>        <span class=
"org-keyword">continue</span>
<span class="linenr">2169: </span>      }
<span class="linenr">2170: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">name</span> = prop.key.content
<span class="linenr">2171: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">existing</span> = knownProps.get(name)
<span class="linenr">2172: </span>      <span class=
"org-keyword">if</span> (existing) {
<span class="linenr">2173: </span>        <span class=
"org-keyword">if</span> (name === <span class=
"org-string">'style'</span> || name === <span class=
"org-string">'class'</span> || isOn(name)) {
<span class=
"linenr">2174: </span>          mergeAsArray(existing, prop)
<span class="linenr">2175: </span>        }
<span class="linenr">2176: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">unexpected duplicate, should have emitted error during parse</span>
<span class="linenr">2177: </span>      } <span class=
"org-keyword">else</span> {
<span class=
"linenr">2178: </span>        knownProps.set(name, prop)
<span class="linenr">2179: </span>        deduped.push(prop)
<span class="linenr">2180: </span>      }
<span class="linenr">2181: </span>    }
<span class="linenr">2182: </span>    <span class=
"org-keyword">return</span> deduped
<span class="linenr">2183: </span>  }
<span class="linenr">2184: </span>  
<span class="linenr">2185: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">mergeAsArray</span>(<span class=
"org-variable-name">existing</span>, <span class=
"org-variable-name">incoming</span>) {
<span class="linenr">2186: </span>    <span class=
"org-keyword">if</span> (existing.value.type === NodeTypes.JS_ARRAY_EXPRESSION) {
<span class=
"linenr">2187: </span>      existing.value.elements.push(incoming.value)
<span class="linenr">2188: </span>    } <span class=
"org-keyword">else</span> {
<span class=
"linenr">2189: </span>      existing.value = createArrayExpression(
<span class=
"linenr">2190: </span>        [existing.value, incoming.value],
<span class="linenr">2191: </span>        existing.loc
<span class="linenr">2192: </span>      )
<span class="linenr">2193: </span>    }
<span class="linenr">2194: </span>  }
<span class="linenr">2195: </span>  
<span class="linenr">2196: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">buildDirectiveArgs</span>(
<span class="linenr">2197: </span>    <span class=
"org-variable-name">dir</span>,
<span class="linenr">2198: </span>    context
<span class="linenr">2199: </span>  ) {
<span class="linenr">2200: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">dirArgs</span> = []
<span class="linenr">2201: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">runtime</span> = directiveImportMap.get(dir)
<span class="linenr">2202: </span>    <span class=
"org-keyword">if</span> (runtime) {
<span class="linenr">2203: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">built-in directive with runtime</span>
<span class=
"linenr">2204: </span>      dirArgs.push(context.helperString(runtime))
<span class="linenr">2205: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr">2206: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">user directive.</span>
<span class="linenr">2207: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">see if we have directives exposed via &lt;script setup&gt;</span>
<span class="linenr">2208: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">fromSetup</span> =
<span class=
"linenr">2209: </span>        !__BROWSER__ &amp;& resolveSetupReference(<span class="org-string">'v-'</span> + dir.name, context)
<span class="linenr">2210: </span>      <span class=
"org-keyword">if</span> (fromSetup) {
<span class="linenr">2211: </span>        dirArgs.push(fromSetup)
<span class="linenr">2212: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr">2213: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">inject statement for resolving directive</span>
<span class=
"linenr">2214: </span>        context.helper(RESOLVE_DIRECTIVE)
<span class=
"linenr">2215: </span>        context.directives.add(dir.name)
<span class=
"linenr">2216: </span>        dirArgs.push(toValidAssetId(dir.name, <span class="org-string">`directive`</span>))
<span class="linenr">2217: </span>      }
<span class="linenr">2218: </span>    }
<span class="linenr">2219: </span>    <span class=
"org-keyword">const</span> { loc } = dir
<span class="linenr">2220: </span>    <span class=
"org-keyword">if</span> (dir.exp) dirArgs.push(dir.exp)
<span class="linenr">2221: </span>    <span class=
"org-keyword">if</span> (dir.arg) {
<span class="linenr">2222: </span>      <span class=
"org-keyword">if</span> (!dir.exp) {
<span class="linenr">2223: </span>        dirArgs.push(<span class=
"org-string">`void 0`</span>)
<span class="linenr">2224: </span>      }
<span class="linenr">2225: </span>      dirArgs.push(dir.arg)
<span class="linenr">2226: </span>    }
<span class="linenr">2227: </span>    <span class=
"org-keyword">if</span> (Object.keys(dir.modifiers).length) {
<span class="linenr">2228: </span>      <span class=
"org-keyword">if</span> (!dir.arg) {
<span class="linenr">2229: </span>        <span class=
"org-keyword">if</span> (!dir.exp) {
<span class=
"linenr">2230: </span>          dirArgs.push(<span class=
"org-string">`void 0`</span>)
<span class="linenr">2231: </span>        }
<span class="linenr">2232: </span>        dirArgs.push(<span class=
"org-string">`void 0`</span>)
<span class="linenr">2233: </span>      }
<span class="linenr">2234: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">trueExpression</span> = createSimpleExpression(<span class="org-string">`true`</span>, <span class="org-constant">false</span>, loc)
<span class="linenr">2235: </span>      dirArgs.push(
<span class="linenr">2236: </span>        createObjectExpression(
<span class=
"linenr">2237: </span>          dir.modifiers.map(modifier =&gt;
<span class=
"linenr">2238: </span>            createObjectProperty(modifier, trueExpression)
<span class="linenr">2239: </span>          ),
<span class="linenr">2240: </span>          loc
<span class="linenr">2241: </span>        )
<span class="linenr">2242: </span>      )
<span class="linenr">2243: </span>    }
<span class="linenr">2244: </span>    <span class=
"org-keyword">return</span> createArrayExpression(dirArgs, dir.loc)
<span class="linenr">2245: </span>  }
<span class="linenr">2246: </span>  
<span class="linenr">2247: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">stringifyDynamicPropNames</span>(<span class=
"org-variable-name">props</span>) {
<span class="linenr">2248: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">propsNamesString</span> = <span class=
"org-string">`[`</span>
<span class="linenr">2249: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>, <span class=
"org-variable-name">l</span> = props.length; i &lt; l; i++) {
<span class=
"linenr">2250: </span>      propsNamesString += JSON.stringify(props[i])
<span class="linenr">2251: </span>      <span class=
"org-keyword">if</span> (i &lt; l - <span class=
"org-highlight-numbers-number">1</span>) propsNamesString += <span class="org-string">', '</span>
<span class="linenr">2252: </span>    }
<span class="linenr">2253: </span>    <span class=
"org-keyword">return</span> propsNamesString + <span class=
"org-string">`]`</span>
<span class="linenr">2254: </span>  }
<span class="linenr">2255: </span>  
<span class="linenr">2256: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">isComponentTag</span>(<span class=
"org-variable-name">tag</span>) {
<span class="linenr">2257: </span>    <span class=
"org-keyword">return</span> tag === <span class=
"org-string">'component'</span> || tag === <span class=
"org-string">'Component'</span>
<span class="linenr">2258: </span>  }
<span class="linenr">2259: </span>  
<span class="linenr">2260: </span>  
<span class="linenr">2261: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isLiteralWhitelisted</span> = <span class=
"org-comment-delimiter">/*</span><span class=
"org-comment">#__PURE__</span><span class=
"org-comment-delimiter">*/</span> makeMap(<span class=
"org-string">'true,false,null,this'</span>)
<span class="linenr">2262: </span>  
<span class="linenr">2263: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">transformExpression</span> = (node, context) =&gt; {
<span class="linenr">2264: </span>    logg(<span class=
"org-string">`transformExpression`</span>, node)
<span class="linenr">2265: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">插值处理</span>
<span class="linenr">2266: </span>    <span class=
"org-keyword">if</span> (node.type === NodeTypes.INTERPOLATION) {
<span class=
"linenr">2267: </span>      node.content = processExpression(
<span class="linenr">2268: </span>        node.content ,
<span class="linenr">2269: </span>        context
<span class="linenr">2270: </span>      )
<span class="linenr">2271: </span>    } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (node.type === NodeTypes.ELEMENT) {
<span class="linenr">2272: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">处理元素上的指令</span>
<span class="linenr">2273: </span>      <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; node.props.length; i++) {
<span class="linenr">2274: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">dir</span> = node.props[i]
<span class="linenr">2275: </span>        logg(<span class=
"org-string">`transformExpression - prop[${i}] - directive`</span>, node.props[i])
<span class="linenr">2276: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">do not process for v-on & v-for since they are special handled</span>
<span class="linenr">2277: </span>        <span class=
"org-keyword">if</span> (dir.type === NodeTypes.DIRECTIVE &amp;& dir.name !== <span class="org-string">'for'</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">v-for 在 vFor.ts 中处理</span>
<span class="linenr">2278: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">exp</span> = dir.exp
<span class="linenr">2279: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">arg</span> = dir.arg
<span class="linenr">2280: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">do not process exp if this is v-on:arg - we need special handling</span>
<span class="linenr">2281: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">for wrapping inline statements.</span>
<span class="linenr">2282: </span>          <span class=
"org-keyword">if</span> (
<span class="linenr">2283: </span>            exp &amp;&
<span class=
"linenr">2284: </span>            exp.type === NodeTypes.SIMPLE_EXPRESSION &amp;&
<span class=
"linenr">2285: </span>            !(dir.name === <span class=
"org-string">'on'</span> &amp;& arg)
<span class="linenr">2286: </span>          ) {
<span class=
"linenr">2287: </span>            dir.exp = processExpression(
<span class="linenr">2288: </span>              exp,
<span class="linenr">2289: </span>              context,
<span class="linenr">2290: </span>              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">slot args must be processed as function params</span>
<span class=
"linenr">2291: </span>              dir.name === <span class=
"org-string">'slot'</span>
<span class="linenr">2292: </span>            )
<span class="linenr">2293: </span>          }
<span class="linenr">2294: </span>          <span class=
"org-keyword">if</span> (arg &amp;& arg.type === NodeTypes.SIMPLE_EXPRESSION &amp;& !arg.isStatic) {
<span class=
"linenr">2295: </span>            dir.arg = processExpression(arg, context)
<span class="linenr">2296: </span>          }
<span class="linenr">2297: </span>        }
<span class="linenr">2298: </span>      }
<span class="linenr">2299: </span>    }
<span class="linenr">2300: </span>  }
<span class="linenr">2301: </span>  
<span class="linenr">2302: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">Important: since this function uses Node.js only dependencies, it should</span>
<span class="linenr">2303: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">always be used with a leading !__BROWSER__ check so that it can be</span>
<span class="linenr">2304: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">tree-shaken from the browser build.</span>
<span class="linenr">2305: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">processExpression</span>(
<span class="linenr">2306: </span>    <span class=
"org-variable-name">node</span>,
<span class="linenr">2307: </span>    <span class=
"org-variable-name">context</span>,
<span class="linenr">2308: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">some expressions like v-slot props & v-for aliases should be parsed as</span>
<span class="linenr">2309: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">function params</span>
<span class="linenr">2310: </span>    asParams = <span class=
"org-constant">false</span>,
<span class="linenr">2311: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">v-on handler values may contain multiple statements</span>
<span class=
"linenr">2312: </span>    asRawStatements = <span class="org-constant">false</span>,
<span class=
"linenr">2313: </span>    localVars = Object.create(context.identifiers)
<span class="linenr">2314: </span>  ) {
<span class="linenr">2315: </span>    <span class=
"org-keyword">if</span> (__BROWSER__) {
<span class="linenr">2316: </span>      <span class=
"org-keyword">return</span> node
<span class="linenr">2317: </span>    }
<span class="linenr">2318: </span>  
<span class="linenr">2319: </span>    <span class=
"org-keyword">if</span> (!context.prefixIdentifiers || !node.content.trim()) {
<span class="linenr">2320: </span>      <span class=
"org-keyword">return</span> node
<span class="linenr">2321: </span>    }
<span class="linenr">2322: </span>  
<span class="linenr">2323: </span>    <span class=
"org-keyword">const</span> { inline, bindingMetadata } = context
<span class="linenr">2324: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">rewriteIdentifier</span> = (raw, parent, id) =&gt; {
<span class="linenr">2325: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">type</span> = hasOwn(bindingMetadata, raw) &amp;& bindingMetadata[raw]
<span class="linenr">2326: </span>      <span class=
"org-keyword">if</span> (inline) {
<span class="linenr">2327: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">x = y</span>
<span class="linenr">2328: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isAssignmentLVal</span> =
<span class=
"linenr">2329: </span>          parent &amp;& parent.type === <span class="org-string">'AssignmentExpression'</span> &amp;& parent.left === id
<span class="linenr">2330: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">x++</span>
<span class="linenr">2331: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isUpdateArg</span> =
<span class=
"linenr">2332: </span>          parent &amp;& parent.type === <span class="org-string">'UpdateExpression'</span> &amp;& parent.argument === id
<span class="linenr">2333: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">({ x } = y)</span>
<span class="linenr">2334: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isDestructureAssignment</span> =
<span class=
"linenr">2335: </span>          parent &amp;& isInDestructureAssignment(parent, parentStack)
<span class="linenr">2336: </span>  
<span class="linenr">2337: </span>        <span class=
"org-keyword">if</span> (type === BindingTypes.SETUP_CONST || localVars[raw]) {
<span class="linenr">2338: </span>          <span class=
"org-keyword">return</span> raw
<span class="linenr">2339: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (type === BindingTypes.SETUP_REF) {
<span class="linenr">2340: </span>          <span class=
"org-keyword">return</span> <span class=
"org-string">`${raw}.value`</span>
<span class="linenr">2341: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (type === BindingTypes.SETUP_MAYBE_REF) {
<span class="linenr">2342: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">const binding that may or may not be ref</span>
<span class="linenr">2343: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">if it's not a ref, then assignments don't make sense -</span>
<span class="linenr">2344: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">so we ignore the non-ref assignment case and generate code</span>
<span class="linenr">2345: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">that assumes the value to be a ref for more efficiency</span>
<span class="linenr">2346: </span>          <span class=
"org-keyword">return</span> isAssignmentLVal || isUpdateArg || isDestructureAssignment
<span class="linenr">2347: </span>            ? <span class=
"org-string">`${raw}.value`</span>
<span class="linenr">2348: </span>            : <span class=
"org-string">`${context.helperString(UNREF)}(${raw})`</span>
<span class="linenr">2349: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (type === BindingTypes.SETUP_LET) {
<span class="linenr">2350: </span>          <span class=
"org-keyword">if</span> (isAssignmentLVal) {
<span class="linenr">2351: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">let binding.</span>
<span class="linenr">2352: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">this is a bit more tricky as we need to cover the case where</span>
<span class="linenr">2353: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">let is a local non-ref value, and we need to replicate the</span>
<span class="linenr">2354: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">right hand side value.</span>
<span class="linenr">2355: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">x = y --&gt; isRef(x) ? x.value = y : x = y</span>
<span class="linenr">2356: </span>            <span class=
"org-keyword">const</span> { right: rVal, operator } = parent
<span class="linenr">2357: </span>            <span class=
"org-keyword">const</span> <span class=
"org-variable-name">rExp</span> = rawExp.slice(rVal.start - <span class="org-highlight-numbers-number">1</span>, rVal.end - <span class="org-highlight-numbers-number">1</span>)
<span class="linenr">2358: </span>            <span class=
"org-keyword">const</span> <span class=
"org-variable-name">rExpString</span> = stringifyExpression(
<span class="linenr">2359: </span>              processExpression(
<span class=
"linenr">2360: </span>                createSimpleExpression(rExp, <span class="org-constant">false</span>),
<span class="linenr">2361: </span>                context,
<span class="linenr">2362: </span>                <span class=
"org-constant">false</span>,
<span class="linenr">2363: </span>                <span class=
"org-constant">false</span>,
<span class="linenr">2364: </span>                knownIds
<span class="linenr">2365: </span>              )
<span class="linenr">2366: </span>            )
<span class="linenr">2367: </span>            <span class=
"org-keyword">return</span> <span class=
"org-string">`${context.helperString(IS_REF)}(${raw})${``} ? ${raw}.value ${operator} ${rExpString} : ${raw}`</span>
<span class="linenr">2368: </span>          } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (isUpdateArg) {
<span class="linenr">2369: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">make id replace parent in the code range so the raw update operator</span>
<span class="linenr">2370: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">is removed</span>
<span class=
"linenr">2371: </span>            id.start = parent.start
<span class="linenr">2372: </span>            id.end = parent.end
<span class="linenr">2373: </span>            <span class=
"org-keyword">const</span> { prefix: isPrefix, operator } = parent
<span class="linenr">2374: </span>            <span class=
"org-keyword">const</span> <span class=
"org-variable-name">prefix</span> = isPrefix ? operator : <span class="org-string">``</span>
<span class="linenr">2375: </span>            <span class=
"org-keyword">const</span> <span class=
"org-variable-name">postfix</span> = isPrefix ? <span class=
"org-string">``</span> : operator
<span class="linenr">2376: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">let binding.</span>
<span class="linenr">2377: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">x++ --&gt; isRef(a) ? a.value++ : a++</span>
<span class="linenr">2378: </span>            <span class=
"org-keyword">return</span> <span class=
"org-string">`${context.helperString(IS_REF)}(${raw})${``} ? ${prefix}${raw}.value${postfix} : ${prefix}${raw}${postfix}`</span>
<span class="linenr">2379: </span>          } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (isDestructureAssignment) {
<span class="linenr">2380: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment"><span class="org-bold"><span class=
"org-warning">TODO</span></span></span>
<span class="linenr">2381: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">let binding in a destructure assignment - it's very tricky to</span>
<span class="linenr">2382: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">handle both possible cases here without altering the original</span>
<span class="linenr">2383: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">structure of the code, so we just assume it's not a ref here</span>
<span class="linenr">2384: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">for now</span>
<span class="linenr">2385: </span>            <span class=
"org-keyword">return</span> raw
<span class="linenr">2386: </span>          } <span class=
"org-keyword">else</span> {
<span class="linenr">2387: </span>            <span class=
"org-keyword">return</span> <span class=
"org-string">`${context.helperString(UNREF)}(${raw})`</span>
<span class="linenr">2388: </span>          }
<span class="linenr">2389: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (type === BindingTypes.PROPS) {
<span class="linenr">2390: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">use __props which is generated by compileScript so in ts mode</span>
<span class="linenr">2391: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">it gets correct type</span>
<span class="linenr">2392: </span>          <span class=
"org-keyword">return</span> <span class=
"org-string">`__props.${raw}`</span>
<span class="linenr">2393: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (type === BindingTypes.PROPS_ALIASED) {
<span class="linenr">2394: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">prop with a different local alias (from defineProps() destructure)</span>
<span class="linenr">2395: </span>          <span class=
"org-keyword">return</span> <span class=
"org-string">`__props.${bindingMetadata.__propsAliases[raw]}`</span>
<span class="linenr">2396: </span>        }
<span class="linenr">2397: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr">2398: </span>        <span class=
"org-keyword">if</span> (type &amp;& type.startsWith(<span class=
"org-string">'setup'</span>)) {
<span class="linenr">2399: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">setup bindings in non-inline mode</span>
<span class="linenr">2400: </span>          <span class=
"org-keyword">return</span> <span class=
"org-string">`$setup.${raw}`</span>
<span class="linenr">2401: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (type === BindingTypes.PROPS_ALIASED) {
<span class="linenr">2402: </span>          <span class=
"org-keyword">return</span> <span class=
"org-string">`$props.${bindingMetadata.__propsAliases[raw]}`</span>
<span class="linenr">2403: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (type) {
<span class="linenr">2404: </span>          <span class=
"org-keyword">return</span> <span class=
"org-string">`$${type}.${raw}`</span>
<span class="linenr">2405: </span>        }
<span class="linenr">2406: </span>      }
<span class="linenr">2407: </span>  
<span class="linenr">2408: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">fallback to ctx</span>
<span class="linenr">2409: </span>      <span class=
"org-keyword">return</span> <span class=
"org-string">`_ctx.${raw}`</span>
<span class="linenr">2410: </span>    }
<span class="linenr">2411: </span>  
<span class="linenr">2412: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">fast path if expression is a simple identifier.</span>
<span class="linenr">2413: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">rawExp</span> = node.content
<span class="linenr">2414: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">bail constant on parens (function invocation) and dot (member access)</span>
<span class="linenr">2415: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">bailConstant</span> = rawExp.indexOf(<span class="org-string">`(`</span>) &gt; -<span class="org-highlight-numbers-number">1</span> || rawExp.indexOf(<span class="org-string">'.'</span>) &gt; <span class="org-highlight-numbers-number">0</span>
<span class="linenr">2416: </span>  
<span class="linenr">2417: </span>    logg(<span class=
"org-string">`processExpression - node.content: ${rawExp}`</span>)
<span class="linenr">2418: </span>    <span class=
"org-keyword">if</span> (isSimpleIdentifier(rawExp)) {
<span class="linenr">2419: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isScopeVarReference</span> = context.identifiers[rawExp]
<span class="linenr">2420: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isAllowedGlobal</span> = isGloballyWhitelisted(rawExp)
<span class="linenr">2421: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isLiteral</span> = isLiteralWhitelisted(rawExp)
<span class="linenr">2422: </span>      <span class=
"org-keyword">if</span> (!asParams &amp;& !isScopeVarReference &amp;& !isAllowedGlobal &amp;& !isLiteral) {
<span class="linenr">2423: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">const bindings exposed from setup can be skipped for patching but</span>
<span class="linenr">2424: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">cannot be hoisted to module scope</span>
<span class="linenr">2425: </span>        <span class=
"org-keyword">if</span> (bindingMetadata[node.content] === BindingTypes.SETUP_CONST) {
<span class=
"linenr">2426: </span>          node.constType = ConstantTypes.CAN_SKIP_PATCH
<span class="linenr">2427: </span>        }
<span class=
"linenr">2428: </span>        node.content = rewriteIdentifier(rawExp)
<span class="linenr">2429: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (!isScopeVarReference) {
<span class="linenr">2430: </span>        <span class=
"org-keyword">if</span> (isLiteral) {
<span class=
"linenr">2431: </span>          node.constType = ConstantTypes.CAN_STRINGIFY
<span class="linenr">2432: </span>        } <span class=
"org-keyword">else</span> {
<span class=
"linenr">2433: </span>          node.constType = ConstantTypes.CAN_HOIST
<span class="linenr">2434: </span>        }
<span class="linenr">2435: </span>      }
<span class="linenr">2436: </span>      <span class=
"org-keyword">return</span> node
<span class="linenr">2437: </span>    }
<span class="linenr">2438: </span>  
<span class="linenr">2439: </span>    <span class=
"org-keyword">let</span> <span class="org-variable-name">ast</span>
<span class="linenr">2440: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">exp needs to be parsed differently:</span>
<span class="linenr">2441: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">1. Multiple inline statements (v-on, with presence of `;`): parse as raw</span>
<span class="linenr">2442: </span>    <span class=
"org-comment-delimiter">//    </span><span class=
"org-comment">exp, but make sure to pad with spaces for consistent ranges</span>
<span class="linenr">2443: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">2. Expressions: wrap with parens (for e.g. object expressions)</span>
<span class="linenr">2444: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">3. Function arguments (v-for, v-slot): place in a function argument position</span>
<span class="linenr">2445: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">source</span> = asRawStatements
<span class="linenr">2446: </span>      ? <span class=
"org-string">` ${rawExp} `</span>
<span class="linenr">2447: </span>      : <span class=
"org-string">`(${rawExp})${asParams ? `</span>=&gt;{}<span class=
"org-string">` : ``}`</span>
<span class="linenr">2448: </span>    <span class=
"org-keyword">try</span> {
<span class=
"linenr">2449: </span>      ast = babelParser.parse(source, {
<span class=
"linenr">2450: </span>        plugins: context.expressionPlugins
<span class="linenr">2451: </span>      }).program
<span class="linenr">2452: </span>    } <span class=
"org-keyword">catch</span> (e) {
<span class="linenr">2453: </span>      <span class=
"org-keyword">return</span> node
<span class="linenr">2454: </span>    }
<span class="linenr">2455: </span>  
<span class="linenr">2456: </span>    logg(<span class=
"org-string">`processExpression - babel parse`</span>, ast)
<span class="linenr">2457: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">ids</span> = []
<span class="linenr">2458: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">parentStack</span> = []
<span class="linenr">2459: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">knownIds</span> = Object.create(context.identifiers)
<span class="linenr">2460: </span>  
<span class="linenr">2461: </span>    walkIdentifiers(
<span class="linenr">2462: </span>      ast,
<span class=
"linenr">2463: </span>      (node, parent, _, isReferenced, isLocal) =&gt; {
<span class="linenr">2464: </span>        <span class=
"org-keyword">if</span> (isStaticPropertyKey(node, parent)) {
<span class="linenr">2465: </span>          <span class=
"org-keyword">return</span>
<span class="linenr">2466: </span>        }
<span class="linenr">2467: </span>  
<span class="linenr">2468: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">needPrefix</span> = isReferenced &amp;& canPrefix(node)
<span class="linenr">2469: </span>        <span class=
"org-keyword">if</span> (needPrefix &amp;& !isLocal) {
<span class="linenr">2470: </span>          <span class=
"org-keyword">if</span> (isStaticProperty(parent) &amp;& parent.shorthand) {
<span class="linenr">2471: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">property shorthand like { foo }, we need to add the key since</span>
<span class="linenr">2472: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">we rewrite the value</span>
<span class=
"linenr">2473: </span>            node.prefix = <span class=
"org-string">`${node.name}: `</span>
<span class="linenr">2474: </span>          }
<span class=
"linenr">2475: </span>          node.name = rewriteIdentifier(node.name, parent, node)
<span class="linenr">2476: </span>          ids.push(node)
<span class="linenr">2477: </span>        } <span class=
"org-keyword">else</span> {
<span class="linenr">2478: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">The identifier is considered constant unless it's pointing to a</span>
<span class="linenr">2479: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">local scope variable (a v-for alias, or a v-slot prop)</span>
<span class="linenr">2480: </span>          <span class=
"org-keyword">if</span> (!(needPrefix &amp;& isLocal) &amp;& !bailConstant) {
<span class=
"linenr">2481: </span>            node.isConstant = <span class=
"org-constant">true</span>
<span class="linenr">2482: </span>          }
<span class="linenr">2483: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">also generate sub-expressions for other identifiers for better</span>
<span class="linenr">2484: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">source map support. (except for property keys which are static)</span>
<span class="linenr">2485: </span>          ids.push(node)
<span class="linenr">2486: </span>        }
<span class="linenr">2487: </span>      },
<span class="linenr">2488: </span>      <span class=
"org-constant">true</span>, <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">invoke on ALL identifiers</span>
<span class="linenr">2489: </span>      parentStack,
<span class="linenr">2490: </span>      knownIds
<span class="linenr">2491: </span>    )
<span class="linenr">2492: </span>  
<span class="linenr">2493: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">We break up the compound expression into an array of strings and sub</span>
<span class="linenr">2494: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">expressions (for identifiers that have been prefixed). In codegen, if</span>
<span class="linenr">2495: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">an ExpressionNode has the `.children` property, it will be used instead of</span>
<span class="linenr">2496: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">`.content`.</span>
<span class="linenr">2497: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">children</span> = []
<span class=
"linenr">2498: </span>    ids.sort((a, b) =&gt; a.start - b.start)
<span class="linenr">2499: </span>    ids.forEach((id, i) =&gt; {
<span class="linenr">2500: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">range is offset by -1 due to the wrapping parens when parsed</span>
<span class="linenr">2501: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">start</span> = id.start - <span class=
"org-highlight-numbers-number">1</span>
<span class="linenr">2502: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">end</span> = id.end - <span class=
"org-highlight-numbers-number">1</span>
<span class="linenr">2503: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">last</span> = ids[i - <span class=
"org-highlight-numbers-number">1</span>]
<span class="linenr">2504: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">leadingText</span> = rawExp.slice(last ? last.end - <span class="org-highlight-numbers-number">1</span> : <span class="org-highlight-numbers-number">0</span>, start)
<span class="linenr">2505: </span>      <span class=
"org-keyword">if</span> (leadingText.length || id.prefix) {
<span class=
"linenr">2506: </span>        children.push(leadingText + (id.prefix || <span class="org-string">``</span>))
<span class="linenr">2507: </span>      }
<span class="linenr">2508: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">source</span> = rawExp.slice(start, end)
<span class="linenr">2509: </span>      children.push(
<span class="linenr">2510: </span>        createSimpleExpression(
<span class="linenr">2511: </span>          id.name,
<span class="linenr">2512: </span>          <span class=
"org-constant">false</span>,
<span class="linenr">2513: </span>          {
<span class="linenr">2514: </span>            source,
<span class=
"linenr">2515: </span>            start: advancePositionWithClone(node.loc.start, source, start),
<span class=
"linenr">2516: </span>            end: advancePositionWithClone(node.loc.start, source, end)
<span class="linenr">2517: </span>          },
<span class=
"linenr">2518: </span>          id.isConstant ? ConstantTypes.CAN_STRINGIFY : ConstantTypes.NOT_CONSTANT
<span class="linenr">2519: </span>        )
<span class="linenr">2520: </span>      )
<span class="linenr">2521: </span>      <span class=
"org-keyword">if</span> (i === ids.length - <span class=
"org-highlight-numbers-number">1</span> &amp;& end &lt; rawExp.length) {
<span class=
"linenr">2522: </span>        children.push(rawExp.slice(end))
<span class="linenr">2523: </span>      }
<span class="linenr">2524: </span>    })
<span class="linenr">2525: </span>  
<span class="linenr">2526: </span>    <span class=
"org-keyword">let</span> <span class="org-variable-name">ret</span>
<span class="linenr">2527: </span>    <span class=
"org-keyword">if</span> (children.length) {
<span class=
"linenr">2528: </span>      ret = createCompoundExpression(children, node.loc)
<span class="linenr">2529: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr">2530: </span>      ret = node
<span class=
"linenr">2531: </span>      ret.constType = bailConstant
<span class=
"linenr">2532: </span>        ? ConstantTypes.NOT_CONSTANT
<span class=
"linenr">2533: </span>        : ConstantTypes.CAN_STRINGIFY
<span class="linenr">2534: </span>    }
<span class=
"linenr">2535: </span>    ret.identifiers = Object.keys(knownIds)
<span class="linenr">2536: </span>    <span class=
"org-keyword">return</span> ret
<span class="linenr">2537: </span>  }
<span class="linenr">2538: </span>  
<span class="linenr">2539: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">canPrefix</span>(<span class=
"org-variable-name">id</span>) {
<span class="linenr">2540: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">skip whitelisted globals</span>
<span class="linenr">2541: </span>    <span class=
"org-keyword">if</span> (isGloballyWhitelisted(id.name)) {
<span class="linenr">2542: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">2543: </span>    }
<span class="linenr">2544: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">special case for webpack compilation</span>
<span class="linenr">2545: </span>    <span class=
"org-keyword">if</span> (id.name === <span class=
"org-string">'require'</span>) {
<span class="linenr">2546: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">2547: </span>    }
<span class="linenr">2548: </span>    <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr">2549: </span>  }
<span class="linenr">2550: </span>  
<span class="linenr">2551: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">stringifyExpression</span>(<span class=
"org-variable-name">exp</span>) {
<span class="linenr">2552: </span>    <span class=
"org-keyword">if</span> (isString(exp)) {
<span class="linenr">2553: </span>      <span class=
"org-keyword">return</span> exp
<span class="linenr">2554: </span>    } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (exp.type === NodeTypes.SIMPLE_EXPRESSION) {
<span class="linenr">2555: </span>      <span class=
"org-keyword">return</span> exp.content
<span class="linenr">2556: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr">2557: </span>      <span class=
"org-keyword">return</span> (exp.children)
<span class="linenr">2558: </span>        .map(stringifyExpression)
<span class="linenr">2559: </span>        .join(<span class=
"org-string">''</span>)
<span class="linenr">2560: </span>    }
<span class="linenr">2561: </span>  }
<span class="linenr">2562: </span>  
<span class="linenr">2563: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">transformSlotOutlet</span> = (node, context) =&gt; {
<span class="linenr">2564: </span>    <span class=
"org-keyword">if</span> (isSlotOutlet(node)) { <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">&lt;slot/&gt;</span>
<span class="linenr">2565: </span>      <span class=
"org-keyword">const</span> { children, loc } = node
<span class="linenr">2566: </span>      <span class=
"org-keyword">const</span> { slotName, slotProps } = processSlotOutlet(node, context)
<span class="linenr">2567: </span>  
<span class="linenr">2568: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">slotArgs</span> = [
<span class=
"linenr">2569: </span>        context.prefixIdentifiers ? <span class="org-string">`_ctx.$slots`</span> : <span class="org-string">`$slots`</span>,
<span class="linenr">2570: </span>        slotName,
<span class="linenr">2571: </span>        <span class=
"org-string">'{}'</span>, <span class=
"org-comment-delimiter">//  </span><span class=
"org-comment">props</span>
<span class="linenr">2572: </span>        <span class=
"org-string">'undefined'</span>, <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">children</span>
<span class="linenr">2573: </span>        <span class=
"org-string">'true'</span>
<span class="linenr">2574: </span>      ]
<span class="linenr">2575: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">expectedLen</span> = <span class=
"org-highlight-numbers-number">2</span>
<span class="linenr">2576: </span>  
<span class="linenr">2577: </span>      <span class=
"org-keyword">if</span> (slotProps) {
<span class="linenr">2578: </span>        slotArgs[<span class=
"org-highlight-numbers-number">2</span>] = slotProps
<span class=
"linenr">2579: </span>        expectedLen = <span class="org-highlight-numbers-number">3</span>
<span class="linenr">2580: </span>      }
<span class="linenr">2581: </span>  
<span class="linenr">2582: </span>      <span class=
"org-keyword">if</span> (children.length) {
<span class="linenr">2583: </span>        slotArgs[<span class=
"org-highlight-numbers-number">3</span>] = createFunctionExpression([], children, <span class="org-constant">false</span>, <span class="org-constant">false</span>, loc)
<span class=
"linenr">2584: </span>        expectedLen = <span class="org-highlight-numbers-number">4</span>
<span class="linenr">2585: </span>      }
<span class="linenr">2586: </span>  
<span class="linenr">2587: </span>      <span class=
"org-keyword">if</span> (context.scopeId &amp;& !context.slotted) {
<span class=
"linenr">2588: </span>        expectedLen = <span class="org-highlight-numbers-number">5</span>
<span class="linenr">2589: </span>      }
<span class=
"linenr">2590: </span>      slotArgs.splice(expectedLen) <span class="org-comment-delimiter">// </span><span class="org-comment">remove unused arguments</span>
<span class="linenr">2591: </span>  
<span class="linenr">2592: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">-&gt; renderSlot($slots, slotName, props, children, true)</span>
<span class=
"linenr">2593: </span>      node.codegenNode = createCallExpression(
<span class=
"linenr">2594: </span>        context.helper(RENDER_SLOT), <span class="org-comment-delimiter">// </span><span class="org-comment">renderSlot</span>
<span class="linenr">2595: </span>        slotArgs,
<span class="linenr">2596: </span>        loc
<span class="linenr">2597: </span>      )
<span class="linenr">2598: </span>    }
<span class="linenr">2599: </span>  }
<span class="linenr">2600: </span>  
<span class="linenr">2601: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">processSlotOutlet</span>(
<span class="linenr">2602: </span>    <span class=
"org-variable-name">node</span>,
<span class="linenr">2603: </span>    context
<span class="linenr">2604: </span>  ) {
<span class="linenr">2605: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">slotName</span> = <span class=
"org-string">`"default"`</span>
<span class="linenr">2606: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">slotProps</span> = <span class=
"org-constant">undefined</span>
<span class="linenr">2607: </span>  
<span class="linenr">2608: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">nonNameProps</span> = [] <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">无名插槽</span>
<span class="linenr">2609: </span>    logg(<span class=
"org-string">`processSlotOutlet| props.length = ${node.props.length}`</span>)
<span class="linenr">2610: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; node.props.length; i++) {
<span class="linenr">2611: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">p</span> = node.props[i]
<span class="linenr">2612: </span>      logg(<span class=
"org-string">`processSlotOutlet| props[${i}]`</span>, p)
<span class="linenr">2613: </span>      <span class=
"org-keyword">if</span> (p.type === NodeTypes.ATTRIBUTE) { <span class="org-comment-delimiter">// </span><span class="org-comment">静态 &lt;slot name="xxx"/&gt;</span>
<span class="linenr">2614: </span>        <span class=
"org-keyword">if</span> (p.value) {
<span class="linenr">2615: </span>          <span class=
"org-keyword">if</span> (p.name === <span class=
"org-string">'name'</span>) {
<span class=
"linenr">2616: </span>            slotName = JSON.stringify(p.value.content)
<span class="linenr">2617: </span>          } <span class=
"org-keyword">else</span> {
<span class=
"linenr">2618: </span>            p.name = camelize(p.name)
<span class="linenr">2619: </span>            nonNameProps.push(p)
<span class="linenr">2620: </span>          }
<span class="linenr">2621: </span>        }
<span class="linenr">2622: </span>      } <span class=
"org-keyword">else</span> { <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">动态 &lt;slot :name="xxx"/&gt;</span>
<span class="linenr">2623: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">动态插槽 &lt;slot v-bind:name="slotName"/&gt;</span>
<span class="linenr">2624: </span>        <span class=
"org-keyword">if</span> (p.name === <span class=
"org-string">'bind'</span> &amp;& isStaticArgOf(p.arg, <span class=
"org-string">'name'</span>)) {
<span class="linenr">2625: </span>          <span class=
"org-keyword">if</span> (p.exp) slotName = p.exp
<span class="linenr">2626: </span>        } <span class=
"org-keyword">else</span> {
<span class="linenr">2627: </span>          <span class=
"org-keyword">if</span> (p.name === <span class=
"org-string">'bind'</span> &amp;& p.arg &amp;& isStaticExp(p.arg)) {
<span class=
"linenr">2628: </span>            p.arg.content = camelize(p.arg.content)
<span class="linenr">2629: </span>          }
<span class="linenr">2630: </span>          nonNameProps.push(p)
<span class="linenr">2631: </span>        }
<span class="linenr">2632: </span>      }
<span class="linenr">2633: </span>    }
<span class="linenr">2634: </span>  
<span class="linenr">2635: </span>    logg(<span class=
"org-string">`processSlotOutlet| nonNameProps.length=${nonNameProps.length}`</span>)
<span class="linenr">2636: </span>    <span class=
"org-keyword">if</span> (nonNameProps.length &gt; <span class=
"org-highlight-numbers-number">0</span>) {
<span class="linenr">2637: </span>      <span class=
"org-keyword">const</span> { props, directives } = buildProps(node, context, nonNameProps)
<span class="linenr">2638: </span>      slotProps = props
<span class="linenr">2639: </span>  
<span class="linenr">2640: </span>      <span class=
"org-keyword">if</span> (directives.length) {
<span class="linenr">2641: </span>        logg(<span class=
"org-string">'[ERROR] X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET'</span>)
<span class="linenr">2642: </span>      }
<span class="linenr">2643: </span>    }
<span class="linenr">2644: </span>  
<span class="linenr">2645: </span>    <span class=
"org-keyword">return</span> {
<span class="linenr">2646: </span>      slotName,
<span class="linenr">2647: </span>      slotProps
<span class="linenr">2648: </span>    }
<span class="linenr">2649: </span>  }
<span class="linenr">2650: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">Merge adjacent text nodes and expressions into a single expression</span>
<span class="linenr">2651: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">e.g. &lt;div&gt;abc {{ d }} {{ e }}&lt;/div&gt; should have a single expression node as child.</span>
<span class="linenr">2652: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">transformText</span> = (node, context) =&gt; {
<span class="linenr">2653: </span>    <span class=
"org-keyword">if</span> (
<span class=
"linenr">2654: </span>      node.type === NodeTypes.ROOT ||
<span class=
"linenr">2655: </span>      node.type === NodeTypes.ELEMENT ||
<span class=
"linenr">2656: </span>      node.type === NodeTypes.FOR ||
<span class=
"linenr">2657: </span>      node.type === NodeTypes.IF_BRANCH
<span class="linenr">2658: </span>    ) {
<span class="linenr">2659: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">perform the transform on node exit so that all expressions have already</span>
<span class="linenr">2660: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">been processed.</span>
<span class="linenr">2661: </span>      <span class=
"org-keyword">return</span> () =&gt; {
<span class="linenr">2662: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">children</span> = node.children
<span class="linenr">2663: </span>        <span class=
"org-keyword">let</span> <span class=
"org-variable-name">currentContainer</span> = <span class=
"org-constant">undefined</span>
<span class="linenr">2664: </span>        <span class=
"org-keyword">let</span> <span class=
"org-variable-name">hasText</span> = <span class=
"org-constant">false</span>
<span class="linenr">2665: </span>  
<span class="linenr">2666: </span>        <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; children.length; i++) {
<span class="linenr">2667: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">child</span> = children[i]
<span class="linenr">2668: </span>          <span class=
"org-keyword">if</span> (isText(child)) {
<span class=
"linenr">2669: </span>            hasText = <span class="org-constant">true</span>
<span class="linenr">2670: </span>            <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">j</span> = i + <span class=
"org-highlight-numbers-number">1</span>; j &lt; children.length; j++) {
<span class="linenr">2671: </span>              <span class=
"org-keyword">const</span> <span class=
"org-variable-name">next</span> = children[j]
<span class="linenr">2672: </span>              <span class=
"org-keyword">if</span> (isText(next)) {
<span class="linenr">2673: </span>                <span class=
"org-keyword">if</span> (!currentContainer) {
<span class=
"linenr">2674: </span>                  currentContainer = children[i] = {
<span class=
"linenr">2675: </span>                    type: NodeTypes.COMPOUND_EXPRESSION,
<span class=
"linenr">2676: </span>                    loc: child.loc,
<span class=
"linenr">2677: </span>                    children: [child]
<span class="linenr">2678: </span>                  }
<span class="linenr">2679: </span>                }
<span class="linenr">2680: </span>                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">merge adjacent text node into current</span>
<span class=
"linenr">2681: </span>                currentContainer.children.push(<span class="org-string">` + `</span>, next)
<span class=
"linenr">2682: </span>                children.splice(j, <span class="org-highlight-numbers-number">1</span>)
<span class="linenr">2683: </span>                j--
<span class="linenr">2684: </span>              } <span class=
"org-keyword">else</span> {
<span class=
"linenr">2685: </span>                currentContainer = <span class="org-constant">undefined</span>
<span class="linenr">2686: </span>                <span class=
"org-keyword">break</span>
<span class="linenr">2687: </span>              }
<span class="linenr">2688: </span>            }
<span class="linenr">2689: </span>          }
<span class="linenr">2690: </span>        }
<span class="linenr">2691: </span>  
<span class="linenr">2692: </span>        <span class=
"org-keyword">if</span> (
<span class="linenr">2693: </span>          !hasText ||
<span class="linenr">2694: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">if this is a plain element with a single text child, leave it</span>
<span class="linenr">2695: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">as-is since the runtime has dedicated fast path for this by directly</span>
<span class="linenr">2696: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">setting textContent of the element.</span>
<span class="linenr">2697: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">for component root it's always normalized anyway.</span>
<span class=
"linenr">2698: </span>          (children.length === <span class=
"org-highlight-numbers-number">1</span> &amp;&
<span class=
"linenr">2699: </span>            (node.type === NodeTypes.ROOT ||
<span class=
"linenr">2700: </span>              (node.type === NodeTypes.ELEMENT &amp;&
<span class=
"linenr">2701: </span>                node.tagType === ElementTypes.ELEMENT &amp;&
<span class="linenr">2702: </span>                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">#3756</span>
<span class="linenr">2703: </span>                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">custom directives can potentially add DOM elements arbitrarily,</span>
<span class="linenr">2704: </span>                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">we need to avoid setting textContent of the element at runtime</span>
<span class="linenr">2705: </span>                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">to avoid accidentally overwriting the DOM elements added</span>
<span class="linenr">2706: </span>                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">by the user through custom directives.</span>
<span class="linenr">2707: </span>                !node.props.find(
<span class="linenr">2708: </span>                  p =&gt;
<span class=
"linenr">2709: </span>                    p.type === NodeTypes.DIRECTIVE &amp;&
<span class=
"linenr">2710: </span>                    !context.directiveTransforms[p.name]
<span class="linenr">2711: </span>                ))))
<span class="linenr">2712: </span>        ) {
<span class="linenr">2713: </span>          <span class=
"org-keyword">return</span>
<span class="linenr">2714: </span>        }
<span class="linenr">2715: </span>  
<span class="linenr">2716: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">pre-convert text nodes into createTextVNode(text) calls to avoid</span>
<span class="linenr">2717: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">runtime normalization.</span>
<span class="linenr">2718: </span>        <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; children.length; i++) {
<span class="linenr">2719: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">child</span> = children[i]
<span class="linenr">2720: </span>          <span class=
"org-keyword">if</span> (isText(child) || child.type === NodeTypes.COMPOUND_EXPRESSION) {
<span class="linenr">2721: </span>            <span class=
"org-keyword">const</span> <span class=
"org-variable-name">callArgs</span> = []
<span class="linenr">2722: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">createTextVNode defaults to single whitespace, so if it is a</span>
<span class="linenr">2723: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">single space the code could be an empty call to save bytes.</span>
<span class="linenr">2724: </span>            <span class=
"org-keyword">if</span> (child.type !== NodeTypes.TEXT || child.content !== <span class="org-string">' '</span>) {
<span class=
"linenr">2725: </span>              callArgs.push(child)
<span class="linenr">2726: </span>            }
<span class="linenr">2727: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">mark dynamic text with flag so it gets patched inside a block</span>
<span class="linenr">2728: </span>            <span class=
"org-keyword">if</span> (
<span class="linenr">2729: </span>              !context.ssr &amp;&
<span class=
"linenr">2730: </span>              getConstantType(child, context) === ConstantTypes.NOT_CONSTANT
<span class="linenr">2731: </span>            ) {
<span class="linenr">2732: </span>              callArgs.push(
<span class="linenr">2733: </span>                PatchFlags.TEXT +
<span class=
"linenr">2734: </span>                  (__DEV__ ? <span class=
"org-string">` /* ${PatchFlagNames[PatchFlags.TEXT]} */`</span> : <span class="org-string">``</span>)
<span class="linenr">2735: </span>              )
<span class="linenr">2736: </span>            }
<span class="linenr">2737: </span>            children[i] = {
<span class=
"linenr">2738: </span>              type: NodeTypes.TEXT_CALL,
<span class="linenr">2739: </span>              content: child,
<span class="linenr">2740: </span>              loc: child.loc,
<span class=
"linenr">2741: </span>              codegenNode: createCallExpression(
<span class=
"linenr">2742: </span>                context.helper(CREATE_TEXT),
<span class="linenr">2743: </span>                callArgs
<span class="linenr">2744: </span>              )
<span class="linenr">2745: </span>            }
<span class="linenr">2746: </span>          }
<span class="linenr">2747: </span>        }
<span class="linenr">2748: </span>      }
<span class="linenr">2749: </span>    }
<span class="linenr">2750: </span>  }
<span class="linenr">2751: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">v-bind without arg is handled directly in ./transformElements.ts due to it affecting</span>
<span class="linenr">2752: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">codegen for the entire props object. This transform here is only for v-bind</span>
<span class="linenr">2753: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">*with* args.</span>
<span class="linenr">2754: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">transformBind</span> = (dir, _node, context) =&gt; {
<span class="linenr">2755: </span>    <span class=
"org-keyword">const</span> { exp, modifiers, loc } = dir
<span class="linenr">2756: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">arg</span> = dir.arg
<span class="linenr">2757: </span>  
<span class="linenr">2758: </span>    <span class=
"org-keyword">if</span> (arg.type !== NodeTypes.SIMPLE_EXPRESSION) {
<span class=
"linenr">2759: </span>      arg.children.unshift(<span class=
"org-string">`(`</span>)
<span class=
"linenr">2760: </span>      arg.children.push(<span class=
"org-string">`) || ""`</span>)
<span class="linenr">2761: </span>    } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (!arg.isStatic) {
<span class="linenr">2762: </span>      arg.content = <span class=
"org-string">`${arg.content} || ""`</span>
<span class="linenr">2763: </span>    }
<span class="linenr">2764: </span>  
<span class="linenr">2765: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">.sync is replaced by v-model:arg</span>
<span class="linenr">2766: </span>    <span class=
"org-keyword">if</span> (modifiers.includes(<span class=
"org-string">'camel'</span>)) {
<span class="linenr">2767: </span>      <span class=
"org-keyword">if</span> (arg.type === NodeTypes.SIMPLE_EXPRESSION) {
<span class="linenr">2768: </span>        <span class=
"org-keyword">if</span> (arg.isStatic) {
<span class=
"linenr">2769: </span>          arg.content = camelize(arg.content)
<span class="linenr">2770: </span>        } <span class=
"org-keyword">else</span> {
<span class=
"linenr">2771: </span>          arg.content = <span class=
"org-string">`${context.helperString(CAMELIZE)}(${arg.content})`</span>
<span class="linenr">2772: </span>        }
<span class="linenr">2773: </span>      } <span class=
"org-keyword">else</span> {
<span class=
"linenr">2774: </span>        arg.children.unshift(<span class=
"org-string">`${context.helperString(CAMELIZE)}(`</span>)
<span class=
"linenr">2775: </span>        arg.children.push(<span class=
"org-string">`)`</span>)
<span class="linenr">2776: </span>      }
<span class="linenr">2777: </span>    }
<span class="linenr">2778: </span>  
<span class="linenr">2779: </span>    <span class=
"org-keyword">if</span> (!context.inSSR) {
<span class="linenr">2780: </span>      <span class=
"org-keyword">if</span> (modifiers.includes(<span class=
"org-string">'prop'</span>)) {
<span class=
"linenr">2781: </span>        injectPrefix(arg, <span class=
"org-string">'.'</span>)
<span class="linenr">2782: </span>      }
<span class="linenr">2783: </span>      <span class=
"org-keyword">if</span> (modifiers.includes(<span class=
"org-string">'attr'</span>)) {
<span class=
"linenr">2784: </span>        injectPrefix(arg, <span class=
"org-string">'^'</span>)
<span class="linenr">2785: </span>      }
<span class="linenr">2786: </span>    }
<span class="linenr">2787: </span>  
<span class="linenr">2788: </span>    <span class=
"org-keyword">if</span> (
<span class="linenr">2789: </span>      !exp ||
<span class=
"linenr">2790: </span>      (exp.type === NodeTypes.SIMPLE_EXPRESSION &amp;& !exp.content.trim())
<span class="linenr">2791: </span>    ) {
<span class="linenr">2792: </span>      logg(<span class=
"org-string">`transformBind v-bind no expression`</span>)
<span class="linenr">2793: </span>      <span class=
"org-keyword">return</span> {
<span class=
"linenr">2794: </span>        props: [createObjectProperty(arg, createSimpleExpression(<span class="org-string">''</span>, <span class="org-constant">true</span>, loc))]
<span class="linenr">2795: </span>      }
<span class="linenr">2796: </span>    }
<span class="linenr">2797: </span>  
<span class="linenr">2798: </span>    <span class=
"org-keyword">return</span> {
<span class=
"linenr">2799: </span>      props: [createObjectProperty(arg, exp)]
<span class="linenr">2800: </span>    }
<span class="linenr">2801: </span>  }
<span class="linenr">2802: </span>  
<span class="linenr">2803: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">injectPrefix</span> = (arg, prefix) =&gt; {
<span class="linenr">2804: </span>    <span class=
"org-keyword">if</span> (arg.type === NodeTypes.SIMPLE_EXPRESSION) {
<span class="linenr">2805: </span>      <span class=
"org-keyword">if</span> (arg.isStatic) {
<span class=
"linenr">2806: </span>        arg.content = prefix + arg.content
<span class="linenr">2807: </span>      } <span class=
"org-keyword">else</span> {
<span class=
"linenr">2808: </span>        arg.content = <span class="org-string">`\`${prefix}\${${arg.content}}\``</span>
<span class="linenr">2809: </span>      }
<span class="linenr">2810: </span>    } <span class=
"org-keyword">else</span> {
<span class=
"linenr">2811: </span>      arg.children.unshift(<span class=
"org-string">`'${prefix}' + (`</span>)
<span class=
"linenr">2812: </span>      arg.children.push(<span class=
"org-string">`)`</span>)
<span class="linenr">2813: </span>    }
<span class="linenr">2814: </span>  }
<span class="linenr">2815: </span>  
<span class="linenr">2816: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">transformFor</span> = createStructuralDirectiveTransform(
<span class="linenr">2817: </span>    <span class=
"org-string">'for'</span>,
<span class="linenr">2818: </span>    (node, dir, context) =&gt; {
<span class="linenr">2819: </span>      <span class=
"org-keyword">const</span> { helper, removeHelper } = context
<span class="linenr">2820: </span>      <span class=
"org-keyword">return</span> processFor(node, dir, context, forNode =&gt; {
<span class="linenr">2821: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">create the loop render function expression now, and add the</span>
<span class="linenr">2822: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">iterator on exit after all children have been traversed</span>
<span class="linenr">2823: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">renderExp</span> = createCallExpression(helper(RENDER_LIST), [
<span class="linenr">2824: </span>          forNode.source
<span class="linenr">2825: </span>        ])
<span class="linenr">2826: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isTemplate</span> = isTemplateNode(node)
<span class="linenr">2827: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">memo</span> = findDir(node, <span class=
"org-string">'memo'</span>)
<span class="linenr">2828: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">keyProp</span> = findProp(node, <span class=
"org-string">`key`</span>)
<span class="linenr">2829: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">keyExp</span> =
<span class="linenr">2830: </span>          keyProp &amp;&
<span class=
"linenr">2831: </span>          (keyProp.type === NodeTypes.ATTRIBUTE
<span class=
"linenr">2832: </span>            ? createSimpleExpression(keyProp.value.content, <span class="org-constant">true</span>)
<span class="linenr">2833: </span>            : keyProp.exp)
<span class="linenr">2834: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">keyProperty</span> = keyProp ? createObjectProperty(<span class="org-string">`key`</span>, keyExp) : <span class="org-constant">null</span>
<span class="linenr">2835: </span>  
<span class="linenr">2836: </span>        <span class=
"org-keyword">if</span> (!__BROWSER__ &amp;& isTemplate) {
<span class="linenr">2837: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">#2085 / #5288 process :key and v-memo expressions need to be</span>
<span class="linenr">2838: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">processed on `&lt;template v-for&gt;`. In this case the node is discarded</span>
<span class="linenr">2839: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">and never traversed so its binding expressions won't be processed</span>
<span class="linenr">2840: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">by the normal transforms.</span>
<span class="linenr">2841: </span>          <span class=
"org-keyword">if</span> (memo) {
<span class=
"linenr">2842: </span>            memo.exp = processExpression(
<span class="linenr">2843: </span>              memo.exp ,
<span class="linenr">2844: </span>              context
<span class="linenr">2845: </span>            )
<span class="linenr">2846: </span>          }
<span class="linenr">2847: </span>          <span class=
"org-keyword">if</span> (keyProperty &amp;& keyProp.type !== NodeTypes.ATTRIBUTE) {
<span class=
"linenr">2848: </span>            keyProperty.value = processExpression(
<span class="linenr">2849: </span>              keyProperty.value ,
<span class="linenr">2850: </span>              context
<span class="linenr">2851: </span>            )
<span class="linenr">2852: </span>          }
<span class="linenr">2853: </span>        }
<span class="linenr">2854: </span>  
<span class="linenr">2855: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isStableFragment</span> =
<span class=
"linenr">2856: </span>          forNode.source.type === NodeTypes.SIMPLE_EXPRESSION &amp;&
<span class=
"linenr">2857: </span>          forNode.source.constType &gt; ConstantTypes.NOT_CONSTANT
<span class="linenr">2858: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">fragmentFlag</span> = isStableFragment
<span class=
"linenr">2859: </span>          ? PatchFlags.STABLE_FRAGMENT
<span class="linenr">2860: </span>          : keyProp
<span class=
"linenr">2861: </span>          ? PatchFlags.KEYED_FRAGMENT
<span class=
"linenr">2862: </span>          : PatchFlags.UNKEYED_FRAGMENT
<span class="linenr">2863: </span>  
<span class=
"linenr">2864: </span>        forNode.codegenNode = createVNodeCall(
<span class="linenr">2865: </span>          context,
<span class="linenr">2866: </span>          helper(FRAGMENT),
<span class="linenr">2867: </span>          <span class=
"org-constant">undefined</span>,
<span class="linenr">2868: </span>          renderExp,
<span class="linenr">2869: </span>          fragmentFlag +
<span class=
"linenr">2870: </span>            (__DEV__ ? <span class=
"org-string">` /* ${PatchFlagNames[fragmentFlag]} */`</span> : <span class="org-string">``</span>),
<span class="linenr">2871: </span>          <span class=
"org-constant">undefined</span>,
<span class="linenr">2872: </span>          <span class=
"org-constant">undefined</span>,
<span class="linenr">2873: </span>          <span class=
"org-constant">true</span> <span class=
"org-comment-delimiter">/* </span><span class=
"org-comment">isBlock</span><span class=
"org-comment-delimiter"> */</span>,
<span class=
"linenr">2874: </span>          !isStableFragment <span class=
"org-comment-delimiter">/* </span><span class=
"org-comment">disableTracking</span><span class=
"org-comment-delimiter"> */</span>,
<span class="linenr">2875: </span>          <span class=
"org-constant">false</span> <span class=
"org-comment-delimiter">/* </span><span class=
"org-comment">isComponent</span><span class=
"org-comment-delimiter"> */</span>,
<span class="linenr">2876: </span>          node.loc
<span class="linenr">2877: </span>        )
<span class="linenr">2878: </span>  
<span class="linenr">2879: </span>        <span class=
"org-keyword">return</span> () =&gt; {
<span class="linenr">2880: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">finish the codegen now that all children have been traversed</span>
<span class="linenr">2881: </span>          <span class=
"org-keyword">let</span> <span class=
"org-variable-name">childBlock</span>
<span class="linenr">2882: </span>          <span class=
"org-keyword">const</span> { children } = forNode
<span class="linenr">2883: </span>  
<span class="linenr">2884: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">check &lt;template v-for&gt; key placement</span>
<span class="linenr">2885: </span>          <span class=
"org-keyword">if</span> ((__DEV__ || !__BROWSER__) &amp;& isTemplate) {
<span class=
"linenr">2886: </span>            node.children.some(c =&gt; {
<span class="linenr">2887: </span>              <span class=
"org-keyword">if</span> (c.type === NodeTypes.ELEMENT) {
<span class="linenr">2888: </span>                <span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> = findProp(c, <span class=
"org-string">'key'</span>)
<span class="linenr">2889: </span>                <span class=
"org-keyword">if</span> (key) {
<span class=
"linenr">2890: </span>                  logg(<span class=
"org-string">`transformFor - key on template`</span>)
<span class="linenr">2891: </span>                  <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr">2892: </span>                }
<span class="linenr">2893: </span>              }
<span class="linenr">2894: </span>            })
<span class="linenr">2895: </span>          }
<span class="linenr">2896: </span>  
<span class="linenr">2897: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">needFragmentWrapper</span> =
<span class=
"linenr">2898: </span>            children.length !== <span class=
"org-highlight-numbers-number">1</span> || children[<span class=
"org-highlight-numbers-number">0</span>].type !== NodeTypes.ELEMENT
<span class="linenr">2899: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">slotOutlet</span> = isSlotOutlet(node)
<span class="linenr">2900: </span>            ? node
<span class="linenr">2901: </span>            : isTemplate &amp;&
<span class=
"linenr">2902: </span>              node.children.length === <span class="org-highlight-numbers-number">1</span> &amp;&
<span class=
"linenr">2903: </span>              isSlotOutlet(node.children[<span class="org-highlight-numbers-number">0</span>])
<span class=
"linenr">2904: </span>            ? node.children[<span class=
"org-highlight-numbers-number">0</span>] <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">api-extractor somehow fails to infer this</span>
<span class="linenr">2905: </span>            : <span class=
"org-constant">null</span>
<span class="linenr">2906: </span>  
<span class="linenr">2907: </span>          <span class=
"org-keyword">if</span> (slotOutlet) {
<span class="linenr">2908: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">&lt;slot v-for="..."&gt; or &lt;template v-for="..."&gt;&lt;slot/&gt;&lt;/template&gt;</span>
<span class=
"linenr">2909: </span>            childBlock = slotOutlet.codegenNode
<span class="linenr">2910: </span>            <span class=
"org-keyword">if</span> (isTemplate &amp;& keyProperty) {
<span class="linenr">2911: </span>              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">&lt;template v-for="..." :key="..."&gt;&lt;slot/&gt;&lt;/template&gt;</span>
<span class="linenr">2912: </span>              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">we need to inject the key to the renderSlot() call.</span>
<span class="linenr">2913: </span>              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">the props for renderSlot is passed as the 3rd argument.</span>
<span class=
"linenr">2914: </span>              injectProp(childBlock, keyProperty, context)
<span class="linenr">2915: </span>            }
<span class="linenr">2916: </span>          } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (needFragmentWrapper) {
<span class="linenr">2917: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">&lt;template v-for="..."&gt; with text or multi-elements</span>
<span class="linenr">2918: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">should generate a fragment block for each loop</span>
<span class=
"linenr">2919: </span>            childBlock = createVNodeCall(
<span class="linenr">2920: </span>              context,
<span class="linenr">2921: </span>              helper(FRAGMENT),
<span class=
"linenr">2922: </span>              keyProperty ? createObjectExpression([keyProperty]) : <span class="org-constant">undefined</span>,
<span class="linenr">2923: </span>              node.children,
<span class=
"linenr">2924: </span>              PatchFlags.STABLE_FRAGMENT +
<span class="linenr">2925: </span>                (__DEV__
<span class="linenr">2926: </span>                  ? <span class=
"org-string">` /* ${PatchFlagNames[PatchFlags.STABLE_FRAGMENT]} */`</span>
<span class="linenr">2927: </span>                  : <span class=
"org-string">``</span>),
<span class="linenr">2928: </span>              <span class=
"org-constant">undefined</span>,
<span class="linenr">2929: </span>              <span class=
"org-constant">undefined</span>,
<span class="linenr">2930: </span>              <span class=
"org-constant">true</span>,
<span class="linenr">2931: </span>              <span class=
"org-constant">undefined</span>,
<span class="linenr">2932: </span>              <span class=
"org-constant">false</span> <span class=
"org-comment-delimiter">/* </span><span class=
"org-comment">isComponent</span><span class=
"org-comment-delimiter"> */</span>
<span class="linenr">2933: </span>            )
<span class="linenr">2934: </span>          } <span class=
"org-keyword">else</span> {
<span class="linenr">2935: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">Normal element v-for. Directly use the child's codegenNode</span>
<span class="linenr">2936: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">but mark it as a block.</span>
<span class=
"linenr">2937: </span>            childBlock = children[<span class="org-highlight-numbers-number">0</span>].codegenNode
<span class="linenr">2938: </span>            <span class=
"org-keyword">if</span> (isTemplate &amp;& keyProperty) {
<span class=
"linenr">2939: </span>              injectProp(childBlock, keyProperty, context)
<span class="linenr">2940: </span>            }
<span class="linenr">2941: </span>            <span class=
"org-keyword">if</span> (childBlock.isBlock !== !isStableFragment) {
<span class="linenr">2942: </span>              <span class=
"org-keyword">if</span> (childBlock.isBlock) {
<span class="linenr">2943: </span>                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">switch from block to vnode</span>
<span class=
"linenr">2944: </span>                removeHelper(OPEN_BLOCK)
<span class="linenr">2945: </span>                removeHelper(
<span class=
"linenr">2946: </span>                  getVNodeBlockHelper(context.inSSR, childBlock.isComponent)
<span class="linenr">2947: </span>                )
<span class="linenr">2948: </span>              } <span class=
"org-keyword">else</span> {
<span class="linenr">2949: </span>                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">switch from vnode to block</span>
<span class="linenr">2950: </span>                removeHelper(
<span class=
"linenr">2951: </span>                  getVNodeHelper(context.inSSR, childBlock.isComponent)
<span class="linenr">2952: </span>                )
<span class="linenr">2953: </span>              }
<span class="linenr">2954: </span>            }
<span class=
"linenr">2955: </span>            childBlock.isBlock = !isStableFragment
<span class="linenr">2956: </span>            <span class=
"org-keyword">if</span> (childBlock.isBlock) {
<span class="linenr">2957: </span>              helper(OPEN_BLOCK)
<span class=
"linenr">2958: </span>              helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent))
<span class="linenr">2959: </span>            } <span class=
"org-keyword">else</span> {
<span class=
"linenr">2960: </span>              helper(getVNodeHelper(context.inSSR, childBlock.isComponent))
<span class="linenr">2961: </span>            }
<span class="linenr">2962: </span>          }
<span class="linenr">2963: </span>  
<span class="linenr">2964: </span>          <span class=
"org-keyword">if</span> (memo) {
<span class="linenr">2965: </span>            <span class=
"org-keyword">const</span> <span class=
"org-variable-name">loop</span> = createFunctionExpression(
<span class=
"linenr">2966: </span>              createForLoopParams(forNode.parseResult, [
<span class=
"linenr">2967: </span>                createSimpleExpression(<span class="org-string">`_cached`</span>)
<span class="linenr">2968: </span>              ])
<span class="linenr">2969: </span>            )
<span class=
"linenr">2970: </span>            loop.body = createBlockStatement([
<span class=
"linenr">2971: </span>              createCompoundExpression([<span class="org-string">`const _memo = (`</span>, memo.exp, <span class="org-string">`)`</span>]),
<span class=
"linenr">2972: </span>              createCompoundExpression([
<span class="linenr">2973: </span>                <span class=
"org-string">`if (_cached`</span>,
<span class=
"linenr">2974: </span>                ...(keyExp ? [<span class=
"org-string">` &amp;& _cached.key === `</span>, keyExp] : []),
<span class="linenr">2975: </span>                <span class=
"org-string">` &amp;& ${context.helperString(</span>
<span class="linenr">2976: </span><span class=
"org-string">                  IS_MEMO_SAME</span>
<span class="linenr">2977: </span><span class=
"org-string">                )}(_cached, _memo)) return _cached`</span>
<span class="linenr">2978: </span>              ]),
<span class=
"linenr">2979: </span>              createCompoundExpression([<span class="org-string">`const _item = `</span>, childBlock]),
<span class=
"linenr">2980: </span>              createSimpleExpression(<span class="org-string">`_item.memo = _memo`</span>),
<span class=
"linenr">2981: </span>              createSimpleExpression(<span class="org-string">`return _item`</span>)
<span class="linenr">2982: </span>            ])
<span class=
"linenr">2983: </span>            renderExp.<span class="org-constant">arguments</span>.push(
<span class="linenr">2984: </span>              loop,
<span class=
"linenr">2985: </span>              createSimpleExpression(<span class="org-string">`_cache`</span>),
<span class=
"linenr">2986: </span>              createSimpleExpression(String(context.cached++))
<span class="linenr">2987: </span>            )
<span class="linenr">2988: </span>          } <span class=
"org-keyword">else</span> {
<span class=
"linenr">2989: </span>            renderExp.<span class="org-constant">arguments</span>.push(
<span class=
"linenr">2990: </span>              createFunctionExpression(
<span class=
"linenr">2991: </span>                createForLoopParams(forNode.parseResult),
<span class="linenr">2992: </span>                childBlock,
<span class="linenr">2993: </span>                <span class=
"org-constant">true</span> <span class=
"org-comment-delimiter">/* </span><span class=
"org-comment">force newline</span><span class=
"org-comment-delimiter"> */</span>
<span class="linenr">2994: </span>              )
<span class="linenr">2995: </span>            )
<span class="linenr">2996: </span>          }
<span class="linenr">2997: </span>        }
<span class="linenr">2998: </span>      })
<span class="linenr">2999: </span>    }
<span class="linenr">3000: </span>  )
<span class="linenr">3001: </span>  
<span class="linenr">3002: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">target-agnostic transform used for both Client and SSR</span>
<span class="linenr">3003: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">processFor</span>(
<span class="linenr">3004: </span>    <span class=
"org-variable-name">node</span>,
<span class="linenr">3005: </span>    <span class=
"org-variable-name">dir</span>,
<span class="linenr">3006: </span>    <span class=
"org-variable-name">context</span>,
<span class="linenr">3007: </span>    processCodegen
<span class="linenr">3008: </span>  ) {
<span class="linenr">3009: </span>    <span class=
"org-keyword">if</span> (!dir.exp) {
<span class="linenr">3010: </span>      logg(<span class=
"org-string">`processFor - dir.exp is null`</span>)
<span class="linenr">3011: </span>      <span class=
"org-keyword">return</span>
<span class="linenr">3012: </span>    }
<span class="linenr">3013: </span>  
<span class="linenr">3014: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">parseResult</span> = parseForExpression(
<span class="linenr">3015: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">can only be simple expression because vFor transform is applied</span>
<span class="linenr">3016: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">before expression transform.</span>
<span class="linenr">3017: </span>      dir.exp,
<span class="linenr">3018: </span>      context
<span class="linenr">3019: </span>    )
<span class="linenr">3020: </span>  
<span class="linenr">3021: </span>    <span class=
"org-keyword">if</span> (!parseResult) {
<span class="linenr">3022: </span>      logg(<span class=
"org-string">`processFor - parseResult is null`</span>)
<span class="linenr">3023: </span>      <span class=
"org-keyword">return</span>
<span class="linenr">3024: </span>    }
<span class="linenr">3025: </span>  
<span class="linenr">3026: </span>    <span class=
"org-keyword">const</span> { addIdentifiers, removeIdentifiers, scopes } = context
<span class="linenr">3027: </span>    <span class=
"org-keyword">const</span> { source, value, key, index } = parseResult
<span class="linenr">3028: </span>  
<span class="linenr">3029: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">forNode</span> = {
<span class="linenr">3030: </span>      type: NodeTypes.FOR,
<span class="linenr">3031: </span>      loc: dir.loc,
<span class="linenr">3032: </span>      source,
<span class="linenr">3033: </span>      valueAlias: value,
<span class="linenr">3034: </span>      keyAlias: key,
<span class="linenr">3035: </span>      objectIndexAlias: index,
<span class="linenr">3036: </span>      parseResult,
<span class=
"linenr">3037: </span>      children: isTemplateNode(node) ? node.children : [node]
<span class="linenr">3038: </span>    }
<span class="linenr">3039: </span>  
<span class="linenr">3040: </span>    context.replaceNode(forNode)
<span class="linenr">3041: </span>  
<span class="linenr">3042: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">bookkeeping</span>
<span class="linenr">3043: </span>    scopes.vFor++
<span class="linenr">3044: </span>    <span class=
"org-keyword">if</span> (!__BROWSER__ &amp;& context.prefixIdentifiers) {
<span class="linenr">3045: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">scope management</span>
<span class="linenr">3046: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">inject identifiers to context</span>
<span class=
"linenr">3047: </span>      value &amp;& addIdentifiers(value)
<span class=
"linenr">3048: </span>      key &amp;& addIdentifiers(key)
<span class=
"linenr">3049: </span>      index &amp;& addIdentifiers(index)
<span class="linenr">3050: </span>    }
<span class="linenr">3051: </span>  
<span class="linenr">3052: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">onExit</span> = processCodegen &amp;& processCodegen(forNode)
<span class="linenr">3053: </span>  
<span class="linenr">3054: </span>    <span class=
"org-keyword">return</span> () =&gt; {
<span class="linenr">3055: </span>      scopes.vFor--
<span class="linenr">3056: </span>      <span class=
"org-keyword">if</span> (!__BROWSER__ &amp;& context.prefixIdentifiers) {
<span class=
"linenr">3057: </span>        value &amp;& removeIdentifiers(value)
<span class=
"linenr">3058: </span>        key &amp;& removeIdentifiers(key)
<span class=
"linenr">3059: </span>        index &amp;& removeIdentifiers(index)
<span class="linenr">3060: </span>      }
<span class="linenr">3061: </span>      <span class=
"org-keyword">if</span> (onExit) onExit()
<span class="linenr">3062: </span>    }
<span class="linenr">3063: </span>  }
<span class="linenr">3064: </span>  
<span class="linenr">3065: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">forAliasRE</span> = <span class=
"org-string">/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/</span>
<span class="linenr">3066: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">This regex doesn't cover the case if key or index aliases have destructuring,</span>
<span class="linenr">3067: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">but those do not make sense in the first place, so this works in practice.</span>
<span class="linenr">3068: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">forIteratorRE</span> = <span class=
"org-string">/,([^,\}\]]*)(?:,([^,\}\]]*))?$/</span>
<span class="linenr">3069: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">stripParensRE</span> = <span class=
"org-string">/^\(|\)$/</span>g
<span class="linenr">3070: </span>  
<span class="linenr">3071: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">parseForExpression</span>(
<span class="linenr">3072: </span>    <span class=
"org-variable-name">input</span>,
<span class="linenr">3073: </span>    context
<span class="linenr">3074: </span>  ) {
<span class="linenr">3075: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">loc</span> = input.loc
<span class="linenr">3076: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">exp</span> = input.content
<span class="linenr">3077: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">inMatch</span> = exp.match(forAliasRE)
<span class="linenr">3078: </span>    <span class=
"org-keyword">if</span> (!inMatch) <span class=
"org-keyword">return</span>
<span class="linenr">3079: </span>  
<span class="linenr">3080: </span>    <span class=
"org-keyword">const</span> [, <span class=
"org-variable-name">LHS</span>, <span class=
"org-variable-name">RHS</span>] = inMatch
<span class="linenr">3081: </span>  
<span class="linenr">3082: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">result</span> = {
<span class=
"linenr">3083: </span>      source: createAliasExpression(
<span class="linenr">3084: </span>        loc,
<span class="linenr">3085: </span>        RHS.trim(),
<span class=
"linenr">3086: </span>        exp.indexOf(RHS, LHS.length)
<span class="linenr">3087: </span>      ),
<span class="linenr">3088: </span>      value: <span class=
"org-constant">undefined</span>,
<span class="linenr">3089: </span>      key: <span class=
"org-constant">undefined</span>,
<span class="linenr">3090: </span>      index: <span class=
"org-constant">undefined</span>
<span class="linenr">3091: </span>    }
<span class="linenr">3092: </span>    <span class=
"org-keyword">if</span> (!__BROWSER__ &amp;& context.prefixIdentifiers) {
<span class=
"linenr">3093: </span>      result.source = processExpression(
<span class="linenr">3094: </span>        result.source,
<span class="linenr">3095: </span>        context
<span class="linenr">3096: </span>      )
<span class="linenr">3097: </span>    }
<span class="linenr">3098: </span>  
<span class="linenr">3099: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">valueContent</span> = LHS.trim().replace(stripParensRE, <span class="org-string">''</span>).trim()
<span class="linenr">3100: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">trimmedOffset</span> = LHS.indexOf(valueContent)
<span class="linenr">3101: </span>  
<span class="linenr">3102: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">iteratorMatch</span> = valueContent.match(forIteratorRE)
<span class="linenr">3103: </span>    <span class=
"org-keyword">if</span> (iteratorMatch) {
<span class=
"linenr">3104: </span>      valueContent = valueContent.replace(forIteratorRE, <span class="org-string">''</span>).trim()
<span class="linenr">3105: </span>  
<span class="linenr">3106: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">keyContent</span> = iteratorMatch[<span class=
"org-highlight-numbers-number">1</span>].trim()
<span class="linenr">3107: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">keyOffset</span>
<span class="linenr">3108: </span>      <span class=
"org-keyword">if</span> (keyContent) {
<span class=
"linenr">3109: </span>        keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length)
<span class=
"linenr">3110: </span>        result.key = createAliasExpression(loc, keyContent, keyOffset)
<span class="linenr">3111: </span>        <span class=
"org-keyword">if</span> (!__BROWSER__ &amp;& context.prefixIdentifiers) {
<span class=
"linenr">3112: </span>          result.key = processExpression(result.key, context, <span class="org-constant">true</span>)
<span class="linenr">3113: </span>        }
<span class="linenr">3114: </span>      }
<span class="linenr">3115: </span>  
<span class="linenr">3116: </span>      <span class=
"org-keyword">if</span> (iteratorMatch[<span class=
"org-highlight-numbers-number">2</span>]) {
<span class="linenr">3117: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">indexContent</span> = iteratorMatch[<span class="org-highlight-numbers-number">2</span>].trim()
<span class="linenr">3118: </span>  
<span class="linenr">3119: </span>        <span class=
"org-keyword">if</span> (indexContent) {
<span class=
"linenr">3120: </span>          result.index = createAliasExpression(
<span class="linenr">3121: </span>            loc,
<span class="linenr">3122: </span>            indexContent,
<span class="linenr">3123: </span>            exp.indexOf(
<span class="linenr">3124: </span>              indexContent,
<span class="linenr">3125: </span>              result.key
<span class=
"linenr">3126: </span>                ? keyOffset + keyContent.length
<span class=
"linenr">3127: </span>                : trimmedOffset + valueContent.length
<span class="linenr">3128: </span>            )
<span class="linenr">3129: </span>          )
<span class="linenr">3130: </span>          <span class=
"org-keyword">if</span> (!__BROWSER__ &amp;& context.prefixIdentifiers) {
<span class=
"linenr">3131: </span>            result.index = processExpression(result.index, context, <span class="org-constant">true</span>)
<span class="linenr">3132: </span>          }
<span class="linenr">3133: </span>        }
<span class="linenr">3134: </span>      }
<span class="linenr">3135: </span>    }
<span class="linenr">3136: </span>  
<span class="linenr">3137: </span>    <span class=
"org-keyword">if</span> (valueContent) {
<span class=
"linenr">3138: </span>      result.value = createAliasExpression(loc, valueContent, trimmedOffset)
<span class="linenr">3139: </span>      <span class=
"org-keyword">if</span> (!__BROWSER__ &amp;& context.prefixIdentifiers) {
<span class=
"linenr">3140: </span>        result.value = processExpression(result.value, context, <span class="org-constant">true</span>)
<span class="linenr">3141: </span>      }
<span class="linenr">3142: </span>    }
<span class="linenr">3143: </span>  
<span class="linenr">3144: </span>    <span class=
"org-keyword">return</span> result
<span class="linenr">3145: </span>  }
<span class="linenr">3146: </span>  
<span class="linenr">3147: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">createAliasExpression</span>(
<span class="linenr">3148: </span>    <span class=
"org-variable-name">range</span>,
<span class="linenr">3149: </span>    <span class=
"org-variable-name">content</span>,
<span class="linenr">3150: </span>    offset
<span class="linenr">3151: </span>  ) {
<span class="linenr">3152: </span>    <span class=
"org-keyword">return</span> createSimpleExpression(
<span class="linenr">3153: </span>      content,
<span class="linenr">3154: </span>      <span class=
"org-constant">false</span>,
<span class=
"linenr">3155: </span>      getInnerRange(range, offset, content.length)
<span class="linenr">3156: </span>    )
<span class="linenr">3157: </span>  }
<span class="linenr">3158: </span>  
<span class="linenr">3159: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">createForLoopParams</span>(
<span class="linenr">3160: </span>    { value, key, index },
<span class="linenr">3161: </span>    memoArgs = []
<span class="linenr">3162: </span>  ) {
<span class="linenr">3163: </span>    <span class=
"org-keyword">return</span> createParamsList([value, key, index, ...memoArgs])
<span class="linenr">3164: </span>  }
<span class="linenr">3165: </span>  
<span class="linenr">3166: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">createParamsList</span>(<span class=
"org-variable-name">args</span>) {
<span class="linenr">3167: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = args.length
<span class="linenr">3168: </span>    <span class=
"org-keyword">while</span> (i--) {
<span class="linenr">3169: </span>      <span class=
"org-keyword">if</span> (args[i]) <span class=
"org-keyword">break</span>
<span class="linenr">3170: </span>    }
<span class="linenr">3171: </span>    <span class=
"org-keyword">return</span> args
<span class="linenr">3172: </span>      .slice(<span class=
"org-highlight-numbers-number">0</span>, i + <span class=
"org-highlight-numbers-number">1</span>)
<span class=
"linenr">3173: </span>      .map((arg, i) =&gt; arg || createSimpleExpression(<span class="org-string">`_`</span>.repeat(i + <span class="org-highlight-numbers-number">1</span>), <span class="org-constant">false</span>))
<span class="linenr">3174: </span>  }
<span class="linenr">3175: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">processIf</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">dir</span>, <span class=
"org-variable-name">context</span>, <span class=
"org-variable-name">processCodegen</span>) {
<span class="linenr">3176: </span>    logg(<span class=
"org-string">'processIf - node - dir'</span>, node, dir)
<span class="linenr">3177: </span>    <span class=
"org-keyword">if</span> (
<span class="linenr">3178: </span>      dir.name !== <span class=
"org-string">'else'</span> &amp;&
<span class=
"linenr">3179: </span>      (!dir.exp || !dir.exp.content.trim())
<span class="linenr">3180: </span>    ) {
<span class="linenr">3181: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">loc</span> = dir.exp ? dir.exp.loc : node.loc
<span class="linenr">3182: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">&lt;div v-if&gt;&lt;/div&gt; 没有指令值的情况，默认值为 true</span>
<span class=
"linenr">3183: </span>      dir.exp = createSimpleExpression(<span class="org-string">`true`</span>, <span class="org-constant">false</span>, loc)
<span class="linenr">3184: </span>    }
<span class="linenr">3185: </span>  
<span class="linenr">3186: </span>    <span class=
"org-keyword">if</span> (!__BROWSER__ &amp;& context.prefixIdentifiers &amp;& dir.exp) {
<span class="linenr">3187: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">dir.exp can only be simple expression because vIf transform is applied</span>
<span class="linenr">3188: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">before expression transform.</span>
<span class=
"linenr">3189: </span>      dir.exp = processExpression(dir.exp, context)
<span class="linenr">3190: </span>    }
<span class="linenr">3191: </span>  
<span class="linenr">3192: </span>    <span class=
"org-keyword">if</span> (dir.name === <span class=
"org-string">'if'</span>) { <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">v-if</span>
<span class="linenr">3193: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">branch</span> = createIfBranch(node, dir)
<span class="linenr">3194: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">ifNode</span> = {
<span class="linenr">3195: </span>        type: NodeTypes.IF,
<span class="linenr">3196: </span>        loc: node.loc,
<span class="linenr">3197: </span>        branches: [branch]
<span class="linenr">3198: </span>      }
<span class="linenr">3199: </span>      context.replaceNode(ifNode)
<span class="linenr">3200: </span>      <span class=
"org-keyword">if</span> (processCodegen) {
<span class="linenr">3201: </span>        <span class=
"org-keyword">return</span> processCodegen(ifNode, branch, <span class="org-constant">true</span>)
<span class="linenr">3202: </span>      }
<span class="linenr">3203: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr">3204: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">locate the adjacent v-if</span>
<span class="linenr">3205: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">siblings</span> = context.parent.children
<span class="linenr">3206: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">comments</span> = []
<span class="linenr">3207: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = siblings.indexOf(node)
<span class="linenr">3208: </span>      <span class=
"org-keyword">while</span> (i-- &gt;= -<span class=
"org-highlight-numbers-number">1</span>) {
<span class="linenr">3209: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">sibling</span> = siblings[i]
<span class="linenr">3210: </span>  
<span class="linenr">3211: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">空行，空文本</span>
<span class="linenr">3212: </span>        <span class=
"org-keyword">if</span> (
<span class="linenr">3213: </span>          sibling &amp;&
<span class=
"linenr">3214: </span>          sibling.type === NodeTypes.TEXT &amp;&
<span class=
"linenr">3215: </span>          !sibling.content.trim().length
<span class="linenr">3216: </span>        ) {
<span class=
"linenr">3217: </span>          context.removeNode(sibling)
<span class="linenr">3218: </span>          <span class=
"org-keyword">continue</span>
<span class="linenr">3219: </span>        }
<span class="linenr">3220: </span>  
<span class="linenr">3221: </span>        <span class=
"org-keyword">if</span> (sibling &amp;& sibling.type === NodeTypes.IF) {
<span class="linenr">3222: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">这里会将原本的结点删除，而是用新组装的 if 结构(包含else-if, else 分支的结构，node.branches[...])</span>
<span class="linenr">3223: </span>          context.removeNode()
<span class="linenr">3224: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">branch</span> = createIfBranch(node, dir)
<span class=
"linenr">3225: </span>          sibling.branches.push(branch)
<span class="linenr">3226: </span>  
<span class="linenr">3227: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">onExit</span> = processCodegen &amp;& processCodegen(sibling, branch, <span class="org-constant">false</span>)
<span class="linenr">3228: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">这里需要手动触发一次遍历，因为上面将原本的分支节点从原来的节点树中删除了</span>
<span class=
"linenr">3229: </span>          traverseNode(branch, context)
<span class="linenr">3230: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">回溯结束后执行收集到的 transformXxx 函数</span>
<span class="linenr">3231: </span>          <span class=
"org-keyword">if</span> (onExit) onExit()
<span class="linenr">3232: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">make sure to reset currentNode after traversal to indicate this</span>
<span class="linenr">3233: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">node has been removed.</span>
<span class=
"linenr">3234: </span>          context.currentNode = <span class=
"org-constant">null</span>
<span class="linenr">3235: </span>        }
<span class="linenr">3236: </span>        <span class=
"org-keyword">break</span>
<span class="linenr">3237: </span>      }
<span class="linenr">3238: </span>    }
<span class="linenr">3239: </span>  }
<span class="linenr">3240: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">createIfBranch</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">dir</span>) {
<span class="linenr">3241: </span>    <span class=
"org-keyword">return</span> {
<span class="linenr">3242: </span>      type: NodeTypes.IF_BRANCH,
<span class="linenr">3243: </span>      loc: node.loc,
<span class=
"linenr">3244: </span>      condition: dir.name === <span class=
"org-string">'else'</span> ? <span class=
"org-constant">undefined</span> : dir.exp,
<span class="linenr">3245: </span>      children:
<span class=
"linenr">3246: </span>        node.tagType === ElementTypes.TEMPLATE &amp;& !findDir(node, <span class="org-string">'for'</span>)
<span class="linenr">3247: </span>          ? node.children
<span class="linenr">3248: </span>          : [node],
<span class=
"linenr">3249: </span>      userKey: findProp(node, <span class=
"org-string">`key`</span>)
<span class="linenr">3250: </span>    }
<span class="linenr">3251: </span>  }
<span class="linenr">3252: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">createCodegenNodeForBranch</span>(<span class=
"org-variable-name">branch</span>, <span class=
"org-variable-name">keyIndex</span>, <span class=
"org-variable-name">context</span>) {
<span class="linenr">3253: </span>    <span class=
"org-keyword">if</span> (branch.condition) {
<span class="linenr">3254: </span>      <span class=
"org-keyword">return</span> createConditionalExpression(
<span class="linenr">3255: </span>        branch.condition,
<span class=
"linenr">3256: </span>        createChildrenCodegenNode(branch, keyIndex, context),
<span class="linenr">3257: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">这里是考虑到只有 v-if 的情况，因为 v-if 指令最后都会被解析成三目运算符形式</span>
<span class="linenr">3258: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">如： &lt;div v-if="foo"/&gt;&lt;div v-else/&gt; =&gt; foo ? ... : ...</span>
<span class="linenr">3259: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">如： &lt;div v-if="foo"/&gt;&lt;div v-else-if="bar"/&gt;&lt;div v-else/&gt; =&gt; foo ? ... : bar ? ... : ...</span>
<span class="linenr">3260: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">所以必需得要有一个 v-else，如果没有的话就相当于是 `foo ? ...` 这样的语句是不合法的</span>
<span class="linenr">3261: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">因此这里在判断没有 v-else 分支的情况时默认给它创建了个注释节点</span>
<span class=
"linenr">3262: </span>        createCallExpression(context.helper(CREATE_COMMENT), [
<span class="linenr">3263: </span>          __DEV__ ? <span class=
"org-string">'"v-if"'</span> : <span class=
"org-string">'""'</span>,
<span class="linenr">3264: </span>          <span class=
"org-string">'true'</span>
<span class="linenr">3265: </span>        ])
<span class="linenr">3266: </span>      )
<span class="linenr">3267: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr">3268: </span>      <span class=
"org-keyword">return</span> createChildrenCodegenNode(branch, keyIndex, context)
<span class="linenr">3269: </span>    }
<span class="linenr">3270: </span>  }
<span class="linenr">3271: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">createChildrenCodegenNode</span>(<span class=
"org-variable-name">branch</span>, <span class=
"org-variable-name">keyIndex</span>, <span class=
"org-variable-name">context</span>) {
<span class="linenr">3272: </span>    <span class=
"org-keyword">const</span> { helper } = context
<span class="linenr">3273: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">keyProperty</span> = createObjectProperty(
<span class="linenr">3274: </span>      <span class=
"org-string">`key`</span>,
<span class="linenr">3275: </span>      createSimpleExpression(
<span class="linenr">3276: </span>        <span class=
"org-string">`${keyIndex}`</span>,
<span class="linenr">3277: </span>        <span class=
"org-constant">false</span>,
<span class="linenr">3278: </span>        locStub,
<span class="linenr">3279: </span>        ConstantTypes.CAN_HOIST
<span class="linenr">3280: </span>      )
<span class="linenr">3281: </span>    )
<span class="linenr">3282: </span>    <span class=
"org-keyword">const</span> { children } = branch
<span class="linenr">3283: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">firstChild</span> = children[<span class=
"org-highlight-numbers-number">0</span>]
<span class="linenr">3284: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">needFragmentWrapper</span> =
<span class=
"linenr">3285: </span>      children.length !== <span class=
"org-highlight-numbers-number">1</span> || firstChild.type !== NodeTypes.ELEMENT
<span class="linenr">3286: </span>    <span class=
"org-keyword">if</span> (needFragmentWrapper) {
<span class="linenr">3287: </span>      <span class=
"org-keyword">if</span> (children.length === <span class=
"org-highlight-numbers-number">1</span> &amp;& firstChild.type === NodeTypes.FOR) {
<span class="linenr">3288: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">optimize away nested fragments when child is a ForNode</span>
<span class="linenr">3289: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">vnodeCall</span> = firstChild.codegenNode
<span class=
"linenr">3290: </span>        injectProp(vnodeCall, keyProperty, context)
<span class="linenr">3291: </span>        <span class=
"org-keyword">return</span> vnodeCall
<span class="linenr">3292: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr">3293: </span>        <span class=
"org-keyword">let</span> <span class=
"org-variable-name">patchFlag</span> = PatchFlags.STABLE_FRAGMENT
<span class="linenr">3294: </span>        <span class=
"org-keyword">let</span> <span class=
"org-variable-name">patchFlagText</span> = PatchFlagNames[PatchFlags.STABLE_FRAGMENT]
<span class="linenr">3295: </span>  
<span class="linenr">3296: </span>        <span class=
"org-keyword">return</span> createVNodeCall(
<span class="linenr">3297: </span>          context,
<span class="linenr">3298: </span>          helper(FRAGMENT),
<span class=
"linenr">3299: </span>          createObjectExpression([keyProperty]),
<span class="linenr">3300: </span>          children,
<span class=
"linenr">3301: </span>          patchFlag + (__DEV__ ? <span class=
"org-string">` /* ${patchFlagText} */`</span> : <span class=
"org-string">``</span>),
<span class="linenr">3302: </span>          <span class=
"org-constant">undefined</span>,
<span class="linenr">3303: </span>          <span class=
"org-constant">undefined</span>,
<span class="linenr">3304: </span>          <span class=
"org-constant">true</span>,
<span class="linenr">3305: </span>          <span class=
"org-constant">false</span>,
<span class="linenr">3306: </span>          <span class=
"org-constant">false</span> <span class=
"org-comment-delimiter">/* </span><span class=
"org-comment">isComponent</span><span class=
"org-comment-delimiter"> */</span>,
<span class="linenr">3307: </span>          branch.loc
<span class="linenr">3308: </span>        )
<span class="linenr">3309: </span>      }
<span class="linenr">3310: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr">3311: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">ret</span> = firstChild.codegenNode
<span class="linenr">3312: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">vnodeCall</span> = getMemoedVNodeCall(ret)
<span class="linenr">3313: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">Change createVNode to createBlock.</span>
<span class="linenr">3314: </span>      <span class=
"org-keyword">if</span> (vnodeCall.type === NodeTypes.VNODE_CALL) {
<span class=
"linenr">3315: </span>        makeBlock(vnodeCall, context)
<span class="linenr">3316: </span>      }
<span class="linenr">3317: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">inject branch key</span>
<span class=
"linenr">3318: </span>      injectProp(vnodeCall, keyProperty, context)
<span class="linenr">3319: </span>      <span class=
"org-keyword">return</span> ret
<span class="linenr">3320: </span>    }
<span class="linenr">3321: </span>  }
<span class="linenr">3322: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">isSameKey</span>(<span class=
"org-variable-name">a</span>, <span class=
"org-variable-name">b</span>) {
<span class="linenr">3323: </span>    <span class=
"org-keyword">if</span> (!a || a.type !== b.type) {
<span class="linenr">3324: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">3325: </span>    }
<span class="linenr">3326: </span>    <span class=
"org-keyword">if</span> (a.type === NodeTypes.ATTRIBUTE) {
<span class="linenr">3327: </span>      <span class=
"org-keyword">if</span> (a.value.content !== b.value.content) {
<span class="linenr">3328: </span>        <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">3329: </span>      }
<span class="linenr">3330: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr">3331: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">directive</span>
<span class="linenr">3332: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">exp</span> = a.exp
<span class="linenr">3333: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">branchExp</span> = b.exp
<span class="linenr">3334: </span>      <span class=
"org-keyword">if</span> (exp.type !== branchExp.type) {
<span class="linenr">3335: </span>        <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">3336: </span>      }
<span class="linenr">3337: </span>      <span class=
"org-keyword">if</span> (
<span class=
"linenr">3338: </span>        exp.type !== NodeTypes.SIMPLE_EXPRESSION ||
<span class=
"linenr">3339: </span>        exp.isStatic !== branchExp.isStatic ||
<span class=
"linenr">3340: </span>        exp.content !== branchExp.content
<span class="linenr">3341: </span>      ) {
<span class="linenr">3342: </span>        <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">3343: </span>      }
<span class="linenr">3344: </span>    }
<span class="linenr">3345: </span>    <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr">3346: </span>  }
<span class="linenr">3347: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">getParentCondition</span>(<span class=
"org-variable-name">node</span>) {
<span class="linenr">3348: </span>    <span class=
"org-keyword">while</span> (<span class=
"org-constant">true</span>) {
<span class="linenr">3349: </span>      <span class=
"org-keyword">if</span> (node.type === NodeTypes.JS_CONDITIONAL_EXPRESSION) {
<span class="linenr">3350: </span>        <span class=
"org-keyword">if</span> (node.alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION) {
<span class="linenr">3351: </span>          node = node.alternate
<span class="linenr">3352: </span>        } <span class=
"org-keyword">else</span> {
<span class="linenr">3353: </span>          <span class=
"org-keyword">return</span> node
<span class="linenr">3354: </span>        }
<span class="linenr">3355: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (node.type === NodeTypes.JS_CACHE_EXPRESSION) {
<span class="linenr">3356: </span>        node = node.value
<span class="linenr">3357: </span>      }
<span class="linenr">3358: </span>    }
<span class="linenr">3359: </span>  }
<span class="linenr">3360: </span>  
<span class="linenr">3361: </span>  
<span class="linenr">3362: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">transformIf</span> = createStructuralDirectiveTransform(
<span class="linenr">3363: </span>    <span class=
"org-string">/^(if|else|else-if)$/</span>,
<span class="linenr">3364: </span>    (node, dir, context) =&gt; {
<span class="linenr">3365: </span>      <span class=
"org-keyword">return</span> processIf(node, dir, context, (ifNode, branch, isRoot) =&gt; {
<span class="linenr">3366: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">siblings</span> = context.parent.children
<span class="linenr">3367: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">if...else if...else 都处于同级渲染</span>
<span class="linenr">3368: </span>        <span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = siblings.indexOf(ifNode)
<span class="linenr">3369: </span>        <span class=
"org-keyword">let</span> <span class=
"org-variable-name">key</span> = <span class=
"org-highlight-numbers-number">0</span>
<span class="linenr">3370: </span>        <span class=
"org-keyword">while</span> (i-- &gt;= <span class=
"org-highlight-numbers-number">0</span>) {
<span class="linenr">3371: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">sibling</span> = siblings[i]
<span class="linenr">3372: </span>          <span class=
"org-keyword">if</span> (sibling &amp;& sibling.type === NodeTypes.IF) {
<span class=
"linenr">3373: </span>            key += sibling.branches.length
<span class="linenr">3374: </span>          }
<span class="linenr">3375: </span>        }
<span class="linenr">3376: </span>  
<span class="linenr">3377: </span>        logg(<span class=
"org-string">'transformIf'</span>, ifNode, { isRoot, branch })
<span class="linenr">3378: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">退出时的回调，当所有 children 被遍历转换完成时被调用生成 codegenNode</span>
<span class="linenr">3379: </span>        <span class=
"org-keyword">return</span> () =&gt; {
<span class="linenr">3380: </span>          <span class=
"org-keyword">if</span> (isRoot) { <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">v-if</span>
<span class=
"linenr">3381: </span>            ifNode.codegenNode = createCodegenNodeForBranch(
<span class=
"linenr">3382: </span>              branch, key, context
<span class="linenr">3383: </span>            )
<span class="linenr">3384: </span>            logg(<span class=
"org-string">'transformIf - isRoot - v-if'</span>, ifNode)
<span class="linenr">3385: </span>          } <span class=
"org-keyword">else</span> { <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">v-else, v-else-if</span>
<span class="linenr">3386: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">将 v-else-* 分枝挂到 v-if 节点下面</span>
<span class="linenr">3387: </span>            <span class=
"org-keyword">const</span> <span class=
"org-variable-name">parentCondition</span> = getParentCondition(ifNode.codegenNode)
<span class=
"linenr">3388: </span>            parentCondition.alternate = createCodegenNodeForBranch(
<span class=
"linenr">3389: </span>              branch, key + ifNode.branches.length - <span class="org-highlight-numbers-number">1</span>,
<span class="linenr">3390: </span>              context
<span class="linenr">3391: </span>            )
<span class="linenr">3392: </span>            logg(<span class=
"org-string">'transformIf - v-else-*'</span>, ifNode)
<span class="linenr">3393: </span>          }
<span class="linenr">3394: </span>        }
<span class="linenr">3395: </span>  
<span class="linenr">3396: </span>      })
<span class="linenr">3397: </span>    }
<span class="linenr">3398: </span>  )
<span class="linenr">3399: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">memoSeen</span> = <span class=
"org-keyword">new</span> <span class="org-type">WeakSet</span>()
<span class="linenr">3400: </span>  
<span class="linenr">3401: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">transformMemo</span> = (node, context) =&gt; {
<span class="linenr">3402: </span>    <span class=
"org-keyword">if</span> (node.type === NodeTypes.ELEMENT) {
<span class="linenr">3403: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">dir</span> = findDir(node, <span class=
"org-string">'memo'</span>)
<span class="linenr">3404: </span>      <span class=
"org-keyword">if</span> (!dir || memoSeen.has(node)) {
<span class="linenr">3405: </span>        <span class=
"org-keyword">return</span>
<span class="linenr">3406: </span>      }
<span class="linenr">3407: </span>      memoSeen.add(node)
<span class="linenr">3408: </span>      <span class=
"org-keyword">return</span> () =&gt; {
<span class="linenr">3409: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">codegenNode</span> = node.codegenNode || context.currentNode.codegenNode
<span class="linenr">3410: </span>        <span class=
"org-keyword">if</span> (codegenNode &amp;& codegenNode.type === NodeTypes.VNODE_CALL) {
<span class="linenr">3411: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">non-component sub tree should be turned into a block</span>
<span class="linenr">3412: </span>          <span class=
"org-keyword">if</span> (node.tagType !== ElementTypes.COMPONENT) {
<span class=
"linenr">3413: </span>            makeBlock(codegenNode, context)
<span class="linenr">3414: </span>          }
<span class=
"linenr">3415: </span>          node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
<span class="linenr">3416: </span>            dir.exp,
<span class=
"linenr">3417: </span>            createFunctionExpression(<span class="org-constant">undefined</span>, codegenNode),
<span class="linenr">3418: </span>            <span class=
"org-string">`_cache`</span>,
<span class=
"linenr">3419: </span>            String(context.cached++)
<span class="linenr">3420: </span>          ])
<span class="linenr">3421: </span>        }
<span class="linenr">3422: </span>      }
<span class="linenr">3423: </span>    }
<span class="linenr">3424: </span>  }
<span class="linenr">3425: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">transformModel</span> = (dir, node, context) =&gt; {
<span class="linenr">3426: </span>    <span class=
"org-keyword">const</span> { exp, arg } = dir
<span class="linenr">3427: </span>    <span class=
"org-keyword">if</span> (!exp) {
<span class="linenr">3428: </span>      logg(<span class=
"org-string">`transformModel no exp`</span>)
<span class="linenr">3429: </span>      <span class=
"org-keyword">return</span> createTransformProps()
<span class="linenr">3430: </span>    }
<span class="linenr">3431: </span>  
<span class="linenr">3432: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">rawExp</span> = exp.loc.source
<span class="linenr">3433: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">expString</span> =
<span class=
"linenr">3434: </span>      exp.type === NodeTypes.SIMPLE_EXPRESSION ? exp.content : rawExp
<span class="linenr">3435: </span>  
<span class="linenr">3436: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">im SFC &lt;script setup&gt; inline mode, the exp may have been transformed into</span>
<span class="linenr">3437: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">_unref(exp)</span>
<span class="linenr">3438: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">bindingType</span> = context.bindingMetadata[rawExp]
<span class="linenr">3439: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">maybeRef</span> =
<span class="linenr">3440: </span>      !__BROWSER__ &amp;&
<span class="linenr">3441: </span>      context.inline &amp;&
<span class="linenr">3442: </span>      bindingType &amp;&
<span class=
"linenr">3443: </span>      bindingType !== BindingTypes.SETUP_CONST
<span class="linenr">3444: </span>  
<span class="linenr">3445: </span>    <span class=
"org-keyword">if</span> (
<span class="linenr">3446: </span>      !expString.trim() ||
<span class=
"linenr">3447: </span>      (!isMemberExpression(expString, context) &amp;& !maybeRef)
<span class="linenr">3448: </span>    ) {
<span class="linenr">3449: </span>      <span class=
"org-keyword">return</span> createTransformProps()
<span class="linenr">3450: </span>    }
<span class="linenr">3451: </span>  
<span class="linenr">3452: </span>    <span class=
"org-keyword">if</span> (
<span class="linenr">3453: </span>      !__BROWSER__ &amp;&
<span class=
"linenr">3454: </span>      context.prefixIdentifiers &amp;&
<span class=
"linenr">3455: </span>      isSimpleIdentifier(expString) &amp;&
<span class=
"linenr">3456: </span>      context.identifiers[expString]
<span class="linenr">3457: </span>    ) {
<span class="linenr">3458: </span>      <span class=
"org-keyword">return</span> createTransformProps()
<span class="linenr">3459: </span>    }
<span class="linenr">3460: </span>  
<span class="linenr">3461: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">propName</span> = arg ? arg : createSimpleExpression(<span class="org-string">'modelValue'</span>, <span class="org-constant">true</span>)
<span class="linenr">3462: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">eventName</span> = arg
<span class="linenr">3463: </span>      ? isStaticExp(arg)
<span class="linenr">3464: </span>        ? <span class=
"org-string">`onUpdate:${arg.content}`</span>
<span class=
"linenr">3465: </span>        : createCompoundExpression([<span class="org-string">'"onUpdate:" + '</span>, arg])
<span class="linenr">3466: </span>      : <span class=
"org-string">`onUpdate:modelValue`</span>
<span class="linenr">3467: </span>  
<span class="linenr">3468: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">assignmentExp</span>
<span class="linenr">3469: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">eventArg</span> = context.isTS ? <span class=
"org-string">`($event: any)`</span> : <span class=
"org-string">`$event`</span>
<span class="linenr">3470: </span>    <span class=
"org-keyword">if</span> (maybeRef) {
<span class="linenr">3471: </span>      <span class=
"org-keyword">if</span> (bindingType === BindingTypes.SETUP_REF) {
<span class="linenr">3472: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">v-model used on known ref.</span>
<span class=
"linenr">3473: </span>        assignmentExp = createCompoundExpression([
<span class="linenr">3474: </span>          <span class=
"org-string">`${eventArg} =&gt; ((`</span>,
<span class=
"linenr">3475: </span>          createSimpleExpression(rawExp, <span class="org-constant">false</span>, exp.loc),
<span class="linenr">3476: </span>          <span class=
"org-string">`).value = $event)`</span>
<span class="linenr">3477: </span>        ])
<span class="linenr">3478: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr">3479: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">v-model used on a potentially ref binding in &lt;script setup&gt; inline mode.</span>
<span class="linenr">3480: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">the assignment needs to check whether the binding is actually a ref.</span>
<span class="linenr">3481: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">altAssignment</span> =
<span class=
"linenr">3482: </span>          bindingType === BindingTypes.SETUP_LET ? <span class="org-string">`${rawExp} = $event`</span> : <span class="org-string">`null`</span>
<span class=
"linenr">3483: </span>        assignmentExp = createCompoundExpression([
<span class="linenr">3484: </span>          <span class=
"org-string">`${eventArg} =&gt; (${context.helperString(IS_REF)}(${rawExp}) ? (`</span>,
<span class=
"linenr">3485: </span>          createSimpleExpression(rawExp, <span class="org-constant">false</span>, exp.loc),
<span class="linenr">3486: </span>          <span class=
"org-string">`).value = $event : ${altAssignment})`</span>
<span class="linenr">3487: </span>        ])
<span class="linenr">3488: </span>      }
<span class="linenr">3489: </span>    } <span class=
"org-keyword">else</span> {
<span class=
"linenr">3490: </span>      assignmentExp = createCompoundExpression([
<span class="linenr">3491: </span>        <span class=
"org-string">`${eventArg} =&gt; ((`</span>,
<span class="linenr">3492: </span>        exp,
<span class="linenr">3493: </span>        <span class=
"org-string">`) = $event)`</span>
<span class="linenr">3494: </span>      ])
<span class="linenr">3495: </span>    }
<span class="linenr">3496: </span>  
<span class="linenr">3497: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">props</span> = [
<span class="linenr">3498: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">modelValue: foo</span>
<span class=
"linenr">3499: </span>      createObjectProperty(propName, dir.exp),
<span class="linenr">3500: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">"onUpdate:modelValue": $event =&gt; (foo = $event)</span>
<span class=
"linenr">3501: </span>      createObjectProperty(eventName, assignmentExp)
<span class="linenr">3502: </span>    ]
<span class="linenr">3503: </span>  
<span class="linenr">3504: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">cache v-model handler if applicable (when it doesn't refer any scope vars)</span>
<span class="linenr">3505: </span>    <span class=
"org-keyword">if</span> (
<span class="linenr">3506: </span>      !__BROWSER__ &amp;&
<span class=
"linenr">3507: </span>      context.prefixIdentifiers &amp;&
<span class="linenr">3508: </span>      !context.inVOnce &amp;&
<span class=
"linenr">3509: </span>      context.cacheHandlers &amp;&
<span class=
"linenr">3510: </span>      !hasScopeRef(exp, context.identifiers)
<span class="linenr">3511: </span>    ) {
<span class="linenr">3512: </span>      props[<span class=
"org-highlight-numbers-number">1</span>].value = context.cache(props[<span class="org-highlight-numbers-number">1</span>].value)
<span class="linenr">3513: </span>    }
<span class="linenr">3514: </span>  
<span class="linenr">3515: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">modelModifiers: { foo: true, "bar-baz": true }</span>
<span class="linenr">3516: </span>    <span class=
"org-keyword">if</span> (dir.modifiers.length &amp;& node.tagType === ElementTypes.COMPONENT) {
<span class="linenr">3517: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">modifiers</span> = dir.modifiers
<span class=
"linenr">3518: </span>        .map(m =&gt; (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + <span class="org-string">`: true`</span>)
<span class="linenr">3519: </span>        .join(<span class=
"org-string">`, `</span>)
<span class="linenr">3520: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">modifiersKey</span> = arg
<span class="linenr">3521: </span>        ? isStaticExp(arg)
<span class="linenr">3522: </span>          ? <span class=
"org-string">`${arg.content}Modifiers`</span>
<span class=
"linenr">3523: </span>          : createCompoundExpression([arg, <span class="org-string">' + "Modifiers"'</span>])
<span class="linenr">3524: </span>        : <span class=
"org-string">`modelModifiers`</span>
<span class="linenr">3525: </span>      props.push(
<span class="linenr">3526: </span>        createObjectProperty(
<span class="linenr">3527: </span>          modifiersKey,
<span class="linenr">3528: </span>          createSimpleExpression(
<span class="linenr">3529: </span>            <span class=
"org-string">`{ ${modifiers} }`</span>,
<span class="linenr">3530: </span>            <span class=
"org-constant">false</span>,
<span class="linenr">3531: </span>            dir.loc,
<span class=
"linenr">3532: </span>            ConstantTypes.CAN_HOIST
<span class="linenr">3533: </span>          )
<span class="linenr">3534: </span>        )
<span class="linenr">3535: </span>      )
<span class="linenr">3536: </span>    }
<span class="linenr">3537: </span>  
<span class="linenr">3538: </span>    <span class=
"org-keyword">return</span> createTransformProps(props)
<span class="linenr">3539: </span>  }
<span class="linenr">3540: </span>  
<span class="linenr">3541: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">createTransformProps</span>(<span class=
"org-variable-name">props</span> = []) {
<span class="linenr">3542: </span>    <span class=
"org-keyword">return</span> { props }
<span class="linenr">3543: </span>  }
<span class="linenr">3544: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">函数表达式正则, @click="fnExp"</span>
<span class="linenr">3545: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">fnExpRE</span> =
<span class="linenr">3546: </span>    <span class=
"org-string">/^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*=&gt;|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/</span>
<span class="linenr">3547: </span>  
<span class="linenr">3548: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">transformOn</span> = (
<span class="linenr">3549: </span>    dir,
<span class="linenr">3550: </span>    node,
<span class="linenr">3551: </span>    context,
<span class="linenr">3552: </span>    augmentor
<span class="linenr">3553: </span>  ) =&gt; {
<span class="linenr">3554: </span>    <span class=
"org-keyword">const</span> { loc, modifiers, arg } = dir
<span class="linenr">3555: </span>  
<span class="linenr">3556: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">eventName</span>
<span class="linenr">3557: </span>    <span class=
"org-keyword">if</span> (arg.type === NodeTypes.SIMPLE_EXPRESSION) {
<span class="linenr">3558: </span>      <span class=
"org-keyword">if</span> (arg.isStatic) {
<span class="linenr">3559: </span>        <span class=
"org-keyword">let</span> <span class=
"org-variable-name">rawName</span> = arg.content
<span class="linenr">3560: </span>  
<span class="linenr">3561: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">将事件名转成驼峰式</span>
<span class=
"linenr">3562: </span>        eventName = createSimpleExpression(
<span class=
"linenr">3563: </span>          toHandlerKey(camelize(rawName)),
<span class="linenr">3564: </span>          <span class=
"org-constant">true</span>,
<span class="linenr">3565: </span>          arg.loc
<span class="linenr">3566: </span>        )
<span class="linenr">3567: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr">3568: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">#2388 toHandlerKey 将事件名转成 onXxx, 如：eventName -&gt; onEventName</span>
<span class=
"linenr">3569: </span>        eventName = createCompoundExpression([
<span class="linenr">3570: </span>          <span class=
"org-string">`${context.helperString(TO_HANDLER_KEY)}(`</span>,
<span class="linenr">3571: </span>          arg,
<span class="linenr">3572: </span>          <span class=
"org-string">`)`</span>
<span class="linenr">3573: </span>        ])
<span class="linenr">3574: </span>      }
<span class="linenr">3575: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr">3576: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">already a compound expression.</span>
<span class="linenr">3577: </span>  
<span class="linenr">3578: </span>      eventName = arg
<span class=
"linenr">3579: </span>      eventName.children.unshift(<span class=
"org-string">`${context.helperString(TO_HANDLER_KEY)}(`</span>)
<span class=
"linenr">3580: </span>      eventName.children.push(<span class=
"org-string">`)`</span>)
<span class="linenr">3581: </span>    }
<span class="linenr">3582: </span>  
<span class="linenr">3583: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">handler processing, 事件表达式内容</span>
<span class="linenr">3584: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">exp</span> = dir.exp
<span class="linenr">3585: </span>    <span class=
"org-keyword">if</span> (exp &amp;& !exp.content.trim()) {
<span class="linenr">3586: </span>      exp = <span class=
"org-constant">undefined</span>
<span class="linenr">3587: </span>    }
<span class="linenr">3588: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">事件处理函数缓存</span>
<span class="linenr">3589: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">shouldCache</span> = context.cacheHandlers &amp;& !exp &amp;& !context.inVOnce
<span class="linenr">3590: </span>    <span class=
"org-keyword">if</span> (exp) {
<span class="linenr">3591: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isMemberExp</span> = isMemberExpression(exp.content, context)
<span class="linenr">3592: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isInlineStatement</span> = !(isMemberExp || fnExpRE.test(exp.content))
<span class="linenr">3593: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">hasMultipleStatements</span> = exp.content.includes(<span class="org-string">`;`</span>)
<span class="linenr">3594: </span>  
<span class="linenr">3595: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">process the expression since it's been skipped</span>
<span class="linenr">3596: </span>      <span class=
"org-keyword">if</span> (!__BROWSER__ &amp;& context.prefixIdentifiers) {
<span class=
"linenr">3597: </span>        isInlineStatement &amp;& context.addIdentifiers(<span class="org-string">`$event`</span>)
<span class=
"linenr">3598: </span>        exp = dir.exp = processExpression(
<span class="linenr">3599: </span>          exp,
<span class="linenr">3600: </span>          context,
<span class="linenr">3601: </span>          <span class=
"org-constant">false</span>,
<span class="linenr">3602: </span>          hasMultipleStatements
<span class="linenr">3603: </span>        )
<span class=
"linenr">3604: </span>        isInlineStatement &amp;& context.removeIdentifiers(<span class="org-string">`$event`</span>)
<span class="linenr">3605: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">with scope analysis, the function is hoistable if it has no reference</span>
<span class="linenr">3606: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">to scope variables.</span>
<span class="linenr">3607: </span>        shouldCache =
<span class=
"linenr">3608: </span>          context.cacheHandlers &amp;&
<span class="linenr">3609: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">unnecessary to cache inside v-once</span>
<span class="linenr">3610: </span>          !context.inVOnce &amp;&
<span class="linenr">3611: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">runtime constants don't need to be cached</span>
<span class="linenr">3612: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">(this is analyzed by compileScript in SFC &lt;script setup&gt;)</span>
<span class=
"linenr">3613: </span>          !(exp.type === NodeTypes.SIMPLE_EXPRESSION &amp;& exp.constType &gt; <span class="org-highlight-numbers-number">0</span>) &amp;&
<span class="linenr">3614: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">#1541 bail if this is a member exp handler passed to a component -</span>
<span class="linenr">3615: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">we need to use the original function to preserve arity,</span>
<span class="linenr">3616: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">e.g. &lt;transition&gt; relies on checking cb.length to determine</span>
<span class="linenr">3617: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">transition end handling. Inline function is ok since its arity</span>
<span class="linenr">3618: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">is preserved even when cached.</span>
<span class=
"linenr">3619: </span>          !(isMemberExp &amp;& node.tagType === ElementTypes.COMPONENT) &amp;&
<span class="linenr">3620: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">bail if the function references closure variables (v-for, v-slot)</span>
<span class="linenr">3621: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">it must be passed fresh to avoid stale values.</span>
<span class=
"linenr">3622: </span>          !hasScopeRef(exp, context.identifiers)
<span class="linenr">3623: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">If the expression is optimizable and is a member expression pointing</span>
<span class="linenr">3624: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">to a function, turn it into invocation (and wrap in an arrow function</span>
<span class="linenr">3625: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">below) so that it always accesses the latest value when called - thus</span>
<span class="linenr">3626: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">avoiding the need to be patched.</span>
<span class="linenr">3627: </span>        <span class=
"org-keyword">if</span> (shouldCache &amp;& isMemberExp) {
<span class="linenr">3628: </span>          <span class=
"org-keyword">if</span> (exp.type === NodeTypes.SIMPLE_EXPRESSION) {
<span class=
"linenr">3629: </span>            exp.content = <span class=
"org-string">`${exp.content} &amp;& ${exp.content}(...args)`</span>
<span class="linenr">3630: </span>          } <span class=
"org-keyword">else</span> {
<span class=
"linenr">3631: </span>            exp.children = [...exp.children, <span class="org-string">` &amp;& `</span>, ...exp.children, <span class="org-string">`(...args)`</span>]
<span class="linenr">3632: </span>          }
<span class="linenr">3633: </span>        }
<span class="linenr">3634: </span>      }
<span class="linenr">3635: </span>  
<span class="linenr">3636: </span>      <span class=
"org-keyword">if</span> (isInlineStatement || (shouldCache &amp;& isMemberExp)) {
<span class="linenr">3637: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">wrap inline statement in a function expression</span>
<span class="linenr">3638: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">($event) =&gt; statement</span>
<span class="linenr">3639: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">(...args) =&gt; { statement1;statement2 }</span>
<span class=
"linenr">3640: </span>        exp = createCompoundExpression([
<span class="linenr">3641: </span>          <span class=
"org-string">`${</span>
<span class="linenr">3642: </span><span class=
"org-string">            isInlineStatement</span>
<span class="linenr">3643: </span><span class=
"org-string">              ? `</span>$event<span class=
"org-string">`</span>
<span class="linenr">3644: </span><span class=
"org-string">              : `</span>(...args)<span class=
"org-string">`</span>
<span class="linenr">3645: </span><span class=
"org-string">          } =&gt; ${hasMultipleStatements ? `</span>{<span class="org-string">` : `</span>(<span class="org-string">`}`</span>,
<span class="linenr">3646: </span>          exp,
<span class=
"linenr">3647: </span>          hasMultipleStatements ? <span class="org-string">`}`</span> : <span class="org-string">`)`</span>
<span class="linenr">3648: </span>        ])
<span class="linenr">3649: </span>      }
<span class="linenr">3650: </span>    }
<span class="linenr">3651: </span>  
<span class="linenr">3652: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">ret</span> = {
<span class="linenr">3653: </span>      props: [
<span class="linenr">3654: </span>        createObjectProperty(
<span class="linenr">3655: </span>          eventName,
<span class=
"linenr">3656: </span>          exp || createSimpleExpression(<span class="org-string">`() =&gt; {}`</span>, <span class="org-constant">false</span>, loc)
<span class="linenr">3657: </span>        )
<span class="linenr">3658: </span>      ]
<span class="linenr">3659: </span>    }
<span class="linenr">3660: </span>  
<span class="linenr">3661: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">apply extended compiler augmentor</span>
<span class="linenr">3662: </span>    <span class=
"org-keyword">if</span> (augmentor) {
<span class="linenr">3663: </span>      ret = augmentor(ret)
<span class="linenr">3664: </span>    }
<span class="linenr">3665: </span>  
<span class="linenr">3666: </span>    <span class=
"org-keyword">if</span> (shouldCache) {
<span class="linenr">3667: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">cache handlers so that it's always the same handler being passed down.</span>
<span class="linenr">3668: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">this avoids unnecessary re-renders when users use inline handlers on</span>
<span class="linenr">3669: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">components.</span>
<span class="linenr">3670: </span>      ret.props[<span class=
"org-highlight-numbers-number">0</span>].value = context.cache(ret.props[<span class="org-highlight-numbers-number">0</span>].value)
<span class="linenr">3671: </span>    }
<span class="linenr">3672: </span>  
<span class="linenr">3673: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">mark the key as handler for props normalization check</span>
<span class=
"linenr">3674: </span>    ret.props.forEach(p =&gt; (p.key.isHandlerKey = <span class="org-constant">true</span>))
<span class="linenr">3675: </span>    <span class=
"org-keyword">return</span> ret
<span class="linenr">3676: </span>  }
<span class="linenr">3677: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">seen</span> = <span class=
"org-keyword">new</span> <span class="org-type">WeakSet</span>()
<span class="linenr">3678: </span>  
<span class="linenr">3679: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">transformOnce</span> = (node, context) =&gt; {
<span class="linenr">3680: </span>    <span class=
"org-keyword">if</span> (node.type === NodeTypes.ELEMENT &amp;& findDir(node, <span class="org-string">'once'</span>, <span class="org-constant">true</span>)) {
<span class="linenr">3681: </span>      <span class=
"org-keyword">if</span> (seen.has(node) || context.inVOnce) {
<span class="linenr">3682: </span>        logg(<span class=
"org-string">`transformOnce node has seen`</span>)
<span class="linenr">3683: </span>        <span class=
"org-keyword">return</span>
<span class="linenr">3684: </span>      }
<span class="linenr">3685: </span>      seen.add(node)
<span class=
"linenr">3686: </span>      context.inVOnce = <span class=
"org-constant">true</span>
<span class=
"linenr">3687: </span>      context.helper(SET_BLOCK_TRACKING)
<span class="linenr">3688: </span>      <span class=
"org-keyword">return</span> () =&gt; {
<span class=
"linenr">3689: </span>        context.inVOnce = <span class=
"org-constant">false</span>
<span class="linenr">3690: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">cur</span> = context.currentNode
<span class="linenr">3691: </span>        <span class=
"org-keyword">if</span> (cur.codegenNode) {
<span class=
"linenr">3692: </span>          cur.codegenNode = context.cache(cur.codegenNode, <span class="org-constant">true</span> <span class="org-comment-delimiter">/* </span><span class="org-comment">isVNode</span><span class="org-comment-delimiter"> */</span>)
<span class="linenr">3693: </span>        }
<span class="linenr">3694: </span>      }
<span class="linenr">3695: </span>    }
<span class="linenr">3696: </span>  }
<span class="linenr">3697: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">Important: since this function uses Node.js only dependencies, it should</span>
<span class="linenr">3698: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">always be used with a leading !__BROWSER__ check so that it can be</span>
<span class="linenr">3699: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">tree-shaken from the browser build.</span>
<span class="linenr">3700: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">processExpression</span>(
<span class="linenr">3701: </span>    <span class=
"org-variable-name">node</span>,
<span class="linenr">3702: </span>    <span class=
"org-variable-name">context</span>,
<span class="linenr">3703: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">some expressions like v-slot props & v-for aliases should be parsed as</span>
<span class="linenr">3704: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">function params</span>
<span class="linenr">3705: </span>    asParams = <span class=
"org-constant">false</span>,
<span class="linenr">3706: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">v-on handler values may contain multiple statements</span>
<span class=
"linenr">3707: </span>    asRawStatements = <span class="org-constant">false</span>,
<span class=
"linenr">3708: </span>    localVars = Object.create(context.identifiers)
<span class="linenr">3709: </span>  ) {
<span class="linenr">3710: </span>    <span class=
"org-keyword">if</span> (__BROWSER__) {
<span class="linenr">3711: </span>      <span class=
"org-keyword">return</span> node
<span class="linenr">3712: </span>    }
<span class="linenr">3713: </span>  
<span class="linenr">3714: </span>    <span class=
"org-keyword">if</span> (!context.prefixIdentifiers || !node.content.trim()) {
<span class="linenr">3715: </span>      <span class=
"org-keyword">return</span> node
<span class="linenr">3716: </span>    }
<span class="linenr">3717: </span>  
<span class="linenr">3718: </span>    <span class=
"org-keyword">const</span> { inline, bindingMetadata } = context
<span class="linenr">3719: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">rewriteIdentifier</span> = (raw, parent, id) =&gt; {
<span class="linenr">3720: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">type</span> = hasOwn(bindingMetadata, raw) &amp;& bindingMetadata[raw]
<span class="linenr">3721: </span>      <span class=
"org-keyword">if</span> (inline) {
<span class="linenr">3722: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">x = y</span>
<span class="linenr">3723: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isAssignmentLVal</span> =
<span class=
"linenr">3724: </span>          parent &amp;& parent.type === <span class="org-string">'AssignmentExpression'</span> &amp;& parent.left === id
<span class="linenr">3725: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">x++</span>
<span class="linenr">3726: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isUpdateArg</span> =
<span class=
"linenr">3727: </span>          parent &amp;& parent.type === <span class="org-string">'UpdateExpression'</span> &amp;& parent.argument === id
<span class="linenr">3728: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">({ x } = y)</span>
<span class="linenr">3729: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isDestructureAssignment</span> =
<span class=
"linenr">3730: </span>          parent &amp;& isInDestructureAssignment(parent, parentStack)
<span class="linenr">3731: </span>  
<span class="linenr">3732: </span>        <span class=
"org-keyword">if</span> (type === BindingTypes.SETUP_CONST || localVars[raw]) {
<span class="linenr">3733: </span>          <span class=
"org-keyword">return</span> raw
<span class="linenr">3734: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (type === BindingTypes.SETUP_REF) {
<span class="linenr">3735: </span>          <span class=
"org-keyword">return</span> <span class=
"org-string">`${raw}.value`</span>
<span class="linenr">3736: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (type === BindingTypes.SETUP_MAYBE_REF) {
<span class="linenr">3737: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">const binding that may or may not be ref</span>
<span class="linenr">3738: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">if it's not a ref, then assignments don't make sense -</span>
<span class="linenr">3739: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">so we ignore the non-ref assignment case and generate code</span>
<span class="linenr">3740: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">that assumes the value to be a ref for more efficiency</span>
<span class="linenr">3741: </span>          <span class=
"org-keyword">return</span> isAssignmentLVal || isUpdateArg || isDestructureAssignment
<span class="linenr">3742: </span>            ? <span class=
"org-string">`${raw}.value`</span>
<span class="linenr">3743: </span>            : <span class=
"org-string">`${context.helperString(UNREF)}(${raw})`</span>
<span class="linenr">3744: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (type === BindingTypes.SETUP_LET) {
<span class="linenr">3745: </span>          <span class=
"org-keyword">if</span> (isAssignmentLVal) {
<span class="linenr">3746: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">let binding.</span>
<span class="linenr">3747: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">this is a bit more tricky as we need to cover the case where</span>
<span class="linenr">3748: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">let is a local non-ref value, and we need to replicate the</span>
<span class="linenr">3749: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">right hand side value.</span>
<span class="linenr">3750: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">x = y --&gt; isRef(x) ? x.value = y : x = y</span>
<span class="linenr">3751: </span>            <span class=
"org-keyword">const</span> { right: rVal, operator } = parent
<span class="linenr">3752: </span>            <span class=
"org-keyword">const</span> <span class=
"org-variable-name">rExp</span> = rawExp.slice(rVal.start - <span class="org-highlight-numbers-number">1</span>, rVal.end - <span class="org-highlight-numbers-number">1</span>)
<span class="linenr">3753: </span>            <span class=
"org-keyword">const</span> <span class=
"org-variable-name">rExpString</span> = stringifyExpression(
<span class="linenr">3754: </span>              processExpression(
<span class=
"linenr">3755: </span>                createSimpleExpression(rExp, <span class="org-constant">false</span>),
<span class="linenr">3756: </span>                context,
<span class="linenr">3757: </span>                <span class=
"org-constant">false</span>,
<span class="linenr">3758: </span>                <span class=
"org-constant">false</span>,
<span class="linenr">3759: </span>                knownIds
<span class="linenr">3760: </span>              )
<span class="linenr">3761: </span>            )
<span class="linenr">3762: </span>            <span class=
"org-keyword">return</span> <span class=
"org-string">`${context.helperString(IS_REF)}(${raw})${``} ? ${raw}.value ${operator} ${rExpString} : ${raw}`</span>
<span class="linenr">3763: </span>          } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (isUpdateArg) {
<span class="linenr">3764: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">make id replace parent in the code range so the raw update operator</span>
<span class="linenr">3765: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">is removed</span>
<span class=
"linenr">3766: </span>            id.start = parent.start
<span class="linenr">3767: </span>            id.end = parent.end
<span class="linenr">3768: </span>            <span class=
"org-keyword">const</span> { prefix: isPrefix, operator } = parent
<span class="linenr">3769: </span>            <span class=
"org-keyword">const</span> <span class=
"org-variable-name">prefix</span> = isPrefix ? operator : <span class="org-string">``</span>
<span class="linenr">3770: </span>            <span class=
"org-keyword">const</span> <span class=
"org-variable-name">postfix</span> = isPrefix ? <span class=
"org-string">``</span> : operator
<span class="linenr">3771: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">let binding.</span>
<span class="linenr">3772: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">x++ --&gt; isRef(a) ? a.value++ : a++</span>
<span class="linenr">3773: </span>            <span class=
"org-keyword">return</span> <span class=
"org-string">`${context.helperString(IS_REF)}(${raw})${``} ? ${prefix}${raw}.value${postfix} : ${prefix}${raw}${postfix}`</span>
<span class="linenr">3774: </span>          } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (isDestructureAssignment) {
<span class="linenr">3775: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment"><span class="org-bold"><span class=
"org-warning">TODO</span></span></span>
<span class="linenr">3776: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">let binding in a destructure assignment - it's very tricky to</span>
<span class="linenr">3777: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">handle both possible cases here without altering the original</span>
<span class="linenr">3778: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">structure of the code, so we just assume it's not a ref here</span>
<span class="linenr">3779: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">for now</span>
<span class="linenr">3780: </span>            <span class=
"org-keyword">return</span> raw
<span class="linenr">3781: </span>          } <span class=
"org-keyword">else</span> {
<span class="linenr">3782: </span>            <span class=
"org-keyword">return</span> <span class=
"org-string">`${context.helperString(UNREF)}(${raw})`</span>
<span class="linenr">3783: </span>          }
<span class="linenr">3784: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (type === BindingTypes.PROPS) {
<span class="linenr">3785: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">use __props which is generated by compileScript so in ts mode</span>
<span class="linenr">3786: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">it gets correct type</span>
<span class="linenr">3787: </span>          <span class=
"org-keyword">return</span> <span class=
"org-string">`__props.${raw}`</span>
<span class="linenr">3788: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (type === BindingTypes.PROPS_ALIASED) {
<span class="linenr">3789: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">prop with a different local alias (from defineProps() destructure)</span>
<span class="linenr">3790: </span>          <span class=
"org-keyword">return</span> <span class=
"org-string">`__props.${bindingMetadata.__propsAliases[raw]}`</span>
<span class="linenr">3791: </span>        }
<span class="linenr">3792: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr">3793: </span>        <span class=
"org-keyword">if</span> (type &amp;& type.startsWith(<span class=
"org-string">'setup'</span>)) {
<span class="linenr">3794: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">setup bindings in non-inline mode</span>
<span class="linenr">3795: </span>          <span class=
"org-keyword">return</span> <span class=
"org-string">`$setup.${raw}`</span>
<span class="linenr">3796: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (type === BindingTypes.PROPS_ALIASED) {
<span class="linenr">3797: </span>          <span class=
"org-keyword">return</span> <span class=
"org-string">`$props.${bindingMetadata.__propsAliases[raw]}`</span>
<span class="linenr">3798: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (type) {
<span class="linenr">3799: </span>          <span class=
"org-keyword">return</span> <span class=
"org-string">`$${type}.${raw}`</span>
<span class="linenr">3800: </span>        }
<span class="linenr">3801: </span>      }
<span class="linenr">3802: </span>  
<span class="linenr">3803: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">fallback to ctx</span>
<span class="linenr">3804: </span>      <span class=
"org-keyword">return</span> <span class=
"org-string">`_ctx.${raw}`</span>
<span class="linenr">3805: </span>    }
<span class="linenr">3806: </span>  
<span class="linenr">3807: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">fast path if expression is a simple identifier.</span>
<span class="linenr">3808: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">rawExp</span> = node.content
<span class="linenr">3809: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">bail constant on parens (function invocation) and dot (member access)</span>
<span class="linenr">3810: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">bailConstant</span> = rawExp.indexOf(<span class="org-string">`(`</span>) &gt; -<span class="org-highlight-numbers-number">1</span> || rawExp.indexOf(<span class="org-string">'.'</span>) &gt; <span class="org-highlight-numbers-number">0</span>
<span class="linenr">3811: </span>  
<span class="linenr">3812: </span>    <span class=
"org-keyword">if</span> (isSimpleIdentifier(rawExp)) {
<span class="linenr">3813: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isScopeVarReference</span> = context.identifiers[rawExp]
<span class="linenr">3814: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isAllowedGlobal</span> = isGloballyWhitelisted(rawExp)
<span class="linenr">3815: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isLiteral</span> = isLiteralWhitelisted(rawExp)
<span class="linenr">3816: </span>      <span class=
"org-keyword">if</span> (!asParams &amp;& !isScopeVarReference &amp;& !isAllowedGlobal &amp;& !isLiteral) {
<span class="linenr">3817: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">const bindings exposed from setup can be skipped for patching but</span>
<span class="linenr">3818: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">cannot be hoisted to module scope</span>
<span class="linenr">3819: </span>        <span class=
"org-keyword">if</span> (bindingMetadata[node.content] === BindingTypes.SETUP_CONST) {
<span class=
"linenr">3820: </span>          node.constType = ConstantTypes.CAN_SKIP_PATCH
<span class="linenr">3821: </span>        }
<span class=
"linenr">3822: </span>        node.content = rewriteIdentifier(rawExp)
<span class="linenr">3823: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (!isScopeVarReference) {
<span class="linenr">3824: </span>        <span class=
"org-keyword">if</span> (isLiteral) {
<span class=
"linenr">3825: </span>          node.constType = ConstantTypes.CAN_STRINGIFY
<span class="linenr">3826: </span>        } <span class=
"org-keyword">else</span> {
<span class=
"linenr">3827: </span>          node.constType = ConstantTypes.CAN_HOIST
<span class="linenr">3828: </span>        }
<span class="linenr">3829: </span>      }
<span class="linenr">3830: </span>      <span class=
"org-keyword">return</span> node
<span class="linenr">3831: </span>    }
<span class="linenr">3832: </span>  
<span class="linenr">3833: </span>    <span class=
"org-keyword">let</span> <span class="org-variable-name">ast</span>
<span class="linenr">3834: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">exp needs to be parsed differently:</span>
<span class="linenr">3835: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">1. Multiple inline statements (v-on, with presence of `;`): parse as raw</span>
<span class="linenr">3836: </span>    <span class=
"org-comment-delimiter">//    </span><span class=
"org-comment">exp, but make sure to pad with spaces for consistent ranges</span>
<span class="linenr">3837: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">2. Expressions: wrap with parens (for e.g. object expressions)</span>
<span class="linenr">3838: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">3. Function arguments (v-for, v-slot): place in a function argument position</span>
<span class="linenr">3839: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">source</span> = asRawStatements
<span class="linenr">3840: </span>      ? <span class=
"org-string">` ${rawExp} `</span>
<span class="linenr">3841: </span>      : <span class=
"org-string">`(${rawExp})${asParams ? `</span>=&gt;{}<span class=
"org-string">` : ``}`</span>
<span class="linenr">3842: </span>    <span class=
"org-keyword">try</span> {
<span class=
"linenr">3843: </span>      ast = babelParser.parse(source, {
<span class=
"linenr">3844: </span>        plugins: context.expressionPlugins
<span class="linenr">3845: </span>      }).program
<span class="linenr">3846: </span>    } <span class=
"org-keyword">catch</span> (e) {
<span class="linenr">3847: </span>      <span class=
"org-keyword">return</span> node
<span class="linenr">3848: </span>    }
<span class="linenr">3849: </span>  
<span class="linenr">3850: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">ids</span>= []
<span class="linenr">3851: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">parentStack</span> = []
<span class="linenr">3852: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">knownIds</span> = Object.create(context.identifiers)
<span class="linenr">3853: </span>  
<span class="linenr">3854: </span>    walkIdentifiers(
<span class="linenr">3855: </span>      ast,
<span class=
"linenr">3856: </span>      (node, parent, _, isReferenced, isLocal) =&gt; {
<span class="linenr">3857: </span>        <span class=
"org-keyword">if</span> (isStaticPropertyKey(node, parent)) {
<span class="linenr">3858: </span>          <span class=
"org-keyword">return</span>
<span class="linenr">3859: </span>        }
<span class="linenr">3860: </span>  
<span class="linenr">3861: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">needPrefix</span> = isReferenced &amp;& canPrefix(node)
<span class="linenr">3862: </span>        <span class=
"org-keyword">if</span> (needPrefix &amp;& !isLocal) {
<span class="linenr">3863: </span>          <span class=
"org-keyword">if</span> (isStaticProperty(parent) &amp;& parent.shorthand) {
<span class="linenr">3864: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">property shorthand like { foo }, we need to add the key since</span>
<span class="linenr">3865: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">we rewrite the value</span>
<span class=
"linenr">3866: </span>            node.prefix = <span class=
"org-string">`${node.name}: `</span>
<span class="linenr">3867: </span>          }
<span class=
"linenr">3868: </span>          node.name = rewriteIdentifier(node.name, parent, node)
<span class="linenr">3869: </span>          ids.push(node)
<span class="linenr">3870: </span>        } <span class=
"org-keyword">else</span> {
<span class="linenr">3871: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">The identifier is considered constant unless it's pointing to a</span>
<span class="linenr">3872: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">local scope variable (a v-for alias, or a v-slot prop)</span>
<span class="linenr">3873: </span>          <span class=
"org-keyword">if</span> (!(needPrefix &amp;& isLocal) &amp;& !bailConstant) {
<span class=
"linenr">3874: </span>            node.isConstant = <span class=
"org-constant">true</span>
<span class="linenr">3875: </span>          }
<span class="linenr">3876: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">also generate sub-expressions for other identifiers for better</span>
<span class="linenr">3877: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">source map support. (except for property keys which are static)</span>
<span class="linenr">3878: </span>          ids.push(node)
<span class="linenr">3879: </span>        }
<span class="linenr">3880: </span>      },
<span class="linenr">3881: </span>      <span class=
"org-constant">true</span>, <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">invoke on ALL identifiers</span>
<span class="linenr">3882: </span>      parentStack,
<span class="linenr">3883: </span>      knownIds
<span class="linenr">3884: </span>    )
<span class="linenr">3885: </span>  
<span class="linenr">3886: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">We break up the compound expression into an array of strings and sub</span>
<span class="linenr">3887: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">expressions (for identifiers that have been prefixed). In codegen, if</span>
<span class="linenr">3888: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">an ExpressionNode has the `.children` property, it will be used instead of</span>
<span class="linenr">3889: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">`.content`.</span>
<span class="linenr">3890: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">children</span> = []
<span class=
"linenr">3891: </span>    ids.sort((a, b) =&gt; a.start - b.start)
<span class="linenr">3892: </span>    ids.forEach((id, i) =&gt; {
<span class="linenr">3893: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">range is offset by -1 due to the wrapping parens when parsed</span>
<span class="linenr">3894: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">start</span> = id.start - <span class=
"org-highlight-numbers-number">1</span>
<span class="linenr">3895: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">end</span> = id.end - <span class=
"org-highlight-numbers-number">1</span>
<span class="linenr">3896: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">last</span> = ids[i - <span class=
"org-highlight-numbers-number">1</span>]
<span class="linenr">3897: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">leadingText</span> = rawExp.slice(last ? last.end - <span class="org-highlight-numbers-number">1</span> : <span class="org-highlight-numbers-number">0</span>, start)
<span class="linenr">3898: </span>      <span class=
"org-keyword">if</span> (leadingText.length || id.prefix) {
<span class=
"linenr">3899: </span>        children.push(leadingText + (id.prefix || <span class="org-string">``</span>))
<span class="linenr">3900: </span>      }
<span class="linenr">3901: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">source</span> = rawExp.slice(start, end)
<span class="linenr">3902: </span>      children.push(
<span class="linenr">3903: </span>        createSimpleExpression(
<span class="linenr">3904: </span>          id.name,
<span class="linenr">3905: </span>          <span class=
"org-constant">false</span>,
<span class="linenr">3906: </span>          {
<span class="linenr">3907: </span>            source,
<span class=
"linenr">3908: </span>            start: advancePositionWithClone(node.loc.start, source, start),
<span class=
"linenr">3909: </span>            end: advancePositionWithClone(node.loc.start, source, end)
<span class="linenr">3910: </span>          },
<span class=
"linenr">3911: </span>          id.isConstant ? ConstantTypes.CAN_STRINGIFY : ConstantTypes.NOT_CONSTANT
<span class="linenr">3912: </span>        )
<span class="linenr">3913: </span>      )
<span class="linenr">3914: </span>      <span class=
"org-keyword">if</span> (i === ids.length - <span class=
"org-highlight-numbers-number">1</span> &amp;& end &lt; rawExp.length) {
<span class=
"linenr">3915: </span>        children.push(rawExp.slice(end))
<span class="linenr">3916: </span>      }
<span class="linenr">3917: </span>    })
<span class="linenr">3918: </span>  
<span class="linenr">3919: </span>    <span class=
"org-keyword">let</span> <span class="org-variable-name">ret</span>
<span class="linenr">3920: </span>    <span class=
"org-keyword">if</span> (children.length) {
<span class=
"linenr">3921: </span>      ret = createCompoundExpression(children, node.loc)
<span class="linenr">3922: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr">3923: </span>      ret = node
<span class=
"linenr">3924: </span>      ret.constType = bailConstant
<span class=
"linenr">3925: </span>        ? ConstantTypes.NOT_CONSTANT
<span class=
"linenr">3926: </span>        : ConstantTypes.CAN_STRINGIFY
<span class="linenr">3927: </span>    }
<span class=
"linenr">3928: </span>    ret.identifiers = Object.keys(knownIds)
<span class="linenr">3929: </span>    <span class=
"org-keyword">return</span> ret
<span class="linenr">3930: </span>  }
<span class="linenr">3931: </span>  
<span class="linenr">3932: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">canPrefix</span>(<span class=
"org-variable-name">id</span>) {
<span class="linenr">3933: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">skip whitelisted globals</span>
<span class="linenr">3934: </span>    <span class=
"org-keyword">if</span> (isGloballyWhitelisted(id.name)) {
<span class="linenr">3935: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">3936: </span>    }
<span class="linenr">3937: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">special case for webpack compilation</span>
<span class="linenr">3938: </span>    <span class=
"org-keyword">if</span> (id.name === <span class=
"org-string">'require'</span>) {
<span class="linenr">3939: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">3940: </span>    }
<span class="linenr">3941: </span>    <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr">3942: </span>  }
<span class="linenr">3943: </span>  
<span class="linenr">3944: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">stringifyExpression</span>(<span class=
"org-variable-name">exp</span>){
<span class="linenr">3945: </span>    <span class=
"org-keyword">if</span> (isString(exp)) {
<span class="linenr">3946: </span>      <span class=
"org-keyword">return</span> exp
<span class="linenr">3947: </span>    } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (exp.type === NodeTypes.SIMPLE_EXPRESSION) {
<span class="linenr">3948: </span>      <span class=
"org-keyword">return</span> exp.content
<span class="linenr">3949: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr">3950: </span>      <span class=
"org-keyword">return</span> exp.children.map(stringifyExpression).join(<span class="org-string">''</span>)
<span class="linenr">3951: </span>    }
<span class="linenr">3952: </span>  }
<span class="linenr">3953: </span>  
<span class="linenr">3954: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">createRoot</span>(<span class=
"org-variable-name">children</span>, <span class=
"org-variable-name">loc</span> = <span class=
"org-variable-name">locStub</span>) {
<span class="linenr">3955: </span>    <span class=
"org-keyword">return</span> {
<span class="linenr">3956: </span>      type: NodeTypes.ROOT,
<span class="linenr">3957: </span>      children,
<span class="linenr">3958: </span>      helpers: [],
<span class="linenr">3959: </span>      components: [],
<span class="linenr">3960: </span>      directives: [],
<span class="linenr">3961: </span>      hoists: [],
<span class="linenr">3962: </span>      imports: [],
<span class="linenr">3963: </span>      cached: <span class=
"org-highlight-numbers-number">0</span>,
<span class="linenr">3964: </span>      temps: <span class=
"org-highlight-numbers-number">0</span>,
<span class="linenr">3965: </span>      codegenNode: <span class=
"org-constant">undefined</span>,
<span class="linenr">3966: </span>      loc
<span class="linenr">3967: </span>    }
<span class="linenr">3968: </span>  }
<span class="linenr">3969: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">createVNodeCall</span>(
<span class="linenr">3970: </span>    <span class=
"org-variable-name">context</span>,
<span class="linenr">3971: </span>    <span class=
"org-variable-name">tag</span>,
<span class="linenr">3972: </span>    <span class=
"org-variable-name">props</span>,
<span class="linenr">3973: </span>    <span class=
"org-variable-name">children</span>,
<span class="linenr">3974: </span>    <span class=
"org-variable-name">patchFlag</span>,
<span class="linenr">3975: </span>    <span class=
"org-variable-name">dynamicProps</span>,
<span class="linenr">3976: </span>    <span class=
"org-variable-name">directives</span>,
<span class="linenr">3977: </span>    isBlock = <span class=
"org-constant">false</span>,
<span class=
"linenr">3978: </span>    disableTracking = <span class="org-constant">false</span>,
<span class="linenr">3979: </span>    isComponent = <span class=
"org-constant">false</span>,
<span class="linenr">3980: </span>    loc = locStub
<span class="linenr">3981: </span>  ) {
<span class="linenr">3982: </span>    <span class=
"org-keyword">if</span> (context) {
<span class="linenr">3983: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">单个子节点用 block</span>
<span class="linenr">3984: </span>      <span class=
"org-keyword">if</span> (isBlock) {
<span class=
"linenr">3985: </span>        context.helper(OPEN_BLOCK)
<span class=
"linenr">3986: </span>        context.helper(getVNodeBlockHelper(context.inSSR, isComponent))
<span class="linenr">3987: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr">3988: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">多个节节点用 fragment</span>
<span class=
"linenr">3989: </span>        context.helper(getVNodeHelper(context.inSSR, isComponent))
<span class="linenr">3990: </span>      }
<span class="linenr">3991: </span>      <span class=
"org-keyword">if</span> (directives) {
<span class=
"linenr">3992: </span>        context.helper(WITH_DIRECTIVES)
<span class="linenr">3993: </span>      }
<span class="linenr">3994: </span>    }
<span class="linenr">3995: </span>  
<span class="linenr">3996: </span>    <span class=
"org-keyword">return</span> {
<span class="linenr">3997: </span>      type: NodeTypes.VNODE_CALL,
<span class="linenr">3998: </span>      tag,
<span class="linenr">3999: </span>      props,
<span class="linenr">4000: </span>      children,
<span class="linenr">4001: </span>      patchFlag,
<span class="linenr">4002: </span>      dynamicProps,
<span class="linenr">4003: </span>      directives,
<span class="linenr">4004: </span>      isBlock,
<span class="linenr">4005: </span>      disableTracking,
<span class="linenr">4006: </span>      isComponent,
<span class="linenr">4007: </span>      loc
<span class="linenr">4008: </span>    }
<span class="linenr">4009: </span>  }
<span class="linenr">4010: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">createArrayExpression</span>(<span class=
"org-variable-name">elements</span>, <span class=
"org-variable-name">loc</span> = <span class=
"org-variable-name">locStub</span>) {
<span class="linenr">4011: </span>    <span class=
"org-keyword">return</span> {
<span class=
"linenr">4012: </span>      type: NodeTypes.JS_ARRAY_EXPRESSION,
<span class="linenr">4013: </span>      loc,
<span class="linenr">4014: </span>      elements
<span class="linenr">4015: </span>    }
<span class="linenr">4016: </span>  }
<span class="linenr">4017: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">createObjectExpression</span>(<span class=
"org-variable-name">properties</span>, <span class=
"org-variable-name">loc</span> = <span class=
"org-variable-name">locStub</span>) {
<span class="linenr">4018: </span>    <span class=
"org-keyword">return</span> {
<span class=
"linenr">4019: </span>      type: NodeTypes.JS_OBJECT_EXPRESSION,
<span class="linenr">4020: </span>      loc,
<span class="linenr">4021: </span>      properties
<span class="linenr">4022: </span>    }
<span class="linenr">4023: </span>  }
<span class="linenr">4024: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">createObjectProperty</span>(<span class=
"org-variable-name">key</span>, <span class=
"org-variable-name">value</span>) {
<span class="linenr">4025: </span>    <span class=
"org-keyword">return</span> {
<span class=
"linenr">4026: </span>      type: NodeTypes.JS_PROPERTY,
<span class="linenr">4027: </span>      loc: locStub,
<span class=
"linenr">4028: </span>      key: isString(key) ? createSimpleExpression(key, <span class="org-constant">true</span>) : key,
<span class="linenr">4029: </span>      value
<span class="linenr">4030: </span>    }
<span class="linenr">4031: </span>  }
<span class="linenr">4032: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">createSimpleExpression</span>(
<span class="linenr">4033: </span>    <span class=
"org-variable-name">content</span>,
<span class="linenr">4034: </span>    isStatic = <span class=
"org-constant">false</span>,
<span class="linenr">4035: </span>    loc  = locStub,
<span class=
"linenr">4036: </span>    constType = ConstantTypes.NOT_CONSTANT
<span class="linenr">4037: </span>  ) {
<span class="linenr">4038: </span>    <span class=
"org-keyword">return</span> {
<span class=
"linenr">4039: </span>      type: NodeTypes.SIMPLE_EXPRESSION,
<span class="linenr">4040: </span>      loc,
<span class="linenr">4041: </span>      content,
<span class="linenr">4042: </span>      isStatic,
<span class=
"linenr">4043: </span>      constType: isStatic ? ConstantTypes.CAN_STRINGIFY : constType
<span class="linenr">4044: </span>    }
<span class="linenr">4045: </span>  }
<span class="linenr">4046: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">createInterpolation</span>(<span class=
"org-variable-name">content</span>, <span class=
"org-variable-name">loc</span>) {
<span class="linenr">4047: </span>    <span class=
"org-keyword">return</span> {
<span class=
"linenr">4048: </span>      type: NodeTypes.INTERPOLATION,
<span class="linenr">4049: </span>      loc,
<span class="linenr">4050: </span>      content: isString(content)
<span class=
"linenr">4051: </span>        ? createSimpleExpression(content, <span class="org-constant">false</span>, loc)
<span class="linenr">4052: </span>        : content
<span class="linenr">4053: </span>    }
<span class="linenr">4054: </span>  }
<span class="linenr">4055: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">createCompoundExpression</span>(<span class=
"org-variable-name">children</span>, <span class=
"org-variable-name">loc</span> = <span class=
"org-variable-name">locStub</span>) {
<span class="linenr">4056: </span>    <span class=
"org-keyword">return</span> {
<span class=
"linenr">4057: </span>      type: NodeTypes.COMPOUND_EXPRESSION,
<span class="linenr">4058: </span>      loc,
<span class="linenr">4059: </span>      children
<span class="linenr">4060: </span>    }
<span class="linenr">4061: </span>  }
<span class="linenr">4062: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">createCallExpression</span>(<span class=
"org-variable-name">callee</span>, <span class=
"org-variable-name">args</span> = [], <span class=
"org-variable-name">loc</span> = <span class=
"org-variable-name">locStub</span>) {
<span class="linenr">4063: </span>    <span class=
"org-keyword">return</span> {
<span class=
"linenr">4064: </span>      type: NodeTypes.JS_CALL_EXPRESSION,
<span class="linenr">4065: </span>      loc,
<span class="linenr">4066: </span>      callee,
<span class="linenr">4067: </span>      <span class=
"org-constant">arguments</span>: args
<span class="linenr">4068: </span>    }
<span class="linenr">4069: </span>  }
<span class="linenr">4070: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">createFunctionExpression</span>(
<span class="linenr">4071: </span>    <span class=
"org-variable-name">params</span>,
<span class="linenr">4072: </span>    returns = <span class=
"org-constant">undefined</span>,
<span class="linenr">4073: </span>    newline = <span class=
"org-constant">false</span>,
<span class="linenr">4074: </span>    isSlot = <span class=
"org-constant">false</span>,
<span class="linenr">4075: </span>    loc = locStub
<span class="linenr">4076: </span>  ) {
<span class="linenr">4077: </span>    <span class=
"org-keyword">return</span> {
<span class=
"linenr">4078: </span>      type: NodeTypes.JS_FUNCTION_EXPRESSION,
<span class="linenr">4079: </span>      params,
<span class="linenr">4080: </span>      returns,
<span class="linenr">4081: </span>      newline,
<span class="linenr">4082: </span>      isSlot,
<span class="linenr">4083: </span>      loc
<span class="linenr">4084: </span>    }
<span class="linenr">4085: </span>  }
<span class="linenr">4086: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">createConditionalExpression</span>(
<span class="linenr">4087: </span>    <span class=
"org-variable-name">test</span>,
<span class="linenr">4088: </span>    <span class=
"org-variable-name">consequent</span>,
<span class="linenr">4089: </span>    <span class=
"org-variable-name">alternate</span>,
<span class="linenr">4090: </span>    newline = <span class=
"org-constant">true</span>
<span class="linenr">4091: </span>  ) {
<span class="linenr">4092: </span>    <span class=
"org-keyword">return</span> {
<span class=
"linenr">4093: </span>      type: NodeTypes.JS_CONDITIONAL_EXPRESSION,
<span class="linenr">4094: </span>      test,
<span class="linenr">4095: </span>      consequent,
<span class="linenr">4096: </span>      alternate,
<span class="linenr">4097: </span>      newline,
<span class="linenr">4098: </span>      loc: locStub
<span class="linenr">4099: </span>    }
<span class="linenr">4100: </span>  }
<span class="linenr">4101: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">createCacheExpression</span>(
<span class="linenr">4102: </span>    <span class=
"org-variable-name">index</span>,
<span class="linenr">4103: </span>    <span class=
"org-variable-name">value</span>,
<span class="linenr">4104: </span>    isVNode = <span class=
"org-constant">false</span>
<span class="linenr">4105: </span>  ) {
<span class="linenr">4106: </span>    <span class=
"org-keyword">return</span> {
<span class=
"linenr">4107: </span>      type: NodeTypes.JS_CACHE_EXPRESSION,
<span class="linenr">4108: </span>      index,
<span class="linenr">4109: </span>      value,
<span class="linenr">4110: </span>      isVNode,
<span class="linenr">4111: </span>      loc: locStub
<span class="linenr">4112: </span>    }
<span class="linenr">4113: </span>  }
<span class="linenr">4114: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">createBlockStatement</span>(<span class=
"org-variable-name">body</span>) {
<span class="linenr">4115: </span>    <span class=
"org-keyword">return</span> {
<span class=
"linenr">4116: </span>      type: NodeTypes.JS_BLOCK_STATEMENT,
<span class="linenr">4117: </span>      body,
<span class="linenr">4118: </span>      loc: locStub
<span class="linenr">4119: </span>    }
<span class="linenr">4120: </span>  }
<span class="linenr">4121: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">createTemplateLiteral</span>(<span class=
"org-variable-name">elements</span>) {
<span class="linenr">4122: </span>    <span class=
"org-keyword">return</span> {
<span class=
"linenr">4123: </span>      type: NodeTypes.JS_TEMPLATE_LITERAL,
<span class="linenr">4124: </span>      elements,
<span class="linenr">4125: </span>      loc: locStub
<span class="linenr">4126: </span>    }
<span class="linenr">4127: </span>  }
<span class="linenr">4128: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">createIfStatement</span>(<span class=
"org-variable-name">test</span>, <span class=
"org-variable-name">consequent</span>, <span class=
"org-variable-name">alternate</span>) {
<span class="linenr">4129: </span>    <span class=
"org-keyword">return</span> {
<span class=
"linenr">4130: </span>      type: NodeTypes.JS_IF_STATEMENT,
<span class="linenr">4131: </span>      test,
<span class="linenr">4132: </span>      consequent,
<span class="linenr">4133: </span>      alternate,
<span class="linenr">4134: </span>      loc: locStub
<span class="linenr">4135: </span>    }
<span class="linenr">4136: </span>  }
<span class="linenr">4137: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">createAssignmentExpression</span>(<span class=
"org-variable-name">left</span>, <span class=
"org-variable-name">right</span>) {
<span class="linenr">4138: </span>    <span class=
"org-keyword">return</span> {
<span class=
"linenr">4139: </span>      type: NodeTypes.JS_ASSIGNMENT_EXPRESSION,
<span class="linenr">4140: </span>      left,
<span class="linenr">4141: </span>      right,
<span class="linenr">4142: </span>      loc: locStub
<span class="linenr">4143: </span>    }
<span class="linenr">4144: </span>  }
<span class="linenr">4145: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">createSequenceExpression</span>(<span class=
"org-variable-name">expressions</span>) {
<span class="linenr">4146: </span>    <span class=
"org-keyword">return</span> {
<span class=
"linenr">4147: </span>      type: NodeTypes.JS_SEQUENCE_EXPRESSION,
<span class="linenr">4148: </span>      expressions,
<span class="linenr">4149: </span>      loc: locStub
<span class="linenr">4150: </span>    }
<span class="linenr">4151: </span>  }
<span class="linenr">4152: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">createReturnStatement</span>(<span class=
"org-variable-name">returns</span>) {
<span class="linenr">4153: </span>    <span class=
"org-keyword">return</span> {
<span class=
"linenr">4154: </span>      type: NodeTypes.JS_RETURN_STATEMENT,
<span class="linenr">4155: </span>      returns,
<span class="linenr">4156: </span>      loc: locStub
<span class="linenr">4157: </span>    }
<span class="linenr">4158: </span>  }
<span class="linenr">4159: </span>  
<span class="linenr">4160: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">transform</span>(<span class=
"org-variable-name">root</span>, <span class=
"org-variable-name">options</span>) {
<span class="linenr">4161: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">transform 上下文</span>
<span class="linenr">4162: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">context</span> = createTransformContext(root, options)
<span class="linenr">4163: </span>  
<span class="linenr">4164: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">递归遍历整个 ast root 树，最终为每颗子树生成 codegenNode</span>
<span class="linenr">4165: </span>    traverseNode(root, context)
<span class="linenr">4166: </span>  
<span class="linenr">4167: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">静态提升处理</span>
<span class="linenr">4168: </span>    <span class=
"org-keyword">if</span> (options.hoistStatic) {
<span class="linenr">4169: </span>      hoistStatic(root, context)
<span class="linenr">4170: </span>    }
<span class="linenr">4171: </span>  
<span class="linenr">4172: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">创建 root codegenNode 代码</span>
<span class="linenr">4173: </span>    <span class=
"org-keyword">if</span> (!options.ssr) {
<span class=
"linenr">4174: </span>      createRootCodegen(root, context)
<span class="linenr">4175: </span>    }
<span class="linenr">4176: </span>  
<span class="linenr">4177: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">finalize meta information</span>
<span class=
"linenr">4178: </span>    root.helpers = [...context.helpers.keys()]
<span class=
"linenr">4179: </span>    root.components = [...context.components]
<span class=
"linenr">4180: </span>    root.directives = [...context.directives]
<span class=
"linenr">4181: </span>    root.imports = context.imports
<span class="linenr">4182: </span>    root.hoists = context.hoists
<span class="linenr">4183: </span>    root.temps = context.temps
<span class="linenr">4184: </span>    root.cached = context.cached
<span class="linenr">4185: </span>  }
<span class="linenr">4186: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">getBaseTransformPreset</span>(<span class=
"org-variable-name">prefixIdentifiers</span>) {
<span class="linenr">4187: </span>    <span class=
"org-keyword">return</span> [
<span class="linenr">4188: </span>      [
<span class="linenr">4189: </span>        transformOnce,
<span class="linenr">4190: </span>        transformIf,
<span class="linenr">4191: </span>        transformMemo,
<span class="linenr">4192: </span>        transformFor,
<span class=
"linenr">4193: </span>        ...(!__BROWSER__ &amp;& prefixIdentifiers
<span class="linenr">4194: </span>          ? [
<span class="linenr">4195: </span>              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">order is important</span>
<span class=
"linenr">4196: </span>              trackVForSlotScopes,
<span class="linenr">4197: </span>              transformExpression
<span class="linenr">4198: </span>            ]
<span class=
"linenr">4199: </span>          : __BROWSER__ &amp;& __DEV__
<span class="linenr">4200: </span>          ? [transformExpression]
<span class="linenr">4201: </span>          : []),
<span class="linenr">4202: </span>        transformSlotOutlet,
<span class="linenr">4203: </span>        transformElement,
<span class="linenr">4204: </span>        trackSlotScopes,
<span class="linenr">4205: </span>        transformText
<span class="linenr">4206: </span>      ],
<span class="linenr">4207: </span>      {
<span class="linenr">4208: </span>        on: transformOn,
<span class="linenr">4209: </span>        bind: transformBind,
<span class="linenr">4210: </span>        model: transformModel
<span class="linenr">4211: </span>      }
<span class="linenr">4212: </span>    ]
<span class="linenr">4213: </span>  }
<span class="linenr">4214: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">createCodegenContext</span>(
<span class="linenr">4215: </span>    <span class=
"org-variable-name">ast</span>,
<span class="linenr">4216: </span>    {
<span class="linenr">4217: </span>      mode = <span class=
"org-string">'function'</span>,
<span class=
"linenr">4218: </span>      prefixIdentifiers = mode === <span class="org-string">'module'</span>,
<span class="linenr">4219: </span>      sourceMap = <span class=
"org-constant">false</span>,
<span class="linenr">4220: </span>      filename = <span class=
"org-string">`template.vue.html`</span>,
<span class="linenr">4221: </span>      scopeId = <span class=
"org-constant">null</span>,
<span class=
"linenr">4222: </span>      optimizeImports = <span class=
"org-constant">false</span>,
<span class=
"linenr">4223: </span>      runtimeGlobalName = <span class=
"org-string">`Vue`</span>,
<span class=
"linenr">4224: </span>      runtimeModuleName = <span class=
"org-string">`vue`</span>,
<span class=
"linenr">4225: </span>      ssrRuntimeModuleName = <span class=
"org-string">'vue/server-renderer'</span>,
<span class="linenr">4226: </span>      ssr = <span class=
"org-constant">false</span>,
<span class="linenr">4227: </span>      isTS = <span class=
"org-constant">false</span>,
<span class="linenr">4228: </span>      inSSR = <span class=
"org-constant">false</span>
<span class="linenr">4229: </span>    }
<span class="linenr">4230: </span>  ) {
<span class="linenr">4231: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">context</span> = {
<span class="linenr">4232: </span>      mode,
<span class="linenr">4233: </span>      prefixIdentifiers,
<span class="linenr">4234: </span>      sourceMap,
<span class="linenr">4235: </span>      filename,
<span class="linenr">4236: </span>      scopeId,
<span class="linenr">4237: </span>      optimizeImports,
<span class="linenr">4238: </span>      runtimeGlobalName,
<span class="linenr">4239: </span>      runtimeModuleName,
<span class="linenr">4240: </span>      ssrRuntimeModuleName,
<span class="linenr">4241: </span>      ssr,
<span class="linenr">4242: </span>      isTS,
<span class="linenr">4243: </span>      inSSR,
<span class="linenr">4244: </span>      source: ast.loc.source,
<span class="linenr">4245: </span>      code: <span class=
"org-string">``</span>,
<span class="linenr">4246: </span>      column: <span class=
"org-highlight-numbers-number">1</span>,
<span class="linenr">4247: </span>      line: <span class=
"org-highlight-numbers-number">1</span>,
<span class="linenr">4248: </span>      offset: <span class=
"org-highlight-numbers-number">0</span>,
<span class="linenr">4249: </span>      indentLevel: <span class=
"org-highlight-numbers-number">0</span>,
<span class="linenr">4250: </span>      pure: <span class=
"org-constant">false</span>,
<span class="linenr">4251: </span>      map: <span class=
"org-constant">undefined</span>,
<span class="linenr">4252: </span>      helper(key) {
<span class="linenr">4253: </span>        <span class=
"org-keyword">return</span> <span class=
"org-string">`_${helperNameMap[key]}`</span>
<span class="linenr">4254: </span>      },
<span class="linenr">4255: </span>      push(code, node) {
<span class="linenr">4256: </span>        context.code += code
<span class="linenr">4257: </span>        <span class=
"org-keyword">if</span> (!__BROWSER__ &amp;& context.map) {
<span class="linenr">4258: </span>          <span class=
"org-keyword">if</span> (node) {
<span class="linenr">4259: </span>            <span class=
"org-keyword">let</span> <span class=
"org-variable-name">name</span>
<span class="linenr">4260: </span>            <span class=
"org-keyword">if</span> (node.type === NodeTypes.SIMPLE_EXPRESSION &amp;& !node.isStatic) {
<span class="linenr">4261: </span>              <span class=
"org-keyword">const</span> <span class=
"org-variable-name">content</span> = node.content.replace(<span class="org-string">/^_ctx\./</span>, <span class="org-string">''</span>)
<span class="linenr">4262: </span>              <span class=
"org-keyword">if</span> (content !== node.content &amp;& isSimpleIdentifier(content)) {
<span class="linenr">4263: </span>                name = content
<span class="linenr">4264: </span>              }
<span class="linenr">4265: </span>            }
<span class=
"linenr">4266: </span>            addMapping(node.loc.start, name)
<span class="linenr">4267: </span>          }
<span class=
"linenr">4268: </span>          advancePositionWithMutation(context, code)
<span class="linenr">4269: </span>          <span class=
"org-keyword">if</span> (node &amp;& node.loc !== locStub) {
<span class=
"linenr">4270: </span>            addMapping(node.loc.end)
<span class="linenr">4271: </span>          }
<span class="linenr">4272: </span>        }
<span class="linenr">4273: </span>      },
<span class="linenr">4274: </span>      indent() {
<span class=
"linenr">4275: </span>        newline(++context.indentLevel)
<span class="linenr">4276: </span>      },
<span class=
"linenr">4277: </span>      deindent(withoutNewLine = <span class=
"org-constant">false</span>) {
<span class="linenr">4278: </span>        <span class=
"org-keyword">if</span> (withoutNewLine) {
<span class="linenr">4279: </span>          --context.indentLevel
<span class="linenr">4280: </span>        } <span class=
"org-keyword">else</span> {
<span class=
"linenr">4281: </span>          newline(--context.indentLevel)
<span class="linenr">4282: </span>        }
<span class="linenr">4283: </span>      },
<span class="linenr">4284: </span>      newline() {
<span class=
"linenr">4285: </span>        newline(context.indentLevel)
<span class="linenr">4286: </span>      }
<span class="linenr">4287: </span>    }
<span class="linenr">4288: </span>  
<span class="linenr">4289: </span>    <span class=
"org-keyword">function</span> <span class=
"org-function-name">newline</span>(<span class=
"org-variable-name">n</span>) {
<span class="linenr">4290: </span>      context.push(<span class=
"org-string">'\n'</span> + <span class=
"org-string">`  `</span>.repeat(n))
<span class="linenr">4291: </span>    }
<span class="linenr">4292: </span>  
<span class="linenr">4293: </span>    <span class=
"org-keyword">function</span> <span class=
"org-function-name">addMapping</span>(<span class=
"org-variable-name">loc</span>, <span class=
"org-variable-name">name</span>) {
<span class="linenr">4294: </span>      context.map.addMapping({
<span class="linenr">4295: </span>        name,
<span class="linenr">4296: </span>        source: context.filename,
<span class="linenr">4297: </span>        original: {
<span class="linenr">4298: </span>          line: loc.line,
<span class=
"linenr">4299: </span>          column: loc.column - <span class=
"org-highlight-numbers-number">1</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">source-map column is 0 based</span>
<span class="linenr">4300: </span>        },
<span class="linenr">4301: </span>        generated: {
<span class="linenr">4302: </span>          line: context.line,
<span class=
"linenr">4303: </span>          column: context.column - <span class="org-highlight-numbers-number">1</span>
<span class="linenr">4304: </span>        }
<span class="linenr">4305: </span>      })
<span class="linenr">4306: </span>    }
<span class="linenr">4307: </span>  
<span class="linenr">4308: </span>    <span class=
"org-keyword">return</span> context
<span class="linenr">4309: </span>  }
<span class="linenr">4310: </span>  
<span class="linenr">4311: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">genModulePreamble</span>(<span class=
"org-variable-name">ast</span>, <span class=
"org-variable-name">context</span>, <span class=
"org-variable-name">genScopeId</span>, <span class=
"org-variable-name">inline</span>) {
<span class="linenr">4312: </span>    <span class=
"org-keyword">const</span> {
<span class="linenr">4313: </span>      push,
<span class="linenr">4314: </span>      newline,
<span class="linenr">4315: </span>      optimizeImports,
<span class="linenr">4316: </span>      runtimeModuleName,
<span class="linenr">4317: </span>      ssrRuntimeModuleName
<span class="linenr">4318: </span>    } = context
<span class="linenr">4319: </span>  
<span class="linenr">4320: </span>    <span class=
"org-keyword">if</span> (genScopeId &amp;& ast.hoists.length) {
<span class=
"linenr">4321: </span>      ast.helpers.push(PUSH_SCOPE_ID, POP_SCOPE_ID)
<span class="linenr">4322: </span>    }
<span class="linenr">4323: </span>  
<span class="linenr">4324: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">generate import statements for helpers</span>
<span class="linenr">4325: </span>    <span class=
"org-keyword">if</span> (ast.helpers.length) {
<span class="linenr">4326: </span>      <span class=
"org-keyword">if</span> (optimizeImports) {
<span class="linenr">4327: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">when bundled with webpack with code-split, calling an import binding</span>
<span class="linenr">4328: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">as a function leads to it being wrapped with `Object(a.b)` or `(0,a.b)`,</span>
<span class="linenr">4329: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">incurring both payload size increase and potential perf overhead.</span>
<span class="linenr">4330: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">therefore we assign the imports to variables (which is a constant ~50b</span>
<span class="linenr">4331: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">cost per-component instead of scaling with template size)</span>
<span class="linenr">4332: </span>        push(
<span class="linenr">4333: </span>          <span class=
"org-string">`import { ${ast.helpers</span>
<span class="linenr">4334: </span><span class=
"org-string">            .map(s =&gt; helperNameMap[s])</span>
<span class="linenr">4335: </span><span class=
"org-string">            .join(', ')} } from ${JSON.stringify(runtimeModuleName)}\n`</span>
<span class="linenr">4336: </span>        )
<span class="linenr">4337: </span>        push(
<span class="linenr">4338: </span>          <span class=
"org-string">`\n// Binding optimization for webpack code-split\nconst ${ast.helpers</span>
<span class="linenr">4339: </span><span class=
"org-string">            .map(s =&gt; `</span>_${helperNameMap[s]} = ${helperNameMap[s]}<span class="org-string">`)</span>
<span class="linenr">4340: </span><span class=
"org-string">            .join(', ')}\n`</span>
<span class="linenr">4341: </span>        )
<span class="linenr">4342: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr">4343: </span>        push(
<span class="linenr">4344: </span>          <span class=
"org-string">`import { ${ast.helpers</span>
<span class="linenr">4345: </span><span class=
"org-string">            .map(s =&gt; `</span>${helperNameMap[s]} as _${helperNameMap[s]}<span class="org-string">`)</span>
<span class="linenr">4346: </span><span class=
"org-string">            .join(', ')} } from ${JSON.stringify(runtimeModuleName)}\n`</span>
<span class="linenr">4347: </span>        )
<span class="linenr">4348: </span>      }
<span class="linenr">4349: </span>    }
<span class="linenr">4350: </span>  
<span class="linenr">4351: </span>    <span class=
"org-keyword">if</span> (ast.ssrHelpers &amp;& ast.ssrHelpers.length) {
<span class="linenr">4352: </span>      push(
<span class="linenr">4353: </span>        <span class=
"org-string">`import { ${ast.ssrHelpers</span>
<span class="linenr">4354: </span><span class=
"org-string">          .map(s =&gt; `</span>${helperNameMap[s]} as _${helperNameMap[s]}<span class="org-string">`)</span>
<span class="linenr">4355: </span><span class=
"org-string">          .join(', ')} } from "${ssrRuntimeModuleName}"\n`</span>
<span class="linenr">4356: </span>      )
<span class="linenr">4357: </span>    }
<span class="linenr">4358: </span>  
<span class="linenr">4359: </span>    <span class=
"org-keyword">if</span> (ast.imports.length) {
<span class=
"linenr">4360: </span>      genImports(ast.imports, context)
<span class="linenr">4361: </span>      newline()
<span class="linenr">4362: </span>    }
<span class="linenr">4363: </span>  
<span class=
"linenr">4364: </span>    genHoists(ast.hoists, context)
<span class="linenr">4365: </span>    newline()
<span class="linenr">4366: </span>  
<span class="linenr">4367: </span>    <span class=
"org-keyword">if</span> (!inline) {
<span class="linenr">4368: </span>      push(<span class=
"org-string">`export `</span>)
<span class="linenr">4369: </span>    }
<span class="linenr">4370: </span>  }
<span class="linenr">4371: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">genImports</span>(<span class=
"org-variable-name">importsOptions</span>, <span class=
"org-variable-name">context</span>) {
<span class="linenr">4372: </span>    <span class=
"org-keyword">if</span> (!importsOptions.length) {
<span class="linenr">4373: </span>      <span class=
"org-keyword">return</span>
<span class="linenr">4374: </span>    }
<span class=
"linenr">4375: </span>    importsOptions.forEach(imports =&gt; {
<span class="linenr">4376: </span>      context.push(<span class=
"org-string">`import `</span>)
<span class=
"linenr">4377: </span>      genNode(imports.exp, context)
<span class="linenr">4378: </span>      context.push(<span class=
"org-string">` from '${imports.path}'`</span>)
<span class="linenr">4379: </span>      context.newline()
<span class="linenr">4380: </span>    })
<span class="linenr">4381: </span>  }
<span class="linenr">4382: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">genFunctionPreamble</span>(<span class=
"org-variable-name">ast</span>, <span class=
"org-variable-name">context</span>) {
<span class="linenr">4383: </span>    <span class=
"org-keyword">const</span> {
<span class="linenr">4384: </span>      ssr,
<span class="linenr">4385: </span>      prefixIdentifiers,
<span class="linenr">4386: </span>      push,
<span class="linenr">4387: </span>      newline,
<span class="linenr">4388: </span>      runtimeModuleName,
<span class="linenr">4389: </span>      runtimeGlobalName,
<span class="linenr">4390: </span>      ssrRuntimeModuleName
<span class="linenr">4391: </span>    } = context
<span class="linenr">4392: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">VueBinding</span> =
<span class="linenr">4393: </span>      !__BROWSER__ &amp;& ssr
<span class="linenr">4394: </span>        ? <span class=
"org-string">`require(${JSON.stringify(runtimeModuleName)})`</span>
<span class="linenr">4395: </span>        : runtimeGlobalName
<span class="linenr">4396: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">aliasHelper</span> = (s) =&gt; <span class=
"org-string">`${helperNameMap[s]}: _${helperNameMap[s]}`</span>
<span class="linenr">4397: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">Generate const declaration for helpers</span>
<span class="linenr">4398: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">In prefix mode, we place the const declaration at top so it's done</span>
<span class="linenr">4399: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">only once; But if we not prefixing, we place the declaration inside the</span>
<span class="linenr">4400: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">with block so it doesn't incur the `in` check cost for every helper access.</span>
<span class="linenr">4401: </span>    <span class=
"org-keyword">if</span> (ast.helpers.length &gt; <span class=
"org-highlight-numbers-number">0</span>) {
<span class="linenr">4402: </span>      <span class=
"org-keyword">if</span> (!__BROWSER__ &amp;& prefixIdentifiers) {
<span class="linenr">4403: </span>        push(
<span class="linenr">4404: </span>          <span class=
"org-string">`const { ${ast.helpers.map(aliasHelper).join(', ')} } = ${VueBinding}\n`</span>
<span class="linenr">4405: </span>        )
<span class="linenr">4406: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr">4407: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">"with" mode.</span>
<span class="linenr">4408: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">save Vue in a separate variable to avoid collision</span>
<span class="linenr">4409: </span>        push(<span class=
"org-string">`const _Vue = ${VueBinding}\n`</span>)
<span class="linenr">4410: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">in "with" mode, helpers are declared inside the with block to avoid</span>
<span class="linenr">4411: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">has check cost, but hoists are lifted out of the function - we need</span>
<span class="linenr">4412: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">to provide the helper here.</span>
<span class="linenr">4413: </span>        <span class=
"org-keyword">if</span> (ast.hoists.length) {
<span class="linenr">4414: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">staticHelpers</span> = [
<span class="linenr">4415: </span>            CREATE_VNODE,
<span class="linenr">4416: </span>            CREATE_ELEMENT_VNODE,
<span class="linenr">4417: </span>            CREATE_COMMENT,
<span class="linenr">4418: </span>            CREATE_TEXT,
<span class="linenr">4419: </span>            CREATE_STATIC
<span class="linenr">4420: </span>          ]
<span class=
"linenr">4421: </span>            .filter(helper =&gt; ast.helpers.includes(helper))
<span class="linenr">4422: </span>            .map(aliasHelper)
<span class="linenr">4423: </span>            .join(<span class=
"org-string">', '</span>)
<span class="linenr">4424: </span>          push(<span class=
"org-string">`const { ${staticHelpers} } = _Vue\n`</span>)
<span class="linenr">4425: </span>        }
<span class="linenr">4426: </span>      }
<span class="linenr">4427: </span>    }
<span class="linenr">4428: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">generate variables for ssr helpers</span>
<span class="linenr">4429: </span>    <span class=
"org-keyword">if</span> (!__BROWSER__ &amp;& ast.ssrHelpers &amp;& ast.ssrHelpers.length) {
<span class="linenr">4430: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">ssr guarantees prefixIdentifier: true</span>
<span class="linenr">4431: </span>      push(
<span class="linenr">4432: </span>        <span class=
"org-string">`const { ${ast.ssrHelpers</span>
<span class="linenr">4433: </span><span class=
"org-string">          .map(aliasHelper)</span>
<span class="linenr">4434: </span><span class=
"org-string">          .join(', ')} } = require("${ssrRuntimeModuleName}")\n`</span>
<span class="linenr">4435: </span>      )
<span class="linenr">4436: </span>    }
<span class=
"linenr">4437: </span>    genHoists(ast.hoists, context)
<span class="linenr">4438: </span>    newline()
<span class="linenr">4439: </span>    push(<span class=
"org-string">`return `</span>)
<span class="linenr">4440: </span>  }
<span class="linenr">4441: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">genHoists</span>(<span class=
"org-variable-name">hoists</span>, <span class=
"org-variable-name">context</span>) {
<span class="linenr">4442: </span>    <span class=
"org-keyword">if</span> (!hoists.length) {
<span class="linenr">4443: </span>      <span class=
"org-keyword">return</span>
<span class="linenr">4444: </span>    }
<span class="linenr">4445: </span>    context.pure = <span class=
"org-constant">true</span>
<span class="linenr">4446: </span>    <span class=
"org-keyword">const</span> { push, newline, helper, scopeId, mode } = context
<span class="linenr">4447: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">genScopeId</span> = !__BROWSER__ &amp;& scopeId != <span class="org-constant">null</span> &amp;& mode !== <span class="org-string">'function'</span>
<span class="linenr">4448: </span>    newline()
<span class="linenr">4449: </span>  
<span class="linenr">4450: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">generate inlined withScopeId helper</span>
<span class="linenr">4451: </span>    <span class=
"org-keyword">if</span> (genScopeId) {
<span class="linenr">4452: </span>      push(
<span class="linenr">4453: </span>        <span class=
"org-string">`const _withScopeId = n =&gt; (${helper(</span>
<span class="linenr">4454: </span><span class=
"org-string">          PUSH_SCOPE_ID</span>
<span class="linenr">4455: </span><span class=
"org-string">        )}("${scopeId}"),n=n(),${helper(POP_SCOPE_ID)}(),n)`</span>
<span class="linenr">4456: </span>      )
<span class="linenr">4457: </span>      newline()
<span class="linenr">4458: </span>    }
<span class="linenr">4459: </span>  
<span class="linenr">4460: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; hoists.length; i++) {
<span class="linenr">4461: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">exp</span> = hoists[i]
<span class="linenr">4462: </span>      <span class=
"org-keyword">if</span> (exp) {
<span class="linenr">4463: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">needScopeIdWrapper</span> = genScopeId &amp;& exp.type === NodeTypes.VNODE_CALL
<span class="linenr">4464: </span>        push(
<span class="linenr">4465: </span>          <span class=
"org-string">`const _hoisted_${i + 1} = ${</span>
<span class="linenr">4466: </span><span class=
"org-string">            needScopeIdWrapper ? `</span>${PURE_ANNOTATION} _withScopeId(() =&gt; <span class="org-string">` : ``</span>
<span class="linenr">4467: </span><span class=
"org-string">          }`</span>
<span class="linenr">4468: </span>        )
<span class="linenr">4469: </span>        genNode(exp, context)
<span class="linenr">4470: </span>        <span class=
"org-keyword">if</span> (needScopeIdWrapper) {
<span class="linenr">4471: </span>          push(<span class=
"org-string">`)`</span>)
<span class="linenr">4472: </span>        }
<span class="linenr">4473: </span>        newline()
<span class="linenr">4474: </span>      }
<span class="linenr">4475: </span>    }
<span class="linenr">4476: </span>  
<span class="linenr">4477: </span>    context.pure = <span class=
"org-constant">false</span>
<span class="linenr">4478: </span>  }
<span class="linenr">4479: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">type = 'component' | 'directive' | 'filter'</span>
<span class="linenr">4480: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">genAssets</span>(<span class=
"org-variable-name">assets</span>, <span class=
"org-variable-name">type</span>, { <span class=
"org-variable-name">helper</span>, <span class=
"org-variable-name">push</span>, <span class=
"org-variable-name">newline</span>, <span class=
"org-variable-name">isTS</span> }) {
<span class="linenr">4481: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">resolver</span> = helper(
<span class="linenr">4482: </span>      type === <span class=
"org-string">'component'</span>
<span class="linenr">4483: </span>        ? RESOLVE_COMPONENT
<span class="linenr">4484: </span>        : RESOLVE_DIRECTIVE
<span class="linenr">4485: </span>    )
<span class="linenr">4486: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; assets.length; i++) {
<span class="linenr">4487: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">id</span> = assets[i]
<span class="linenr">4488: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">potential component implicit self-reference inferred from SFC filename</span>
<span class="linenr">4489: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">maybeSelfReference</span> = id.endsWith(<span class="org-string">'__self'</span>)
<span class="linenr">4490: </span>      <span class=
"org-keyword">if</span> (maybeSelfReference) {
<span class=
"linenr">4491: </span>        id = id.slice(<span class="org-highlight-numbers-number">0</span>, -<span class="org-highlight-numbers-number">6</span>)
<span class="linenr">4492: </span>      }
<span class="linenr">4493: </span>      push(
<span class="linenr">4494: </span>        <span class=
"org-string">`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${</span>
<span class="linenr">4495: </span><span class=
"org-string">          maybeSelfReference ? `</span>, <span class=
"org-constant">true</span><span class="org-string">` : ``</span>
<span class="linenr">4496: </span><span class=
"org-string">        })${isTS ? `</span>!<span class=
"org-string">` : ``}`</span>
<span class="linenr">4497: </span>      )
<span class="linenr">4498: </span>      <span class=
"org-keyword">if</span> (i &lt; assets.length - <span class=
"org-highlight-numbers-number">1</span>) {
<span class="linenr">4499: </span>        newline()
<span class="linenr">4500: </span>      }
<span class="linenr">4501: </span>    }
<span class="linenr">4502: </span>  }
<span class="linenr">4503: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">genText</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
<span class=
"linenr">4504: </span>    context.push(JSON.stringify(node.content), node)
<span class="linenr">4505: </span>  }
<span class="linenr">4506: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">genExpression</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
<span class="linenr">4507: </span>    <span class=
"org-keyword">const</span> { content, isStatic } = node
<span class=
"linenr">4508: </span>    context.push(isStatic ? JSON.stringify(content) : content, node)
<span class="linenr">4509: </span>  }
<span class="linenr">4510: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">genInterpolation</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
<span class="linenr">4511: </span>    <span class=
"org-keyword">const</span> { push, helper, pure } = context
<span class="linenr">4512: </span>    <span class=
"org-keyword">if</span> (pure) push(PURE_ANNOTATION)
<span class="linenr">4513: </span>    push(<span class=
"org-string">`${helper(TO_DISPLAY_STRING)}(`</span>)
<span class=
"linenr">4514: </span>    genNode(node.content, context)
<span class="linenr">4515: </span>    push(<span class=
"org-string">`)`</span>)
<span class="linenr">4516: </span>  }
<span class="linenr">4517: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">genCompoundExpression</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
<span class="linenr">4518: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; node.children.length; i++) {
<span class="linenr">4519: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">child</span> = node.children[i]
<span class="linenr">4520: </span>      <span class=
"org-keyword">if</span> (isString(child)) {
<span class="linenr">4521: </span>        context.push(child)
<span class="linenr">4522: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr">4523: </span>        genNode(child, context)
<span class="linenr">4524: </span>      }
<span class="linenr">4525: </span>    }
<span class="linenr">4526: </span>  }
<span class="linenr">4527: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">genComment</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
<span class="linenr">4528: </span>    <span class=
"org-keyword">const</span> { push, helper, pure } = context
<span class="linenr">4529: </span>    <span class=
"org-keyword">if</span> (pure) {
<span class="linenr">4530: </span>      push(PURE_ANNOTATION)
<span class="linenr">4531: </span>    }
<span class="linenr">4532: </span>    push(<span class=
"org-string">`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`</span>, node)
<span class="linenr">4533: </span>  }
<span class="linenr">4534: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">genVNodeCall</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
<span class="linenr">4535: </span>    <span class=
"org-keyword">const</span> { push, helper, pure } = context
<span class="linenr">4536: </span>    <span class=
"org-keyword">const</span> {
<span class="linenr">4537: </span>      tag,
<span class="linenr">4538: </span>      props,
<span class="linenr">4539: </span>      children,
<span class="linenr">4540: </span>      patchFlag,
<span class="linenr">4541: </span>      dynamicProps,
<span class="linenr">4542: </span>      directives,
<span class="linenr">4543: </span>      isBlock,
<span class="linenr">4544: </span>      disableTracking,
<span class="linenr">4545: </span>      isComponent
<span class="linenr">4546: </span>    } = node
<span class="linenr">4547: </span>    <span class=
"org-keyword">if</span> (directives) {
<span class=
"linenr">4548: </span>      push(helper(WITH_DIRECTIVES) + <span class="org-string">`(`</span>)
<span class="linenr">4549: </span>    }
<span class="linenr">4550: </span>    <span class=
"org-keyword">if</span> (isBlock) {
<span class="linenr">4551: </span>      push(<span class=
"org-string">`(${helper(OPEN_BLOCK)}(${disableTracking ? `</span><span class="org-constant">true</span><span class="org-string">` : ``}), `</span>)
<span class="linenr">4552: </span>    }
<span class="linenr">4553: </span>    <span class=
"org-keyword">if</span> (pure) {
<span class="linenr">4554: </span>      push(PURE_ANNOTATION)
<span class="linenr">4555: </span>    }
<span class="linenr">4556: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">callHelper</span> = isBlock
<span class=
"linenr">4557: </span>      ? getVNodeBlockHelper(context.inSSR, isComponent)
<span class=
"linenr">4558: </span>      : getVNodeHelper(context.inSSR, isComponent)
<span class=
"linenr">4559: </span>    push(helper(callHelper) + <span class=
"org-string">`(`</span>, node)
<span class="linenr">4560: </span>    genNodeList(
<span class=
"linenr">4561: </span>      genNullableArgs([tag, props, children, patchFlag, dynamicProps]),
<span class="linenr">4562: </span>      context
<span class="linenr">4563: </span>    )
<span class="linenr">4564: </span>    push(<span class=
"org-string">`)`</span>)
<span class="linenr">4565: </span>    <span class=
"org-keyword">if</span> (isBlock) {
<span class="linenr">4566: </span>      push(<span class=
"org-string">`)`</span>)
<span class="linenr">4567: </span>    }
<span class="linenr">4568: </span>    <span class=
"org-keyword">if</span> (directives) {
<span class="linenr">4569: </span>      push(<span class=
"org-string">`, `</span>)
<span class=
"linenr">4570: </span>      genNode(directives, context)
<span class="linenr">4571: </span>      push(<span class=
"org-string">`)`</span>)
<span class="linenr">4572: </span>    }
<span class="linenr">4573: </span>  }
<span class="linenr">4574: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">JavaScript</span>
<span class="linenr">4575: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">genCallExpression</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
<span class="linenr">4576: </span>    <span class=
"org-keyword">const</span> { push, helper, pure } = context
<span class="linenr">4577: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">callee</span> = isString(node.callee) ? node.callee : helper(node.callee)
<span class="linenr">4578: </span>    <span class=
"org-keyword">if</span> (pure) {
<span class="linenr">4579: </span>      push(PURE_ANNOTATION)
<span class="linenr">4580: </span>    }
<span class="linenr">4581: </span>    push(callee + <span class=
"org-string">`(`</span>, node)
<span class="linenr">4582: </span>    genNodeList(node.<span class=
"org-constant">arguments</span>, context)
<span class="linenr">4583: </span>    push(<span class=
"org-string">`)`</span>)
<span class="linenr">4584: </span>  }
<span class="linenr">4585: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">genObjectExpression</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
<span class="linenr">4586: </span>    <span class=
"org-keyword">const</span> { push, indent, deindent, newline } = context
<span class="linenr">4587: </span>    <span class=
"org-keyword">const</span> { properties } = node
<span class="linenr">4588: </span>    <span class=
"org-keyword">if</span> (!properties.length) {
<span class="linenr">4589: </span>      push(<span class=
"org-string">`{}`</span>, node)
<span class="linenr">4590: </span>      <span class=
"org-keyword">return</span>
<span class="linenr">4591: </span>    }
<span class="linenr">4592: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">multilines</span> =
<span class=
"linenr">4593: </span>      properties.length &gt; <span class=
"org-highlight-numbers-number">1</span> ||
<span class=
"linenr">4594: </span>      ((!__BROWSER__ || __DEV__) &amp;&
<span class=
"linenr">4595: </span>        properties.some(p =&gt; p.value.type !== NodeTypes.SIMPLE_EXPRESSION))
<span class=
"linenr">4596: </span>    push(multilines ? <span class="org-string">`{`</span> : <span class="org-string">`{ `</span>)
<span class="linenr">4597: </span>    multilines &amp;& indent()
<span class="linenr">4598: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; properties.length; i++) {
<span class="linenr">4599: </span>      <span class=
"org-keyword">const</span> { key, value } = properties[i]
<span class="linenr">4600: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">key</span>
<span class=
"linenr">4601: </span>      genExpressionAsPropertyKey(key, context)
<span class="linenr">4602: </span>      push(<span class=
"org-string">`: `</span>)
<span class="linenr">4603: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">value</span>
<span class="linenr">4604: </span>      genNode(value, context)
<span class="linenr">4605: </span>      <span class=
"org-keyword">if</span> (i &lt; properties.length - <span class=
"org-highlight-numbers-number">1</span>) {
<span class="linenr">4606: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">will only reach this if it's multilines</span>
<span class="linenr">4607: </span>        push(<span class=
"org-string">`,`</span>)
<span class="linenr">4608: </span>        newline()
<span class="linenr">4609: </span>      }
<span class="linenr">4610: </span>    }
<span class="linenr">4611: </span>    multilines &amp;& deindent()
<span class=
"linenr">4612: </span>    push(multilines ? <span class="org-string">`}`</span> : <span class="org-string">` }`</span>)
<span class="linenr">4613: </span>  }
<span class="linenr">4614: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">genArrayExpression</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
<span class=
"linenr">4615: </span>    genNodeListAsArray(node.elements, context)
<span class="linenr">4616: </span>  }
<span class="linenr">4617: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">genFunctionExpression</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
<span class="linenr">4618: </span>    <span class=
"org-keyword">const</span> { push, indent, deindent } = context
<span class="linenr">4619: </span>    <span class=
"org-keyword">const</span> { params, returns, body, newline, isSlot } = node
<span class="linenr">4620: </span>    <span class=
"org-keyword">if</span> (isSlot) {
<span class="linenr">4621: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">wrap slot functions with owner context</span>
<span class="linenr">4622: </span>      push(<span class=
"org-string">`_${helperNameMap[WITH_CTX]}(`</span>)
<span class="linenr">4623: </span>    }
<span class="linenr">4624: </span>    push(<span class=
"org-string">`(`</span>, node)
<span class="linenr">4625: </span>    <span class=
"org-keyword">if</span> (isArray(params)) {
<span class=
"linenr">4626: </span>      genNodeList(params, context)
<span class="linenr">4627: </span>    } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (params) {
<span class="linenr">4628: </span>      genNode(params, context)
<span class="linenr">4629: </span>    }
<span class="linenr">4630: </span>    push(<span class=
"org-string">`) =&gt; `</span>)
<span class="linenr">4631: </span>    <span class=
"org-keyword">if</span> (newline || body) {
<span class="linenr">4632: </span>      push(<span class=
"org-string">`{`</span>)
<span class="linenr">4633: </span>      indent()
<span class="linenr">4634: </span>    }
<span class="linenr">4635: </span>    <span class=
"org-keyword">if</span> (returns) {
<span class="linenr">4636: </span>      <span class=
"org-keyword">if</span> (newline) {
<span class="linenr">4637: </span>        push(<span class=
"org-string">`return `</span>)
<span class="linenr">4638: </span>      }
<span class="linenr">4639: </span>      <span class=
"org-keyword">if</span> (isArray(returns)) {
<span class=
"linenr">4640: </span>        genNodeListAsArray(returns, context)
<span class="linenr">4641: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr">4642: </span>        genNode(returns, context)
<span class="linenr">4643: </span>      }
<span class="linenr">4644: </span>    } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (body) {
<span class="linenr">4645: </span>      genNode(body, context)
<span class="linenr">4646: </span>    }
<span class="linenr">4647: </span>    <span class=
"org-keyword">if</span> (newline || body) {
<span class="linenr">4648: </span>      deindent()
<span class="linenr">4649: </span>      push(<span class=
"org-string">`}`</span>)
<span class="linenr">4650: </span>    }
<span class="linenr">4651: </span>    <span class=
"org-keyword">if</span> (isSlot) {
<span class="linenr">4652: </span>      push(<span class=
"org-string">`)`</span>)
<span class="linenr">4653: </span>    }
<span class="linenr">4654: </span>  }
<span class="linenr">4655: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">genConditionalExpression</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
<span class="linenr">4656: </span>    <span class=
"org-keyword">const</span> { test, consequent, alternate, newline: needNewline } = node
<span class="linenr">4657: </span>    <span class=
"org-keyword">const</span> { push, indent, deindent, newline } = context
<span class="linenr">4658: </span>    <span class=
"org-keyword">if</span> (test.type === NodeTypes.SIMPLE_EXPRESSION) {
<span class="linenr">4659: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">needsParens</span> = !isSimpleIdentifier(test.content)
<span class=
"linenr">4660: </span>      needsParens &amp;& push(<span class=
"org-string">`(`</span>)
<span class=
"linenr">4661: </span>      genExpression(test, context)
<span class=
"linenr">4662: </span>      needsParens &amp;& push(<span class=
"org-string">`)`</span>)
<span class="linenr">4663: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr">4664: </span>      push(<span class=
"org-string">`(`</span>)
<span class="linenr">4665: </span>      genNode(test, context)
<span class="linenr">4666: </span>      push(<span class=
"org-string">`)`</span>)
<span class="linenr">4667: </span>    }
<span class="linenr">4668: </span>    needNewline &amp;& indent()
<span class="linenr">4669: </span>    context.indentLevel++
<span class=
"linenr">4670: </span>    needNewline || push(<span class=
"org-string">` `</span>)
<span class="linenr">4671: </span>    push(<span class=
"org-string">`? `</span>)
<span class="linenr">4672: </span>    genNode(consequent, context)
<span class="linenr">4673: </span>    context.indentLevel--
<span class="linenr">4674: </span>    needNewline &amp;& newline()
<span class=
"linenr">4675: </span>    needNewline || push(<span class=
"org-string">` `</span>)
<span class="linenr">4676: </span>    push(<span class=
"org-string">`: `</span>)
<span class="linenr">4677: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isNested</span> = alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION
<span class="linenr">4678: </span>    <span class=
"org-keyword">if</span> (!isNested) {
<span class="linenr">4679: </span>      context.indentLevel++
<span class="linenr">4680: </span>    }
<span class="linenr">4681: </span>    genNode(alternate, context)
<span class="linenr">4682: </span>    <span class=
"org-keyword">if</span> (!isNested) {
<span class="linenr">4683: </span>      context.indentLevel--
<span class="linenr">4684: </span>    }
<span class=
"linenr">4685: </span>    needNewline &amp;& deindent(<span class=
"org-constant">true</span> <span class=
"org-comment-delimiter">/* </span><span class=
"org-comment">without newline</span><span class=
"org-comment-delimiter"> */</span>)
<span class="linenr">4686: </span>  }
<span class="linenr">4687: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">genCacheExpression</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
<span class="linenr">4688: </span>    <span class=
"org-keyword">const</span> { push, helper, indent, deindent, newline } = context
<span class="linenr">4689: </span>    push(<span class=
"org-string">`_cache[${node.index}] || (`</span>)
<span class="linenr">4690: </span>    <span class=
"org-keyword">if</span> (node.isVNode) {
<span class="linenr">4691: </span>      indent()
<span class="linenr">4692: </span>      push(<span class=
"org-string">`${helper(SET_BLOCK_TRACKING)}(-1),`</span>)
<span class="linenr">4693: </span>      newline()
<span class="linenr">4694: </span>    }
<span class="linenr">4695: </span>    push(<span class=
"org-string">`_cache[${node.index}] = `</span>)
<span class="linenr">4696: </span>    genNode(node.value, context)
<span class="linenr">4697: </span>    <span class=
"org-keyword">if</span> (node.isVNode) {
<span class="linenr">4698: </span>      push(<span class=
"org-string">`,`</span>)
<span class="linenr">4699: </span>      newline()
<span class="linenr">4700: </span>      push(<span class=
"org-string">`${helper(SET_BLOCK_TRACKING)}(1),`</span>)
<span class="linenr">4701: </span>      newline()
<span class="linenr">4702: </span>      push(<span class=
"org-string">`_cache[${node.index}]`</span>)
<span class="linenr">4703: </span>      deindent()
<span class="linenr">4704: </span>    }
<span class="linenr">4705: </span>    push(<span class=
"org-string">`)`</span>)
<span class="linenr">4706: </span>  }
<span class="linenr">4707: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">genNodeList</span>(<span class=
"org-variable-name">nodes</span>, <span class=
"org-variable-name">context</span>, <span class=
"org-variable-name">multilines</span> = <span class=
"org-constant">false</span>, <span class=
"org-variable-name">comma</span> = <span class=
"org-constant">true</span>) {
<span class="linenr">4708: </span>    <span class=
"org-keyword">const</span> { push, newline } = context
<span class="linenr">4709: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; nodes.length; i++) {
<span class="linenr">4710: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">node</span> = nodes[i]
<span class="linenr">4711: </span>      <span class=
"org-keyword">if</span> (isString(node)) {
<span class="linenr">4712: </span>        push(node)
<span class="linenr">4713: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (isArray(node)) {
<span class=
"linenr">4714: </span>        genNodeListAsArray(node, context)
<span class="linenr">4715: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr">4716: </span>        genNode(node, context)
<span class="linenr">4717: </span>      }
<span class="linenr">4718: </span>      <span class=
"org-keyword">if</span> (i &lt; nodes.length - <span class=
"org-highlight-numbers-number">1</span>) {
<span class="linenr">4719: </span>        <span class=
"org-keyword">if</span> (multilines) {
<span class=
"linenr">4720: </span>          comma &amp;& push(<span class=
"org-string">','</span>)
<span class="linenr">4721: </span>          newline()
<span class="linenr">4722: </span>        } <span class=
"org-keyword">else</span> {
<span class=
"linenr">4723: </span>          comma &amp;& push(<span class=
"org-string">', '</span>)
<span class="linenr">4724: </span>        }
<span class="linenr">4725: </span>      }
<span class="linenr">4726: </span>    }
<span class="linenr">4727: </span>  }
<span class="linenr">4728: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">genTemplateLiteral</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
<span class="linenr">4729: </span>    <span class=
"org-keyword">const</span> { push, indent, deindent } = context
<span class="linenr">4730: </span>    push(<span class=
"org-string">'`'</span>)
<span class="linenr">4731: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">l</span> = node.elements.length
<span class="linenr">4732: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">multilines</span> = l &gt; <span class=
"org-highlight-numbers-number">3</span>
<span class="linenr">4733: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; l; i++) {
<span class="linenr">4734: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">e</span> = node.elements[i]
<span class="linenr">4735: </span>      <span class=
"org-keyword">if</span> (isString(e)) {
<span class=
"linenr">4736: </span>        push(e.replace(<span class=
"org-string">/(`|\$|\\)/</span>g, <span class=
"org-string">'\\$1'</span>))
<span class="linenr">4737: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr">4738: </span>        push(<span class=
"org-string">'${'</span>)
<span class="linenr">4739: </span>        <span class=
"org-keyword">if</span> (multilines) indent()
<span class="linenr">4740: </span>        genNode(e, context)
<span class="linenr">4741: </span>        <span class=
"org-keyword">if</span> (multilines) deindent()
<span class="linenr">4742: </span>        push(<span class=
"org-string">'}'</span>)
<span class="linenr">4743: </span>      }
<span class="linenr">4744: </span>    }
<span class="linenr">4745: </span>    push(<span class=
"org-string">'`'</span>)
<span class="linenr">4746: </span>  }
<span class="linenr">4747: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">genIfStatement</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
<span class="linenr">4748: </span>    <span class=
"org-keyword">const</span> { push, indent, deindent } = context
<span class="linenr">4749: </span>    <span class=
"org-keyword">const</span> { test, consequent, alternate } = node
<span class="linenr">4750: </span>    push(<span class=
"org-string">`if (`</span>)
<span class="linenr">4751: </span>    genNode(test, context)
<span class="linenr">4752: </span>    push(<span class=
"org-string">`) {`</span>)
<span class="linenr">4753: </span>    indent()
<span class="linenr">4754: </span>    genNode(consequent, context)
<span class="linenr">4755: </span>    deindent()
<span class="linenr">4756: </span>    push(<span class=
"org-string">`}`</span>)
<span class="linenr">4757: </span>    <span class=
"org-keyword">if</span> (alternate) {
<span class="linenr">4758: </span>      push(<span class=
"org-string">` else `</span>)
<span class="linenr">4759: </span>      <span class=
"org-keyword">if</span> (alternate.type === NodeTypes.JS_IF_STATEMENT) {
<span class=
"linenr">4760: </span>        genIfStatement(alternate, context)
<span class="linenr">4761: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr">4762: </span>        push(<span class=
"org-string">`{`</span>)
<span class="linenr">4763: </span>        indent()
<span class=
"linenr">4764: </span>        genNode(alternate, context)
<span class="linenr">4765: </span>        deindent()
<span class="linenr">4766: </span>        push(<span class=
"org-string">`}`</span>)
<span class="linenr">4767: </span>      }
<span class="linenr">4768: </span>    }
<span class="linenr">4769: </span>  }
<span class="linenr">4770: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">genAssignmentExpression</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
<span class="linenr">4771: </span>    genNode(node.left, context)
<span class="linenr">4772: </span>    context.push(<span class=
"org-string">` = `</span>)
<span class="linenr">4773: </span>    genNode(node.right, context)
<span class="linenr">4774: </span>  }
<span class="linenr">4775: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">genSequenceExpression</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
<span class="linenr">4776: </span>    context.push(<span class=
"org-string">`(`</span>)
<span class=
"linenr">4777: </span>    genNodeList(node.expressions, context)
<span class="linenr">4778: </span>    context.push(<span class=
"org-string">`)`</span>)
<span class="linenr">4779: </span>  }
<span class="linenr">4780: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">genReturnStatement</span>({ returns }, context) {
<span class="linenr">4781: </span>    context.push(<span class=
"org-string">`return `</span>)
<span class="linenr">4782: </span>    <span class=
"org-keyword">if</span> (isArray(returns)) {
<span class=
"linenr">4783: </span>      genNodeListAsArray(returns, context)
<span class="linenr">4784: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr">4785: </span>      genNode(returns, context)
<span class="linenr">4786: </span>    }
<span class="linenr">4787: </span>  }
<span class="linenr">4788: </span>  
<span class="linenr">4789: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">genNode</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
<span class="linenr">4790: </span>    <span class=
"org-keyword">if</span> (isString(node)) {
<span class="linenr">4791: </span>      context.push(node)
<span class="linenr">4792: </span>      <span class=
"org-keyword">return</span>
<span class="linenr">4793: </span>    }
<span class="linenr">4794: </span>    <span class=
"org-keyword">if</span> (isSymbol(node)) {
<span class=
"linenr">4795: </span>      context.push(context.helper(node))
<span class="linenr">4796: </span>      <span class=
"org-keyword">return</span>
<span class="linenr">4797: </span>    }
<span class="linenr">4798: </span>    <span class=
"org-keyword">switch</span> (node.type) {
<span class="linenr">4799: </span>      <span class=
"org-keyword">case</span> NodeTypes.ELEMENT:
<span class="linenr">4800: </span>      <span class=
"org-keyword">case</span> NodeTypes.IF:
<span class="linenr">4801: </span>      <span class=
"org-keyword">case</span> NodeTypes.FOR:
<span class=
"linenr">4802: </span>        genNode(node.codegenNode, context)
<span class="linenr">4803: </span>        <span class=
"org-keyword">break</span>
<span class="linenr">4804: </span>      <span class=
"org-keyword">case</span> NodeTypes.TEXT:
<span class="linenr">4805: </span>        genText(node, context)
<span class="linenr">4806: </span>        <span class=
"org-keyword">break</span>
<span class="linenr">4807: </span>      <span class=
"org-keyword">case</span> NodeTypes.SIMPLE_EXPRESSION:
<span class=
"linenr">4808: </span>        genExpression(node, context)
<span class="linenr">4809: </span>        <span class=
"org-keyword">break</span>
<span class="linenr">4810: </span>      <span class=
"org-keyword">case</span> NodeTypes.INTERPOLATION:
<span class=
"linenr">4811: </span>        genInterpolation(node, context)
<span class="linenr">4812: </span>        <span class=
"org-keyword">break</span>
<span class="linenr">4813: </span>      <span class=
"org-keyword">case</span> NodeTypes.TEXT_CALL:
<span class=
"linenr">4814: </span>        genNode(node.codegenNode, context)
<span class="linenr">4815: </span>        <span class=
"org-keyword">break</span>
<span class="linenr">4816: </span>      <span class=
"org-keyword">case</span> NodeTypes.COMPOUND_EXPRESSION:
<span class=
"linenr">4817: </span>        genCompoundExpression(node, context)
<span class="linenr">4818: </span>        <span class=
"org-keyword">break</span>
<span class="linenr">4819: </span>      <span class=
"org-keyword">case</span> NodeTypes.COMMENT:
<span class="linenr">4820: </span>        genComment(node, context)
<span class="linenr">4821: </span>        <span class=
"org-keyword">break</span>
<span class="linenr">4822: </span>      <span class=
"org-keyword">case</span> NodeTypes.VNODE_CALL:
<span class=
"linenr">4823: </span>        genVNodeCall(node, context)
<span class="linenr">4824: </span>        <span class=
"org-keyword">break</span>
<span class="linenr">4825: </span>  
<span class="linenr">4826: </span>      <span class=
"org-keyword">case</span> NodeTypes.JS_CALL_EXPRESSION:
<span class=
"linenr">4827: </span>        genCallExpression(node, context)
<span class="linenr">4828: </span>        <span class=
"org-keyword">break</span>
<span class="linenr">4829: </span>      <span class=
"org-keyword">case</span> NodeTypes.JS_OBJECT_EXPRESSION:
<span class=
"linenr">4830: </span>        genObjectExpression(node, context)
<span class="linenr">4831: </span>        <span class=
"org-keyword">break</span>
<span class="linenr">4832: </span>      <span class=
"org-keyword">case</span> NodeTypes.JS_ARRAY_EXPRESSION:
<span class=
"linenr">4833: </span>        genArrayExpression(node, context)
<span class="linenr">4834: </span>        <span class=
"org-keyword">break</span>
<span class="linenr">4835: </span>      <span class=
"org-keyword">case</span> NodeTypes.JS_FUNCTION_EXPRESSION:
<span class=
"linenr">4836: </span>        genFunctionExpression(node, context)
<span class="linenr">4837: </span>        <span class=
"org-keyword">break</span>
<span class="linenr">4838: </span>      <span class=
"org-keyword">case</span> NodeTypes.JS_CONDITIONAL_EXPRESSION:
<span class=
"linenr">4839: </span>        genConditionalExpression(node, context)
<span class="linenr">4840: </span>        <span class=
"org-keyword">break</span>
<span class="linenr">4841: </span>      <span class=
"org-keyword">case</span> NodeTypes.JS_CACHE_EXPRESSION:
<span class=
"linenr">4842: </span>        genCacheExpression(node, context)
<span class="linenr">4843: </span>        <span class=
"org-keyword">break</span>
<span class="linenr">4844: </span>      <span class=
"org-keyword">case</span> NodeTypes.JS_BLOCK_STATEMENT:
<span class=
"linenr">4845: </span>        genNodeList(node.body, context, <span class="org-constant">true</span>, <span class="org-constant">false</span>)
<span class="linenr">4846: </span>        <span class=
"org-keyword">break</span>
<span class="linenr">4847: </span>  
<span class="linenr">4848: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">SSR only types</span>
<span class="linenr">4849: </span>      <span class=
"org-keyword">case</span> NodeTypes.JS_TEMPLATE_LITERAL:
<span class=
"linenr">4850: </span>        !__BROWSER__ &amp;& genTemplateLiteral(node, context)
<span class="linenr">4851: </span>        <span class=
"org-keyword">break</span>
<span class="linenr">4852: </span>      <span class=
"org-keyword">case</span> NodeTypes.JS_IF_STATEMENT:
<span class=
"linenr">4853: </span>        !__BROWSER__ &amp;& genIfStatement(node, context)
<span class="linenr">4854: </span>        <span class=
"org-keyword">break</span>
<span class="linenr">4855: </span>      <span class=
"org-keyword">case</span> NodeTypes.JS_ASSIGNMENT_EXPRESSION:
<span class=
"linenr">4856: </span>        !__BROWSER__ &amp;& genAssignmentExpression(node, context)
<span class="linenr">4857: </span>        <span class=
"org-keyword">break</span>
<span class="linenr">4858: </span>      <span class=
"org-keyword">case</span> NodeTypes.JS_SEQUENCE_EXPRESSION:
<span class=
"linenr">4859: </span>        !__BROWSER__ &amp;& genSequenceExpression(node, context)
<span class="linenr">4860: </span>        <span class=
"org-keyword">break</span>
<span class="linenr">4861: </span>      <span class=
"org-keyword">case</span> NodeTypes.JS_RETURN_STATEMENT:
<span class=
"linenr">4862: </span>        !__BROWSER__ &amp;& genReturnStatement(node, context)
<span class="linenr">4863: </span>        <span class=
"org-keyword">break</span>
<span class="linenr">4864: </span>  
<span class="linenr">4865: </span>      <span class=
"org-comment-delimiter">/* </span><span class=
"org-comment">istanbul ignore next</span><span class=
"org-comment-delimiter"> */</span>
<span class="linenr">4866: </span>      <span class=
"org-keyword">case</span> NodeTypes.IF_BRANCH:
<span class="linenr">4867: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">noop</span>
<span class="linenr">4868: </span>        <span class=
"org-keyword">break</span>
<span class="linenr">4869: </span>      <span class=
"org-keyword">default</span>:
<span class="linenr">4870: </span>        logg(<span class=
"org-string">`unhandled codegen node type: ${node.type}`</span>)
<span class="linenr">4871: </span>    }
<span class="linenr">4872: </span>  }
<span class="linenr">4873: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">genNodeListAsArray</span>(<span class=
"org-variable-name">nodes</span>, <span class=
"org-variable-name">context</span>) {
<span class="linenr">4874: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">multilines</span> =
<span class=
"linenr">4875: </span>      nodes.length &gt; <span class=
"org-highlight-numbers-number">3</span> ||
<span class=
"linenr">4876: </span>      ((!__BROWSER__ || __DEV__) &amp;& nodes.some(n =&gt; isArray(n) || !isText(n)))
<span class="linenr">4877: </span>    context.push(<span class=
"org-string">`[`</span>)
<span class=
"linenr">4878: </span>    multilines &amp;& context.indent()
<span class=
"linenr">4879: </span>    genNodeList(nodes, context, multilines)
<span class=
"linenr">4880: </span>    multilines &amp;& context.deindent()
<span class="linenr">4881: </span>    context.push(<span class=
"org-string">`]`</span>)
<span class="linenr">4882: </span>  }
<span class="linenr">4883: </span>  
<span class="linenr">4884: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">generate</span>(<span class=
"org-variable-name">ast</span>, <span class=
"org-variable-name">options</span> = {}) {
<span class="linenr">4885: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">context</span> = createCodegenContext(ast, options)
<span class="linenr">4886: </span>    <span class=
"org-keyword">if</span> (options.onContextCreated) options.onContextCreated(context)
<span class="linenr">4887: </span>    <span class=
"org-keyword">const</span> {
<span class="linenr">4888: </span>      mode,
<span class="linenr">4889: </span>      push,
<span class="linenr">4890: </span>      prefixIdentifiers,
<span class="linenr">4891: </span>      indent,
<span class="linenr">4892: </span>      deindent,
<span class="linenr">4893: </span>      newline,
<span class="linenr">4894: </span>      scopeId,
<span class="linenr">4895: </span>      ssr
<span class="linenr">4896: </span>    } = context
<span class="linenr">4897: </span>  
<span class="linenr">4898: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">hasHelpers</span> = ast.helpers.length &gt; <span class="org-highlight-numbers-number">0</span>
<span class="linenr">4899: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">useWithBlock</span> = !prefixIdentifiers &amp;& mode !== <span class="org-string">'module'</span>
<span class="linenr">4900: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">genScopeId</span> = !__BROWSER__ &amp;& scopeId != <span class="org-constant">null</span> &amp;& mode === <span class="org-string">'module'</span>
<span class="linenr">4901: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isSetupInlined</span> = !__BROWSER__ &amp;& !!options.inline
<span class="linenr">4902: </span>  
<span class="linenr">4903: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">preambles</span>
<span class="linenr">4904: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">in setup() inline mode, the preamble is generated in a sub context</span>
<span class="linenr">4905: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">and returned separately.</span>
<span class="linenr">4906: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">preambleContext</span> = isSetupInlined
<span class=
"linenr">4907: </span>      ? createCodegenContext(ast, options)
<span class="linenr">4908: </span>      : context
<span class="linenr">4909: </span>    <span class=
"org-keyword">if</span> (!__BROWSER__ &amp;& mode === <span class=
"org-string">'module'</span>) {
<span class=
"linenr">4910: </span>      genModulePreamble(ast, preambleContext, genScopeId, isSetupInlined)
<span class="linenr">4911: </span>    } <span class=
"org-keyword">else</span> {
<span class=
"linenr">4912: </span>      genFunctionPreamble(ast, preambleContext)
<span class="linenr">4913: </span>    }
<span class="linenr">4914: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">enter render function</span>
<span class="linenr">4915: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">functionName</span> = ssr ? <span class=
"org-string">`ssrRender`</span> : <span class=
"org-string">`render`</span>
<span class="linenr">4916: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">args</span> = ssr ? [<span class=
"org-string">'_ctx'</span>, <span class=
"org-string">'_push'</span>, <span class=
"org-string">'_parent'</span>, <span class=
"org-string">'_attrs'</span>] : [<span class=
"org-string">'_ctx'</span>, <span class=
"org-string">'_cache'</span>]
<span class="linenr">4917: </span>    <span class=
"org-keyword">if</span> (!__BROWSER__ &amp;& options.bindingMetadata &amp;& !options.inline) {
<span class="linenr">4918: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">binding optimization args</span>
<span class="linenr">4919: </span>      args.push(<span class=
"org-string">'$props'</span>, <span class=
"org-string">'$setup'</span>, <span class=
"org-string">'$data'</span>, <span class=
"org-string">'$options'</span>)
<span class="linenr">4920: </span>    }
<span class="linenr">4921: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">signature</span> =
<span class=
"linenr">4922: </span>      !__BROWSER__ &amp;& options.isTS
<span class=
"linenr">4923: </span>        ? args.map(arg =&gt; <span class=
"org-string">`${arg}: any`</span>).join(<span class=
"org-string">','</span>)
<span class="linenr">4924: </span>        : args.join(<span class=
"org-string">', '</span>)
<span class="linenr">4925: </span>  
<span class="linenr">4926: </span>    <span class=
"org-keyword">if</span> (isSetupInlined) {
<span class="linenr">4927: </span>      push(<span class=
"org-string">`(${signature}) =&gt; {`</span>)
<span class="linenr">4928: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr">4929: </span>      push(<span class=
"org-string">`function ${functionName}(${signature}) {`</span>)
<span class="linenr">4930: </span>    }
<span class="linenr">4931: </span>    indent()
<span class="linenr">4932: </span>  
<span class="linenr">4933: </span>    <span class=
"org-keyword">if</span> (useWithBlock) {
<span class="linenr">4934: </span>      push(<span class=
"org-string">`with (_ctx) {`</span>)
<span class="linenr">4935: </span>      indent()
<span class="linenr">4936: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">function mode const declarations should be inside with block</span>
<span class="linenr">4937: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">also they should be renamed to avoid collision with user properties</span>
<span class="linenr">4938: </span>      <span class=
"org-keyword">if</span> (hasHelpers) {
<span class="linenr">4939: </span>        push(
<span class="linenr">4940: </span>          <span class=
"org-string">`const { ${ast.helpers</span>
<span class="linenr">4941: </span><span class=
"org-string">            .map(s =&gt; `</span>${helperNameMap[s]}: _${helperNameMap[s]}<span class="org-string">`)</span>
<span class="linenr">4942: </span><span class=
"org-string">            .join(', ')} } = _Vue`</span>
<span class="linenr">4943: </span>        )
<span class="linenr">4944: </span>        push(<span class=
"org-string">`\n`</span>)
<span class="linenr">4945: </span>        newline()
<span class="linenr">4946: </span>      }
<span class="linenr">4947: </span>    }
<span class="linenr">4948: </span>  
<span class="linenr">4949: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">generate asset resolution statements</span>
<span class="linenr">4950: </span>    <span class=
"org-keyword">if</span> (ast.components.length) {
<span class=
"linenr">4951: </span>      genAssets(ast.components, <span class=
"org-string">'component'</span>, context)
<span class="linenr">4952: </span>      <span class=
"org-keyword">if</span> (ast.directives.length || ast.temps &gt; <span class="org-highlight-numbers-number">0</span>) {
<span class="linenr">4953: </span>        newline()
<span class="linenr">4954: </span>      }
<span class="linenr">4955: </span>    }
<span class="linenr">4956: </span>    <span class=
"org-keyword">if</span> (ast.directives.length) {
<span class=
"linenr">4957: </span>      genAssets(ast.directives, <span class=
"org-string">'directive'</span>, context)
<span class="linenr">4958: </span>      <span class=
"org-keyword">if</span> (ast.temps &gt; <span class=
"org-highlight-numbers-number">0</span>) {
<span class="linenr">4959: </span>        newline()
<span class="linenr">4960: </span>      }
<span class="linenr">4961: </span>    }
<span class="linenr">4962: </span>  
<span class="linenr">4963: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">临时变量</span>
<span class="linenr">4964: </span>    <span class=
"org-keyword">if</span> (ast.temps &gt; <span class=
"org-highlight-numbers-number">0</span>) {
<span class="linenr">4965: </span>      push(<span class=
"org-string">`let `</span>)
<span class="linenr">4966: </span>      <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; ast.temps; i++) {
<span class="linenr">4967: </span>        push(<span class=
"org-string">`${i &gt; 0 ? `</span>, <span class=
"org-string">` : ``}_temp${i}`</span>)
<span class="linenr">4968: </span>      }
<span class="linenr">4969: </span>    }
<span class="linenr">4970: </span>    <span class=
"org-keyword">if</span> (ast.components.length || ast.directives.length || ast.temps) {
<span class="linenr">4971: </span>      push(<span class=
"org-string">`\n`</span>)
<span class="linenr">4972: </span>      newline()
<span class="linenr">4973: </span>    }
<span class="linenr">4974: </span>  
<span class="linenr">4975: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">generate the VNode tree expression</span>
<span class="linenr">4976: </span>    <span class=
"org-keyword">if</span> (!ssr) {
<span class="linenr">4977: </span>      push(<span class=
"org-string">`return `</span>)
<span class="linenr">4978: </span>    }
<span class="linenr">4979: </span>    <span class=
"org-keyword">if</span> (ast.codegenNode) {
<span class=
"linenr">4980: </span>      genNode(ast.codegenNode, context)
<span class="linenr">4981: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr">4982: </span>      push(<span class=
"org-string">`null`</span>)
<span class="linenr">4983: </span>    }
<span class="linenr">4984: </span>  
<span class="linenr">4985: </span>    <span class=
"org-keyword">if</span> (useWithBlock) {
<span class="linenr">4986: </span>      deindent()
<span class="linenr">4987: </span>      push(<span class=
"org-string">`}`</span>)
<span class="linenr">4988: </span>    }
<span class="linenr">4989: </span>  
<span class="linenr">4990: </span>    deindent()
<span class="linenr">4991: </span>    push(<span class=
"org-string">`}`</span>)
<span class="linenr">4992: </span>  
<span class="linenr">4993: </span>    <span class=
"org-keyword">return</span> {
<span class="linenr">4994: </span>      ast,
<span class="linenr">4995: </span>      code: context.code,
<span class=
"linenr">4996: </span>      preamble: isSetupInlined ? preambleContext.code : <span class="org-string">``</span>,
<span class="linenr">4997: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">SourceMapGenerator does have toJSON() method but it's not in the types</span>
<span class=
"linenr">4998: </span>      map: context.map ? context.map.toJSON() : <span class="org-constant">undefined</span>
<span class="linenr">4999: </span>    }
<span class="linenr">5000: </span>  }
<span class="linenr">5001: </span>
<span class="linenr">5002: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">baseCompile</span>(<span class=
"org-variable-name">template</span>, <span class=
"org-variable-name">options</span> = {}) {
<span class="linenr">5003: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isModuleMode</span> = options.mode === <span class="org-string">'module'</span>
<span class="linenr">5004: </span>
<span class="linenr">5005: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">prefixIdentifiers</span> =
<span class=
"linenr">5006: </span>        !__BROWSER__ &amp;& (options.prefixIdentifiers === <span class="org-constant">true</span> || isModuleMode)
<span class="linenr">5007: </span>
<span class="linenr">5008: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">ast</span> = isString(template) ? baseParse(template, options) : template
<span class="linenr">5009: </span>    <span class=
"org-keyword">const</span> [<span class=
"org-variable-name">nodeTransforms</span>, <span class=
"org-variable-name">directiveTransforms</span>] = getBaseTransformPreset(prefixIdentifiers)
<span class="linenr">5010: </span>
<span class="linenr">5011: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">转换出每个节点的 codegenNode</span>
<span class="linenr">5012: </span>    transform(
<span class="linenr">5013: </span>        ast,
<span class="linenr">5014: </span>        extend({}, options, {
<span class="linenr">5015: </span>        prefixIdentifiers,
<span class="linenr">5016: </span>        nodeTransforms: [
<span class="linenr">5017: </span>            ...nodeTransforms,
<span class=
"linenr">5018: </span>            ...(options.nodeTransforms || []) <span class="org-comment-delimiter">// </span><span class="org-comment">user transforms</span>
<span class="linenr">5019: </span>        ],
<span class=
"linenr">5020: </span>        directiveTransforms: extend(
<span class="linenr">5021: </span>            {},
<span class="linenr">5022: </span>            directiveTransforms,
<span class=
"linenr">5023: </span>            options.directiveTransforms || {} <span class="org-comment-delimiter">// </span><span class="org-comment">user transforms</span>
<span class="linenr">5024: </span>        )
<span class="linenr">5025: </span>        })
<span class="linenr">5026: </span>    )
<span class="linenr">5027: </span>
<span class="linenr">5028: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">生成 codegen</span>
<span class="linenr">5029: </span>    <span class=
"org-keyword">return</span> generate(ast, extend({}, options, { prefixIdentifiers }))
<span class="linenr">5030: </span>  }
</pre>
      </div>
      <div class="org-src-container">
        <pre class="src src-js" id="org8070bda"><span class=
        "linenr">  1: </span><span class=
        "org-keyword">const</span> <span class=
        "org-variable-name">compilerDom</span> = (<span class=
        "org-keyword">function</span>() {
<span class="linenr">  2: </span>  
<span class="linenr">  3: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">Parse inline CSS strings for static style attributes into an object.</span>
<span class="linenr">  4: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">This is a NodeTransform since it works on the static `style` attribute and</span>
<span class="linenr">  5: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">converts it into a dynamic equivalent:</span>
<span class="linenr">  6: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">style="color: red" -&gt; :style='{ "color": "red" }'</span>
<span class="linenr">  7: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">It is then processed by `transformElement` and included in the generated</span>
<span class="linenr">  8: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">props.</span>
<span class="linenr">  9: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">transformStyle</span> = node =&gt; {
<span class="linenr"> 10: </span>    <span class=
"org-keyword">if</span> (node.type === NodeTypes.ELEMENT) {
<span class=
"linenr"> 11: </span>      node.props.forEach((p, i) =&gt; {
<span class="linenr"> 12: </span>        <span class=
"org-keyword">if</span> (p.type === NodeTypes.ATTRIBUTE &amp;& p.name === <span class="org-string">'style'</span> &amp;& p.value) {
<span class="linenr"> 13: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">replace p with an expression node</span>
<span class="linenr"> 14: </span>          node.props[i] = {
<span class=
"linenr"> 15: </span>            type: NodeTypes.DIRECTIVE,
<span class="linenr"> 16: </span>            name: <span class=
"org-string">`bind`</span>,
<span class=
"linenr"> 17: </span>            arg: createSimpleExpression(<span class="org-string">`style`</span>, <span class="org-constant">true</span>, p.loc),
<span class=
"linenr"> 18: </span>            exp: parseInlineCSS(p.value.content, p.loc),
<span class="linenr"> 19: </span>            modifiers: [],
<span class="linenr"> 20: </span>            loc: p.loc
<span class="linenr"> 21: </span>          }
<span class="linenr"> 22: </span>        }
<span class="linenr"> 23: </span>      })
<span class="linenr"> 24: </span>    }
<span class="linenr"> 25: </span>  }
<span class="linenr"> 26: </span>  
<span class="linenr"> 27: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">parseInlineCSS</span> = (cssText, loc) =&gt; {
<span class="linenr"> 28: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">normalized</span> = parseStringStyle(cssText)
<span class="linenr"> 29: </span>    <span class=
"org-keyword">return</span> createSimpleExpression(
<span class="linenr"> 30: </span>      JSON.stringify(normalized),
<span class="linenr"> 31: </span>      <span class=
"org-constant">false</span>,
<span class="linenr"> 32: </span>      loc,
<span class="linenr"> 33: </span>      ConstantTypes.CAN_STRINGIFY
<span class="linenr"> 34: </span>    )
<span class="linenr"> 35: </span>  }
<span class="linenr"> 36: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">transformVHtml</span> = (dir, node, context) =&gt; {
<span class="linenr"> 37: </span>    <span class=
"org-keyword">const</span> { exp, loc } = dir
<span class="linenr"> 38: </span>    <span class=
"org-keyword">if</span> (!exp) {
<span class="linenr"> 39: </span>      logg(<span class=
"org-string">"v-html no exp"</span>)
<span class="linenr"> 40: </span>    }
<span class="linenr"> 41: </span>    <span class=
"org-keyword">if</span> (node.children.length) {
<span class="linenr"> 42: </span>      logg(<span class=
"org-string">'v-html can not has children'</span>)
<span class=
"linenr"> 43: </span>      node.children.length = <span class=
"org-highlight-numbers-number">0</span>
<span class="linenr"> 44: </span>    }
<span class="linenr"> 45: </span>    <span class=
"org-keyword">return</span> {
<span class="linenr"> 46: </span>      props: [
<span class="linenr"> 47: </span>        createObjectProperty(
<span class=
"linenr"> 48: </span>          createSimpleExpression(<span class=
"org-string">`innerHTML`</span>, <span class=
"org-constant">true</span>, loc),
<span class=
"linenr"> 49: </span>          exp || createSimpleExpression(<span class="org-string">''</span>, <span class="org-constant">true</span>)
<span class="linenr"> 50: </span>        )
<span class="linenr"> 51: </span>      ]
<span class="linenr"> 52: </span>    }
<span class="linenr"> 53: </span>  }
<span class="linenr"> 54: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">transformVText</span> = (dir, node, context) =&gt; {
<span class="linenr"> 55: </span>    <span class=
"org-keyword">const</span> { exp, loc } = dir
<span class="linenr"> 56: </span>    <span class=
"org-keyword">if</span> (!exp) {
<span class="linenr"> 57: </span>      logg(<span class=
"org-string">'v-text no exp'</span>)
<span class="linenr"> 58: </span>    }
<span class="linenr"> 59: </span>    <span class=
"org-keyword">if</span> (node.children.length) {
<span class="linenr"> 60: </span>      logg(<span class=
"org-string">'v-text can not have children'</span>)
<span class=
"linenr"> 61: </span>      node.children.length = <span class=
"org-highlight-numbers-number">0</span>
<span class="linenr"> 62: </span>    }
<span class="linenr"> 63: </span>    <span class=
"org-keyword">return</span> {
<span class="linenr"> 64: </span>      props: [
<span class="linenr"> 65: </span>        createObjectProperty(
<span class=
"linenr"> 66: </span>          createSimpleExpression(<span class=
"org-string">`textContent`</span>, <span class=
"org-constant">true</span>),
<span class="linenr"> 67: </span>          exp
<span class=
"linenr"> 68: </span>            ? createCallExpression(
<span class=
"linenr"> 69: </span>                context.helperString(TO_DISPLAY_STRING),
<span class="linenr"> 70: </span>                [exp],
<span class="linenr"> 71: </span>                loc
<span class="linenr"> 72: </span>              )
<span class=
"linenr"> 73: </span>            : createSimpleExpression(<span class="org-string">''</span>, <span class="org-constant">true</span>)
<span class="linenr"> 74: </span>        )
<span class="linenr"> 75: </span>      ]
<span class="linenr"> 76: </span>    }
<span class="linenr"> 77: </span>  }
<span class="linenr"> 78: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">transformModel</span> = (dir, node, context) =&gt; {
<span class="linenr"> 79: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">baseResult</span> = transformModel(dir, node, context)
<span class="linenr"> 80: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">base transform has errors OR component v-model (only need props)</span>
<span class="linenr"> 81: </span>    <span class=
"org-keyword">if</span> (!baseResult.props.length || node.tagType === ElementTypes.COMPONENT) {
<span class="linenr"> 82: </span>      <span class=
"org-keyword">return</span> baseResult
<span class="linenr"> 83: </span>    }
<span class="linenr"> 84: </span>  
<span class="linenr"> 85: </span>    <span class=
"org-keyword">if</span> (dir.arg) {
<span class="linenr"> 86: </span>      logg(<span class=
"org-string">"transfromModel - X_V_MODEL_ARG_ON_ELEMENT"</span>)
<span class="linenr"> 87: </span>    }
<span class="linenr"> 88: </span>  
<span class="linenr"> 89: </span>    <span class=
"org-keyword">function</span> <span class=
"org-function-name">checkDuplicatedValue</span>() {
<span class="linenr"> 90: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">value</span> = findProp(node, <span class=
"org-string">'value'</span>)
<span class="linenr"> 91: </span>      <span class=
"org-keyword">if</span> (value) {
<span class="linenr"> 92: </span>        logg(<span class=
"org-string">"transfromModel - X_V_MODEL_UNNECESSARY_VALUE"</span>)
<span class="linenr"> 93: </span>      }
<span class="linenr"> 94: </span>    }
<span class="linenr"> 95: </span>  
<span class="linenr"> 96: </span>    <span class=
"org-keyword">const</span> { tag } = node
<span class="linenr"> 97: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isCustomElement</span> = context.isCustomElement(tag)
<span class="linenr"> 98: </span>    <span class=
"org-keyword">if</span> (
<span class="linenr"> 99: </span>      tag === <span class=
"org-string">'input'</span> ||
<span class="linenr">100: </span>      tag === <span class=
"org-string">'textarea'</span> ||
<span class="linenr">101: </span>      tag === <span class=
"org-string">'select'</span> ||
<span class="linenr">102: </span>      isCustomElement
<span class="linenr">103: </span>    ) {
<span class="linenr">104: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">directiveToUse</span> = V_MODEL_TEXT
<span class="linenr">105: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">isInvalidType</span> = <span class=
"org-constant">false</span>
<span class="linenr">106: </span>      <span class=
"org-keyword">if</span> (tag === <span class=
"org-string">'input'</span> || isCustomElement) {
<span class="linenr">107: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">type</span> = findProp(node, <span class=
"org-string">`type`</span>)
<span class="linenr">108: </span>        <span class=
"org-keyword">if</span> (type) {
<span class="linenr">109: </span>          <span class=
"org-keyword">if</span> (type.type === NodeTypes.DIRECTIVE) {
<span class="linenr">110: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">:type="foo"</span>
<span class=
"linenr">111: </span>            directiveToUse = V_MODEL_DYNAMIC
<span class="linenr">112: </span>          } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (type.value) {
<span class="linenr">113: </span>            <span class=
"org-keyword">switch</span> (type.value.content) {
<span class="linenr">114: </span>              <span class=
"org-keyword">case</span> <span class="org-string">'radio'</span>:
<span class=
"linenr">115: </span>                directiveToUse = V_MODEL_RADIO
<span class="linenr">116: </span>                <span class=
"org-keyword">break</span>
<span class="linenr">117: </span>              <span class=
"org-keyword">case</span> <span class=
"org-string">'checkbox'</span>:
<span class=
"linenr">118: </span>                directiveToUse = V_MODEL_CHECKBOX
<span class="linenr">119: </span>                <span class=
"org-keyword">break</span>
<span class="linenr">120: </span>              <span class=
"org-keyword">case</span> <span class="org-string">'file'</span>:
<span class=
"linenr">121: </span>                isInvalidType = <span class=
"org-constant">true</span>
<span class="linenr">122: </span>                logg(<span class=
"org-string">"[DOM]transformModel - X_V_MODEL_ON_FILE_INPUT_ELEMENT"</span>)
<span class="linenr">123: </span>                <span class=
"org-keyword">break</span>
<span class="linenr">124: </span>              <span class=
"org-keyword">default</span>:
<span class="linenr">125: </span>                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">text type</span>
<span class=
"linenr">126: </span>                __DEV__ &amp;& checkDuplicatedValue()
<span class="linenr">127: </span>                <span class=
"org-keyword">break</span>
<span class="linenr">128: </span>            }
<span class="linenr">129: </span>          }
<span class="linenr">130: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (hasDynamicKeyVBind(node)) {
<span class="linenr">131: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">element has bindings with dynamic keys, which can possibly contain</span>
<span class="linenr">132: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">"type".</span>
<span class=
"linenr">133: </span>          directiveToUse = V_MODEL_DYNAMIC
<span class="linenr">134: </span>        } <span class=
"org-keyword">else</span> {
<span class="linenr">135: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">text type</span>
<span class=
"linenr">136: </span>          __DEV__ &amp;& checkDuplicatedValue()
<span class="linenr">137: </span>        }
<span class="linenr">138: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (tag === <span class=
"org-string">'select'</span>) {
<span class=
"linenr">139: </span>        directiveToUse = V_MODEL_SELECT
<span class="linenr">140: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr">141: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">textarea</span>
<span class=
"linenr">142: </span>        __DEV__ &amp;& checkDuplicatedValue()
<span class="linenr">143: </span>      }
<span class="linenr">144: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">inject runtime directive</span>
<span class="linenr">145: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">by returning the helper symbol via needRuntime</span>
<span class="linenr">146: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">the import will replaced a resolveDirective call.</span>
<span class="linenr">147: </span>      <span class=
"org-keyword">if</span> (!isInvalidType) {
<span class=
"linenr">148: </span>        baseResult.needRuntime = context.helper(directiveToUse)
<span class="linenr">149: </span>      }
<span class="linenr">150: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr">151: </span>      logg(<span class=
"org-string">"[DOM]transformModel - X_V_MODEL_ON_INVALID_ELEMENT"</span>)
<span class="linenr">152: </span>    }
<span class="linenr">153: </span>  
<span class="linenr">154: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">native vmodel doesn't need the `modelValue` props since they are also</span>
<span class="linenr">155: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">passed to the runtime as `binding.value`. removing it reduces code size.</span>
<span class=
"linenr">156: </span>    baseResult.props = baseResult.props.filter(
<span class="linenr">157: </span>      p =&gt;
<span class="linenr">158: </span>        !(
<span class=
"linenr">159: </span>          p.key.type === NodeTypes.SIMPLE_EXPRESSION &amp;&
<span class=
"linenr">160: </span>          p.key.content === <span class=
"org-string">'modelValue'</span>
<span class="linenr">161: </span>        )
<span class="linenr">162: </span>    )
<span class="linenr">163: </span>  
<span class="linenr">164: </span>    <span class=
"org-keyword">return</span> baseResult
<span class="linenr">165: </span>  }
<span class="linenr">166: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isEventOptionModifier</span> = <span class=
"org-comment-delimiter">/*</span><span class=
"org-comment">#__PURE__</span><span class=
"org-comment-delimiter">*/</span> makeMap(<span class=
"org-string">`passive,once,capture`</span>)
<span class="linenr">167: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isNonKeyModifier</span> = <span class=
"org-comment-delimiter">/*</span><span class=
"org-comment">#__PURE__</span><span class=
"org-comment-delimiter">*/</span> makeMap(
<span class="linenr">168: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">event propagation management</span>
<span class="linenr">169: </span>    <span class=
"org-string">`stop,prevent,self,`</span> +
<span class="linenr">170: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">system modifiers + exact</span>
<span class="linenr">171: </span>      <span class=
"org-string">`ctrl,shift,alt,meta,exact,`</span> +
<span class="linenr">172: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">mouse</span>
<span class="linenr">173: </span>      <span class=
"org-string">`middle`</span>
<span class="linenr">174: </span>  )
<span class="linenr">175: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">left & right could be mouse or key modifiers based on event type</span>
<span class="linenr">176: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">maybeKeyModifier</span> = <span class=
"org-comment-delimiter">/*</span><span class=
"org-comment">#__PURE__</span><span class=
"org-comment-delimiter">*/</span> makeMap(<span class=
"org-string">'left,right'</span>)
<span class="linenr">177: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isKeyboardEvent</span> = <span class=
"org-comment-delimiter">/*</span><span class=
"org-comment">#__PURE__</span><span class=
"org-comment-delimiter">*/</span> makeMap(
<span class="linenr">178: </span>    <span class=
"org-string">`onkeyup,onkeydown,onkeypress`</span>,
<span class="linenr">179: </span>    <span class=
"org-constant">true</span>
<span class="linenr">180: </span>  )
<span class="linenr">181: </span>  
<span class="linenr">182: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">将修饰符分类</span>
<span class="linenr">183: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">resolveModifiers</span> = (key, modifiers, context, loc) =&gt; {
<span class="linenr">184: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">keyModifiers</span> = []
<span class="linenr">185: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">nonKeyModifiers</span> = []
<span class="linenr">186: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">eventOptionModifiers</span> = []
<span class="linenr">187: </span>  
<span class="linenr">188: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; modifiers.length; i++) {
<span class="linenr">189: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">modifier</span> = modifiers[i]
<span class="linenr">190: </span>  
<span class="linenr">191: </span>      <span class=
"org-keyword">if</span> (isEventOptionModifier(modifier)) {
<span class="linenr">192: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">eventOptionModifiers: modifiers for addEventListener() options,</span>
<span class="linenr">193: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">e.g. .passive & .capture</span>
<span class=
"linenr">194: </span>        eventOptionModifiers.push(modifier)
<span class="linenr">195: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr">196: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">runtimeModifiers: modifiers that needs runtime guards</span>
<span class="linenr">197: </span>        <span class=
"org-keyword">if</span> (maybeKeyModifier(modifier)) {
<span class="linenr">198: </span>          <span class=
"org-keyword">if</span> (isStaticExp(key)) {
<span class="linenr">199: </span>            <span class=
"org-keyword">if</span> (isKeyboardEvent(key.content)) {
<span class=
"linenr">200: </span>              keyModifiers.push(modifier)
<span class="linenr">201: </span>            } <span class=
"org-keyword">else</span> {
<span class=
"linenr">202: </span>              nonKeyModifiers.push(modifier)
<span class="linenr">203: </span>            }
<span class="linenr">204: </span>          } <span class=
"org-keyword">else</span> {
<span class=
"linenr">205: </span>            keyModifiers.push(modifier)
<span class=
"linenr">206: </span>            nonKeyModifiers.push(modifier)
<span class="linenr">207: </span>          }
<span class="linenr">208: </span>        } <span class=
"org-keyword">else</span> {
<span class="linenr">209: </span>          <span class=
"org-keyword">if</span> (isNonKeyModifier(modifier)) {
<span class=
"linenr">210: </span>            nonKeyModifiers.push(modifier)
<span class="linenr">211: </span>          } <span class=
"org-keyword">else</span> {
<span class=
"linenr">212: </span>            keyModifiers.push(modifier)
<span class="linenr">213: </span>          }
<span class="linenr">214: </span>        }
<span class="linenr">215: </span>      }
<span class="linenr">216: </span>    }
<span class="linenr">217: </span>  
<span class="linenr">218: </span>    <span class=
"org-keyword">return</span> {
<span class="linenr">219: </span>      keyModifiers,
<span class="linenr">220: </span>      nonKeyModifiers,
<span class="linenr">221: </span>      eventOptionModifiers
<span class="linenr">222: </span>    }
<span class="linenr">223: </span>  }
<span class="linenr">224: </span>  
<span class="linenr">225: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">原生 click 事件</span>
<span class="linenr">226: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">transformClick</span> = (key, event) =&gt; {
<span class="linenr">227: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isStaticClick</span> =
<span class=
"linenr">228: </span>      isStaticExp(key) &amp;& key.content.toLowerCase() === <span class="org-string">'onclick'</span>
<span class="linenr">229: </span>    <span class=
"org-keyword">return</span> isStaticClick
<span class=
"linenr">230: </span>      ? createSimpleExpression(event, <span class="org-constant">true</span>)
<span class=
"linenr">231: </span>      : key.type !== NodeTypes.SIMPLE_EXPRESSION
<span class="linenr">232: </span>      ? createCompoundExpression([
<span class="linenr">233: </span>          <span class=
"org-string">`(`</span>,
<span class="linenr">234: </span>          key,
<span class="linenr">235: </span>          <span class=
"org-string">`) === "onClick" ? "${event}" : (`</span>,
<span class="linenr">236: </span>          key,
<span class="linenr">237: </span>          <span class=
"org-string">`)`</span>
<span class="linenr">238: </span>        ])
<span class="linenr">239: </span>      : key
<span class="linenr">240: </span>  }
<span class="linenr">241: </span>  
<span class="linenr">242: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">transformOn</span> = (dir, node, context) =&gt; {
<span class="linenr">243: </span>    <span class=
"org-keyword">return</span> transformOn(dir, node, context, baseResult =&gt; {
<span class="linenr">244: </span>      <span class=
"org-keyword">const</span> { modifiers } = dir
<span class="linenr">245: </span>      <span class=
"org-keyword">if</span> (!modifiers.length) <span class=
"org-keyword">return</span> baseResult
<span class="linenr">246: </span>  
<span class="linenr">247: </span>      <span class=
"org-keyword">let</span> { key, value: handlerExp } = baseResult.props[<span class="org-highlight-numbers-number">0</span>]
<span class="linenr">248: </span>      <span class=
"org-keyword">const</span> { keyModifiers, nonKeyModifiers, eventOptionModifiers } =
<span class=
"linenr">249: </span>        resolveModifiers(key, modifiers, context, dir.loc)
<span class="linenr">250: </span>  
<span class="linenr">251: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">normalize click.right and click.middle since they don't actually fire</span>
<span class="linenr">252: </span>      <span class=
"org-keyword">if</span> (nonKeyModifiers.includes(<span class=
"org-string">'right'</span>)) {
<span class=
"linenr">253: </span>        key = transformClick(key, <span class=
"org-string">`onContextmenu`</span>)
<span class="linenr">254: </span>      }
<span class="linenr">255: </span>      <span class=
"org-keyword">if</span> (nonKeyModifiers.includes(<span class=
"org-string">'middle'</span>)) {
<span class=
"linenr">256: </span>        key = transformClick(key, <span class=
"org-string">`onMouseup`</span>)
<span class="linenr">257: </span>      }
<span class="linenr">258: </span>  
<span class="linenr">259: </span>      <span class=
"org-keyword">if</span> (nonKeyModifiers.length) {
<span class=
"linenr">260: </span>        handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
<span class="linenr">261: </span>          handlerExp,
<span class=
"linenr">262: </span>          JSON.stringify(nonKeyModifiers)
<span class="linenr">263: </span>        ])
<span class="linenr">264: </span>      }
<span class="linenr">265: </span>  
<span class="linenr">266: </span>      <span class=
"org-keyword">if</span> (
<span class="linenr">267: </span>        keyModifiers.length &amp;&
<span class="linenr">268: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">if event name is dynamic, always wrap with keys guard</span>
<span class=
"linenr">269: </span>        (!isStaticExp(key) || isKeyboardEvent(key.content))
<span class="linenr">270: </span>      ) {
<span class=
"linenr">271: </span>        handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [
<span class="linenr">272: </span>          handlerExp,
<span class=
"linenr">273: </span>          JSON.stringify(keyModifiers)
<span class="linenr">274: </span>        ])
<span class="linenr">275: </span>      }
<span class="linenr">276: </span>  
<span class="linenr">277: </span>      <span class=
"org-keyword">if</span> (eventOptionModifiers.length) {
<span class="linenr">278: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">modifierPostfix</span> = eventOptionModifiers.map(capitalize).join(<span class="org-string">''</span>)
<span class="linenr">279: </span>        key = isStaticExp(key)
<span class=
"linenr">280: </span>          ? createSimpleExpression(<span class="org-string">`${key.content}${modifierPostfix}`</span>, <span class="org-constant">true</span>)
<span class=
"linenr">281: </span>          : createCompoundExpression([<span class="org-string">`(`</span>, key, <span class="org-string">`) + "${modifierPostfix}"`</span>])
<span class="linenr">282: </span>      }
<span class="linenr">283: </span>  
<span class="linenr">284: </span>      <span class=
"org-keyword">return</span> {
<span class=
"linenr">285: </span>        props: [createObjectProperty(key, handlerExp)]
<span class="linenr">286: </span>      }
<span class="linenr">287: </span>    })
<span class="linenr">288: </span>  }
<span class="linenr">289: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">transformShow</span> = (dir, node, context) =&gt; {
<span class="linenr">290: </span>    <span class=
"org-keyword">const</span> { exp, loc } = dir
<span class="linenr">291: </span>    <span class=
"org-keyword">if</span> (!exp) {
<span class="linenr">292: </span>      logg(<span class=
"org-string">'transformShow no exp.'</span>)
<span class="linenr">293: </span>    }
<span class="linenr">294: </span>  
<span class="linenr">295: </span>    <span class=
"org-keyword">return</span> {
<span class="linenr">296: </span>      props: [],
<span class=
"linenr">297: </span>      needRuntime: context.helper(V_SHOW)
<span class="linenr">298: </span>    }
<span class="linenr">299: </span>  }
<span class="linenr">300: </span>   <span class=
"org-keyword">const</span> <span class=
"org-variable-name">StringifyThresholds</span> = {
<span class=
"linenr">301: </span>     ELEMENT_WITH_BINDING_COUNT: <span class=
"org-highlight-numbers-number">5</span>,
<span class="linenr">302: </span>     NODE_COUNT: <span class=
"org-highlight-numbers-number">20</span>
<span class="linenr">303: </span>  }
<span class="linenr">304: </span>  
<span class="linenr">305: </span>  <span class="org-doc">/**</span>
<span class="linenr">306: </span><span class=
"org-doc">   * Regex for replacing placeholders for embedded constant variables</span>
<span class="linenr">307: </span><span class=
"org-doc">   * (e.g. import URL string constants generated by compiler-sfc)</span>
<span class="linenr">308: </span><span class="org-doc">   */</span>
<span class="linenr">309: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">expReplaceRE</span> = <span class=
"org-string">/__VUE_EXP_START__(.*?)__VUE_EXP_END__/</span>g
<span class="linenr">310: </span>  
<span class="linenr">311: </span>  <span class="org-doc">/**</span>
<span class="linenr">312: </span><span class=
"org-doc">   * Turn eligible hoisted static trees into stringified static nodes, e.g.</span>
<span class="linenr">313: </span><span class="org-doc">   *</span>
<span class="linenr">314: </span><span class=
"org-doc">   * ```js</span>
<span class="linenr">315: </span><span class=
"org-doc">   * const _hoisted_1 = createStaticVNode(`&lt;div class="foo"&gt;bar&lt;/div&gt;`)</span>
<span class="linenr">316: </span><span class=
"org-doc">   * ```</span>
<span class="linenr">317: </span><span class="org-doc">   *</span>
<span class="linenr">318: </span><span class=
"org-doc">   * A single static vnode can contain stringified content for **multiple**</span>
<span class="linenr">319: </span><span class=
"org-doc">   * consecutive nodes (element and plain text), called a "chunk".</span>
<span class="linenr">320: </span><span class=
"org-doc">   * `@vue/runtime-dom` will create the content via innerHTML in a hidden</span>
<span class="linenr">321: </span><span class=
"org-doc">   * container element and insert all the nodes in place. The call must also</span>
<span class="linenr">322: </span><span class=
"org-doc">   * provide the number of nodes contained in the chunk so that during hydration</span>
<span class="linenr">323: </span><span class=
"org-doc">   * we can know how many nodes the static vnode should adopt.</span>
<span class="linenr">324: </span><span class="org-doc">   *</span>
<span class="linenr">325: </span><span class=
"org-doc">   * The optimization scans a children list that contains hoisted nodes, and</span>
<span class="linenr">326: </span><span class=
"org-doc">   * tries to find the largest chunk of consecutive hoisted nodes before running</span>
<span class="linenr">327: </span><span class=
"org-doc">   * into a non-hoisted node or the end of the list. A chunk is then converted</span>
<span class="linenr">328: </span><span class=
"org-doc">   * into a single static vnode and replaces the hoisted expression of the first</span>
<span class="linenr">329: </span><span class=
"org-doc">   * node in the chunk. Other nodes in the chunk are considered "merged" and</span>
<span class="linenr">330: </span><span class=
"org-doc">   * therefore removed from both the hoist list and the children array.</span>
<span class="linenr">331: </span><span class="org-doc">   *</span>
<span class="linenr">332: </span><span class=
"org-doc">   * This optimization is only performed in Node.js.</span>
<span class="linenr">333: </span><span class="org-doc">   */</span>
<span class="linenr">334: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">stringifyStatic</span> = (children, context, parent) =&gt; {
<span class="linenr">335: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">bail stringification for slot content</span>
<span class="linenr">336: </span>    <span class=
"org-keyword">if</span> (context.scopes.vSlot &gt; <span class=
"org-highlight-numbers-number">0</span>) {
<span class="linenr">337: </span>      <span class=
"org-keyword">return</span>
<span class="linenr">338: </span>    }
<span class="linenr">339: </span>  
<span class="linenr">340: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">nc</span> = <span class=
"org-highlight-numbers-number">0</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">current node count</span>
<span class="linenr">341: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">ec</span> = <span class=
"org-highlight-numbers-number">0</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">current element with binding count</span>
<span class="linenr">342: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">currentChunk</span> = []
<span class="linenr">343: </span>  
<span class="linenr">344: </span>    logg(<span class=
"org-string">`stringifyStatic - children.length = ${children.length}`</span>)
<span class="linenr">345: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">stringifyCurrentChunk</span> = (currentIndex) =&gt; {
<span class="linenr">346: </span>      <span class=
"org-keyword">if</span> (
<span class=
"linenr">347: </span>        nc &gt;= StringifyThresholds.NODE_COUNT ||
<span class=
"linenr">348: </span>        ec &gt;= StringifyThresholds.ELEMENT_WITH_BINDING_COUNT
<span class="linenr">349: </span>      ) {
<span class="linenr">350: </span>        logg(<span class=
"org-string">`stringifyCurrentChunk - index = ${currentIndex}`</span>)
<span class="linenr">351: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">combine all currently eligible nodes into a single static vnode call</span>
<span class="linenr">352: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">staticCall</span> = createCallExpression(context.helper(CREATE_STATIC), [
<span class="linenr">353: </span>          JSON.stringify(
<span class=
"linenr">354: </span>            currentChunk.map(node =&gt; stringifyNode(node, context)).join(<span class="org-string">''</span>)
<span class=
"linenr">355: </span>          ).replace(expReplaceRE, <span class=
"org-string">`" + $1 + "`</span>),
<span class="linenr">356: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">the 2nd argument indicates the number of DOM nodes this static vnode</span>
<span class="linenr">357: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">will insert / hydrate</span>
<span class=
"linenr">358: </span>          String(currentChunk.length)
<span class="linenr">359: </span>        ])
<span class="linenr">360: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">replace the first node's hoisted expression with the static vnode call</span>
<span class=
"linenr">361: </span>        replaceHoist(currentChunk[<span class=
"org-highlight-numbers-number">0</span>], staticCall, context)
<span class="linenr">362: </span>  
<span class="linenr">363: </span>        <span class=
"org-keyword">if</span> (currentChunk.length &gt; <span class=
"org-highlight-numbers-number">1</span>) {
<span class="linenr">364: </span>          <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">1</span>; i &lt; currentChunk.length; i++) {
<span class="linenr">365: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">for the merged nodes, set their hoisted expression to null</span>
<span class=
"linenr">366: </span>            replaceHoist(currentChunk[i], <span class="org-constant">null</span>, context)
<span class="linenr">367: </span>          }
<span class="linenr">368: </span>  
<span class="linenr">369: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">also remove merged nodes from children</span>
<span class="linenr">370: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">deleteCount</span> = currentChunk.length - <span class="org-highlight-numbers-number">1</span>
<span class=
"linenr">371: </span>          children.splice(currentIndex - currentChunk.length + <span class="org-highlight-numbers-number">1</span>, deleteCount)
<span class="linenr">372: </span>          <span class=
"org-keyword">return</span> deleteCount
<span class="linenr">373: </span>        }
<span class="linenr">374: </span>      }
<span class="linenr">375: </span>      <span class=
"org-keyword">return</span> <span class=
"org-highlight-numbers-number">0</span>
<span class="linenr">376: </span>    }
<span class="linenr">377: </span>  
<span class="linenr">378: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>
<span class="linenr">379: </span>    <span class=
"org-keyword">for</span> (; i &lt; children.length; i++) {
<span class="linenr">380: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">child</span> = children[i]
<span class="linenr">381: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">hoisted</span> = getHoistedNode(child)
<span class="linenr">382: </span>      <span class=
"org-keyword">if</span> (hoisted) {
<span class="linenr">383: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">presence of hoisted means child must be a stringifiable node</span>
<span class="linenr">384: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">node</span> = child
<span class="linenr">385: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">result</span> = analyzeNode(node)
<span class="linenr">386: </span>        <span class=
"org-keyword">if</span> (result) {
<span class="linenr">387: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">node is stringifiable, record state</span>
<span class=
"linenr">388: </span>          nc += result[<span class="org-highlight-numbers-number">0</span>]
<span class=
"linenr">389: </span>          ec += result[<span class="org-highlight-numbers-number">1</span>]
<span class="linenr">390: </span>          currentChunk.push(node)
<span class="linenr">391: </span>          <span class=
"org-keyword">continue</span>
<span class="linenr">392: </span>        }
<span class="linenr">393: </span>      }
<span class="linenr">394: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">we only reach here if we ran into a node that is not stringifiable</span>
<span class="linenr">395: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">check if currently analyzed nodes meet criteria for stringification.</span>
<span class="linenr">396: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">adjust iteration index</span>
<span class=
"linenr">397: </span>      i -= stringifyCurrentChunk(i)
<span class="linenr">398: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">reset state</span>
<span class="linenr">399: </span>      nc = <span class=
"org-highlight-numbers-number">0</span>
<span class="linenr">400: </span>      ec = <span class=
"org-highlight-numbers-number">0</span>
<span class=
"linenr">401: </span>      currentChunk.length = <span class=
"org-highlight-numbers-number">0</span>
<span class="linenr">402: </span>    }
<span class="linenr">403: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">in case the last node was also stringifiable</span>
<span class="linenr">404: </span>    stringifyCurrentChunk(i)
<span class="linenr">405: </span>  }
<span class="linenr">406: </span>  
<span class="linenr">407: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">getHoistedNode</span> = (node) =&gt;
<span class=
"linenr">408: </span>    ((node.type === NodeTypes.ELEMENT &amp;& node.tagType === ElementTypes.ELEMENT) ||
<span class=
"linenr">409: </span>      node.type == NodeTypes.TEXT_CALL) &amp;&
<span class="linenr">410: </span>    node.codegenNode &amp;&
<span class=
"linenr">411: </span>    node.codegenNode.type === NodeTypes.SIMPLE_EXPRESSION &amp;&
<span class="linenr">412: </span>    node.codegenNode.hoisted
<span class="linenr">413: </span>  
<span class="linenr">414: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">dataAriaRE</span> = <span class=
"org-string">/^(data|aria)-/</span>
<span class="linenr">415: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isStringifiableAttr</span> = (name, ns) =&gt; {
<span class="linenr">416: </span>    <span class=
"org-keyword">return</span> (
<span class="linenr">417: </span>      (ns === DOMNamespaces.HTML
<span class="linenr">418: </span>        ? isKnownHtmlAttr(name)
<span class="linenr">419: </span>        : ns === DOMNamespaces.SVG
<span class="linenr">420: </span>        ? isKnownSvgAttr(name)
<span class="linenr">421: </span>        : <span class=
"org-constant">false</span>) || dataAriaRE.test(name)
<span class="linenr">422: </span>    )
<span class="linenr">423: </span>  }
<span class="linenr">424: </span>  
<span class="linenr">425: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">replaceHoist</span> = (node,replacement,context) =&gt; {
<span class="linenr">426: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">hoistToReplace</span> = node.codegenNode.hoisted
<span class=
"linenr">427: </span>    context.hoists[context.hoists.indexOf(hoistToReplace)] = replacement
<span class="linenr">428: </span>  }
<span class="linenr">429: </span>  
<span class="linenr">430: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isNonStringifiable</span> = <span class=
"org-comment-delimiter">/*</span><span class=
"org-comment">#__PURE__</span><span class=
"org-comment-delimiter">*/</span> makeMap(
<span class="linenr">431: </span>    <span class=
"org-string">`caption,thead,tr,th,tbody,td,tfoot,colgroup,col`</span>
<span class="linenr">432: </span>  )
<span class="linenr">433: </span>  
<span class="linenr">434: </span>  <span class="org-doc">/**</span>
<span class="linenr">435: </span><span class=
"org-doc">   * for a hoisted node, analyze it and return:</span>
<span class="linenr">436: </span><span class=
"org-doc">   * - false: bailed (contains non-stringifiable props or runtime constant)</span>
<span class="linenr">437: </span><span class=
"org-doc">   * - [nc, ec] where</span>
<span class="linenr">438: </span><span class=
"org-doc">   *   - nc is the number of nodes inside</span>
<span class="linenr">439: </span><span class=
"org-doc">   *   - ec is the number of element with bindings inside</span>
<span class="linenr">440: </span><span class="org-doc">   */</span>
<span class="linenr">441: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">analyzeNode</span>(<span class=
"org-variable-name">node</span>) {
<span class="linenr">442: </span>    <span class=
"org-keyword">if</span> (node.type === NodeTypes.ELEMENT &amp;& isNonStringifiable(node.tag)) {
<span class="linenr">443: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">444: </span>    }
<span class="linenr">445: </span>  
<span class="linenr">446: </span>    <span class=
"org-keyword">if</span> (node.type === NodeTypes.TEXT_CALL) {
<span class="linenr">447: </span>      <span class=
"org-keyword">return</span> [<span class=
"org-highlight-numbers-number">1</span>, <span class=
"org-highlight-numbers-number">0</span>]
<span class="linenr">448: </span>    }
<span class="linenr">449: </span>  
<span class="linenr">450: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">nc</span> = <span class=
"org-highlight-numbers-number">1</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">node count</span>
<span class="linenr">451: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">ec</span> = node.props.length &gt; <span class=
"org-highlight-numbers-number">0</span> ? <span class=
"org-highlight-numbers-number">1</span> : <span class=
"org-highlight-numbers-number">0</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">element w/ binding count</span>
<span class="linenr">452: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">bailed</span> = <span class=
"org-constant">false</span>
<span class="linenr">453: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">bail</span> = () =&gt; {
<span class="linenr">454: </span>      bailed = <span class=
"org-constant">true</span>
<span class="linenr">455: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">456: </span>    }
<span class="linenr">457: </span>  
<span class="linenr">458: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment"><span class="org-bold"><span class=
"org-warning">TODO:</span></span></span><span class=
"org-comment"> check for cases where using innerHTML will result in different</span>
<span class="linenr">459: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">output compared to imperative node insertions.</span>
<span class="linenr">460: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">probably only need to check for most common case</span>
<span class="linenr">461: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">i.e. non-phrasing-content tags inside `&lt;p&gt;`</span>
<span class="linenr">462: </span>    <span class=
"org-keyword">function</span> <span class=
"org-function-name">walk</span>(<span class=
"org-variable-name">node</span>) {
<span class="linenr">463: </span>      <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; node.props.length; i++) {
<span class="linenr">464: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">p</span> = node.props[i]
<span class="linenr">465: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">bail on non-attr bindings</span>
<span class="linenr">466: </span>        <span class=
"org-keyword">if</span> (
<span class=
"linenr">467: </span>          p.type === NodeTypes.ATTRIBUTE &amp;&
<span class=
"linenr">468: </span>          !isStringifiableAttr(p.name, node.ns)
<span class="linenr">469: </span>        ) {
<span class="linenr">470: </span>          <span class=
"org-keyword">return</span> bail()
<span class="linenr">471: </span>        }
<span class="linenr">472: </span>        <span class=
"org-keyword">if</span> (p.type === NodeTypes.DIRECTIVE &amp;& p.name === <span class="org-string">'bind'</span>) {
<span class="linenr">473: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">bail on non-attr bindings</span>
<span class="linenr">474: </span>          <span class=
"org-keyword">if</span> (
<span class="linenr">475: </span>            p.arg &amp;&
<span class=
"linenr">476: </span>            (p.arg.type === NodeTypes.COMPOUND_EXPRESSION ||
<span class=
"linenr">477: </span>              (p.arg.isStatic &amp;& !isStringifiableAttr(p.arg.content, node.ns)))
<span class="linenr">478: </span>          ) {
<span class="linenr">479: </span>            <span class=
"org-keyword">return</span> bail()
<span class="linenr">480: </span>          }
<span class="linenr">481: </span>          <span class=
"org-keyword">if</span> (
<span class="linenr">482: </span>            p.exp &amp;&
<span class=
"linenr">483: </span>            (p.exp.type === NodeTypes.COMPOUND_EXPRESSION ||
<span class=
"linenr">484: </span>              p.exp.constType &lt; ConstantTypes.CAN_STRINGIFY)
<span class="linenr">485: </span>          ) {
<span class="linenr">486: </span>            <span class=
"org-keyword">return</span> bail()
<span class="linenr">487: </span>          }
<span class="linenr">488: </span>        }
<span class="linenr">489: </span>      }
<span class="linenr">490: </span>      <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; node.children.length; i++) {
<span class="linenr">491: </span>        nc++
<span class="linenr">492: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">child</span> = node.children[i]
<span class="linenr">493: </span>        <span class=
"org-keyword">if</span> (child.type === NodeTypes.ELEMENT) {
<span class="linenr">494: </span>          <span class=
"org-keyword">if</span> (child.props.length &gt; <span class=
"org-highlight-numbers-number">0</span>) {
<span class="linenr">495: </span>            ec++
<span class="linenr">496: </span>          }
<span class="linenr">497: </span>          walk(child)
<span class="linenr">498: </span>          <span class=
"org-keyword">if</span> (bailed) {
<span class="linenr">499: </span>            <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">500: </span>          }
<span class="linenr">501: </span>        }
<span class="linenr">502: </span>      }
<span class="linenr">503: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr">504: </span>    }
<span class="linenr">505: </span>  
<span class="linenr">506: </span>    <span class=
"org-keyword">return</span> walk(node) ? [nc, ec] : <span class=
"org-constant">false</span>
<span class="linenr">507: </span>  }
<span class="linenr">508: </span>  
<span class="linenr">509: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">stringifyNode</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
<span class="linenr">510: </span>    <span class=
"org-keyword">if</span> (isString(node)) {
<span class="linenr">511: </span>      <span class=
"org-keyword">return</span> node
<span class="linenr">512: </span>    }
<span class="linenr">513: </span>    <span class=
"org-keyword">if</span> (isSymbol(node)) {
<span class="linenr">514: </span>      <span class=
"org-keyword">return</span> <span class="org-string">``</span>
<span class="linenr">515: </span>    }
<span class="linenr">516: </span>    <span class=
"org-keyword">switch</span> (node.type) {
<span class="linenr">517: </span>      <span class=
"org-keyword">case</span> NodeTypes.ELEMENT:
<span class="linenr">518: </span>        <span class=
"org-keyword">return</span> stringifyElement(node, context)
<span class="linenr">519: </span>      <span class=
"org-keyword">case</span> NodeTypes.TEXT:
<span class="linenr">520: </span>        <span class=
"org-keyword">return</span> escapeHtml(node.content)
<span class="linenr">521: </span>      <span class=
"org-keyword">case</span> NodeTypes.COMMENT:
<span class="linenr">522: </span>        <span class=
"org-keyword">return</span> <span class=
"org-string">`&lt;!--${escapeHtml(node.content)}--&gt;`</span>
<span class="linenr">523: </span>      <span class=
"org-keyword">case</span> NodeTypes.INTERPOLATION:
<span class="linenr">524: </span>        <span class=
"org-keyword">return</span> escapeHtml(toDisplayString(evaluateConstant(node.content)))
<span class="linenr">525: </span>      <span class=
"org-keyword">case</span> NodeTypes.COMPOUND_EXPRESSION:
<span class="linenr">526: </span>        <span class=
"org-keyword">return</span> escapeHtml(evaluateConstant(node))
<span class="linenr">527: </span>      <span class=
"org-keyword">case</span> NodeTypes.TEXT_CALL:
<span class="linenr">528: </span>        <span class=
"org-keyword">return</span> stringifyNode(node.content, context)
<span class="linenr">529: </span>      <span class=
"org-keyword">default</span>:
<span class="linenr">530: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">static trees will not contain if/for nodes</span>
<span class="linenr">531: </span>        <span class=
"org-keyword">return</span> <span class="org-string">''</span>
<span class="linenr">532: </span>    }
<span class="linenr">533: </span>  }
<span class="linenr">534: </span>  
<span class="linenr">535: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">stringifyElement</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
<span class="linenr">536: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">res</span> = <span class=
"org-string">`&lt;${node.tag}`</span>
<span class="linenr">537: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; node.props.length; i++) {
<span class="linenr">538: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">p</span> = node.props[i]
<span class="linenr">539: </span>      <span class=
"org-keyword">if</span> (p.type === NodeTypes.ATTRIBUTE) {
<span class="linenr">540: </span>        res += <span class=
"org-string">` ${p.name}`</span>
<span class="linenr">541: </span>        <span class=
"org-keyword">if</span> (p.value) {
<span class="linenr">542: </span>          res += <span class=
"org-string">`="${escapeHtml(p.value.content)}"`</span>
<span class="linenr">543: </span>        }
<span class="linenr">544: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (p.type === NodeTypes.DIRECTIVE &amp;& p.name === <span class="org-string">'bind'</span>) {
<span class="linenr">545: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">exp</span> = p.exp
<span class="linenr">546: </span>        <span class=
"org-keyword">if</span> (exp.content[<span class=
"org-highlight-numbers-number">0</span>] === <span class=
"org-string">'_'</span>) {
<span class="linenr">547: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">internally generated string constant references</span>
<span class="linenr">548: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">e.g. imported URL strings via compiler-sfc transformAssetUrl plugin</span>
<span class="linenr">549: </span>          res += <span class=
"org-string">` ${p.arg.content}="__VUE_EXP_START__${</span>
<span class="linenr">550: </span><span class=
"org-string">            exp.content</span>
<span class="linenr">551: </span><span class=
"org-string">          }__VUE_EXP_END__"`</span>
<span class="linenr">552: </span>          <span class=
"org-keyword">continue</span>
<span class="linenr">553: </span>        }
<span class="linenr">554: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">constant v-bind, e.g. :foo="1"</span>
<span class="linenr">555: </span>        <span class=
"org-keyword">let</span> <span class=
"org-variable-name">evaluated</span> = evaluateConstant(exp)
<span class="linenr">556: </span>        <span class=
"org-keyword">if</span> (evaluated != <span class=
"org-constant">null</span>) {
<span class="linenr">557: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">arg</span> = p.arg &amp;& p.arg.content
<span class="linenr">558: </span>          <span class=
"org-keyword">if</span> (arg === <span class=
"org-string">'class'</span>) {
<span class=
"linenr">559: </span>            evaluated = normalizeClass(evaluated)
<span class="linenr">560: </span>          } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (arg === <span class=
"org-string">'style'</span>) {
<span class=
"linenr">561: </span>            evaluated = stringifyStyle(normalizeStyle(evaluated))
<span class="linenr">562: </span>          }
<span class="linenr">563: </span>          res += <span class=
"org-string">` ${p.arg.content}="${escapeHtml(evaluated)}"`</span>
<span class="linenr">564: </span>        }
<span class="linenr">565: </span>      }
<span class="linenr">566: </span>    }
<span class="linenr">567: </span>    <span class=
"org-keyword">if</span> (context.scopeId) {
<span class="linenr">568: </span>      res += <span class=
"org-string">` ${context.scopeId}`</span>
<span class="linenr">569: </span>    }
<span class="linenr">570: </span>    res += <span class=
"org-string">`&gt;`</span>
<span class="linenr">571: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; node.children.length; i++) {
<span class=
"linenr">572: </span>      res += stringifyNode(node.children[i], context)
<span class="linenr">573: </span>    }
<span class="linenr">574: </span>    <span class=
"org-keyword">if</span> (!isVoidTag(node.tag)) {
<span class="linenr">575: </span>      res += <span class=
"org-string">`&lt;/${node.tag}&gt;`</span>
<span class="linenr">576: </span>    }
<span class="linenr">577: </span>    <span class=
"org-keyword">return</span> res
<span class="linenr">578: </span>  }
<span class="linenr">579: </span>  
<span class="linenr">580: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">__UNSAFE__</span>
<span class="linenr">581: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">Reason: eval.</span>
<span class="linenr">582: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">It's technically safe to eval because only constant expressions are possible</span>
<span class="linenr">583: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">here, e.g. `{{ 1 }}` or `{{ 'foo' }}`</span>
<span class="linenr">584: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">in addition, constant exps bail on presence of parens so you can't even</span>
<span class="linenr">585: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">run JSFuck in here. But we mark it unsafe for security review purposes.</span>
<span class="linenr">586: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">(see compiler-core/src/transformExpressions)</span>
<span class="linenr">587: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">evaluateConstant</span>(<span class=
"org-variable-name">exp</span>) {
<span class="linenr">588: </span>    <span class=
"org-keyword">if</span> (exp.type === NodeTypes.SIMPLE_EXPRESSION) {
<span class="linenr">589: </span>      <span class=
"org-keyword">return</span> <span class=
"org-keyword">new</span> <span class=
"org-type">Function</span>(<span class=
"org-string">`return ${exp.content}`</span>)()
<span class="linenr">590: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr">591: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">compound</span>
<span class="linenr">592: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">res</span> = <span class="org-string">``</span>
<span class=
"linenr">593: </span>      exp.children.forEach(c =&gt; {
<span class="linenr">594: </span>        <span class=
"org-keyword">if</span> (isString(c) || isSymbol(c)) {
<span class="linenr">595: </span>          <span class=
"org-keyword">return</span>
<span class="linenr">596: </span>        }
<span class="linenr">597: </span>        <span class=
"org-keyword">if</span> (c.type === NodeTypes.TEXT) {
<span class="linenr">598: </span>          res += c.content
<span class="linenr">599: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (c.type === NodeTypes.INTERPOLATION) {
<span class=
"linenr">600: </span>          res += toDisplayString(evaluateConstant(c.content))
<span class="linenr">601: </span>        } <span class=
"org-keyword">else</span> {
<span class=
"linenr">602: </span>          res += evaluateConstant(c)
<span class="linenr">603: </span>        }
<span class="linenr">604: </span>      })
<span class="linenr">605: </span>      <span class=
"org-keyword">return</span> res
<span class="linenr">606: </span>    }
<span class="linenr">607: </span>  }
<span class="linenr">608: </span>  
<span class="linenr">609: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">DOMDirectiveTransforms</span> = {
<span class="linenr">610: </span>    cloak: noopDirectiveTransform,
<span class="linenr">611: </span>    html: transformVHtml,
<span class="linenr">612: </span>    text: transformVText,
<span class=
"linenr">613: </span>    model: transformModel, <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">override compiler-core</span>
<span class="linenr">614: </span>    on: transformOn, <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">override compiler-core</span>
<span class="linenr">615: </span>    show: transformShow
<span class="linenr">616: </span>  }
<span class="linenr">617: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">DOMNodeTransforms</span> = [
<span class="linenr">618: </span>    transformStyle,
<span class=
"linenr">619: </span>    ...(__DEV__ ? [warnTransitionChildren] : [])
<span class="linenr">620: </span>  ]
<span class="linenr">621: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">compile</span>(<span class=
"org-variable-name">template</span>, <span class=
"org-variable-name">options</span> = {}) {
<span class="linenr">622: </span>    <span class=
"org-keyword">return</span> baseCompile(
<span class="linenr">623: </span>      template,
<span class=
"linenr">624: </span>      extend({}, parserOptions, options, {
<span class="linenr">625: </span>        nodeTransforms: [
<span class="linenr">626: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">ignore &lt;script&gt; and &lt;tag&gt;</span>
<span class="linenr">627: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">this is not put inside DOMNodeTransforms because that list is used</span>
<span class="linenr">628: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">by compiler-ssr to generate vnode fallback branches</span>
<span class="linenr">629: </span>          ignoreSideEffectTags,
<span class="linenr">630: </span>          ...DOMNodeTransforms,
<span class=
"linenr">631: </span>          ...(options.nodeTransforms || [])
<span class="linenr">632: </span>        ],
<span class=
"linenr">633: </span>        directiveTransforms: extend(
<span class="linenr">634: </span>          {},
<span class="linenr">635: </span>          DOMDirectiveTransforms,
<span class=
"linenr">636: </span>          options.directiveTransforms || {}
<span class="linenr">637: </span>        ),
<span class=
"linenr">638: </span>        transformHoist: __BROWSER__ ? <span class="org-constant">null</span> : stringifyStatic
<span class="linenr">639: </span>      })
<span class="linenr">640: </span>    )
<span class="linenr">641: </span>  }
<span class="linenr">642: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">parse</span>(<span class=
"org-variable-name">template</span>, <span class=
"org-variable-name">options</span> = {}) {
<span class="linenr">643: </span>    <span class=
"org-keyword">return</span> baseParse(template, extend({}, parserOptions, options))
<span class="linenr">644: </span>  }
<span class="linenr">645: </span>
<span class="linenr">646: </span>  <span class=
"org-keyword">return</span> {
<span class="linenr">647: </span>    DOMNodeTransforms,
<span class="linenr">648: </span>    DOMDirectiveTransforms,
<span class="linenr">649: </span>    compile,
<span class="linenr">650: </span>    parse,
<span class="linenr">651: </span>    transformStyle,
<span class="linenr">652: </span>  }
<span class="linenr">653: </span>}())
</pre>
      </div>
    </details><br>
    <details class="code-details" style=
    "padding: 1em; background-color: #e5f5e5; /* background-color: pink; */ border-radius: 15px; color: hsl(157 75%); font-size: 0.9em; box-shadow: 0.05em 0.1em 5px 0.01em #00000057;">
      <summary>
        <strong><font face="Courier" size="3" color=
        "green">compiler-sfc</font></strong>
      </summary>
      <div class="org-src-container">
        <pre class="src src-js"><span class=
        "linenr">   1: </span><span class=
        "org-keyword">const</span> <span class=
        "org-variable-name">__ESM_BROWSER__</span> = <span class=
        "org-constant">false</span>, <span class=
        "org-variable-name">__GLOBAL__</span> = <span class=
        "org-constant">true</span>
<span class="linenr">   2: </span><span class=
"org-keyword">let</span> <span class=
"org-variable-name">MagicString</span> = require(process.env.NODE_LIB + <span class="org-string">'/magic-string'</span>)
<span class="linenr">   3: </span>
<span class="linenr">   4: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">createCache</span>(<span class=
"org-variable-name">size</span> = <span class=
"org-highlight-numbers-number">500</span>) {
<span class="linenr">   5: </span>  <span class=
"org-keyword">return</span> <span class=
"org-keyword">new</span> <span class="org-type">Map</span>()
<span class="linenr">   6: </span>}
<span class="linenr">   7: </span>
<span class="linenr">   8: </span>
<span class="linenr">   9: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">defaultExportRE</span> = <span class=
"org-string">/((?:^|\n|;)\s*)export(\s*)default/</span>
<span class="linenr">  10: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">namedDefaultExportRE</span> = <span class=
"org-string">/((?:^|\n|;)\s*)export(.+)as(\s*)default/</span>s
<span class="linenr">  11: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">exportDefaultClassRE</span> =
<span class="linenr">  12: </span>  <span class=
"org-string">/((?:^|\n|;)\s*)export\s+default\s+class\s+([\w$]+)/</span>
<span class="linenr">  13: </span>
<span class="linenr">  14: </span><span class="org-doc">/**</span>
<span class="linenr">  15: </span><span class=
"org-doc"> * Utility for rewriting `export default` in a script block into a variable</span>
<span class="linenr">  16: </span><span class=
"org-doc"> * declaration so that we can inject things into it</span>
<span class="linenr">  17: </span><span class="org-doc"> */</span>
<span class="linenr">  18: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">rewriteDefault</span>(<span class=
"org-variable-name">input</span>, <span class=
"org-variable-name">as</span>, <span class=
"org-variable-name">parserPlugins</span>) {
<span class="linenr">  19: </span>  <span class=
"org-keyword">if</span> (!hasDefaultExport(input)) {
<span class="linenr">  20: </span>    <span class=
"org-keyword">return</span> input + <span class=
"org-string">`\nconst ${as} = {}`</span>
<span class="linenr">  21: </span>  }
<span class="linenr">  22: </span>
<span class="linenr">  23: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">replaced</span>
<span class="linenr">  24: </span>
<span class="linenr">  25: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">classMatch</span> = input.match(exportDefaultClassRE)
<span class="linenr">  26: </span>  <span class=
"org-keyword">if</span> (classMatch) {
<span class="linenr">  27: </span>    replaced =
<span class=
"linenr">  28: </span>      input.replace(exportDefaultClassRE, <span class="org-string">'$1class $2'</span>) +
<span class="linenr">  29: </span>      <span class=
"org-string">`\nconst ${as} = ${classMatch[2]}`</span>
<span class="linenr">  30: </span>  } <span class=
"org-keyword">else</span> {
<span class=
"linenr">  31: </span>    replaced = input.replace(defaultExportRE, <span class="org-string">`$1const ${as} =`</span>)
<span class="linenr">  32: </span>  }
<span class="linenr">  33: </span>  <span class=
"org-keyword">if</span> (!hasDefaultExport(replaced)) {
<span class="linenr">  34: </span>    <span class=
"org-keyword">return</span> replaced
<span class="linenr">  35: </span>  }
<span class="linenr">  36: </span>
<span class="linenr">  37: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">if the script somehow still contains `default export`, it probably has</span>
<span class="linenr">  38: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">multi-line comments or template strings. fallback to a full parse.</span>
<span class="linenr">  39: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">s</span> = <span class=
"org-keyword">new</span> <span class=
"org-type">MagicString</span>(input)
<span class="linenr">  40: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">ast</span> = babelParser.parse(input, {
<span class="linenr">  41: </span>    sourceType: <span class=
"org-string">'module'</span>,
<span class="linenr">  42: </span>    plugins: parserPlugins
<span class="linenr">  43: </span>  }).program.body
<span class="linenr">  44: </span>  ast.forEach(node =&gt; {
<span class="linenr">  45: </span>    <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'ExportDefaultDeclaration'</span>) {
<span class=
"linenr">  46: </span>      s.overwrite(node.start, node.declaration.start, <span class="org-string">`const ${as} = `</span>)
<span class="linenr">  47: </span>    }
<span class="linenr">  48: </span>    <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'ExportNamedDeclaration'</span>) {
<span class=
"linenr">  49: </span>      node.specifiers.forEach(specifier =&gt; {
<span class="linenr">  50: </span>        <span class=
"org-keyword">if</span> (
<span class=
"linenr">  51: </span>          specifier.type === <span class=
"org-string">'ExportSpecifier'</span> &amp;&
<span class=
"linenr">  52: </span>          specifier.exported.type === <span class="org-string">'Identifier'</span> &amp;&
<span class=
"linenr">  53: </span>          specifier.exported.name === <span class="org-string">'default'</span>
<span class="linenr">  54: </span>        ) {
<span class="linenr">  55: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">end</span> = specifier.end
<span class="linenr">  56: </span>          s.overwrite(
<span class="linenr">  57: </span>            specifier.start,
<span class=
"linenr">  58: </span>            input.charAt(end) === <span class="org-string">','</span> ? end + <span class="org-highlight-numbers-number">1</span> : end,
<span class="linenr">  59: </span>            <span class=
"org-string">``</span>
<span class="linenr">  60: </span>          )
<span class="linenr">  61: </span>          s.append(<span class=
"org-string">`\nconst ${as} = ${specifier.local.name}`</span>)
<span class="linenr">  62: </span>        }
<span class="linenr">  63: </span>      })
<span class="linenr">  64: </span>    }
<span class="linenr">  65: </span>  })
<span class="linenr">  66: </span>  <span class=
"org-keyword">return</span> s.toString()
<span class="linenr">  67: </span>}
<span class="linenr">  68: </span>
<span class="linenr">  69: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">hasDefaultExport</span>(<span class=
"org-variable-name">input</span>) {
<span class="linenr">  70: </span>  <span class=
"org-keyword">return</span> defaultExportRE.test(input) || namedDefaultExportRE.test(input)
<span class="linenr">  71: </span>}
<span class="linenr">  72: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">RT</span> = (<span class=
"org-keyword">function</span>() {
<span class="linenr">  73: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">CONVERT_SYMBOL</span> = <span class=
"org-string">'$'</span>
<span class="linenr">  74: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">ESCAPE_SYMBOL</span> = <span class=
"org-string">'$$'</span>
<span class="linenr">  75: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">shorthands</span> = [<span class=
"org-string">'ref'</span>, <span class=
"org-string">'computed'</span>, <span class=
"org-string">'shallowRef'</span>, <span class=
"org-string">'toRef'</span>, <span class=
"org-string">'customRef'</span>]
<span class="linenr">  76: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">transformCheckRE</span> = <span class=
"org-string">/[^\w]\$(?:\$|ref|computed|shallowRef)?\s*(\(|\&lt;)/</span>
<span class="linenr">  77: </span>
<span class="linenr">  78: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">shouldTransform</span>(<span class=
"org-variable-name">src</span>) {
<span class="linenr">  79: </span>  <span class=
"org-keyword">return</span> transformCheckRE.test(src)
<span class="linenr">  80: </span>}
<span class="linenr">  81: </span>
<span class="linenr">  82: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">transform</span>(
<span class="linenr">  83: </span>  <span class=
"org-variable-name">src</span>,
<span class="linenr">  84: </span>  {
<span class="linenr">  85: </span>    filename,
<span class="linenr">  86: </span>    sourceMap,
<span class="linenr">  87: </span>    parserPlugins,
<span class=
"linenr">  88: </span>    importHelpersFrom = <span class=
"org-string">'vue'</span>
<span class="linenr">  89: </span>  } = {}
<span class="linenr">  90: </span>) {
<span class="linenr">  91: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">plugins</span> = parserPlugins || []
<span class="linenr">  92: </span>  <span class=
"org-keyword">if</span> (filename) {
<span class="linenr">  93: </span>    <span class=
"org-keyword">if</span> (<span class=
"org-string">/\.tsx?$/</span>.test(filename)) {
<span class="linenr">  94: </span>      plugins.push(<span class=
"org-string">'typescript'</span>)
<span class="linenr">  95: </span>    }
<span class="linenr">  96: </span>    <span class=
"org-keyword">if</span> (filename.endsWith(<span class=
"org-string">'x'</span>)) {
<span class="linenr">  97: </span>      plugins.push(<span class=
"org-string">'jsx'</span>)
<span class="linenr">  98: </span>    }
<span class="linenr">  99: </span>  }
<span class="linenr"> 100: </span>
<span class="linenr"> 101: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">ast</span> = babelParser.parse(src, {
<span class="linenr"> 102: </span>    sourceType: <span class=
"org-string">'module'</span>,
<span class="linenr"> 103: </span>    plugins
<span class="linenr"> 104: </span>  })
<span class="linenr"> 105: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">s</span> = <span class=
"org-keyword">new</span> <span class=
"org-type">MagicString</span>(src)
<span class="linenr"> 106: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">res</span> = transformAST(ast.program, s, <span class="org-highlight-numbers-number">0</span>)
<span class="linenr"> 107: </span>
<span class="linenr"> 108: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">inject helper imports</span>
<span class="linenr"> 109: </span>  <span class=
"org-keyword">if</span> (res.importedHelpers.length) {
<span class="linenr"> 110: </span>    s.prepend(
<span class="linenr"> 111: </span>      <span class=
"org-string">`import { ${res.importedHelpers</span>
<span class="linenr"> 112: </span><span class=
"org-string">        .map(h =&gt; `</span>${h} as _${h}<span class=
"org-string">`)</span>
<span class="linenr"> 113: </span><span class=
"org-string">        .join(', ')} } from '${importHelpersFrom}'\n`</span>
<span class="linenr"> 114: </span>    )
<span class="linenr"> 115: </span>  }
<span class="linenr"> 116: </span>
<span class="linenr"> 117: </span>  <span class=
"org-keyword">return</span> {
<span class="linenr"> 118: </span>    ...res,
<span class="linenr"> 119: </span>    code: s.toString(),
<span class="linenr"> 120: </span>    map: sourceMap
<span class="linenr"> 121: </span>      ? s.generateMap({
<span class="linenr"> 122: </span>          source: filename,
<span class="linenr"> 123: </span>          hires: <span class=
"org-constant">true</span>,
<span class=
"linenr"> 124: </span>          includeContent: <span class=
"org-constant">true</span>
<span class="linenr"> 125: </span>        })
<span class="linenr"> 126: </span>      : <span class=
"org-constant">null</span>
<span class="linenr"> 127: </span>  }
<span class="linenr"> 128: </span>}
<span class="linenr"> 129: </span>
<span class="linenr"> 130: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">transformAST</span>(
<span class="linenr"> 131: </span>  <span class=
"org-variable-name">ast</span>,
<span class="linenr"> 132: </span>  <span class=
"org-variable-name">s</span>,
<span class="linenr"> 133: </span>  offset = <span class=
"org-highlight-numbers-number">0</span>,
<span class="linenr"> 134: </span>  <span class=
"org-variable-name">knownRefs</span>,
<span class="linenr"> 135: </span>  knownProps
<span class="linenr"> 136: </span>) {
<span class="linenr"> 137: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">convertSymbol</span> = CONVERT_SYMBOL
<span class="linenr"> 138: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">escapeSymbol</span> = ESCAPE_SYMBOL
<span class="linenr"> 139: </span>
<span class="linenr"> 140: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">macro import handling</span>
<span class="linenr"> 141: </span>  <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">node</span> <span class=
"org-keyword">of</span> ast.body) {
<span class="linenr"> 142: </span>    <span class=
"org-keyword">if</span> (
<span class="linenr"> 143: </span>      node.type === <span class=
"org-string">'ImportDeclaration'</span> &amp;&
<span class=
"linenr"> 144: </span>      node.source.value === <span class=
"org-string">'vue/macros'</span>
<span class="linenr"> 145: </span>    ) {
<span class="linenr"> 146: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">remove macro imports</span>
<span class=
"linenr"> 147: </span>      s.remove(node.start + offset, node.end + offset)
<span class="linenr"> 148: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">check aliasing</span>
<span class="linenr"> 149: </span>      <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">specifier</span> <span class=
"org-keyword">of</span> node.specifiers) {
<span class="linenr"> 150: </span>        <span class=
"org-keyword">if</span> (specifier.type === <span class=
"org-string">'ImportSpecifier'</span>) {
<span class="linenr"> 151: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">imported</span> = specifier.imported.name
<span class="linenr"> 152: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">local</span> = specifier.local.name
<span class="linenr"> 153: </span>          <span class=
"org-keyword">if</span> (local !== imported) {
<span class="linenr"> 154: </span>            <span class=
"org-keyword">if</span> (imported === ESCAPE_SYMBOL) {
<span class=
"linenr"> 155: </span>              escapeSymbol = local
<span class="linenr"> 156: </span>            } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (imported === CONVERT_SYMBOL) {
<span class=
"linenr"> 157: </span>              convertSymbol = local
<span class="linenr"> 158: </span>            } <span class=
"org-keyword">else</span> {
<span class="linenr"> 159: </span>              error(
<span class="linenr"> 160: </span>                <span class=
"org-string">`macro imports for ref-creating methods do not support aliasing.`</span>,
<span class="linenr"> 161: </span>                specifier
<span class="linenr"> 162: </span>              )
<span class="linenr"> 163: </span>            }
<span class="linenr"> 164: </span>          }
<span class="linenr"> 165: </span>        }
<span class="linenr"> 166: </span>      }
<span class="linenr"> 167: </span>    }
<span class="linenr"> 168: </span>  }
<span class="linenr"> 169: </span>
<span class="linenr"> 170: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">importedHelpers</span> = <span class=
"org-keyword">new</span> <span class="org-type">Set</span>()
<span class="linenr"> 171: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">rootScope</span> = {}
<span class="linenr"> 172: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">scopeStack</span> = [rootScope]
<span class="linenr"> 173: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">currentScope</span> = rootScope
<span class="linenr"> 174: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">escapeScope</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">inside $$()</span>
<span class="linenr"> 175: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">excludedIds</span> = <span class=
"org-keyword">new</span> <span class="org-type">WeakSet</span>()
<span class="linenr"> 176: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">parentStack</span> = []
<span class="linenr"> 177: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">propsLocalToPublicMap</span> = Object.create(<span class="org-constant">null</span>)
<span class="linenr"> 178: </span>
<span class="linenr"> 179: </span>  <span class=
"org-keyword">if</span> (knownRefs) {
<span class="linenr"> 180: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">of</span> knownRefs) {
<span class=
"linenr"> 181: </span>      rootScope[key] = <span class=
"org-constant">true</span>
<span class="linenr"> 182: </span>    }
<span class="linenr"> 183: </span>  }
<span class="linenr"> 184: </span>  <span class=
"org-keyword">if</span> (knownProps) {
<span class="linenr"> 185: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">in</span> knownProps) {
<span class="linenr"> 186: </span>      <span class=
"org-keyword">const</span> { local } = knownProps[key]
<span class=
"linenr"> 187: </span>      rootScope[local] = <span class=
"org-string">'prop'</span>
<span class=
"linenr"> 188: </span>      propsLocalToPublicMap[local] = key
<span class="linenr"> 189: </span>    }
<span class="linenr"> 190: </span>  }
<span class="linenr"> 191: </span>
<span class="linenr"> 192: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">isRefCreationCall</span>(<span class=
"org-variable-name">callee</span>) {
<span class="linenr"> 193: </span>    <span class=
"org-keyword">if</span> (callee === convertSymbol) {
<span class="linenr"> 194: </span>      <span class=
"org-keyword">return</span> convertSymbol
<span class="linenr"> 195: </span>    }
<span class="linenr"> 196: </span>    <span class=
"org-keyword">if</span> (callee[<span class=
"org-highlight-numbers-number">0</span>] === <span class=
"org-string">'$'</span> &amp;& shorthands.includes(callee.slice(<span class="org-highlight-numbers-number">1</span>))) {
<span class="linenr"> 197: </span>      <span class=
"org-keyword">return</span> callee
<span class="linenr"> 198: </span>    }
<span class="linenr"> 199: </span>    <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr"> 200: </span>  }
<span class="linenr"> 201: </span>
<span class="linenr"> 202: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">error</span>(<span class=
"org-variable-name">msg</span>, <span class=
"org-variable-name">node</span>) {
<span class="linenr"> 203: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">e</span> = <span class=
"org-keyword">new</span> <span class="org-type">Error</span>(msg)
<span class="linenr"> 204: </span>    e.node = node
<span class="linenr"> 205: </span>    <span class=
"org-keyword">throw</span> e
<span class="linenr"> 206: </span>  }
<span class="linenr"> 207: </span>
<span class="linenr"> 208: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">helper</span>(<span class=
"org-variable-name">msg</span>) {
<span class="linenr"> 209: </span>    importedHelpers.add(msg)
<span class="linenr"> 210: </span>    <span class=
"org-keyword">return</span> <span class=
"org-string">`_${msg}`</span>
<span class="linenr"> 211: </span>  }
<span class="linenr"> 212: </span>
<span class="linenr"> 213: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">registerBinding</span>(<span class=
"org-variable-name">id</span>, <span class=
"org-variable-name">isRef</span> = <span class=
"org-constant">false</span>) {
<span class="linenr"> 214: </span>    excludedIds.add(id)
<span class="linenr"> 215: </span>    <span class=
"org-keyword">if</span> (currentScope) {
<span class=
"linenr"> 216: </span>      currentScope[id.name] = isRef
<span class="linenr"> 217: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr"> 218: </span>      error(
<span class="linenr"> 219: </span>        <span class=
"org-string">'registerBinding called without active scope, something is wrong.'</span>,
<span class="linenr"> 220: </span>        id
<span class="linenr"> 221: </span>      )
<span class="linenr"> 222: </span>    }
<span class="linenr"> 223: </span>  }
<span class="linenr"> 224: </span>
<span class="linenr"> 225: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">registerRefBinding</span> = (id) =&gt; registerBinding(id, <span class="org-constant">true</span>)
<span class="linenr"> 226: </span>
<span class="linenr"> 227: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">tempVarCount</span> = <span class=
"org-highlight-numbers-number">0</span>
<span class="linenr"> 228: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">genTempVar</span>() {
<span class="linenr"> 229: </span>    <span class=
"org-keyword">return</span> <span class=
"org-string">`__$temp_${++tempVarCount}`</span>
<span class="linenr"> 230: </span>  }
<span class="linenr"> 231: </span>
<span class="linenr"> 232: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">snip</span>(<span class=
"org-variable-name">nod</span>) {
<span class="linenr"> 233: </span>    <span class=
"org-keyword">return</span> s.original.slice(node.start + offset, node.end + offset)
<span class="linenr"> 234: </span>  }
<span class="linenr"> 235: </span>
<span class="linenr"> 236: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">walkScope</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">isRoot</span> = <span class=
"org-constant">false</span>) {
<span class="linenr"> 237: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">stmt</span> <span class=
"org-keyword">of</span> node.body) {
<span class="linenr"> 238: </span>      <span class=
"org-keyword">if</span> (stmt.type === <span class=
"org-string">'VariableDeclaration'</span>) {
<span class=
"linenr"> 239: </span>        walkVariableDeclaration(stmt, isRoot)
<span class="linenr"> 240: </span>      } <span class=
"org-keyword">else</span> <span class="org-keyword">if</span> (
<span class=
"linenr"> 241: </span>        stmt.type === <span class="org-string">'FunctionDeclaration'</span> ||
<span class=
"linenr"> 242: </span>        stmt.type === <span class="org-string">'ClassDeclaration'</span>
<span class="linenr"> 243: </span>      ) {
<span class="linenr"> 244: </span>        <span class=
"org-keyword">if</span> (stmt.declare || !stmt.id) <span class=
"org-keyword">continue</span>
<span class="linenr"> 245: </span>        registerBinding(stmt.id)
<span class="linenr"> 246: </span>      } <span class=
"org-keyword">else</span> <span class="org-keyword">if</span> (
<span class=
"linenr"> 247: </span>        (stmt.type === <span class=
"org-string">'ForOfStatement'</span> || stmt.type === <span class=
"org-string">'ForInStatement'</span>) &amp;&
<span class=
"linenr"> 248: </span>        stmt.left.type === <span class=
"org-string">'VariableDeclaration'</span>
<span class="linenr"> 249: </span>      ) {
<span class=
"linenr"> 250: </span>        walkVariableDeclaration(stmt.left)
<span class="linenr"> 251: </span>      } <span class=
"org-keyword">else</span> <span class="org-keyword">if</span> (
<span class=
"linenr"> 252: </span>        stmt.type === <span class="org-string">'ExportNamedDeclaration'</span> &amp;&
<span class="linenr"> 253: </span>        stmt.declaration &amp;&
<span class=
"linenr"> 254: </span>        stmt.declaration.type === <span class="org-string">'VariableDeclaration'</span>
<span class="linenr"> 255: </span>      ) {
<span class=
"linenr"> 256: </span>        walkVariableDeclaration(stmt.declaration, isRoot)
<span class="linenr"> 257: </span>      } <span class=
"org-keyword">else</span> <span class="org-keyword">if</span> (
<span class=
"linenr"> 258: </span>        stmt.type === <span class="org-string">'LabeledStatement'</span> &amp;&
<span class=
"linenr"> 259: </span>        stmt.body.type === <span class=
"org-string">'VariableDeclaration'</span>
<span class="linenr"> 260: </span>      ) {
<span class=
"linenr"> 261: </span>        walkVariableDeclaration(stmt.body, isRoot)
<span class="linenr"> 262: </span>      }
<span class="linenr"> 263: </span>    }
<span class="linenr"> 264: </span>  }
<span class="linenr"> 265: </span>
<span class="linenr"> 266: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">walkVariableDeclaration</span>(<span class=
"org-variable-name">stmt</span>, <span class=
"org-variable-name">isRoot</span> = <span class=
"org-constant">false</span>) {
<span class="linenr"> 267: </span>    <span class=
"org-keyword">if</span> (stmt.declare) {
<span class="linenr"> 268: </span>      <span class=
"org-keyword">return</span>
<span class="linenr"> 269: </span>    }
<span class="linenr"> 270: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">decl</span> <span class=
"org-keyword">of</span> stmt.declarations) {
<span class="linenr"> 271: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">refCall</span>
<span class="linenr"> 272: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isCall</span> =
<span class="linenr"> 273: </span>        decl.init &amp;&
<span class=
"linenr"> 274: </span>        decl.init.type === <span class=
"org-string">'CallExpression'</span> &amp;&
<span class=
"linenr"> 275: </span>        decl.init.callee.type === <span class="org-string">'Identifier'</span>
<span class="linenr"> 276: </span>      <span class=
"org-keyword">if</span> (
<span class="linenr"> 277: </span>        isCall &amp;&
<span class=
"linenr"> 278: </span>        (refCall = isRefCreationCall(decl.init.callee.name))
<span class="linenr"> 279: </span>      ) {
<span class=
"linenr"> 280: </span>        processRefDeclaration(refCall, decl.id, decl.init)
<span class="linenr"> 281: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr"> 282: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isProps</span> =
<span class=
"linenr"> 283: </span>          isRoot &amp;& isCall &amp;& decl.init.callee.name === <span class="org-string">'defineProps'</span>
<span class="linenr"> 284: </span>        <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">id</span> <span class=
"org-keyword">of</span> extractIdentifiers(decl.id)) {
<span class="linenr"> 285: </span>          <span class=
"org-keyword">if</span> (isProps) {
<span class="linenr"> 286: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">for defineProps destructure, only exclude them since they</span>
<span class="linenr"> 287: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">are already passed in as knownProps</span>
<span class="linenr"> 288: </span>            excludedIds.add(id)
<span class="linenr"> 289: </span>          } <span class=
"org-keyword">else</span> {
<span class="linenr"> 290: </span>            registerBinding(id)
<span class="linenr"> 291: </span>          }
<span class="linenr"> 292: </span>        }
<span class="linenr"> 293: </span>      }
<span class="linenr"> 294: </span>    }
<span class="linenr"> 295: </span>  }
<span class="linenr"> 296: </span>
<span class="linenr"> 297: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">processRefDeclaration</span>(<span class=
"org-variable-name">method</span>, <span class=
"org-variable-name">id</span>, <span class=
"org-variable-name">call</span>) {
<span class="linenr"> 298: </span>    excludedIds.add(call.callee)
<span class="linenr"> 299: </span>    <span class=
"org-keyword">if</span> (method === convertSymbol) {
<span class="linenr"> 300: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">$</span>
<span class="linenr"> 301: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">remove macro</span>
<span class=
"linenr"> 302: </span>      s.remove(call.callee.start + offset, call.callee.end + offset)
<span class="linenr"> 303: </span>      <span class=
"org-keyword">if</span> (id.type === <span class=
"org-string">'Identifier'</span>) {
<span class="linenr"> 304: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">single variable</span>
<span class="linenr"> 305: </span>        registerRefBinding(id)
<span class="linenr"> 306: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (id.type === <span class=
"org-string">'ObjectPattern'</span>) {
<span class=
"linenr"> 307: </span>        processRefObjectPattern(id, call)
<span class="linenr"> 308: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (id.type === <span class=
"org-string">'ArrayPattern'</span>) {
<span class=
"linenr"> 309: </span>        processRefArrayPattern(id, call)
<span class="linenr"> 310: </span>      }
<span class="linenr"> 311: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr"> 312: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">shorthands</span>
<span class="linenr"> 313: </span>      <span class=
"org-keyword">if</span> (id.type === <span class=
"org-string">'Identifier'</span>) {
<span class="linenr"> 314: </span>        registerRefBinding(id)
<span class="linenr"> 315: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">replace call</span>
<span class="linenr"> 316: </span>        s.overwrite(
<span class="linenr"> 317: </span>          call.start + offset,
<span class=
"linenr"> 318: </span>          call.start + method.length + offset,
<span class=
"linenr"> 319: </span>          helper(method.slice(<span class=
"org-highlight-numbers-number">1</span>))
<span class="linenr"> 320: </span>        )
<span class="linenr"> 321: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr"> 322: </span>        error(<span class=
"org-string">`${method}() cannot be used with destructure patterns.`</span>, call)
<span class="linenr"> 323: </span>      }
<span class="linenr"> 324: </span>    }
<span class="linenr"> 325: </span>  }
<span class="linenr"> 326: </span>
<span class="linenr"> 327: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">processRefObjectPattern</span>(<span class=
"org-variable-name">pattern</span>, <span class=
"org-variable-name">call</span>, <span class=
"org-variable-name">tempVar</span>, <span class=
"org-variable-name">path</span> = []) {
<span class="linenr"> 328: </span>    <span class=
"org-keyword">if</span> (!tempVar) {
<span class="linenr"> 329: </span>      tempVar = genTempVar()
<span class="linenr"> 330: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">const { x } = $(useFoo()) --&gt; const __$temp_1 = useFoo()</span>
<span class=
"linenr"> 331: </span>      s.overwrite(pattern.start + offset, pattern.end + offset, tempVar)
<span class="linenr"> 332: </span>    }
<span class="linenr"> 333: </span>
<span class="linenr"> 334: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">p</span> <span class=
"org-keyword">of</span> pattern.properties) {
<span class="linenr"> 335: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">nameId</span>
<span class="linenr"> 336: </span>      <span class=
"org-keyword">let</span> <span class="org-variable-name">key</span>
<span class="linenr"> 337: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">defaultValue</span>
<span class="linenr"> 338: </span>      <span class=
"org-keyword">if</span> (p.type === <span class=
"org-string">'ObjectProperty'</span>) {
<span class="linenr"> 339: </span>        <span class=
"org-keyword">if</span> (p.key.start === p.value.start) {
<span class="linenr"> 340: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">shorthand { foo }</span>
<span class="linenr"> 341: </span>          nameId = p.key
<span class="linenr"> 342: </span>          <span class=
"org-keyword">if</span> (p.value.type === <span class=
"org-string">'Identifier'</span>) {
<span class="linenr"> 343: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">avoid shorthand value identifier from being processed</span>
<span class=
"linenr"> 344: </span>            excludedIds.add(p.value)
<span class="linenr"> 345: </span>          } <span class=
"org-keyword">else</span> <span class="org-keyword">if</span> (
<span class=
"linenr"> 346: </span>            p.value.type === <span class=
"org-string">'AssignmentPattern'</span> &amp;&
<span class=
"linenr"> 347: </span>            p.value.left.type === <span class="org-string">'Identifier'</span>
<span class="linenr"> 348: </span>          ) {
<span class="linenr"> 349: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">{ foo = 1 }</span>
<span class=
"linenr"> 350: </span>            excludedIds.add(p.value.left)
<span class=
"linenr"> 351: </span>            defaultValue = p.value.right
<span class="linenr"> 352: </span>          }
<span class="linenr"> 353: </span>        } <span class=
"org-keyword">else</span> {
<span class=
"linenr"> 354: </span>          key = p.computed ? p.key : p.key.name
<span class="linenr"> 355: </span>          <span class=
"org-keyword">if</span> (p.value.type === <span class=
"org-string">'Identifier'</span>) {
<span class="linenr"> 356: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">{ foo: bar }</span>
<span class="linenr"> 357: </span>            nameId = p.value
<span class="linenr"> 358: </span>          } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (p.value.type === <span class=
"org-string">'ObjectPattern'</span>) {
<span class=
"linenr"> 359: </span>            processRefObjectPattern(p.value, call, tempVar, [...path, key])
<span class="linenr"> 360: </span>          } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (p.value.type === <span class=
"org-string">'ArrayPattern'</span>) {
<span class=
"linenr"> 361: </span>            processRefArrayPattern(p.value, call, tempVar, [...path, key])
<span class="linenr"> 362: </span>          } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (p.value.type === <span class=
"org-string">'AssignmentPattern'</span>) {
<span class="linenr"> 363: </span>            <span class=
"org-keyword">if</span> (p.value.left.type === <span class=
"org-string">'Identifier'</span>) {
<span class="linenr"> 364: </span>              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">{ foo: bar = 1 }</span>
<span class=
"linenr"> 365: </span>              nameId = p.value.left
<span class=
"linenr"> 366: </span>              defaultValue = p.value.right
<span class="linenr"> 367: </span>            } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (p.value.left.type === <span class=
"org-string">'ObjectPattern'</span>) {
<span class=
"linenr"> 368: </span>              processRefObjectPattern(p.value.left, call, tempVar, [
<span class="linenr"> 369: </span>                ...path,
<span class=
"linenr"> 370: </span>                [key, p.value.right]
<span class="linenr"> 371: </span>              ])
<span class="linenr"> 372: </span>            } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (p.value.left.type === <span class=
"org-string">'ArrayPattern'</span>) {
<span class=
"linenr"> 373: </span>              processRefArrayPattern(p.value.left, call, tempVar, [
<span class="linenr"> 374: </span>                ...path,
<span class=
"linenr"> 375: </span>                [key, p.value.right]
<span class="linenr"> 376: </span>              ])
<span class="linenr"> 377: </span>            } <span class=
"org-keyword">else</span> {
<span class="linenr"> 378: </span>              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">MemberExpression case is not possible here, ignore</span>
<span class="linenr"> 379: </span>            }
<span class="linenr"> 380: </span>          }
<span class="linenr"> 381: </span>        }
<span class="linenr"> 382: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr"> 383: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">rest element { ...foo }</span>
<span class="linenr"> 384: </span>        error(<span class=
"org-string">`reactivity destructure does not support rest elements.`</span>, p)
<span class="linenr"> 385: </span>      }
<span class="linenr"> 386: </span>      <span class=
"org-keyword">if</span> (nameId) {
<span class=
"linenr"> 387: </span>        registerRefBinding(nameId)
<span class="linenr"> 388: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">inject toRef() after original replaced pattern</span>
<span class="linenr"> 389: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">source</span> = pathToString(tempVar, path)
<span class="linenr"> 390: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">keyStr</span> = isString(key)
<span class="linenr"> 391: </span>          ? <span class=
"org-string">`'${key}'`</span>
<span class="linenr"> 392: </span>          : key
<span class="linenr"> 393: </span>          ? snip(key)
<span class="linenr"> 394: </span>          : <span class=
"org-string">`'${nameId.name}'`</span>
<span class="linenr"> 395: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">defaultStr</span> = defaultValue ? <span class=
"org-string">`, ${snip(defaultValue)}`</span> : <span class=
"org-string">``</span>
<span class="linenr"> 396: </span>        s.appendLeft(
<span class="linenr"> 397: </span>          call.end + offset,
<span class="linenr"> 398: </span>          <span class=
"org-string">`,\n  ${nameId.name} = ${helper(</span>
<span class="linenr"> 399: </span><span class=
"org-string">            'toRef'</span>
<span class="linenr"> 400: </span><span class=
"org-string">          )}(${source}, ${keyStr}${defaultStr})`</span>
<span class="linenr"> 401: </span>        )
<span class="linenr"> 402: </span>      }
<span class="linenr"> 403: </span>    }
<span class="linenr"> 404: </span>  }
<span class="linenr"> 405: </span>
<span class="linenr"> 406: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">processRefArrayPattern</span>(<span class=
"org-variable-name">pattern</span>, <span class=
"org-variable-name">call</span>, <span class=
"org-variable-name">tempVar</span>, <span class=
"org-variable-name">path</span> = []) {
<span class="linenr"> 407: </span>    <span class=
"org-keyword">if</span> (!tempVar) {
<span class="linenr"> 408: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">const [x] = $(useFoo()) --&gt; const __$temp_1 = useFoo()</span>
<span class="linenr"> 409: </span>      tempVar = genTempVar()
<span class=
"linenr"> 410: </span>      s.overwrite(pattern.start + offset, pattern.end + offset, tempVar)
<span class="linenr"> 411: </span>    }
<span class="linenr"> 412: </span>
<span class="linenr"> 413: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; pattern.elements.length; i++) {
<span class="linenr"> 414: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">e</span> = pattern.elements[i]
<span class="linenr"> 415: </span>      <span class=
"org-keyword">if</span> (!e) <span class=
"org-keyword">continue</span>
<span class="linenr"> 416: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">nameId</span>
<span class="linenr"> 417: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">defaultValue</span>
<span class="linenr"> 418: </span>      <span class=
"org-keyword">if</span> (e.type === <span class=
"org-string">'Identifier'</span>) {
<span class="linenr"> 419: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">[a] --&gt; [__a]</span>
<span class="linenr"> 420: </span>        nameId = e
<span class="linenr"> 421: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (e.type === <span class=
"org-string">'AssignmentPattern'</span>) {
<span class="linenr"> 422: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">[a = 1]</span>
<span class="linenr"> 423: </span>        nameId = e.left
<span class="linenr"> 424: </span>        defaultValue = e.right
<span class="linenr"> 425: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (e.type === <span class=
"org-string">'RestElement'</span>) {
<span class="linenr"> 426: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">[...a]</span>
<span class="linenr"> 427: </span>        error(<span class=
"org-string">`reactivity destructure does not support rest elements.`</span>, e)
<span class="linenr"> 428: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (e.type === <span class=
"org-string">'ObjectPattern'</span>) {
<span class=
"linenr"> 429: </span>        processRefObjectPattern(e, call, tempVar, [...path, i])
<span class="linenr"> 430: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (e.type === <span class=
"org-string">'ArrayPattern'</span>) {
<span class=
"linenr"> 431: </span>        processRefArrayPattern(e, call, tempVar, [...path, i])
<span class="linenr"> 432: </span>      }
<span class="linenr"> 433: </span>      <span class=
"org-keyword">if</span> (nameId) {
<span class=
"linenr"> 434: </span>        registerRefBinding(nameId)
<span class="linenr"> 435: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">inject toRef() after original replaced pattern</span>
<span class="linenr"> 436: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">source</span> = pathToString(tempVar, path)
<span class="linenr"> 437: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">defaultStr</span> = defaultValue ? <span class=
"org-string">`, ${snip(defaultValue)}`</span> : <span class=
"org-string">``</span>
<span class="linenr"> 438: </span>        s.appendLeft(
<span class="linenr"> 439: </span>          call.end + offset,
<span class="linenr"> 440: </span>          <span class=
"org-string">`,\n  ${nameId.name} = ${helper(</span>
<span class="linenr"> 441: </span><span class=
"org-string">            'toRef'</span>
<span class="linenr"> 442: </span><span class=
"org-string">          )}(${source}, ${i}${defaultStr})`</span>
<span class="linenr"> 443: </span>        )
<span class="linenr"> 444: </span>      }
<span class="linenr"> 445: </span>    }
<span class="linenr"> 446: </span>  }
<span class="linenr"> 447: </span>
<span class="linenr"> 448: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">pathToString</span>(<span class=
"org-variable-name">source</span>, <span class=
"org-variable-name">path</span>) {
<span class="linenr"> 449: </span>    <span class=
"org-keyword">if</span> (path.length) {
<span class="linenr"> 450: </span>      <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">seg</span> <span class=
"org-keyword">of</span> path) {
<span class="linenr"> 451: </span>        <span class=
"org-keyword">if</span> (isArray(seg)) {
<span class="linenr"> 452: </span>          source = <span class=
"org-string">`(${source}${segToString(seg[0])} || ${snip(seg[1])})`</span>
<span class="linenr"> 453: </span>        } <span class=
"org-keyword">else</span> {
<span class=
"linenr"> 454: </span>          source += segToString(seg)
<span class="linenr"> 455: </span>        }
<span class="linenr"> 456: </span>      }
<span class="linenr"> 457: </span>    }
<span class="linenr"> 458: </span>    <span class=
"org-keyword">return</span> source
<span class="linenr"> 459: </span>  }
<span class="linenr"> 460: </span>
<span class="linenr"> 461: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">segToString</span>(<span class=
"org-variable-name">seg</span>) {
<span class="linenr"> 462: </span>    <span class=
"org-keyword">if</span> (<span class=
"org-keyword">typeof</span> seg === <span class=
"org-string">'number'</span>) {
<span class="linenr"> 463: </span>      <span class=
"org-keyword">return</span> <span class=
"org-string">`[${seg}]`</span>
<span class="linenr"> 464: </span>    } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (<span class=
"org-keyword">typeof</span> seg === <span class=
"org-string">'string'</span>) {
<span class="linenr"> 465: </span>      <span class=
"org-keyword">return</span> <span class=
"org-string">`.${seg}`</span>
<span class="linenr"> 466: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr"> 467: </span>      <span class=
"org-keyword">return</span> snip(seg)
<span class="linenr"> 468: </span>    }
<span class="linenr"> 469: </span>  }
<span class="linenr"> 470: </span>
<span class="linenr"> 471: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">rewriteId</span>(<span class=
"org-variable-name">scope</span>, <span class=
"org-variable-name">id</span>, <span class=
"org-variable-name">parent</span>, <span class=
"org-variable-name">parentStack</span>) {
<span class="linenr"> 472: </span>    <span class=
"org-keyword">if</span> (hasOwn(scope, id.name)) {
<span class="linenr"> 473: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">bindingType</span> = scope[id.name]
<span class="linenr"> 474: </span>      <span class=
"org-keyword">if</span> (bindingType) {
<span class="linenr"> 475: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isProp</span> = bindingType === <span class=
"org-string">'prop'</span>
<span class="linenr"> 476: </span>        <span class=
"org-keyword">if</span> (isStaticProperty(parent) &amp;& parent.shorthand) {
<span class="linenr"> 477: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">let binding used in a property shorthand</span>
<span class="linenr"> 478: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">skip for destructure patterns</span>
<span class="linenr"> 479: </span>          <span class=
"org-keyword">if</span> (
<span class="linenr"> 480: </span>            !parent.inPattern ||
<span class=
"linenr"> 481: </span>            isInDestructureAssignment(parent, parentStack)
<span class="linenr"> 482: </span>          ) {
<span class="linenr"> 483: </span>            <span class=
"org-keyword">if</span> (isProp) {
<span class="linenr"> 484: </span>              <span class=
"org-keyword">if</span> (escapeScope) {
<span class="linenr"> 485: </span>                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">prop binding in $$()</span>
<span class="linenr"> 486: </span>                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">{ prop } -&gt; { prop: __prop_prop }</span>
<span class=
"linenr"> 487: </span>                registerEscapedPropBinding(id)
<span class="linenr"> 488: </span>                s.appendLeft(
<span class=
"linenr"> 489: </span>                  id.end + offset,
<span class="linenr"> 490: </span>                  <span class=
"org-string">`: __props_${propsLocalToPublicMap[id.name]}`</span>
<span class="linenr"> 491: </span>                )
<span class="linenr"> 492: </span>              } <span class=
"org-keyword">else</span> {
<span class="linenr"> 493: </span>                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">{ prop } -&gt; { prop: __prop.prop }</span>
<span class="linenr"> 494: </span>                s.appendLeft(
<span class=
"linenr"> 495: </span>                  id.end + offset,
<span class="linenr"> 496: </span>                  <span class=
"org-string">`: __props.${propsLocalToPublicMap[id.name]}`</span>
<span class="linenr"> 497: </span>                )
<span class="linenr"> 498: </span>              }
<span class="linenr"> 499: </span>            } <span class=
"org-keyword">else</span> {
<span class="linenr"> 500: </span>              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">{ foo } -&gt; { foo: foo.value }</span>
<span class=
"linenr"> 501: </span>              s.appendLeft(id.end + offset, <span class="org-string">`: ${id.name}.value`</span>)
<span class="linenr"> 502: </span>            }
<span class="linenr"> 503: </span>          }
<span class="linenr"> 504: </span>        } <span class=
"org-keyword">else</span> {
<span class="linenr"> 505: </span>          <span class=
"org-keyword">if</span> (isProp) {
<span class="linenr"> 506: </span>            <span class=
"org-keyword">if</span> (escapeScope) {
<span class="linenr"> 507: </span>              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">x --&gt; __props_x</span>
<span class=
"linenr"> 508: </span>              registerEscapedPropBinding(id)
<span class="linenr"> 509: </span>              s.overwrite(
<span class=
"linenr"> 510: </span>                id.start + offset,
<span class="linenr"> 511: </span>                id.end + offset,
<span class="linenr"> 512: </span>                <span class=
"org-string">`__props_${propsLocalToPublicMap[id.name]}`</span>
<span class="linenr"> 513: </span>              )
<span class="linenr"> 514: </span>            } <span class=
"org-keyword">else</span> {
<span class="linenr"> 515: </span>              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">x --&gt; __props.x</span>
<span class="linenr"> 516: </span>              s.overwrite(
<span class=
"linenr"> 517: </span>                id.start + offset,
<span class="linenr"> 518: </span>                id.end + offset,
<span class="linenr"> 519: </span>                <span class=
"org-string">`__props.${propsLocalToPublicMap[id.name]}`</span>
<span class="linenr"> 520: </span>              )
<span class="linenr"> 521: </span>            }
<span class="linenr"> 522: </span>          } <span class=
"org-keyword">else</span> {
<span class="linenr"> 523: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">x --&gt; x.value</span>
<span class=
"linenr"> 524: </span>            s.appendLeft(id.end + offset, <span class="org-string">'.value'</span>)
<span class="linenr"> 525: </span>          }
<span class="linenr"> 526: </span>        }
<span class="linenr"> 527: </span>      }
<span class="linenr"> 528: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr"> 529: </span>    }
<span class="linenr"> 530: </span>    <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr"> 531: </span>  }
<span class="linenr"> 532: </span>
<span class="linenr"> 533: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">propBindingRefs</span> = {}
<span class="linenr"> 534: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">registerEscapedPropBinding</span>(<span class=
"org-variable-name">id</span>) {
<span class="linenr"> 535: </span>    <span class=
"org-keyword">if</span> (!propBindingRefs.hasOwnProperty(id.name)) {
<span class=
"linenr"> 536: </span>      propBindingRefs[id.name] = <span class=
"org-constant">true</span>
<span class="linenr"> 537: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">publicKey</span> = propsLocalToPublicMap[id.name]
<span class="linenr"> 538: </span>      s.prependRight(
<span class="linenr"> 539: </span>        offset,
<span class="linenr"> 540: </span>        <span class=
"org-string">`const __props_${publicKey} = ${helper(</span>
<span class="linenr"> 541: </span><span class=
"org-string">          `</span>toRef<span class=
"org-string">`</span>
<span class="linenr"> 542: </span><span class=
"org-string">        )}(__props, '${publicKey}')\n`</span>
<span class="linenr"> 543: </span>      )
<span class="linenr"> 544: </span>    }
<span class="linenr"> 545: </span>  }
<span class="linenr"> 546: </span>
<span class="linenr"> 547: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">check root scope first</span>
<span class="linenr"> 548: </span>  walkScope(ast, <span class=
"org-constant">true</span>)
<span class="linenr"> 549: </span>  walk(ast, {
<span class="linenr"> 550: </span>    enter(node, parent) {
<span class=
"linenr"> 551: </span>      parent &amp;& parentStack.push(parent)
<span class="linenr"> 552: </span>
<span class="linenr"> 553: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">function scopes</span>
<span class="linenr"> 554: </span>      <span class=
"org-keyword">if</span> (isFunctionType(node)) {
<span class=
"linenr"> 555: </span>        scopeStack.push((currentScope = {}))
<span class=
"linenr"> 556: </span>        walkFunctionParams(node, registerBinding)
<span class="linenr"> 557: </span>        <span class=
"org-keyword">if</span> (node.body.type === <span class=
"org-string">'BlockStatement'</span>) {
<span class="linenr"> 558: </span>          walkScope(node.body)
<span class="linenr"> 559: </span>        }
<span class="linenr"> 560: </span>        <span class=
"org-keyword">return</span>
<span class="linenr"> 561: </span>      }
<span class="linenr"> 562: </span>
<span class="linenr"> 563: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">catch param</span>
<span class="linenr"> 564: </span>      <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'CatchClause'</span>) {
<span class=
"linenr"> 565: </span>        scopeStack.push((currentScope = {}))
<span class="linenr"> 566: </span>        <span class=
"org-keyword">if</span> (node.param &amp;& node.param.type === <span class="org-string">'Identifier'</span>) {
<span class=
"linenr"> 567: </span>          registerBinding(node.param)
<span class="linenr"> 568: </span>        }
<span class="linenr"> 569: </span>        walkScope(node.body)
<span class="linenr"> 570: </span>        <span class=
"org-keyword">return</span>
<span class="linenr"> 571: </span>      }
<span class="linenr"> 572: </span>
<span class="linenr"> 573: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">non-function block scopes</span>
<span class="linenr"> 574: </span>      <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'BlockStatement'</span> &amp;& !isFunctionType(parent)) {
<span class=
"linenr"> 575: </span>        scopeStack.push((currentScope = {}))
<span class="linenr"> 576: </span>        walkScope(node)
<span class="linenr"> 577: </span>        <span class=
"org-keyword">return</span>
<span class="linenr"> 578: </span>      }
<span class="linenr"> 579: </span>
<span class="linenr"> 580: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">skip type nodes</span>
<span class="linenr"> 581: </span>      <span class=
"org-keyword">if</span> (
<span class="linenr"> 582: </span>        parent &amp;&
<span class=
"linenr"> 583: </span>        parent.type.startsWith(<span class=
"org-string">'TS'</span>) &amp;&
<span class=
"linenr"> 584: </span>        parent.type !== <span class=
"org-string">'TSAsExpression'</span> &amp;&
<span class=
"linenr"> 585: </span>        parent.type !== <span class=
"org-string">'TSNonNullExpression'</span> &amp;&
<span class=
"linenr"> 586: </span>        parent.type !== <span class=
"org-string">'TSTypeAssertion'</span>
<span class="linenr"> 587: </span>      ) {
<span class="linenr"> 588: </span>        <span class=
"org-keyword">return</span> <span class=
"org-constant">this</span>.skip()
<span class="linenr"> 589: </span>      }
<span class="linenr"> 590: </span>
<span class="linenr"> 591: </span>      <span class=
"org-keyword">if</span> (
<span class=
"linenr"> 592: </span>        node.type === <span class="org-string">'Identifier'</span> &amp;&
<span class="linenr"> 593: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">if inside $$(), skip unless this is a destructured prop binding</span>
<span class=
"linenr"> 594: </span>        !(escapeScope &amp;& rootScope[node.name] !== <span class="org-string">'prop'</span>) &amp;&
<span class=
"linenr"> 595: </span>        isReferencedIdentifier(node, parent, parentStack) &amp;&
<span class="linenr"> 596: </span>        !excludedIds.has(node)
<span class="linenr"> 597: </span>      ) {
<span class="linenr"> 598: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">walk up the scope chain to check if id should be appended .value</span>
<span class="linenr"> 599: </span>        <span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = scopeStack.length
<span class="linenr"> 600: </span>        <span class=
"org-keyword">while</span> (i--) {
<span class="linenr"> 601: </span>          <span class=
"org-keyword">if</span> (rewriteId(scopeStack[i], node, parent, parentStack)) {
<span class="linenr"> 602: </span>            <span class=
"org-keyword">return</span>
<span class="linenr"> 603: </span>          }
<span class="linenr"> 604: </span>        }
<span class="linenr"> 605: </span>      }
<span class="linenr"> 606: </span>
<span class="linenr"> 607: </span>      <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'CallExpression'</span> &amp;& node.callee.type === <span class="org-string">'Identifier'</span>) {
<span class="linenr"> 608: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">callee</span> = node.callee.name
<span class="linenr"> 609: </span>
<span class="linenr"> 610: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">refCall</span> = isRefCreationCall(callee)
<span class="linenr"> 611: </span>        <span class=
"org-keyword">if</span> (refCall &amp;& (!parent || parent.type !== <span class="org-string">'VariableDeclarator'</span>)) {
<span class="linenr"> 612: </span>          <span class=
"org-keyword">return</span> error(
<span class="linenr"> 613: </span>            <span class=
"org-string">`${refCall} can only be used as the initializer of `</span> +
<span class="linenr"> 614: </span>              <span class=
"org-string">`a variable declaration.`</span>,
<span class="linenr"> 615: </span>            node
<span class="linenr"> 616: </span>          )
<span class="linenr"> 617: </span>        }
<span class="linenr"> 618: </span>
<span class="linenr"> 619: </span>        <span class=
"org-keyword">if</span> (callee === escapeSymbol) {
<span class=
"linenr"> 620: </span>          s.remove(node.callee.start + offset, node.callee.end + offset)
<span class="linenr"> 621: </span>          escapeScope = node
<span class="linenr"> 622: </span>        }
<span class="linenr"> 623: </span>
<span class="linenr"> 624: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment"><span class="org-bold"><span class=
"org-warning">TODO</span></span></span><span class=
"org-comment"> remove when out of experimental</span>
<span class="linenr"> 625: </span>        <span class=
"org-keyword">if</span> (callee === <span class=
"org-string">'$raw'</span>) {
<span class="linenr"> 626: </span>          error(
<span class="linenr"> 627: </span>            <span class=
"org-string">`$raw() has been replaced by $$(). `</span> +
<span class="linenr"> 628: </span>              <span class=
"org-string">`See ${RFC_LINK} for latest updates.`</span>,
<span class="linenr"> 629: </span>            node
<span class="linenr"> 630: </span>          )
<span class="linenr"> 631: </span>        }
<span class="linenr"> 632: </span>        <span class=
"org-keyword">if</span> (callee === <span class=
"org-string">'$fromRef'</span>) {
<span class="linenr"> 633: </span>          error(
<span class="linenr"> 634: </span>            <span class=
"org-string">`$fromRef() has been replaced by $(). `</span> +
<span class="linenr"> 635: </span>              <span class=
"org-string">`See ${RFC_LINK} for latest updates.`</span>,
<span class="linenr"> 636: </span>            node
<span class="linenr"> 637: </span>          )
<span class="linenr"> 638: </span>        }
<span class="linenr"> 639: </span>      }
<span class="linenr"> 640: </span>    },
<span class="linenr"> 641: </span>    leave(node, parent) {
<span class=
"linenr"> 642: </span>      parent &amp;& parentStack.pop()
<span class="linenr"> 643: </span>      <span class=
"org-keyword">if</span> (
<span class=
"linenr"> 644: </span>        (node.type === <span class=
"org-string">'BlockStatement'</span> &amp;& !isFunctionType(parent)) ||
<span class="linenr"> 645: </span>        isFunctionType(node)
<span class="linenr"> 646: </span>      ) {
<span class="linenr"> 647: </span>        scopeStack.pop()
<span class=
"linenr"> 648: </span>        currentScope = scopeStack[scopeStack.length - <span class="org-highlight-numbers-number">1</span>] || <span class="org-constant">null</span>
<span class="linenr"> 649: </span>      }
<span class="linenr"> 650: </span>      <span class=
"org-keyword">if</span> (node === escapeScope) {
<span class=
"linenr"> 651: </span>        escapeScope = <span class="org-constant">undefined</span>
<span class="linenr"> 652: </span>      }
<span class="linenr"> 653: </span>    }
<span class="linenr"> 654: </span>  })
<span class="linenr"> 655: </span>
<span class="linenr"> 656: </span>  <span class=
"org-keyword">return</span> {
<span class=
"linenr"> 657: </span>    rootRefs: Object.keys(rootScope).filter(key =&gt; rootScope[key] === <span class="org-constant">true</span>),
<span class=
"linenr"> 658: </span>    importedHelpers: [...importedHelpers]
<span class="linenr"> 659: </span>  }
<span class="linenr"> 660: </span>}
<span class="linenr"> 661: </span>
<span class="linenr"> 662: </span>  <span class=
"org-keyword">return</span> { transformAST, transform, shouldTransform }
<span class="linenr"> 663: </span>}())
<span class="linenr"> 664: </span>
<span class="linenr"> 665: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">range</span> = <span class=
"org-highlight-numbers-number">2</span>
<span class="linenr"> 666: </span>
<span class="linenr"> 667: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">generateCodeFrame</span>(
<span class="linenr"> 668: </span>  <span class=
"org-variable-name">source</span>,
<span class="linenr"> 669: </span>  start = <span class=
"org-highlight-numbers-number">0</span>,
<span class="linenr"> 670: </span>  end = source.length
<span class="linenr"> 671: </span>) {
<span class="linenr"> 672: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">Split the content into individual lines but capture the newline sequence</span>
<span class="linenr"> 673: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">that separated each line. This is important because the actual sequence is</span>
<span class="linenr"> 674: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">needed to properly take into account the full line length for offset</span>
<span class="linenr"> 675: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">comparison</span>
<span class="linenr"> 676: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">lines</span> = source.split(<span class=
"org-string">/(\r?\n)/</span>)
<span class="linenr"> 677: </span>
<span class="linenr"> 678: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">Separate the lines and newline sequences into separate arrays for easier referencing</span>
<span class="linenr"> 679: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">newlineSequences</span> = lines.filter((_, idx) =&gt; idx % <span class="org-highlight-numbers-number">2</span> === <span class="org-highlight-numbers-number">1</span>)
<span class=
"linenr"> 680: </span>  lines = lines.filter((_, idx) =&gt; idx % <span class="org-highlight-numbers-number">2</span> === <span class="org-highlight-numbers-number">0</span>)
<span class="linenr"> 681: </span>
<span class="linenr"> 682: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">count</span> = <span class=
"org-highlight-numbers-number">0</span>
<span class="linenr"> 683: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">res</span> = []
<span class="linenr"> 684: </span>  <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; lines.length; i++) {
<span class="linenr"> 685: </span>    count +=
<span class="linenr"> 686: </span>      lines[i].length +
<span class=
"linenr"> 687: </span>      ((newlineSequences[i] &amp;& newlineSequences[i].length) || <span class="org-highlight-numbers-number">0</span>)
<span class="linenr"> 688: </span>    <span class=
"org-keyword">if</span> (count &gt;= start) {
<span class="linenr"> 689: </span>      <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">j</span> = i - range; j &lt;= i + range || end &gt; count; j++) {
<span class="linenr"> 690: </span>        <span class=
"org-keyword">if</span> (j &lt; <span class=
"org-highlight-numbers-number">0</span> || j &gt;= lines.length) <span class="org-keyword">continue</span>
<span class="linenr"> 691: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">line</span> = j + <span class=
"org-highlight-numbers-number">1</span>
<span class="linenr"> 692: </span>        res.push(
<span class="linenr"> 693: </span>          <span class=
"org-string">`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${</span>
<span class="linenr"> 694: </span><span class=
"org-string">            lines[j]</span>
<span class="linenr"> 695: </span><span class=
"org-string">          }`</span>
<span class="linenr"> 696: </span>        )
<span class="linenr"> 697: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">lineLength</span> = lines[j].length
<span class="linenr"> 698: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">newLineSeqLength</span> =
<span class=
"linenr"> 699: </span>          (newlineSequences[j] &amp;& newlineSequences[j].length) || <span class="org-highlight-numbers-number">0</span>
<span class="linenr"> 700: </span>
<span class="linenr"> 701: </span>        <span class=
"org-keyword">if</span> (j === i) {
<span class="linenr"> 702: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">push underline</span>
<span class="linenr"> 703: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">pad</span> = start - (count - (lineLength + newLineSeqLength))
<span class="linenr"> 704: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">length</span> = Math.max(
<span class="linenr"> 705: </span>            <span class=
"org-highlight-numbers-number">1</span>,
<span class=
"linenr"> 706: </span>            end &gt; count ? lineLength - pad : end - start
<span class="linenr"> 707: </span>          )
<span class="linenr"> 708: </span>          res.push(<span class=
"org-string">`   |  `</span> + <span class=
"org-string">' '</span>.repeat(pad) + <span class=
"org-string">'^'</span>.repeat(length))
<span class="linenr"> 709: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (j &gt; i) {
<span class="linenr"> 710: </span>          <span class=
"org-keyword">if</span> (end &gt; count) {
<span class="linenr"> 711: </span>            <span class=
"org-keyword">const</span> <span class=
"org-variable-name">length</span> = Math.max(Math.min(end - count, lineLength), <span class="org-highlight-numbers-number">1</span>)
<span class="linenr"> 712: </span>            res.push(<span class=
"org-string">`   |  `</span> + <span class=
"org-string">'^'</span>.repeat(length))
<span class="linenr"> 713: </span>          }
<span class="linenr"> 714: </span>
<span class=
"linenr"> 715: </span>          count += lineLength + newLineSeqLength
<span class="linenr"> 716: </span>        }
<span class="linenr"> 717: </span>      }
<span class="linenr"> 718: </span>      <span class=
"org-keyword">break</span>
<span class="linenr"> 719: </span>    }
<span class="linenr"> 720: </span>  }
<span class="linenr"> 721: </span>  <span class=
"org-keyword">return</span> res.join(<span class=
"org-string">'\n'</span>)
<span class="linenr"> 722: </span>}
<span class="linenr"> 723: </span>
<span class="linenr"> 724: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">registerBinding</span>(<span class=
"org-variable-name">bindings</span>, <span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">type</span>) {
<span class="linenr"> 725: </span>  bindings[node.name] = type
<span class="linenr"> 726: </span>}
<span class="linenr"> 727: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">walkDeclaration</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">bindings</span>, <span class=
"org-variable-name">userImportAlias</span>) {
<span class="linenr"> 728: </span>  <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'VariableDeclaration'</span>) {
<span class="linenr"> 729: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isConst</span> = node.kind === <span class=
"org-string">'const'</span>
<span class="linenr"> 730: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">export const foo = ...</span>
<span class="linenr"> 731: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> { id, init } <span class=
"org-keyword">of</span> node.declarations) {
<span class="linenr"> 732: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isDefineCall</span> = !!(
<span class="linenr"> 733: </span>        isConst &amp;&
<span class="linenr"> 734: </span>        isCallOf(
<span class="linenr"> 735: </span>          init,
<span class=
"linenr"> 736: </span>          c =&gt; c === DEFINE_PROPS || c === DEFINE_EMITS || c === WITH_DEFAULTS
<span class="linenr"> 737: </span>        )
<span class="linenr"> 738: </span>      )
<span class="linenr"> 739: </span>      <span class=
"org-keyword">if</span> (id.type === <span class=
"org-string">'Identifier'</span>) {
<span class="linenr"> 740: </span>        <span class=
"org-keyword">let</span> <span class=
"org-variable-name">bindingType</span>
<span class="linenr"> 741: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">userReactiveBinding</span> = userImportAlias[<span class="org-string">'reactive'</span>] || <span class="org-string">'reactive'</span>
<span class="linenr"> 742: </span>        <span class=
"org-keyword">if</span> (isCallOf(init, userReactiveBinding)) {
<span class="linenr"> 743: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">treat reactive() calls as let since it's meant to be mutable</span>
<span class=
"linenr"> 744: </span>          bindingType = BindingTypes.SETUP_LET
<span class="linenr"> 745: </span>        } <span class=
"org-keyword">else</span> <span class="org-keyword">if</span> (
<span class="linenr"> 746: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">if a declaration is a const literal, we can mark it so that</span>
<span class="linenr"> 747: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">the generated render fn code doesn't need to unref() it</span>
<span class="linenr"> 748: </span>          isDefineCall ||
<span class=
"linenr"> 749: </span>          (isConst &amp;& canNeverBeRef(init, userReactiveBinding))
<span class="linenr"> 750: </span>        ) {
<span class=
"linenr"> 751: </span>          bindingType = BindingTypes.SETUP_CONST
<span class="linenr"> 752: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (isConst) {
<span class="linenr"> 753: </span>          <span class=
"org-keyword">if</span> (isCallOf(init, userImportAlias[<span class="org-string">'ref'</span>] || <span class="org-string">'ref'</span>)) {
<span class=
"linenr"> 754: </span>            bindingType = BindingTypes.SETUP_REF
<span class="linenr"> 755: </span>          } <span class=
"org-keyword">else</span> {
<span class=
"linenr"> 756: </span>            bindingType = BindingTypes.SETUP_MAYBE_REF
<span class="linenr"> 757: </span>          }
<span class="linenr"> 758: </span>        } <span class=
"org-keyword">else</span> {
<span class=
"linenr"> 759: </span>          bindingType = BindingTypes.SETUP_LET
<span class="linenr"> 760: </span>        }
<span class=
"linenr"> 761: </span>        registerBinding(bindings, id, bindingType)
<span class="linenr"> 762: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr"> 763: </span>        <span class=
"org-keyword">if</span> (isCallOf(init, DEFINE_PROPS)) {
<span class="linenr"> 764: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">skip walking props destructure</span>
<span class="linenr"> 765: </span>          <span class=
"org-keyword">return</span>
<span class="linenr"> 766: </span>        }
<span class="linenr"> 767: </span>        <span class=
"org-keyword">if</span> (id.type === <span class=
"org-string">'ObjectPattern'</span>) {
<span class=
"linenr"> 768: </span>          walkObjectPattern(id, bindings, isConst, isDefineCall)
<span class="linenr"> 769: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (id.type === <span class=
"org-string">'ArrayPattern'</span>) {
<span class=
"linenr"> 770: </span>          walkArrayPattern(id, bindings, isConst, isDefineCall)
<span class="linenr"> 771: </span>        }
<span class="linenr"> 772: </span>      }
<span class="linenr"> 773: </span>    }
<span class="linenr"> 774: </span>  } <span class=
"org-keyword">else</span> <span class="org-keyword">if</span> (
<span class="linenr"> 775: </span>    node.type === <span class=
"org-string">'TSEnumDeclaration'</span> ||
<span class="linenr"> 776: </span>    node.type === <span class=
"org-string">'FunctionDeclaration'</span> ||
<span class="linenr"> 777: </span>    node.type === <span class=
"org-string">'ClassDeclaration'</span>
<span class="linenr"> 778: </span>  ) {
<span class="linenr"> 779: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">export function foo() {} / export class Foo {}</span>
<span class="linenr"> 780: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">export declarations must be named.</span>
<span class=
"linenr"> 781: </span>    bindings[node.id.name] = BindingTypes.SETUP_CONST
<span class="linenr"> 782: </span>  }
<span class="linenr"> 783: </span>}
<span class="linenr"> 784: </span>
<span class="linenr"> 785: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">walkObjectPattern</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">bindings</span>, <span class=
"org-variable-name">isConst</span>, <span class=
"org-variable-name">isDefineCall</span> = <span class=
"org-constant">false</span>) {
<span class="linenr"> 786: </span>  <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">p</span> <span class=
"org-keyword">of</span> node.properties) {
<span class="linenr"> 787: </span>    <span class=
"org-keyword">if</span> (p.type === <span class=
"org-string">'ObjectProperty'</span>) {
<span class="linenr"> 788: </span>      <span class=
"org-keyword">if</span> (p.key.type === <span class=
"org-string">'Identifier'</span> &amp;& p.key === p.value) {
<span class="linenr"> 789: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">shorthand: const { x } = ...</span>
<span class="linenr"> 790: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">type</span> = isDefineCall
<span class=
"linenr"> 791: </span>          ? BindingTypes.SETUP_CONST
<span class="linenr"> 792: </span>          : isConst
<span class=
"linenr"> 793: </span>          ? BindingTypes.SETUP_MAYBE_REF
<span class=
"linenr"> 794: </span>          : BindingTypes.SETUP_LET
<span class=
"linenr"> 795: </span>        registerBinding(bindings, p.key, type)
<span class="linenr"> 796: </span>      } <span class=
"org-keyword">else</span> {
<span class=
"linenr"> 797: </span>        walkPattern(p.value, bindings, isConst, isDefineCall)
<span class="linenr"> 798: </span>      }
<span class="linenr"> 799: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr"> 800: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">...rest</span>
<span class="linenr"> 801: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">argument can only be identifier when destructuring</span>
<span class="linenr"> 802: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">type</span> = isConst ? BindingTypes.SETUP_CONST : BindingTypes.SETUP_LET
<span class=
"linenr"> 803: </span>      registerBinding(bindings, p.argument, type)
<span class="linenr"> 804: </span>    }
<span class="linenr"> 805: </span>  }
<span class="linenr"> 806: </span>}
<span class="linenr"> 807: </span>
<span class="linenr"> 808: </span>
<span class="linenr"> 809: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">walkArrayPattern</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">bindings</span>, <span class=
"org-variable-name">isConst</span>, <span class=
"org-variable-name">isDefineCall</span> = <span class=
"org-constant">false</span>) {
<span class="linenr"> 810: </span>  <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">e</span> <span class=
"org-keyword">of</span> node.elements) {
<span class=
"linenr"> 811: </span>    e &amp;& walkPattern(e, bindings, isConst, isDefineCall)
<span class="linenr"> 812: </span>  }
<span class="linenr"> 813: </span>}
<span class="linenr"> 814: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">walkPattern</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">bindings</span>, <span class=
"org-variable-name">isConst</span>, <span class=
"org-variable-name">isDefineCall</span> = <span class=
"org-constant">false</span>) {
<span class="linenr"> 815: </span>  <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'Identifier'</span>) {
<span class="linenr"> 816: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">type</span> = isDefineCall
<span class="linenr"> 817: </span>      ? BindingTypes.SETUP_CONST
<span class="linenr"> 818: </span>      : isConst
<span class=
"linenr"> 819: </span>      ? BindingTypes.SETUP_MAYBE_REF
<span class="linenr"> 820: </span>      : BindingTypes.SETUP_LET
<span class=
"linenr"> 821: </span>    registerBinding(bindings, node, type)
<span class="linenr"> 822: </span>  } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'RestElement'</span>) {
<span class="linenr"> 823: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">argument can only be identifier when destructuring</span>
<span class="linenr"> 824: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">type</span> = isConst ? BindingTypes.SETUP_CONST : BindingTypes.SETUP_LET
<span class=
"linenr"> 825: </span>    registerBinding(bindings, node.argument, type)
<span class="linenr"> 826: </span>  } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'ObjectPattern'</span>) {
<span class=
"linenr"> 827: </span>    walkObjectPattern(node, bindings, isConst)
<span class="linenr"> 828: </span>  } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'ArrayPattern'</span>) {
<span class=
"linenr"> 829: </span>    walkArrayPattern(node, bindings, isConst)
<span class="linenr"> 830: </span>  } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'AssignmentPattern'</span>) {
<span class="linenr"> 831: </span>    <span class=
"org-keyword">if</span> (node.left.type === <span class=
"org-string">'Identifier'</span>) {
<span class="linenr"> 832: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">type</span> = isDefineCall
<span class=
"linenr"> 833: </span>        ? BindingTypes.SETUP_CONST
<span class="linenr"> 834: </span>        : isConst
<span class=
"linenr"> 835: </span>        ? BindingTypes.SETUP_MAYBE_REF
<span class="linenr"> 836: </span>        : BindingTypes.SETUP_LET
<span class=
"linenr"> 837: </span>      registerBinding(bindings, node.left, type)
<span class="linenr"> 838: </span>    } <span class=
"org-keyword">else</span> {
<span class=
"linenr"> 839: </span>      walkPattern(node.left, bindings, isConst)
<span class="linenr"> 840: </span>    }
<span class="linenr"> 841: </span>  }
<span class="linenr"> 842: </span>}
<span class="linenr"> 843: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">recordType</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">declaredTypes</span>) {
<span class="linenr"> 844: </span>  <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'TSInterfaceDeclaration'</span>) {
<span class=
"linenr"> 845: </span>    declaredTypes[node.id.name] = [<span class="org-string">`Object`</span>]
<span class="linenr"> 846: </span>  } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'TSTypeAliasDeclaration'</span>) {
<span class=
"linenr"> 847: </span>    declaredTypes[node.id.name] = inferRuntimeType(
<span class="linenr"> 848: </span>      node.typeAnnotation,
<span class="linenr"> 849: </span>      declaredTypes
<span class="linenr"> 850: </span>    )
<span class="linenr"> 851: </span>  } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'ExportNamedDeclaration'</span> &amp;& node.declaration) {
<span class=
"linenr"> 852: </span>    recordType(node.declaration, declaredTypes)
<span class="linenr"> 853: </span>  }
<span class="linenr"> 854: </span>}
<span class="linenr"> 855: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">extractRuntimeProps</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">props</span>, <span class=
"org-variable-name">declaredTypes</span>, <span class=
"org-variable-name">isProd</span>) {
<span class="linenr"> 856: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">members</span> = node.type === <span class=
"org-string">'TSTypeLiteral'</span> ? node.members : node.body
<span class="linenr"> 857: </span>  <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">m</span> <span class=
"org-keyword">of</span> members) {
<span class="linenr"> 858: </span>    <span class=
"org-keyword">if</span> (
<span class="linenr"> 859: </span>      (m.type === <span class=
"org-string">'TSPropertySignature'</span> || m.type === <span class="org-string">'TSMethodSignature'</span>) &amp;&
<span class="linenr"> 860: </span>      m.key.type === <span class=
"org-string">'Identifier'</span>
<span class="linenr"> 861: </span>    ) {
<span class="linenr"> 862: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">type</span>
<span class="linenr"> 863: </span>      <span class=
"org-keyword">if</span> (m.type === <span class=
"org-string">'TSMethodSignature'</span>) {
<span class="linenr"> 864: </span>        type = [<span class=
"org-string">'Function'</span>]
<span class="linenr"> 865: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (m.typeAnnotation) {
<span class=
"linenr"> 866: </span>        type = inferRuntimeType(m.typeAnnotation.typeAnnotation, declaredTypes)
<span class="linenr"> 867: </span>      }
<span class="linenr"> 868: </span>      props[m.key.name] = {
<span class="linenr"> 869: </span>        key: m.key.name,
<span class="linenr"> 870: </span>        required: !m.optional,
<span class=
"linenr"> 871: </span>        type: type || [<span class=
"org-string">`null`</span>]
<span class="linenr"> 872: </span>      }
<span class="linenr"> 873: </span>    }
<span class="linenr"> 874: </span>  }
<span class="linenr"> 875: </span>}
<span class="linenr"> 876: </span>
<span class="linenr"> 877: </span>
<span class="linenr"> 878: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">inferRuntimeType</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">declaredTypes</span>) {
<span class="linenr"> 879: </span>  <span class=
"org-keyword">switch</span> (node.type) {
<span class="linenr"> 880: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'TSStringKeyword'</span>:
<span class="linenr"> 881: </span>      <span class=
"org-keyword">return</span> [<span class=
"org-string">'String'</span>]
<span class="linenr"> 882: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'TSNumberKeyword'</span>:
<span class="linenr"> 883: </span>      <span class=
"org-keyword">return</span> [<span class=
"org-string">'Number'</span>]
<span class="linenr"> 884: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'TSBooleanKeyword'</span>:
<span class="linenr"> 885: </span>      <span class=
"org-keyword">return</span> [<span class=
"org-string">'Boolean'</span>]
<span class="linenr"> 886: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'TSObjectKeyword'</span>:
<span class="linenr"> 887: </span>      <span class=
"org-keyword">return</span> [<span class=
"org-string">'Object'</span>]
<span class="linenr"> 888: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'TSTypeLiteral'</span>:
<span class="linenr"> 889: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment"><span class="org-bold"><span class=
"org-warning">TODO</span></span></span><span class=
"org-comment"> (nice to have) generate runtime property validation</span>
<span class="linenr"> 890: </span>      <span class=
"org-keyword">return</span> [<span class=
"org-string">'Object'</span>]
<span class="linenr"> 891: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'TSFunctionType'</span>:
<span class="linenr"> 892: </span>      <span class=
"org-keyword">return</span> [<span class=
"org-string">'Function'</span>]
<span class="linenr"> 893: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'TSArrayType'</span>:
<span class="linenr"> 894: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'TSTupleType'</span>:
<span class="linenr"> 895: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment"><span class="org-bold"><span class=
"org-warning">TODO</span></span></span><span class=
"org-comment"> (nice to have) generate runtime element type/length checks</span>
<span class="linenr"> 896: </span>      <span class=
"org-keyword">return</span> [<span class=
"org-string">'Array'</span>]
<span class="linenr"> 897: </span>
<span class="linenr"> 898: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'TSLiteralType'</span>:
<span class="linenr"> 899: </span>      <span class=
"org-keyword">switch</span> (node.literal.type) {
<span class="linenr"> 900: </span>        <span class=
"org-keyword">case</span> <span class=
"org-string">'StringLiteral'</span>:
<span class="linenr"> 901: </span>          <span class=
"org-keyword">return</span> [<span class=
"org-string">'String'</span>]
<span class="linenr"> 902: </span>        <span class=
"org-keyword">case</span> <span class=
"org-string">'BooleanLiteral'</span>:
<span class="linenr"> 903: </span>          <span class=
"org-keyword">return</span> [<span class=
"org-string">'Boolean'</span>]
<span class="linenr"> 904: </span>        <span class=
"org-keyword">case</span> <span class=
"org-string">'NumericLiteral'</span>:
<span class="linenr"> 905: </span>        <span class=
"org-keyword">case</span> <span class=
"org-string">'BigIntLiteral'</span>:
<span class="linenr"> 906: </span>          <span class=
"org-keyword">return</span> [<span class=
"org-string">'Number'</span>]
<span class="linenr"> 907: </span>        <span class=
"org-keyword">default</span>:
<span class="linenr"> 908: </span>          <span class=
"org-keyword">return</span> [<span class=
"org-string">`null`</span>]
<span class="linenr"> 909: </span>      }
<span class="linenr"> 910: </span>
<span class="linenr"> 911: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'TSTypeReference'</span>:
<span class="linenr"> 912: </span>      <span class=
"org-keyword">if</span> (node.typeName.type === <span class=
"org-string">'Identifier'</span>) {
<span class="linenr"> 913: </span>        <span class=
"org-keyword">if</span> (declaredTypes[node.typeName.name]) {
<span class="linenr"> 914: </span>          <span class=
"org-keyword">return</span> declaredTypes[node.typeName.name]
<span class="linenr"> 915: </span>        }
<span class="linenr"> 916: </span>        <span class=
"org-keyword">switch</span> (node.typeName.name) {
<span class="linenr"> 917: </span>          <span class=
"org-keyword">case</span> <span class="org-string">'Array'</span>:
<span class="linenr"> 918: </span>          <span class=
"org-keyword">case</span> <span class=
"org-string">'Function'</span>:
<span class="linenr"> 919: </span>          <span class=
"org-keyword">case</span> <span class="org-string">'Object'</span>:
<span class="linenr"> 920: </span>          <span class=
"org-keyword">case</span> <span class="org-string">'Set'</span>:
<span class="linenr"> 921: </span>          <span class=
"org-keyword">case</span> <span class="org-string">'Map'</span>:
<span class="linenr"> 922: </span>          <span class=
"org-keyword">case</span> <span class=
"org-string">'WeakSet'</span>:
<span class="linenr"> 923: </span>          <span class=
"org-keyword">case</span> <span class=
"org-string">'WeakMap'</span>:
<span class="linenr"> 924: </span>          <span class=
"org-keyword">case</span> <span class="org-string">'Date'</span>:
<span class="linenr"> 925: </span>            <span class=
"org-keyword">return</span> [node.typeName.name]
<span class="linenr"> 926: </span>          <span class=
"org-keyword">case</span> <span class="org-string">'Record'</span>:
<span class="linenr"> 927: </span>          <span class=
"org-keyword">case</span> <span class=
"org-string">'Partial'</span>:
<span class="linenr"> 928: </span>          <span class=
"org-keyword">case</span> <span class=
"org-string">'Readonly'</span>:
<span class="linenr"> 929: </span>          <span class=
"org-keyword">case</span> <span class="org-string">'Pick'</span>:
<span class="linenr"> 930: </span>          <span class=
"org-keyword">case</span> <span class="org-string">'Omit'</span>:
<span class="linenr"> 931: </span>          <span class=
"org-keyword">case</span> <span class=
"org-string">'Exclude'</span>:
<span class="linenr"> 932: </span>          <span class=
"org-keyword">case</span> <span class=
"org-string">'Extract'</span>:
<span class="linenr"> 933: </span>          <span class=
"org-keyword">case</span> <span class=
"org-string">'Required'</span>:
<span class="linenr"> 934: </span>          <span class=
"org-keyword">case</span> <span class=
"org-string">'InstanceType'</span>:
<span class="linenr"> 935: </span>            <span class=
"org-keyword">return</span> [<span class=
"org-string">'Object'</span>]
<span class="linenr"> 936: </span>        }
<span class="linenr"> 937: </span>      }
<span class="linenr"> 938: </span>      <span class=
"org-keyword">return</span> [<span class=
"org-string">`null`</span>]
<span class="linenr"> 939: </span>
<span class="linenr"> 940: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'TSParenthesizedType'</span>:
<span class="linenr"> 941: </span>      <span class=
"org-keyword">return</span> inferRuntimeType(node.typeAnnotation, declaredTypes)
<span class="linenr"> 942: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'TSUnionType'</span>:
<span class="linenr"> 943: </span>      <span class=
"org-keyword">return</span> [
<span class="linenr"> 944: </span>        ...<span class=
"org-keyword">new</span> <span class="org-type">Set</span>(
<span class="linenr"> 945: </span>          [].concat(
<span class=
"linenr"> 946: </span>            ...(node.types.map(t =&gt; inferRuntimeType(t, declaredTypes)))
<span class="linenr"> 947: </span>          )
<span class="linenr"> 948: </span>        )
<span class="linenr"> 949: </span>      ]
<span class="linenr"> 950: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'TSIntersectionType'</span>:
<span class="linenr"> 951: </span>      <span class=
"org-keyword">return</span> [<span class=
"org-string">'Object'</span>]
<span class="linenr"> 952: </span>
<span class="linenr"> 953: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'TSSymbolKeyword'</span>:
<span class="linenr"> 954: </span>      <span class=
"org-keyword">return</span> [<span class=
"org-string">'Symbol'</span>]
<span class="linenr"> 955: </span>
<span class="linenr"> 956: </span>    <span class=
"org-keyword">default</span>:
<span class="linenr"> 957: </span>      <span class=
"org-keyword">return</span> [<span class=
"org-string">`null`</span>] <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no runtime check</span>
<span class="linenr"> 958: </span>  }
<span class="linenr"> 959: </span>}
<span class="linenr"> 960: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">toRuntimeTypeString</span>(<span class=
"org-variable-name">types</span>) {
<span class="linenr"> 961: </span>  <span class=
"org-keyword">return</span> types.length &gt; <span class=
"org-highlight-numbers-number">1</span> ? <span class=
"org-string">`[${types.join(', ')}]`</span> : types[<span class=
"org-highlight-numbers-number">0</span>]
<span class="linenr"> 962: </span>}
<span class="linenr"> 963: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">extractRuntimeEmits</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">emits</span>) {
<span class="linenr"> 964: </span>  <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'TSTypeLiteral'</span> || node.type === <span class=
"org-string">'TSInterfaceBody'</span>) {
<span class="linenr"> 965: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">members</span> = node.type === <span class=
"org-string">'TSTypeLiteral'</span> ? node.members : node.body
<span class="linenr"> 966: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">t</span> <span class=
"org-keyword">of</span> members) {
<span class="linenr"> 967: </span>      <span class=
"org-keyword">if</span> (t.type === <span class=
"org-string">'TSCallSignatureDeclaration'</span>) {
<span class=
"linenr"> 968: </span>        extractEventNames(t.parameters[<span class="org-highlight-numbers-number">0</span>], emits)
<span class="linenr"> 969: </span>      }
<span class="linenr"> 970: </span>    }
<span class="linenr"> 971: </span>    <span class=
"org-keyword">return</span>
<span class="linenr"> 972: </span>  } <span class=
"org-keyword">else</span> {
<span class=
"linenr"> 973: </span>    extractEventNames(node.parameters[<span class="org-highlight-numbers-number">0</span>], emits)
<span class="linenr"> 974: </span>  }
<span class="linenr"> 975: </span>}
<span class="linenr"> 976: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">extractEventNames</span>(<span class=
"org-variable-name">eventName</span>, <span class=
"org-variable-name">emits</span>) {
<span class="linenr"> 977: </span>  <span class=
"org-keyword">if</span> (
<span class=
"linenr"> 978: </span>    eventName.type === <span class=
"org-string">'Identifier'</span> &amp;&
<span class=
"linenr"> 979: </span>    eventName.typeAnnotation &amp;&
<span class=
"linenr"> 980: </span>    eventName.typeAnnotation.type === <span class="org-string">'TSTypeAnnotation'</span>
<span class="linenr"> 981: </span>  ) {
<span class="linenr"> 982: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">typeNode</span> = eventName.typeAnnotation.typeAnnotation
<span class="linenr"> 983: </span>    <span class=
"org-keyword">if</span> (typeNode.type === <span class=
"org-string">'TSLiteralType'</span>) {
<span class="linenr"> 984: </span>      <span class=
"org-keyword">if</span> (typeNode.literal.type !== <span class=
"org-string">'UnaryExpression'</span>) {
<span class=
"linenr"> 985: </span>        emits.add(String(typeNode.literal.value))
<span class="linenr"> 986: </span>      }
<span class="linenr"> 987: </span>    } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (typeNode.type === <span class=
"org-string">'TSUnionType'</span>) {
<span class="linenr"> 988: </span>      <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">t</span> <span class=
"org-keyword">of</span> typeNode.types) {
<span class="linenr"> 989: </span>        <span class=
"org-keyword">if</span> (
<span class="linenr"> 990: </span>          t.type === <span class=
"org-string">'TSLiteralType'</span> &amp;&
<span class=
"linenr"> 991: </span>          t.literal.type !== <span class=
"org-string">'UnaryExpression'</span>
<span class="linenr"> 992: </span>        ) {
<span class=
"linenr"> 993: </span>          emits.add(String(t.literal.value))
<span class="linenr"> 994: </span>        }
<span class="linenr"> 995: </span>      }
<span class="linenr"> 996: </span>    }
<span class="linenr"> 997: </span>  }
<span class="linenr"> 998: </span>}
<span class="linenr"> 999: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">genRuntimeEmits</span>(<span class=
"org-variable-name">emits</span>) {
<span class="linenr">1000: </span>  <span class=
"org-keyword">return</span> emits.size
<span class="linenr">1001: </span>    ? <span class=
"org-string">`\n  emits: [${Array.from(emits)</span>
<span class="linenr">1002: </span><span class=
"org-string">        .map(p =&gt; JSON.stringify(p))</span>
<span class="linenr">1003: </span><span class=
"org-string">        .join(', ')}],`</span>
<span class="linenr">1004: </span>    : <span class=
"org-string">``</span>
<span class="linenr">1005: </span>}
<span class="linenr">1006: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">isCallOf</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">test</span>) {
<span class="linenr">1007: </span>  <span class=
"org-keyword">return</span> !!(
<span class="linenr">1008: </span>    node &amp;&
<span class="linenr">1009: </span>    node.type === <span class=
"org-string">'CallExpression'</span> &amp;&
<span class=
"linenr">1010: </span>    node.callee.type === <span class=
"org-string">'Identifier'</span> &amp;&
<span class="linenr">1011: </span>    (<span class=
"org-keyword">typeof</span> test === <span class=
"org-string">'string'</span>
<span class="linenr">1012: </span>      ? node.callee.name === test
<span class="linenr">1013: </span>      : test(node.callee.name))
<span class="linenr">1014: </span>  )
<span class="linenr">1015: </span>}
<span class="linenr">1016: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">canNeverBeRef</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">userReactiveImport</span>) {
<span class="linenr">1017: </span>  <span class=
"org-keyword">if</span> (isCallOf(node, userReactiveImport)) {
<span class="linenr">1018: </span>    <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr">1019: </span>  }
<span class="linenr">1020: </span>  <span class=
"org-keyword">switch</span> (node.type) {
<span class="linenr">1021: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'UnaryExpression'</span>:
<span class="linenr">1022: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'BinaryExpression'</span>:
<span class="linenr">1023: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'ArrayExpression'</span>:
<span class="linenr">1024: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'ObjectExpression'</span>:
<span class="linenr">1025: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'FunctionExpression'</span>:
<span class="linenr">1026: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'ArrowFunctionExpression'</span>:
<span class="linenr">1027: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'UpdateExpression'</span>:
<span class="linenr">1028: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'ClassExpression'</span>:
<span class="linenr">1029: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'TaggedTemplateExpression'</span>:
<span class="linenr">1030: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr">1031: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'SequenceExpression'</span>:
<span class="linenr">1032: </span>      <span class=
"org-keyword">return</span> canNeverBeRef(
<span class=
"linenr">1033: </span>        node.expressions[node.expressions.length - <span class="org-highlight-numbers-number">1</span>],
<span class="linenr">1034: </span>        userReactiveImport
<span class="linenr">1035: </span>      )
<span class="linenr">1036: </span>    <span class=
"org-keyword">default</span>:
<span class="linenr">1037: </span>      <span class=
"org-keyword">if</span> (node.type.endsWith(<span class=
"org-string">'Literal'</span>)) {
<span class="linenr">1038: </span>        <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr">1039: </span>      }
<span class="linenr">1040: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">1041: </span>  }
<span class="linenr">1042: </span>}
<span class="linenr">1043: </span>
<span class="linenr">1044: </span>
<span class="linenr">1045: </span><span class="org-doc">/**</span>
<span class="linenr">1046: </span><span class=
"org-doc"> * Analyze bindings in normal `&lt;script&gt;`</span>
<span class="linenr">1047: </span><span class=
"org-doc"> * Note that `compileScriptSetup` already analyzes bindings as part of its</span>
<span class="linenr">1048: </span><span class=
"org-doc"> * compilation process so this should only be used on single `&lt;script&gt;` SFCs.</span>
<span class="linenr">1049: </span><span class="org-doc"> */</span>
<span class="linenr">1050: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">analyzeScriptBindings</span>(<span class=
"org-variable-name">ast</span>) {
<span class="linenr">1051: </span>  <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">node</span> <span class=
"org-keyword">of</span> ast) {
<span class="linenr">1052: </span>    <span class=
"org-keyword">if</span> (
<span class="linenr">1053: </span>      node.type === <span class=
"org-string">'ExportDefaultDeclaration'</span> &amp;&
<span class=
"linenr">1054: </span>      node.declaration.type === <span class=
"org-string">'ObjectExpression'</span>
<span class="linenr">1055: </span>    ) {
<span class="linenr">1056: </span>      <span class=
"org-keyword">return</span> analyzeBindingsFromOptions(node.declaration)
<span class="linenr">1057: </span>    }
<span class="linenr">1058: </span>  }
<span class="linenr">1059: </span>  <span class=
"org-keyword">return</span> {}
<span class="linenr">1060: </span>}
<span class="linenr">1061: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">analyzeBindingsFromOptions</span>(<span class=
"org-variable-name">node</span>) {
<span class="linenr">1062: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">bindings</span> = {}
<span class="linenr">1063: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">#3270, #3275</span>
<span class="linenr">1064: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">mark non-script-setup so we don't resolve components/directives from these</span>
<span class=
"linenr">1065: </span>  Object.defineProperty(bindings, <span class="org-string">'__isScriptSetup'</span>, {
<span class="linenr">1066: </span>    enumerable: <span class=
"org-constant">false</span>,
<span class="linenr">1067: </span>    value: <span class=
"org-constant">false</span>
<span class="linenr">1068: </span>  })
<span class="linenr">1069: </span>  <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">property</span> <span class=
"org-keyword">of</span> node.properties) {
<span class="linenr">1070: </span>    <span class=
"org-keyword">if</span> (
<span class=
"linenr">1071: </span>      property.type === <span class=
"org-string">'ObjectProperty'</span> &amp;&
<span class="linenr">1072: </span>      !property.computed &amp;&
<span class=
"linenr">1073: </span>      property.key.type === <span class=
"org-string">'Identifier'</span>
<span class="linenr">1074: </span>    ) {
<span class="linenr">1075: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">props</span>
<span class="linenr">1076: </span>      <span class=
"org-keyword">if</span> (property.key.name === <span class=
"org-string">'props'</span>) {
<span class="linenr">1077: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">props: ['foo']</span>
<span class="linenr">1078: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">props: { foo: ... }</span>
<span class="linenr">1079: </span>        <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">of</span> getObjectOrArrayExpressionKeys(property.value)) {
<span class=
"linenr">1080: </span>          bindings[key] = BindingTypes.PROPS
<span class="linenr">1081: </span>        }
<span class="linenr">1082: </span>      }
<span class="linenr">1083: </span>
<span class="linenr">1084: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">inject</span>
<span class="linenr">1085: </span>      <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (property.key.name === <span class=
"org-string">'inject'</span>) {
<span class="linenr">1086: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">inject: ['foo']</span>
<span class="linenr">1087: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">inject: { foo: {} }</span>
<span class="linenr">1088: </span>        <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">of</span> getObjectOrArrayExpressionKeys(property.value)) {
<span class=
"linenr">1089: </span>          bindings[key] = BindingTypes.OPTIONS
<span class="linenr">1090: </span>        }
<span class="linenr">1091: </span>      }
<span class="linenr">1092: </span>
<span class="linenr">1093: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">computed & methods</span>
<span class="linenr">1094: </span>      <span class=
"org-keyword">else</span> <span class="org-keyword">if</span> (
<span class=
"linenr">1095: </span>        property.value.type === <span class=
"org-string">'ObjectExpression'</span> &amp;&
<span class=
"linenr">1096: </span>        (property.key.name === <span class=
"org-string">'computed'</span> || property.key.name === <span class="org-string">'methods'</span>)
<span class="linenr">1097: </span>      ) {
<span class="linenr">1098: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">methods: { foo() {} }</span>
<span class="linenr">1099: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">computed: { foo() {} }</span>
<span class="linenr">1100: </span>        <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">of</span> getObjectExpressionKeys(property.value)) {
<span class=
"linenr">1101: </span>          bindings[key] = BindingTypes.OPTIONS
<span class="linenr">1102: </span>        }
<span class="linenr">1103: </span>      }
<span class="linenr">1104: </span>    }
<span class="linenr">1105: </span>
<span class="linenr">1106: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">setup & data</span>
<span class="linenr">1107: </span>    <span class=
"org-keyword">else</span> <span class="org-keyword">if</span> (
<span class=
"linenr">1108: </span>      property.type === <span class=
"org-string">'ObjectMethod'</span> &amp;&
<span class=
"linenr">1109: </span>      property.key.type === <span class=
"org-string">'Identifier'</span> &amp;&
<span class=
"linenr">1110: </span>      (property.key.name === <span class=
"org-string">'setup'</span> || property.key.name === <span class=
"org-string">'data'</span>)
<span class="linenr">1111: </span>    ) {
<span class="linenr">1112: </span>      <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">bodyItem</span> <span class=
"org-keyword">of</span> property.body.body) {
<span class="linenr">1113: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">setup() {</span>
<span class="linenr">1114: </span>        <span class=
"org-comment-delimiter">//   </span><span class=
"org-comment">return {</span>
<span class="linenr">1115: </span>        <span class=
"org-comment-delimiter">//     </span><span class=
"org-comment">foo: null</span>
<span class="linenr">1116: </span>        <span class=
"org-comment-delimiter">//   </span><span class=
"org-comment">}</span>
<span class="linenr">1117: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">}</span>
<span class="linenr">1118: </span>        <span class=
"org-keyword">if</span> (
<span class=
"linenr">1119: </span>          bodyItem.type === <span class=
"org-string">'ReturnStatement'</span> &amp;&
<span class=
"linenr">1120: </span>          bodyItem.argument &amp;&
<span class=
"linenr">1121: </span>          bodyItem.argument.type === <span class="org-string">'ObjectExpression'</span>
<span class="linenr">1122: </span>        ) {
<span class="linenr">1123: </span>          <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">of</span> getObjectExpressionKeys(bodyItem.argument)) {
<span class="linenr">1124: </span>            bindings[key] =
<span class=
"linenr">1125: </span>              property.key.name === <span class="org-string">'setup'</span>
<span class=
"linenr">1126: </span>                ? BindingTypes.SETUP_MAYBE_REF
<span class=
"linenr">1127: </span>                : BindingTypes.DATA
<span class="linenr">1128: </span>          }
<span class="linenr">1129: </span>        }
<span class="linenr">1130: </span>      }
<span class="linenr">1131: </span>    }
<span class="linenr">1132: </span>  }
<span class="linenr">1133: </span>
<span class="linenr">1134: </span>  <span class=
"org-keyword">return</span> bindings
<span class="linenr">1135: </span>}
<span class="linenr">1136: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">getObjectExpressionKeys</span>(<span class=
"org-variable-name">node</span>) {
<span class="linenr">1137: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">keys</span> = []
<span class="linenr">1138: </span>  <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">prop</span> <span class=
"org-keyword">of</span> node.properties) {
<span class="linenr">1139: </span>    <span class=
"org-keyword">if</span> (
<span class="linenr">1140: </span>      (prop.type === <span class=
"org-string">'ObjectProperty'</span> || prop.type === <span class=
"org-string">'ObjectMethod'</span>) &amp;&
<span class="linenr">1141: </span>      !prop.computed
<span class="linenr">1142: </span>    ) {
<span class="linenr">1143: </span>      <span class=
"org-keyword">if</span> (prop.key.type === <span class=
"org-string">'Identifier'</span>) {
<span class="linenr">1144: </span>        keys.push(prop.key.name)
<span class="linenr">1145: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (prop.key.type === <span class=
"org-string">'StringLiteral'</span>) {
<span class="linenr">1146: </span>        keys.push(prop.key.value)
<span class="linenr">1147: </span>      }
<span class="linenr">1148: </span>    }
<span class="linenr">1149: </span>  }
<span class="linenr">1150: </span>  <span class=
"org-keyword">return</span> keys
<span class="linenr">1151: </span>}
<span class="linenr">1152: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">getArrayExpressionKeys</span>(<span class=
"org-variable-name">node</span>) {
<span class="linenr">1153: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">keys</span> = []
<span class="linenr">1154: </span>  <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">element</span> <span class=
"org-keyword">of</span> node.elements) {
<span class="linenr">1155: </span>    <span class=
"org-keyword">if</span> (element &amp;& element.type === <span class="org-string">'StringLiteral'</span>) {
<span class="linenr">1156: </span>      keys.push(element.value)
<span class="linenr">1157: </span>    }
<span class="linenr">1158: </span>  }
<span class="linenr">1159: </span>  <span class=
"org-keyword">return</span> keys
<span class="linenr">1160: </span>}
<span class="linenr">1161: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">getObjectOrArrayExpressionKeys</span>(<span class="org-variable-name">value</span>) {
<span class="linenr">1162: </span>  <span class=
"org-keyword">if</span> (value.type === <span class=
"org-string">'ArrayExpression'</span>) {
<span class="linenr">1163: </span>    <span class=
"org-keyword">return</span> getArrayExpressionKeys(value)
<span class="linenr">1164: </span>  }
<span class="linenr">1165: </span>  <span class=
"org-keyword">if</span> (value.type === <span class=
"org-string">'ObjectExpression'</span>) {
<span class="linenr">1166: </span>    <span class=
"org-keyword">return</span> getObjectExpressionKeys(value)
<span class="linenr">1167: </span>  }
<span class="linenr">1168: </span>  <span class=
"org-keyword">return</span> []
<span class="linenr">1169: </span>}
<span class="linenr">1170: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">resolveTemplateUsageCheckString</span>(<span class="org-variable-name">sfc</span>) {
<span class="linenr">1171: </span>  <span class=
"org-keyword">const</span> { content, ast } = sfc.template
<span class="linenr">1172: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">cached</span> = templateUsageCheckCache.get(content)
<span class="linenr">1173: </span>  <span class=
"org-keyword">if</span> (cached) {
<span class="linenr">1174: </span>    <span class=
"org-keyword">return</span> cached
<span class="linenr">1175: </span>  }
<span class="linenr">1176: </span>
<span class="linenr">1177: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">code</span> = <span class=
"org-string">''</span>
<span class="linenr">1178: </span>  transform(createRoot([ast]), {
<span class="linenr">1179: </span>    nodeTransforms: [
<span class="linenr">1180: </span>      node =&gt; {
<span class="linenr">1181: </span>        <span class=
"org-keyword">if</span> (node.type === NodeTypes.ELEMENT) {
<span class="linenr">1182: </span>          <span class=
"org-keyword">if</span> (
<span class=
"linenr">1183: </span>            !parserOptions.isNativeTag(node.tag) &amp;&
<span class=
"linenr">1184: </span>            !parserOptions.isBuiltInComponent(node.tag)
<span class="linenr">1185: </span>          ) {
<span class="linenr">1186: </span>            code += <span class=
"org-string">`,${camelize(node.tag)},${capitalize(camelize(node.tag))}`</span>
<span class="linenr">1187: </span>          }
<span class="linenr">1188: </span>          <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; node.props.length; i++) {
<span class="linenr">1189: </span>            <span class=
"org-keyword">const</span> <span class=
"org-variable-name">prop</span> = node.props[i]
<span class="linenr">1190: </span>            <span class=
"org-keyword">if</span> (prop.type === NodeTypes.DIRECTIVE) {
<span class="linenr">1191: </span>              <span class=
"org-keyword">if</span> (!isBuiltInDir(prop.name)) {
<span class=
"linenr">1192: </span>                code += <span class=
"org-string">`,v${capitalize(camelize(prop.name))}`</span>
<span class="linenr">1193: </span>              }
<span class="linenr">1194: </span>              <span class=
"org-keyword">if</span> (prop.exp) {
<span class=
"linenr">1195: </span>                code += <span class=
"org-string">`,${stripStrings(prop.exp.content)}`</span>
<span class="linenr">1196: </span>              }
<span class="linenr">1197: </span>            }
<span class="linenr">1198: </span>          }
<span class="linenr">1199: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (node.type === NodeTypes.INTERPOLATION) {
<span class="linenr">1200: </span>          code += <span class=
"org-string">`,${stripStrings(node.content.content)}`</span>
<span class="linenr">1201: </span>        }
<span class="linenr">1202: </span>      }
<span class="linenr">1203: </span>    ]
<span class="linenr">1204: </span>  })
<span class="linenr">1205: </span>
<span class="linenr">1206: </span>  code += <span class=
"org-string">';'</span>
<span class=
"linenr">1207: </span>  templateUsageCheckCache.set(content, code)
<span class="linenr">1208: </span>  <span class=
"org-keyword">return</span> code
<span class="linenr">1209: </span>}
<span class="linenr">1210: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">stripStrings</span>(<span class=
"org-variable-name">exp</span>) {
<span class="linenr">1211: </span>  <span class=
"org-keyword">return</span> exp
<span class="linenr">1212: </span>    .replace(<span class=
"org-string">/'[^']*'|"[^"]*"/</span>g, <span class=
"org-string">''</span>)
<span class="linenr">1213: </span>    .replace(<span class=
"org-string">/`[^`]+`/</span>g, stripTemplateString)
<span class="linenr">1214: </span>}
<span class="linenr">1215: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">isImportUsed</span>(<span class=
"org-variable-name">local</span>, <span class=
"org-variable-name">sfc</span>) {
<span class="linenr">1216: </span>  <span class=
"org-keyword">return</span> <span class=
"org-keyword">new</span> <span class="org-type">RegExp</span>(
<span class="linenr">1217: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">#4274 escape $ since it's a special char in regex</span>
<span class="linenr">1218: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">(and is the only regex special char that is valid in identifiers)</span>
<span class="linenr">1219: </span>    <span class=
"org-string">`[^\\w$_]${local.replace(/\$/g, '\\$')}[^\\w$_]`</span>
<span class=
"linenr">1220: </span>  ).test(resolveTemplateUsageCheckString(sfc))
<span class="linenr">1221: </span>}
<span class="linenr">1222: </span><span class="org-doc">/**</span>
<span class="linenr">1223: </span><span class=
"org-doc"> * Note: this comparison assumes the prev/next script are already identical,</span>
<span class="linenr">1224: </span><span class=
"org-doc"> * and only checks the special case where &lt;script setup lang="ts"&gt; unused import</span>
<span class="linenr">1225: </span><span class=
"org-doc"> * pruning result changes due to template changes.</span>
<span class="linenr">1226: </span><span class="org-doc"> */</span>
<span class="linenr">1227: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">hmrShouldReload</span>(<span class=
"org-variable-name">prevImports</span>, <span class=
"org-variable-name">next</span>) {
<span class="linenr">1228: </span>  <span class=
"org-keyword">if</span> (
<span class="linenr">1229: </span>    !next.scriptSetup ||
<span class=
"linenr">1230: </span>    (next.scriptSetup.lang !== <span class=
"org-string">'ts'</span> &amp;& next.scriptSetup.lang !== <span class="org-string">'tsx'</span>)
<span class="linenr">1231: </span>  ) {
<span class="linenr">1232: </span>    <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">1233: </span>  }
<span class="linenr">1234: </span>
<span class="linenr">1235: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">for each previous import, check if its used status remain the same based on</span>
<span class="linenr">1236: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">the next descriptor's template</span>
<span class="linenr">1237: </span>  <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">in</span> prevImports) {
<span class="linenr">1238: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">if an import was previous unused, but now is used, we need to force</span>
<span class="linenr">1239: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">reload so that the script now includes that import.</span>
<span class="linenr">1240: </span>    <span class=
"org-keyword">if</span> (!prevImports[key].isUsedInTemplate &amp;& isImportUsed(key, next)) {
<span class="linenr">1241: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr">1242: </span>    }
<span class="linenr">1243: </span>  }
<span class="linenr">1244: </span>
<span class="linenr">1245: </span>  <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">1246: </span>}
<span class="linenr">1247: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">compileTemplate</span>(<span class=
"org-variable-name">options</span>) {
<span class="linenr">1248: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">...省略直接使用现有的 compile</span>
<span class="linenr">1249: </span>
<span class="linenr">1250: </span>  <span class=
"org-keyword">return</span> doCompileTemplate(options)
<span class="linenr">1251: </span>}
<span class="linenr">1252: </span>
<span class="linenr">1253: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">doCompileTemplate</span>({
<span class="linenr">1254: </span>  filename,
<span class="linenr">1255: </span>  id,
<span class="linenr">1256: </span>  scoped,
<span class="linenr">1257: </span>  slotted,
<span class="linenr">1258: </span>  inMap,
<span class="linenr">1259: </span>  source,
<span class="linenr">1260: </span>  ssr = <span class=
"org-constant">false</span>,
<span class="linenr">1261: </span>  ssrCssVars,
<span class="linenr">1262: </span>  isProd = <span class=
"org-constant">false</span>,
<span class="linenr">1263: </span>  compiler,
<span class="linenr">1264: </span>  compilerOptions = {},
<span class="linenr">1265: </span>  transformAssetUrls
<span class="linenr">1266: </span>}) {
<span class="linenr">1267: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">errors</span> = []
<span class="linenr">1268: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">warnings</span> = []
<span class="linenr">1269: </span>
<span class="linenr">1270: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">nodeTransforms</span> = []
<span class="linenr">1271: </span>  <span class=
"org-keyword">if</span> (isObject(transformAssetUrls)) {
<span class="linenr">1272: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">assetOptions</span> = normalizeOptions(transformAssetUrls)
<span class="linenr">1273: </span>    nodeTransforms = [
<span class=
"linenr">1274: </span>      createAssetUrlTransformWithOptions(assetOptions),
<span class=
"linenr">1275: </span>      createSrcsetTransformWithOptions(assetOptions)
<span class="linenr">1276: </span>    ]
<span class="linenr">1277: </span>  } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (transformAssetUrls !== <span class=
"org-constant">false</span>) {
<span class=
"linenr">1278: </span>    nodeTransforms = [transformAssetUrl, transformSrcset]
<span class="linenr">1279: </span>  }
<span class="linenr">1280: </span>
<span class="linenr">1281: </span>  <span class=
"org-keyword">if</span> (!id) {
<span class="linenr">1282: </span>    id = <span class=
"org-string">''</span>
<span class="linenr">1283: </span>  }
<span class="linenr">1284: </span>
<span class="linenr">1285: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">shortId</span> = id.replace(<span class=
"org-string">/^data-v-/</span>, <span class="org-string">''</span>)
<span class="linenr">1286: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">longId</span> = <span class=
"org-string">`data-v-${shortId}`</span>
<span class="linenr">1287: </span>
<span class="linenr">1288: </span>  <span class=
"org-keyword">let</span> { code, ast, preamble, map } = baseCompile(source, {
<span class="linenr">1289: </span>    mode: <span class=
"org-string">'module'</span>,
<span class=
"linenr">1290: </span>    prefixIdentifiers: <span class=
"org-constant">true</span>,
<span class="linenr">1291: </span>    hoistStatic: <span class=
"org-constant">true</span>,
<span class="linenr">1292: </span>    cacheHandlers: <span class=
"org-constant">true</span>,
<span class="linenr">1293: </span>    ssrCssVars:
<span class=
"linenr">1294: </span>      ssr &amp;& ssrCssVars &amp;& ssrCssVars.length
<span class=
"linenr">1295: </span>        ? genCssVarsFromList(ssrCssVars, shortId, isProd)
<span class="linenr">1296: </span>        : <span class=
"org-string">''</span>,
<span class=
"linenr">1297: </span>    scopeId: scoped ? longId : <span class=
"org-constant">undefined</span>,
<span class="linenr">1298: </span>    slotted,
<span class="linenr">1299: </span>    sourceMap: <span class=
"org-constant">true</span>,
<span class="linenr">1300: </span>    ...compilerOptions,
<span class=
"linenr">1301: </span>    nodeTransforms: nodeTransforms.concat(compilerOptions.nodeTransforms || []),
<span class="linenr">1302: </span>    filename,
<span class=
"linenr">1303: </span>    onError: e =&gt; errors.push(e),
<span class=
"linenr">1304: </span>    onWarn: w =&gt; warnings.push(w)
<span class="linenr">1305: </span>  })
<span class="linenr">1306: </span>
<span class="linenr">1307: </span>  <span class=
"org-keyword">return</span> { code, ast, preamble, source, errors, tips, map }
<span class="linenr">1308: </span>}
<span class="linenr">1309: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">hash</span> = require(process.env.NODE_LIB + <span class="org-string">'/hash-sum'</span>)
<span class="linenr">1310: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">CSS_VARS_HELPER</span> = <span class=
"org-string">`useCssVars`</span>
<span class="linenr">1311: </span><span class=
"org-comment-delimiter">// </span><span class=
"org-comment">match v-bind() with max 2-levels of nested parens.</span>
<span class="linenr">1312: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">cssVarRE</span> = <span class=
"org-string">/v-bind\s*\(((?:[^)(]+|\((?:[^)(]+|\([^)(]*\))*\))*)\)/</span>g
<span class="linenr">1313: </span>
<span class="linenr">1314: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">genCssVarsFromList</span>(
<span class="linenr">1315: </span>  <span class=
"org-variable-name">vars</span>,
<span class="linenr">1316: </span>  <span class=
"org-variable-name">id</span>,
<span class="linenr">1317: </span>  isProd
<span class="linenr">1318: </span>) {
<span class="linenr">1319: </span>  <span class=
"org-keyword">return</span> <span class=
"org-string">`{\n  ${vars</span>
<span class="linenr">1320: </span><span class=
"org-string">    .map(key =&gt; `"${genVarName(id, key, isProd)}"</span>: (${key})<span class="org-string">`)</span>
<span class="linenr">1321: </span><span class=
"org-string">    .join(',\n  ')}\n}`</span>
<span class="linenr">1322: </span>}
<span class="linenr">1323: </span>
<span class="linenr">1324: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">genVarName</span>(<span class=
"org-variable-name">id</span>, <span class=
"org-variable-name">raw</span>, <span class=
"org-variable-name">isProd</span>) {
<span class="linenr">1325: </span>  <span class=
"org-keyword">if</span> (isProd) {
<span class="linenr">1326: </span>    <span class=
"org-keyword">return</span> hash(id + raw)
<span class="linenr">1327: </span>  } <span class=
"org-keyword">else</span> {
<span class="linenr">1328: </span>    <span class=
"org-keyword">return</span> <span class=
"org-string">`${id}-${raw.replace(/([^\w-])/g, '_')}`</span>
<span class="linenr">1329: </span>  }
<span class="linenr">1330: </span>}
<span class="linenr">1331: </span>
<span class="linenr">1332: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">noramlizeExpression</span>(<span class=
"org-variable-name">exp</span>) {
<span class="linenr">1333: </span>  exp = exp.trim()
<span class="linenr">1334: </span>  <span class=
"org-keyword">if</span> (
<span class="linenr">1335: </span>    (exp[<span class=
"org-highlight-numbers-number">0</span>] === <span class=
"org-string">`'`</span> &amp;& exp[exp.length - <span class=
"org-highlight-numbers-number">1</span>] === <span class=
"org-string">`'`</span>) ||
<span class="linenr">1336: </span>    (exp[<span class=
"org-highlight-numbers-number">0</span>] === <span class=
"org-string">`"`</span> &amp;& exp[exp.length - <span class=
"org-highlight-numbers-number">1</span>] === <span class=
"org-string">`"`</span>)
<span class="linenr">1337: </span>  ) {
<span class="linenr">1338: </span>    <span class=
"org-keyword">return</span> exp.slice(<span class=
"org-highlight-numbers-number">1</span>, -<span class=
"org-highlight-numbers-number">1</span>)
<span class="linenr">1339: </span>  }
<span class="linenr">1340: </span>  <span class=
"org-keyword">return</span> exp
<span class="linenr">1341: </span>}
<span class="linenr">1342: </span>
<span class="linenr">1343: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">parseCssVars</span>(<span class=
"org-variable-name">sfc</span>) {
<span class="linenr">1344: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">vars</span> = []
<span class=
"linenr">1345: </span>  sfc.styles.forEach(style =&gt; {
<span class="linenr">1346: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">match</span>
<span class="linenr">1347: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">ignore v-bind() in comments /* ... */</span>
<span class="linenr">1348: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">content</span> = style.content.replace(<span class="org-string">/\/\*([\s\S]*?)\*\//</span>g, <span class="org-string">''</span>)
<span class="linenr">1349: </span>    <span class=
"org-keyword">while</span> ((match = cssVarRE.exec(content))) {
<span class="linenr">1350: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">variable</span> = noramlizeExpression(match[<span class="org-highlight-numbers-number">1</span>])
<span class="linenr">1351: </span>      <span class=
"org-keyword">if</span> (!vars.includes(variable)) {
<span class="linenr">1352: </span>        vars.push(variable)
<span class="linenr">1353: </span>      }
<span class="linenr">1354: </span>    }
<span class="linenr">1355: </span>  })
<span class="linenr">1356: </span>  <span class=
"org-keyword">return</span> vars
<span class="linenr">1357: </span>}
<span class="linenr">1358: </span>
<span class="linenr">1359: </span><span class=
"org-comment-delimiter">// </span><span class=
"org-comment">for compileStyle</span>
<span class="linenr">1360: </span>
<span class="linenr">1361: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">cssVarsPlugin</span> = opts =&gt; {
<span class="linenr">1362: </span>  <span class=
"org-keyword">const</span> { id, isProd } = opts
<span class="linenr">1363: </span>  <span class=
"org-keyword">return</span> {
<span class="linenr">1364: </span>    postcssPlugin: <span class=
"org-string">'vue-sfc-vars'</span>,
<span class="linenr">1365: </span>    Declaration(decl) {
<span class="linenr">1366: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">rewrite CSS variables</span>
<span class="linenr">1367: </span>      <span class=
"org-keyword">if</span> (cssVarRE.test(decl.value)) {
<span class=
"linenr">1368: </span>        decl.value = decl.value.replace(cssVarRE, (_, $1) =&gt; {
<span class="linenr">1369: </span>          <span class=
"org-keyword">return</span> <span class=
"org-string">`var(--${genVarName(id, noramlizeExpression($1), isProd)})`</span>
<span class="linenr">1370: </span>        })
<span class="linenr">1371: </span>      }
<span class="linenr">1372: </span>    }
<span class="linenr">1373: </span>  }
<span class="linenr">1374: </span>}
<span class=
"linenr">1375: </span>cssVarsPlugin.postcss = <span class=
"org-constant">true</span>
<span class="linenr">1376: </span>
<span class="linenr">1377: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">genCssVarsCode</span>(
<span class="linenr">1378: </span>  <span class=
"org-variable-name">vars</span>,
<span class="linenr">1379: </span>  <span class=
"org-variable-name">bindings</span>,
<span class="linenr">1380: </span>  <span class=
"org-variable-name">id</span>,
<span class="linenr">1381: </span>  isProd
<span class="linenr">1382: </span>) {
<span class="linenr">1383: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">varsExp</span> = genCssVarsFromList(vars, id, isProd)
<span class="linenr">1384: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">exp</span> = createSimpleExpression(varsExp, <span class="org-constant">false</span>)
<span class="linenr">1385: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">context</span> = createTransformContext(createRoot([]), {
<span class=
"linenr">1386: </span>    prefixIdentifiers: <span class=
"org-constant">true</span>,
<span class="linenr">1387: </span>    inline: <span class=
"org-constant">true</span>,
<span class=
"linenr">1388: </span>    bindingMetadata: bindings.__isScriptSetup === <span class="org-constant">false</span> ? <span class="org-constant">undefined</span> : bindings
<span class="linenr">1389: </span>  })
<span class="linenr">1390: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">transformed</span> = processExpression(exp, context)
<span class="linenr">1391: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">transformedString</span> =
<span class=
"linenr">1392: </span>    transformed.type === NodeTypes.SIMPLE_EXPRESSION
<span class="linenr">1393: </span>      ? transformed.content
<span class="linenr">1394: </span>      : transformed.children
<span class="linenr">1395: </span>          .map(c =&gt; {
<span class="linenr">1396: </span>            <span class=
"org-keyword">return</span> <span class=
"org-keyword">typeof</span> c === <span class=
"org-string">'string'</span>
<span class="linenr">1397: </span>              ? c
<span class="linenr">1398: </span>              : c.content
<span class="linenr">1399: </span>          })
<span class="linenr">1400: </span>          .join(<span class=
"org-string">''</span>)
<span class="linenr">1401: </span>
<span class="linenr">1402: </span>  <span class=
"org-keyword">return</span> <span class=
"org-string">`_${CSS_VARS_HELPER}(_ctx =&gt; (${transformedString}))`</span>
<span class="linenr">1403: </span>}
<span class="linenr">1404: </span>
<span class="linenr">1405: </span><span class=
"org-comment-delimiter">// </span><span class=
"org-comment">&lt;script setup&gt; already gets the calls injected as part of the transform</span>
<span class="linenr">1406: </span><span class=
"org-comment-delimiter">// </span><span class=
"org-comment">this is only for single normal &lt;script&gt;</span>
<span class="linenr">1407: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">genNormalScriptCssVarsCode</span>(
<span class="linenr">1408: </span>  <span class=
"org-variable-name">cssVars</span>,
<span class="linenr">1409: </span>  <span class=
"org-variable-name">bindings</span>,
<span class="linenr">1410: </span>  <span class=
"org-variable-name">id</span>,
<span class="linenr">1411: </span>  isProd
<span class="linenr">1412: </span>) {
<span class="linenr">1413: </span>  <span class=
"org-keyword">return</span> (
<span class="linenr">1414: </span>    <span class=
"org-string">`\nimport { ${CSS_VARS_HELPER} as _${CSS_VARS_HELPER} } from 'vue'\n`</span> +
<span class="linenr">1415: </span>    <span class=
"org-string">`const __injectCSSVars__ = () =&gt; {\n${genCssVarsCode(</span>
<span class="linenr">1416: </span><span class=
"org-string">      cssVars,</span>
<span class="linenr">1417: </span><span class=
"org-string">      bindings,</span>
<span class="linenr">1418: </span><span class=
"org-string">      id,</span>
<span class="linenr">1419: </span><span class=
"org-string">      isProd</span>
<span class="linenr">1420: </span><span class=
"org-string">    )}}\n`</span> +
<span class="linenr">1421: </span>    <span class=
"org-string">`const __setup__ = __default__.setup\n`</span> +
<span class="linenr">1422: </span>    <span class=
"org-string">`__default__.setup = __setup__\n`</span> +
<span class="linenr">1423: </span>    <span class=
"org-string">`  ? (props, ctx) =&gt; { __injectCSSVars__();return __setup__(props, ctx) }\n`</span> +
<span class="linenr">1424: </span>    <span class=
"org-string">`  : __injectCSSVars__\n`</span>
<span class="linenr">1425: </span>  )
<span class="linenr">1426: </span>}
<span class="linenr">1427: </span>
<span class="linenr">1428: </span>
<span class="linenr">1429: </span><span class=
"org-comment-delimiter">// </span><span class=
"org-comment">Special compiler macros</span>
<span class="linenr">1430: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">DEFINE_PROPS</span> = <span class=
"org-string">'defineProps'</span>
<span class="linenr">1431: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">DEFINE_EMITS</span> = <span class=
"org-string">'defineEmits'</span>
<span class="linenr">1432: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">DEFINE_EXPOSE</span> = <span class=
"org-string">'defineExpose'</span>
<span class="linenr">1433: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">WITH_DEFAULTS</span> = <span class=
"org-string">'withDefaults'</span>
<span class="linenr">1434: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">templateUsageCheckCache</span> = createCache()
<span class="linenr">1435: </span>
<span class="linenr">1436: </span><span class=
"org-comment-delimiter">// </span><span class=
"org-comment">constants</span>
<span class="linenr">1437: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">DEFAULT_VAR</span> = <span class=
"org-string">`__default__`</span>
<span class="linenr">1438: </span>
<span class="linenr">1439: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">isBuiltInDir</span> = makeMap(
<span class="linenr">1440: </span>  <span class=
"org-string">`once,memo,if,else,else-if,slot,text,html,on,bind,model,show,cloak,is`</span>
<span class="linenr">1441: </span>)
<span class="linenr">1442: </span>
<span class="linenr">1443: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">compileScript</span>(<span class=
"org-variable-name">sfc</span>, <span class=
"org-variable-name">options</span>) {
<span class="linenr">1444: </span>  <span class=
"org-keyword">let</span> { script, scriptSetup, source, filename } = sfc
<span class="linenr">1445: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">feature flags</span>
<span class="linenr">1446: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment"><span class="org-bold"><span class=
"org-warning">TODO</span></span></span><span class=
"org-comment"> remove support for deprecated options when out of experimental</span>
<span class="linenr">1447: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">enableReactivityTransform</span> =
<span class=
"linenr">1448: </span>    !!options.reactivityTransform ||
<span class="linenr">1449: </span>    !!options.refSugar ||
<span class="linenr">1450: </span>    !!options.refTransform
<span class="linenr">1451: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">enablePropsTransform</span> =
<span class=
"linenr">1452: </span>    !!options.reactivityTransform || !!options.propsDestructureTransform
<span class="linenr">1453: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isProd</span> = !!options.isProd
<span class="linenr">1454: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">genSourceMap</span> = options.sourceMap !== <span class="org-constant">false</span>
<span class="linenr">1455: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">ref 声明的变量</span>
<span class="linenr">1456: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">refBindings</span>
<span class="linenr">1457: </span>
<span class="linenr">1458: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">scopeId</span> = options.id ? options.id.replace(<span class="org-string">/^data-v-/</span>, <span class="org-string">''</span>) : <span class="org-string">''</span>
<span class="linenr">1459: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">cssVars</span> = sfc.cssVars
<span class="linenr">1460: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">scriptLang</span> = script &amp;& script.lang
<span class="linenr">1461: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">scriptSetupLang</span> = scriptSetup &amp;& scriptSetup.lang
<span class="linenr">1462: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isTS</span> =
<span class="linenr">1463: </span>    scriptLang === <span class=
"org-string">'ts'</span> ||
<span class="linenr">1464: </span>    scriptLang === <span class=
"org-string">'tsx'</span> ||
<span class=
"linenr">1465: </span>    scriptSetupLang === <span class=
"org-string">'ts'</span> ||
<span class=
"linenr">1466: </span>    scriptSetupLang === <span class=
"org-string">'tsx'</span>
<span class="linenr">1467: </span>
<span class="linenr">1468: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">resolve parser plugins</span>
<span class="linenr">1469: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">plugins</span> = []
<span class="linenr">1470: </span>  <span class=
"org-keyword">if</span> (!isTS || scriptLang === <span class=
"org-string">'tsx'</span> || scriptSetupLang === <span class=
"org-string">'tsx'</span>) {
<span class="linenr">1471: </span>    plugins.push(<span class=
"org-string">'jsx'</span>)
<span class="linenr">1472: </span>  }
<span class="linenr">1473: </span>  <span class=
"org-keyword">if</span> (options.babelParserPlugins) plugins.push(...options.babelParserPlugins)
<span class="linenr">1474: </span>  <span class=
"org-keyword">if</span> (isTS) plugins.push(<span class=
"org-string">'typescript'</span>, <span class=
"org-string">'decorators-legacy'</span>)
<span class="linenr">1475: </span>
<span class="linenr">1476: </span>  <span class=
"org-keyword">if</span> (!scriptSetup) {
<span class="linenr">1477: </span>    <span class=
"org-keyword">if</span> (!script) {
<span class="linenr">1478: </span>      <span class=
"org-keyword">throw</span> <span class=
"org-keyword">new</span> <span class=
"org-type">Error</span>(<span class=
"org-string">`[@vue/compiler-sfc] SFC contains no &lt;script&gt; tags.`</span>)
<span class="linenr">1479: </span>    }
<span class="linenr">1480: </span>    <span class=
"org-keyword">if</span> (scriptLang &amp;& !isTS &amp;& scriptLang !== <span class="org-string">'jsx'</span>) {
<span class="linenr">1481: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">do not process non js/ts script blocks</span>
<span class="linenr">1482: </span>      <span class=
"org-keyword">return</span> script
<span class="linenr">1483: </span>    }
<span class="linenr">1484: </span>    <span class=
"org-keyword">try</span> {
<span class="linenr">1485: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">content</span> = script.content
<span class="linenr">1486: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">map</span> = script.map
<span class="linenr">1487: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">scriptAst</span> = babelParser.parse(content, {
<span class="linenr">1488: </span>        plugins,
<span class="linenr">1489: </span>        sourceType: <span class=
"org-string">'module'</span>
<span class="linenr">1490: </span>      }).program
<span class="linenr">1491: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">bindings</span> = analyzeScriptBindings(scriptAst.body)
<span class="linenr">1492: </span>      <span class=
"org-keyword">if</span> (enableReactivityTransform &amp;& RT.shouldTransform(content)) {
<span class="linenr">1493: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">s</span> = <span class=
"org-keyword">new</span> <span class=
"org-type">MagicString</span>(source)
<span class="linenr">1494: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">startOffset</span> = script.loc.start.offset
<span class="linenr">1495: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">endOffset</span> = script.loc.end.offset
<span class="linenr">1496: </span>        <span class=
"org-keyword">const</span> { importedHelpers } = RT.transformAST(scriptAst, s, startOffset)
<span class="linenr">1497: </span>        <span class=
"org-keyword">if</span> (importedHelpers.length) {
<span class="linenr">1498: </span>          s.prepend(
<span class="linenr">1499: </span>            <span class=
"org-string">`import { ${importedHelpers</span>
<span class="linenr">1500: </span><span class=
"org-string">              .map(h =&gt; `</span>${h} as _${h}<span class="org-string">`)</span>
<span class="linenr">1501: </span><span class=
"org-string">              .join(', ')} } from 'vue'\n`</span>
<span class="linenr">1502: </span>          )
<span class="linenr">1503: </span>        }
<span class="linenr">1504: </span>        s.remove(<span class=
"org-highlight-numbers-number">0</span>, startOffset)
<span class=
"linenr">1505: </span>        s.remove(endOffset, source.length)
<span class="linenr">1506: </span>        content = s.toString()
<span class="linenr">1507: </span>        <span class=
"org-keyword">if</span> (genSourceMap) {
<span class="linenr">1508: </span>          map = s.generateMap({
<span class="linenr">1509: </span>            source: filename,
<span class="linenr">1510: </span>            hires: <span class=
"org-constant">true</span>,
<span class=
"linenr">1511: </span>            includeContent: <span class=
"org-constant">true</span>
<span class="linenr">1512: </span>          })
<span class="linenr">1513: </span>        }
<span class="linenr">1514: </span>      }
<span class="linenr">1515: </span>      <span class=
"org-keyword">if</span> (cssVars.length) {
<span class=
"linenr">1516: </span>        content = rewriteDefault(content, DEFAULT_VAR, plugins)
<span class=
"linenr">1517: </span>        content += genNormalScriptCssVarsCode(
<span class="linenr">1518: </span>          cssVars,
<span class="linenr">1519: </span>          bindings,
<span class="linenr">1520: </span>          scopeId,
<span class="linenr">1521: </span>          isProd
<span class="linenr">1522: </span>        )
<span class="linenr">1523: </span>        content += <span class=
"org-string">`\nexport default ${DEFAULT_VAR}`</span>
<span class="linenr">1524: </span>      }
<span class="linenr">1525: </span>      <span class=
"org-keyword">return</span> {
<span class="linenr">1526: </span>        ...script,
<span class="linenr">1527: </span>        content,
<span class="linenr">1528: </span>        map,
<span class="linenr">1529: </span>        bindings,
<span class="linenr">1530: </span>        scriptAst: scriptAst.body
<span class="linenr">1531: </span>      }
<span class="linenr">1532: </span>    } <span class=
"org-keyword">catch</span> (e) {
<span class="linenr">1533: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">silently fallback if parse fails since user may be using custom</span>
<span class="linenr">1534: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">babel syntax</span>
<span class="linenr">1535: </span>      <span class=
"org-keyword">return</span> script
<span class="linenr">1536: </span>    }
<span class="linenr">1537: </span>  }
<span class="linenr">1538: </span>
<span class="linenr">1539: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">script 和 script setup 的语言必须一致</span>
<span class="linenr">1540: </span>  <span class=
"org-keyword">if</span> (script &amp;& scriptLang !== scriptSetupLang) {
<span class="linenr">1541: </span>    <span class=
"org-keyword">throw</span> <span class=
"org-keyword">new</span> <span class="org-type">Error</span>(
<span class="linenr">1542: </span>      <span class=
"org-string">`[@vue/compiler-sfc] &lt;script&gt; and &lt;script setup&gt; must have the same `</span> +
<span class="linenr">1543: </span>        <span class=
"org-string">`language type.`</span>
<span class="linenr">1544: </span>    )
<span class="linenr">1545: </span>  }
<span class="linenr">1546: </span>
<span class="linenr">1547: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">只处理 js/ts script</span>
<span class="linenr">1548: </span>  <span class=
"org-keyword">if</span> (scriptSetupLang &amp;& !isTS &amp;& scriptSetupLang !== <span class="org-string">'jsx'</span>) {
<span class="linenr">1549: </span>    <span class=
"org-keyword">return</span> scriptSetup
<span class="linenr">1550: </span>  }
<span class="linenr">1551: </span>
<span class="linenr">1552: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">变量，imports 都需要导出</span>
<span class="linenr">1553: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">bindingMetadata</span> = {}
<span class="linenr">1554: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">helperImports</span> = <span class=
"org-keyword">new</span> <span class="org-type">Set</span>()
<span class="linenr">1555: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">userImports</span> = Object.create(<span class=
"org-constant">null</span>)
<span class="linenr">1556: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">userImportAlias</span> = Object.create(<span class="org-constant">null</span>)
<span class="linenr">1557: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">scriptBindings</span> = Object.create(<span class="org-constant">null</span>)
<span class="linenr">1558: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">setupBindings</span> = Object.create(<span class="org-constant">null</span>)
<span class="linenr">1559: </span>
<span class="linenr">1560: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">defaultExport</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">export default</span>
<span class="linenr">1561: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">hasDefinePropsCall</span> = <span class=
"org-constant">false</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">defineProps()</span>
<span class="linenr">1562: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">hasDefineEmitCall</span> = <span class=
"org-constant">false</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">defineEmits()</span>
<span class="linenr">1563: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">hasDefineExposeCall</span> = <span class=
"org-constant">false</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">defineExpose()</span>
<span class="linenr">1564: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">propsRuntimeDecl</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">属性声明</span>
<span class="linenr">1565: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">propsRuntimeDefaults</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">属性默认值</span>
<span class="linenr">1566: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">propsDestructureDecl</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">属性解构声明</span>
<span class="linenr">1567: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">propsDestructureRestId</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">属性解构的 ... 符号</span>
<span class="linenr">1568: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">propsTypeDecl</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">属性类型声明</span>
<span class="linenr">1569: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">propsTypeDeclRaw</span>
<span class="linenr">1570: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">propsIdentifier</span>
<span class="linenr">1571: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">emitsRuntimeDecl</span>
<span class="linenr">1572: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">emitsTypeDecl</span>
<span class="linenr">1573: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">emitsTypeDeclRaw</span>
<span class="linenr">1574: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">emitIdentifier</span>
<span class="linenr">1575: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">hasAwait</span> = <span class=
"org-constant">false</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">有没 await 符号，如果有则会转成 async setup</span>
<span class="linenr">1576: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">hasInlinedSsrRenderFn</span> = <span class=
"org-constant">false</span>
<span class="linenr">1577: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">props/emits declared via types</span>
<span class="linenr">1578: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">typeDeclaredProps</span> = {}
<span class="linenr">1579: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">typeDeclaredEmits</span> = <span class=
"org-keyword">new</span> <span class="org-type">Set</span>()
<span class="linenr">1580: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">record declared types for runtime props type generation</span>
<span class="linenr">1581: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">declaredTypes</span> = {}
<span class="linenr">1582: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">props destructure data</span>
<span class="linenr">1583: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">propsDestructuredBindings</span> = Object.create(<span class="org-constant">null</span>)
<span class="linenr">1584: </span>
<span class="linenr">1585: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">magic-string state</span>
<span class="linenr">1586: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">s</span> = <span class=
"org-keyword">new</span> <span class=
"org-type">MagicString</span>(source)
<span class="linenr">1587: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">startOffset</span> = scriptSetup.loc.start.offset
<span class="linenr">1588: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">endOffset</span> = scriptSetup.loc.end.offset
<span class="linenr">1589: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">scriptStartOffset</span> = script &amp;& script.loc.start.offset
<span class="linenr">1590: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">scriptEndOffset</span> = script &amp;& script.loc.end.offset
<span class="linenr">1591: </span>
<span class="linenr">1592: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">helper</span>(<span class=
"org-variable-name">key</span>) {
<span class="linenr">1593: </span>    helperImports.add(key)
<span class="linenr">1594: </span>    <span class=
"org-keyword">return</span> <span class=
"org-string">`_${key}`</span>
<span class="linenr">1595: </span>  }
<span class="linenr">1596: </span>    <span class=
"org-keyword">function</span> <span class=
"org-function-name">parse</span>(<span class=
"org-variable-name">input</span>, <span class=
"org-variable-name">options</span>, <span class=
"org-variable-name">offset</span>) {
<span class="linenr">1597: </span>      <span class=
"org-keyword">try</span> {
<span class="linenr">1598: </span>        <span class=
"org-keyword">return</span> babelParser.parse(input, options).program
<span class="linenr">1599: </span>      } <span class=
"org-keyword">catch</span> (e) {
<span class="linenr">1600: </span>        e.message = <span class=
"org-string">`[@vue/compiler-sfc] ${e.message}\n\n${</span>
<span class="linenr">1601: </span><span class=
"org-string">          sfc.filename</span>
<span class="linenr">1602: </span><span class=
"org-string">        }\n${generateCodeFrame(source, e.pos + offset, e.pos + offset + 1)}`</span>
<span class="linenr">1603: </span>        <span class=
"org-keyword">throw</span> e
<span class="linenr">1604: </span>      }
<span class="linenr">1605: </span>    }
<span class="linenr">1606: </span>  
<span class="linenr">1607: </span>  
<span class="linenr">1608: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">error</span>(<span class=
"org-variable-name">msg</span>, <span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">end</span> = <span class=
"org-variable-name">node</span>.<span class=
"org-variable-name">end</span> + <span class=
"org-variable-name">startOffset</span>) {
<span class="linenr">1609: </span>    <span class=
"org-keyword">throw</span> <span class=
"org-keyword">new</span> <span class="org-type">Error</span>(
<span class="linenr">1610: </span>      <span class=
"org-string">`[@vue/compiler-sfc] ${msg}\n\n${sfc.filename}\n${generateCodeFrame(</span>
<span class="linenr">1611: </span><span class=
"org-string">      source,</span>
<span class="linenr">1612: </span><span class=
"org-string">      node.start + startOffset,</span>
<span class="linenr">1613: </span><span class=
"org-string">      end</span>
<span class="linenr">1614: </span><span class=
"org-string">      )}`</span>
<span class="linenr">1615: </span>    )
<span class="linenr">1616: </span>  }
<span class="linenr">1617: </span>    <span class=
"org-keyword">function</span> <span class=
"org-function-name">registerUserImport</span>(<span class=
"org-variable-name">source</span>, <span class=
"org-variable-name">local</span>, <span class=
"org-variable-name">imported</span>, <span class=
"org-variable-name">isType</span>, <span class=
"org-variable-name">isFromSetup</span>) {
<span class="linenr">1618: </span>      <span class=
"org-keyword">if</span> (source === <span class=
"org-string">'vue'</span> &amp;& imported) {
<span class=
"linenr">1619: </span>        userImportAlias[imported] = local
<span class="linenr">1620: </span>      }
<span class="linenr">1621: </span>  
<span class="linenr">1622: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">isUsedInTemplate</span> = <span class=
"org-constant">true</span>
<span class="linenr">1623: </span>      <span class=
"org-keyword">if</span> (isTS &amp;& sfc.template &amp;& !sfc.template.src &amp;& !sfc.template.lang) {
<span class=
"linenr">1624: </span>        isUsedInTemplate = isImportUsed(local, sfc)
<span class="linenr">1625: </span>      }
<span class="linenr">1626: </span>  
<span class="linenr">1627: </span>      userImports[local] = {
<span class="linenr">1628: </span>        isType,
<span class=
"linenr">1629: </span>        imported: imported || <span class=
"org-string">'default'</span>,
<span class="linenr">1630: </span>        source,
<span class="linenr">1631: </span>        isFromSetup,
<span class="linenr">1632: </span>        isUsedInTemplate
<span class="linenr">1633: </span>      }
<span class="linenr">1634: </span>    }
<span class="linenr">1635: </span>  
<span class="linenr">1636: </span>    <span class=
"org-keyword">function</span> <span class=
"org-function-name">processDefineProps</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">declId</span>) {
<span class="linenr">1637: </span>      <span class=
"org-keyword">if</span> (!isCallOf(node, DEFINE_PROPS)) {
<span class="linenr">1638: </span>        <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">1639: </span>      }
<span class="linenr">1640: </span>  
<span class="linenr">1641: </span>      <span class=
"org-keyword">if</span> (hasDefinePropsCall) {
<span class="linenr">1642: </span>        error(<span class=
"org-string">`duplicate ${DEFINE_PROPS}() call`</span>, node)
<span class="linenr">1643: </span>      }
<span class=
"linenr">1644: </span>      hasDefinePropsCall = <span class=
"org-constant">true</span>
<span class="linenr">1645: </span>  
<span class=
"linenr">1646: </span>      propsRuntimeDecl = node.<span class=
"org-constant">arguments</span>[<span class=
"org-highlight-numbers-number">0</span>]
<span class="linenr">1647: </span>  
<span class="linenr">1648: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">call has type parameters - infer runtime types from it</span>
<span class="linenr">1649: </span>      <span class=
"org-keyword">if</span> (node.typeParameters) {
<span class="linenr">1650: </span>        <span class=
"org-keyword">if</span> (propsRuntimeDecl) {
<span class="linenr">1651: </span>          error(
<span class="linenr">1652: </span>            <span class=
"org-string">`${DEFINE_PROPS}() cannot accept both type and non-type arguments `</span> +
<span class="linenr">1653: </span>              <span class=
"org-string">`at the same time. Use one or the other.`</span>,
<span class="linenr">1654: </span>            node
<span class="linenr">1655: </span>          )
<span class="linenr">1656: </span>        }
<span class="linenr">1657: </span>  
<span class=
"linenr">1658: </span>        propsTypeDeclRaw = node.typeParameters.params[<span class="org-highlight-numbers-number">0</span>]
<span class=
"linenr">1659: </span>        propsTypeDecl = resolveQualifiedType(
<span class="linenr">1660: </span>          propsTypeDeclRaw,
<span class=
"linenr">1661: </span>          node =&gt; node.type === <span class="org-string">'TSTypeLiteral'</span>
<span class="linenr">1662: </span>        )
<span class="linenr">1663: </span>  
<span class="linenr">1664: </span>        <span class=
"org-keyword">if</span> (!propsTypeDecl) {
<span class="linenr">1665: </span>          error(
<span class="linenr">1666: </span>            <span class=
"org-string">`type argument passed to ${DEFINE_PROPS}() must be a literal type, `</span> +
<span class="linenr">1667: </span>              <span class=
"org-string">`or a reference to an interface or literal type.`</span>,
<span class="linenr">1668: </span>            propsTypeDeclRaw
<span class="linenr">1669: </span>          )
<span class="linenr">1670: </span>        }
<span class="linenr">1671: </span>      }
<span class="linenr">1672: </span>  
<span class="linenr">1673: </span>      <span class=
"org-keyword">if</span> (declId) {
<span class="linenr">1674: </span>        <span class=
"org-keyword">if</span> (enablePropsTransform &amp;& declId.type === <span class="org-string">'ObjectPattern'</span>) {
<span class=
"linenr">1675: </span>          propsDestructureDecl = declId
<span class="linenr">1676: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">props destructure - handle compilation sugar</span>
<span class="linenr">1677: </span>          <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">prop</span> <span class=
"org-keyword">of</span> declId.properties) {
<span class="linenr">1678: </span>            <span class=
"org-keyword">if</span> (prop.type === <span class=
"org-string">'ObjectProperty'</span>) {
<span class="linenr">1679: </span>              <span class=
"org-keyword">if</span> (prop.computed) {
<span class="linenr">1680: </span>                error(
<span class="linenr">1681: </span>                  <span class=
"org-string">`${DEFINE_PROPS}() destructure cannot use computed key.`</span>,
<span class="linenr">1682: </span>                  prop.key
<span class="linenr">1683: </span>                )
<span class="linenr">1684: </span>              }
<span class="linenr">1685: </span>              <span class=
"org-keyword">const</span> <span class=
"org-variable-name">propKey</span> = prop.key.name
<span class="linenr">1686: </span>              <span class=
"org-keyword">if</span> (prop.value.type === <span class=
"org-string">'AssignmentPattern'</span>) {
<span class="linenr">1687: </span>                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">default value { foo = 123 }</span>
<span class="linenr">1688: </span>                <span class=
"org-keyword">const</span> { left, right } = prop.value
<span class="linenr">1689: </span>                <span class=
"org-keyword">if</span> (left.type !== <span class=
"org-string">'Identifier'</span>) {
<span class="linenr">1690: </span>                  error(
<span class="linenr">1691: </span>                    <span class=
"org-string">`${DEFINE_PROPS}() destructure does not support nested patterns.`</span>,
<span class="linenr">1692: </span>                    left
<span class="linenr">1693: </span>                  )
<span class="linenr">1694: </span>                }
<span class="linenr">1695: </span>                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">store default value</span>
<span class=
"linenr">1696: </span>                propsDestructuredBindings[propKey] = {
<span class=
"linenr">1697: </span>                  local: left.name,
<span class="linenr">1698: </span>                  <span class=
"org-keyword">default</span>: right
<span class="linenr">1699: </span>                }
<span class="linenr">1700: </span>              } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (prop.value.type === <span class=
"org-string">'Identifier'</span>) {
<span class="linenr">1701: </span>                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">simple destructure</span>
<span class=
"linenr">1702: </span>                propsDestructuredBindings[propKey] = {
<span class=
"linenr">1703: </span>                  local: prop.value.name
<span class="linenr">1704: </span>                }
<span class="linenr">1705: </span>              } <span class=
"org-keyword">else</span> {
<span class="linenr">1706: </span>                error(
<span class="linenr">1707: </span>                  <span class=
"org-string">`${DEFINE_PROPS}() destructure does not support nested patterns.`</span>,
<span class="linenr">1708: </span>                  prop.value
<span class="linenr">1709: </span>                )
<span class="linenr">1710: </span>              }
<span class="linenr">1711: </span>            } <span class=
"org-keyword">else</span> {
<span class="linenr">1712: </span>              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">rest spread</span>
<span class=
"linenr">1713: </span>              propsDestructureRestId = prop.argument.name
<span class="linenr">1714: </span>            }
<span class="linenr">1715: </span>          }
<span class="linenr">1716: </span>        } <span class=
"org-keyword">else</span> {
<span class=
"linenr">1717: </span>          propsIdentifier = scriptSetup.content.slice(declId.start, declId.end)
<span class="linenr">1718: </span>        }
<span class="linenr">1719: </span>      }
<span class="linenr">1720: </span>  
<span class="linenr">1721: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr">1722: </span>    }
<span class="linenr">1723: </span>  
<span class="linenr">1724: </span>  
<span class="linenr">1725: </span>    <span class=
"org-keyword">function</span> <span class=
"org-function-name">processWithDefaults</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">declId</span>) {
<span class="linenr">1726: </span>      <span class=
"org-keyword">if</span> (!isCallOf(node, WITH_DEFAULTS)) {
<span class="linenr">1727: </span>        <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">1728: </span>      }
<span class="linenr">1729: </span>      <span class=
"org-keyword">if</span> (processDefineProps(node.<span class=
"org-constant">arguments</span>[<span class=
"org-highlight-numbers-number">0</span>], declId)) {
<span class="linenr">1730: </span>        <span class=
"org-keyword">if</span> (propsRuntimeDecl) {
<span class="linenr">1731: </span>          error(
<span class="linenr">1732: </span>            <span class=
"org-string">`${WITH_DEFAULTS} can only be used with type-based `</span> +
<span class="linenr">1733: </span>              <span class=
"org-string">`${DEFINE_PROPS} declaration.`</span>,
<span class="linenr">1734: </span>            node
<span class="linenr">1735: </span>          )
<span class="linenr">1736: </span>        }
<span class="linenr">1737: </span>        <span class=
"org-keyword">if</span> (propsDestructureDecl) {
<span class="linenr">1738: </span>          error(
<span class="linenr">1739: </span>            <span class=
"org-string">`${WITH_DEFAULTS}() is unnecessary when using destructure with ${DEFINE_PROPS}().\n`</span> +
<span class="linenr">1740: </span>              <span class=
"org-string">`Prefer using destructure default values, e.g. const { foo = 1 } = defineProps(...).`</span>,
<span class="linenr">1741: </span>            node.callee
<span class="linenr">1742: </span>          )
<span class="linenr">1743: </span>        }
<span class=
"linenr">1744: </span>        propsRuntimeDefaults = node.<span class="org-constant">arguments</span>[<span class="org-highlight-numbers-number">1</span>]
<span class="linenr">1745: </span>        <span class=
"org-keyword">if</span> (
<span class=
"linenr">1746: </span>          !propsRuntimeDefaults ||
<span class=
"linenr">1747: </span>          propsRuntimeDefaults.type !== <span class="org-string">'ObjectExpression'</span>
<span class="linenr">1748: </span>        ) {
<span class="linenr">1749: </span>          error(
<span class="linenr">1750: </span>            <span class=
"org-string">`The 2nd argument of ${WITH_DEFAULTS} must be an object literal.`</span>,
<span class=
"linenr">1751: </span>            propsRuntimeDefaults || node
<span class="linenr">1752: </span>          )
<span class="linenr">1753: </span>        }
<span class="linenr">1754: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr">1755: </span>        error(
<span class="linenr">1756: </span>          <span class=
"org-string">`${WITH_DEFAULTS}' first argument must be a ${DEFINE_PROPS} call.`</span>,
<span class="linenr">1757: </span>          node.<span class=
"org-constant">arguments</span>[<span class=
"org-highlight-numbers-number">0</span>] || node
<span class="linenr">1758: </span>        )
<span class="linenr">1759: </span>      }
<span class="linenr">1760: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr">1761: </span>    }
<span class="linenr">1762: </span>  
<span class="linenr">1763: </span>  
<span class="linenr">1764: </span>  
<span class="linenr">1765: </span>    <span class=
"org-keyword">function</span> <span class=
"org-function-name">processDefineEmits</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">declId</span>) {
<span class="linenr">1766: </span>      <span class=
"org-keyword">if</span> (!isCallOf(node, DEFINE_EMITS)) {
<span class="linenr">1767: </span>        <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">1768: </span>      }
<span class="linenr">1769: </span>      <span class=
"org-keyword">if</span> (hasDefineEmitCall) {
<span class="linenr">1770: </span>        error(<span class=
"org-string">`duplicate ${DEFINE_EMITS}() call`</span>, node)
<span class="linenr">1771: </span>      }
<span class=
"linenr">1772: </span>      hasDefineEmitCall = <span class=
"org-constant">true</span>
<span class=
"linenr">1773: </span>      emitsRuntimeDecl = node.<span class=
"org-constant">arguments</span>[<span class=
"org-highlight-numbers-number">0</span>]
<span class="linenr">1774: </span>      <span class=
"org-keyword">if</span> (node.typeParameters) {
<span class="linenr">1775: </span>        <span class=
"org-keyword">if</span> (emitsRuntimeDecl) {
<span class="linenr">1776: </span>          error(
<span class="linenr">1777: </span>            <span class=
"org-string">`${DEFINE_EMITS}() cannot accept both type and non-type arguments `</span> +
<span class="linenr">1778: </span>              <span class=
"org-string">`at the same time. Use one or the other.`</span>,
<span class="linenr">1779: </span>            node
<span class="linenr">1780: </span>          )
<span class="linenr">1781: </span>        }
<span class="linenr">1782: </span>  
<span class=
"linenr">1783: </span>        emitsTypeDeclRaw = node.typeParameters.params[<span class="org-highlight-numbers-number">0</span>]
<span class=
"linenr">1784: </span>        emitsTypeDecl = resolveQualifiedType(
<span class="linenr">1785: </span>          emitsTypeDeclRaw,
<span class=
"linenr">1786: </span>          node =&gt; node.type === <span class="org-string">'TSFunctionType'</span> || node.type === <span class="org-string">'TSTypeLiteral'</span>
<span class="linenr">1787: </span>        )
<span class="linenr">1788: </span>  
<span class="linenr">1789: </span>        <span class=
"org-keyword">if</span> (!emitsTypeDecl) {
<span class="linenr">1790: </span>          error(
<span class="linenr">1791: </span>            <span class=
"org-string">`type argument passed to ${DEFINE_EMITS}() must be a function type, `</span> +
<span class="linenr">1792: </span>              <span class=
"org-string">`a literal type with call signatures, or a reference to the above types.`</span>,
<span class="linenr">1793: </span>            emitsTypeDeclRaw
<span class="linenr">1794: </span>          )
<span class="linenr">1795: </span>        }
<span class="linenr">1796: </span>      }
<span class="linenr">1797: </span>  
<span class="linenr">1798: </span>      <span class=
"org-keyword">if</span> (declId) {
<span class=
"linenr">1799: </span>        emitIdentifier = scriptSetup.content.slice(declId.start, declId.end)
<span class="linenr">1800: </span>      }
<span class="linenr">1801: </span>  
<span class="linenr">1802: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr">1803: </span>    }
<span class="linenr">1804: </span>  
<span class="linenr">1805: </span>  
<span class="linenr">1806: </span>  
<span class="linenr">1807: </span>    <span class=
"org-keyword">function</span> <span class=
"org-function-name">resolveQualifiedType</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">qualifier</span>) {
<span class="linenr">1808: </span>      <span class=
"org-keyword">if</span> (qualifier(node)) {
<span class="linenr">1809: </span>        <span class=
"org-keyword">return</span> node
<span class="linenr">1810: </span>      }
<span class="linenr">1811: </span>      <span class=
"org-keyword">if</span> (
<span class=
"linenr">1812: </span>        node.type === <span class="org-string">'TSTypeReference'</span> &amp;&
<span class=
"linenr">1813: </span>        node.typeName.type === <span class=
"org-string">'Identifier'</span>
<span class="linenr">1814: </span>      ) {
<span class="linenr">1815: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">refName</span> = node.typeName.name
<span class="linenr">1816: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isQualifiedType</span> = (node) =&gt; {
<span class="linenr">1817: </span>          <span class=
"org-keyword">if</span> (
<span class=
"linenr">1818: </span>            node.type === <span class=
"org-string">'TSInterfaceDeclaration'</span> &amp;&
<span class=
"linenr">1819: </span>            node.id.name === refName
<span class="linenr">1820: </span>          ) {
<span class="linenr">1821: </span>            <span class=
"org-keyword">return</span> node.body
<span class="linenr">1822: </span>          } <span class=
"org-keyword">else</span> <span class="org-keyword">if</span> (
<span class=
"linenr">1823: </span>            node.type === <span class=
"org-string">'TSTypeAliasDeclaration'</span> &amp;&
<span class=
"linenr">1824: </span>            node.id.name === refName &amp;&
<span class=
"linenr">1825: </span>            qualifier(node.typeAnnotation)
<span class="linenr">1826: </span>          ) {
<span class="linenr">1827: </span>            <span class=
"org-keyword">return</span> node.typeAnnotation
<span class="linenr">1828: </span>          } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'ExportNamedDeclaration'</span> &amp;& node.declaration) {
<span class="linenr">1829: </span>            <span class=
"org-keyword">return</span> isQualifiedType(node.declaration)
<span class="linenr">1830: </span>          }
<span class="linenr">1831: </span>        }
<span class="linenr">1832: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">body</span> = scriptAst
<span class=
"linenr">1833: </span>          ? [...scriptSetupAst.body, ...scriptAst.body]
<span class="linenr">1834: </span>          : scriptSetupAst.body
<span class="linenr">1835: </span>        <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">node</span> <span class=
"org-keyword">of</span> body) {
<span class="linenr">1836: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">qualified</span> = isQualifiedType(node)
<span class="linenr">1837: </span>          <span class=
"org-keyword">if</span> (qualified) {
<span class="linenr">1838: </span>            <span class=
"org-keyword">return</span> qualified
<span class="linenr">1839: </span>          }
<span class="linenr">1840: </span>        }
<span class="linenr">1841: </span>      }
<span class="linenr">1842: </span>    }
<span class="linenr">1843: </span>  
<span class="linenr">1844: </span>  
<span class="linenr">1845: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">processDefineExpose</span>(<span class=
"org-variable-name">node</span>) {
<span class="linenr">1846: </span>      <span class=
"org-keyword">if</span> (isCallOf(node, DEFINE_EXPOSE)) {
<span class="linenr">1847: </span>        <span class=
"org-keyword">if</span> (hasDefineExposeCall) {
<span class="linenr">1848: </span>          error(<span class=
"org-string">`duplicate ${DEFINE_EXPOSE}() call`</span>, node)
<span class="linenr">1849: </span>        }
<span class=
"linenr">1850: </span>        hasDefineExposeCall = <span class=
"org-constant">true</span>
<span class="linenr">1851: </span>        <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr">1852: </span>      }
<span class="linenr">1853: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">1854: </span>    }
<span class="linenr">1855: </span>  
<span class="linenr">1856: </span>  <span class=
"org-doc">/**</span>
<span class="linenr">1857: </span><span class=
"org-doc">     * await foo()</span>
<span class="linenr">1858: </span><span class=
"org-doc">     * --&gt;</span>
<span class="linenr">1859: </span><span class=
"org-doc">     * ;(</span>
<span class="linenr">1860: </span><span class=
"org-doc">     *   ([__temp,__restore] = withAsyncContext(() =&gt; foo())),</span>
<span class="linenr">1861: </span><span class=
"org-doc">     *   await __temp,</span>
<span class="linenr">1862: </span><span class=
"org-doc">     *   __restore()</span>
<span class="linenr">1863: </span><span class=
"org-doc">     * )</span>
<span class="linenr">1864: </span><span class=
"org-doc">     *</span>
<span class="linenr">1865: </span><span class=
"org-doc">     * const a = await foo()</span>
<span class="linenr">1866: </span><span class=
"org-doc">     * --&gt;</span>
<span class="linenr">1867: </span><span class=
"org-doc">     * const a = (</span>
<span class="linenr">1868: </span><span class=
"org-doc">     *   ([__temp, __restore] = withAsyncContext(() =&gt; foo())),</span>
<span class="linenr">1869: </span><span class=
"org-doc">     *   __temp = await __temp,</span>
<span class="linenr">1870: </span><span class=
"org-doc">     *   __restore(),</span>
<span class="linenr">1871: </span><span class=
"org-doc">     *   __temp</span>
<span class="linenr">1872: </span><span class=
"org-doc">     * )</span>
<span class="linenr">1873: </span><span class=
"org-doc">     */</span>
<span class="linenr">1874: </span>    <span class=
"org-keyword">function</span> <span class=
"org-function-name">processAwait</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">needSemi</span>, <span class=
"org-variable-name">isStatement</span>) {
<span class="linenr">1875: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">argumentStart</span> =
<span class=
"linenr">1876: </span>        node.argument.extra &amp;& node.argument.extra.parenthesized
<span class=
"linenr">1877: </span>          ? node.argument.extra.parenStart
<span class="linenr">1878: </span>          : node.argument.start
<span class="linenr">1879: </span>  
<span class="linenr">1880: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">argumentStr</span> = source.slice(
<span class=
"linenr">1881: </span>        argumentStart + startOffset,
<span class=
"linenr">1882: </span>        node.argument.end + startOffset
<span class="linenr">1883: </span>      )
<span class="linenr">1884: </span>  
<span class="linenr">1885: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">containsNestedAwait</span> = <span class=
"org-string">/\bawait\b/</span>.test(argumentStr)
<span class="linenr">1886: </span>  
<span class="linenr">1887: </span>      s.overwrite(
<span class="linenr">1888: </span>        node.start + startOffset,
<span class=
"linenr">1889: </span>        argumentStart + startOffset,
<span class="linenr">1890: </span>        <span class=
"org-string">`${needSemi ? `</span>;<span class=
"org-string">` : ``}(\n  ([__temp,__restore] = ${helper(</span>
<span class="linenr">1891: </span><span class=
"org-string">          `</span>withAsyncContext<span class=
"org-string">`</span>
<span class="linenr">1892: </span><span class=
"org-string">        )}(${containsNestedAwait ? `</span><span class="org-keyword">async</span> <span class="org-string">` : ``}() =&gt; `</span>
<span class="linenr">1893: </span>      )
<span class="linenr">1894: </span>      s.appendLeft(
<span class="linenr">1895: </span>        node.end + startOffset,
<span class="linenr">1896: </span>        <span class=
"org-string">`)),\n  ${isStatement ? `` : `</span>__temp = <span class="org-string">`}await __temp,\n  __restore()${</span>
<span class="linenr">1897: </span><span class=
"org-string">          isStatement ? `` : `</span>,\n  __temp<span class="org-string">`</span>
<span class="linenr">1898: </span><span class=
"org-string">        }\n)`</span>
<span class="linenr">1899: </span>      )
<span class="linenr">1900: </span>    }
<span class="linenr">1901: </span>  
<span class="linenr">1902: </span>  
<span class="linenr">1903: </span>  <span class=
"org-doc">/**</span>
<span class="linenr">1904: </span><span class=
"org-doc">     * check defaults. If the default object is an object literal with only</span>
<span class="linenr">1905: </span><span class=
"org-doc">     * static properties, we can directly generate more optimized default</span>
<span class="linenr">1906: </span><span class=
"org-doc">     * declarations. Otherwise we will have to fallback to runtime merging.</span>
<span class="linenr">1907: </span><span class=
"org-doc">     */</span>
<span class="linenr">1908: </span>    <span class=
"org-keyword">function</span> <span class=
"org-function-name">hasStaticWithDefaults</span>() {
<span class="linenr">1909: </span>      <span class=
"org-keyword">return</span> (
<span class=
"linenr">1910: </span>        propsRuntimeDefaults &amp;&
<span class=
"linenr">1911: </span>        propsRuntimeDefaults.type === <span class="org-string">'ObjectExpression'</span> &amp;&
<span class=
"linenr">1912: </span>        propsRuntimeDefaults.properties.every(
<span class="linenr">1913: </span>          node =&gt;
<span class=
"linenr">1914: </span>            (node.type === <span class=
"org-string">'ObjectProperty'</span> &amp;& !node.computed) ||
<span class=
"linenr">1915: </span>            node.type === <span class=
"org-string">'ObjectMethod'</span>
<span class="linenr">1916: </span>        )
<span class="linenr">1917: </span>      )
<span class="linenr">1918: </span>    }
<span class="linenr">1919: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">genRuntimeProps</span>(<span class=
"org-variable-name">props</span>) {
<span class="linenr">1920: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">keys</span> = Object.keys(props)
<span class="linenr">1921: </span>      <span class=
"org-keyword">if</span> (!keys.length) {
<span class="linenr">1922: </span>        <span class=
"org-keyword">return</span> <span class="org-string">``</span>
<span class="linenr">1923: </span>      }
<span class="linenr">1924: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">hasStaticDefaults</span> = hasStaticWithDefaults()
<span class="linenr">1925: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">scriptSetupSource</span> = scriptSetup.content
<span class="linenr">1926: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">propsDecls</span> = <span class=
"org-string">`{</span>
<span class="linenr">1927: </span><span class=
"org-string">      ${keys</span>
<span class="linenr">1928: </span><span class=
"org-string">        .map(key =&gt; {</span>
<span class="linenr">1929: </span><span class=
"org-string">          let defaultString</span>
<span class="linenr">1930: </span><span class=
"org-string">          const destructured = genDestructuredDefaultValue(key)</span>
<span class="linenr">1931: </span><span class=
"org-string">          if (destructured) {</span>
<span class="linenr">1932: </span><span class=
"org-string">            defaultString = `</span><span class=
"org-keyword">default</span>: ${destructured}<span class=
"org-string">`</span>
<span class="linenr">1933: </span><span class=
"org-string">          } else if (hasStaticDefaults) {</span>
<span class="linenr">1934: </span><span class=
"org-string">            const prop = propsRuntimeDefaults.properties.find(</span>
<span class="linenr">1935: </span><span class=
"org-string">              (node) =&gt; node.key.name === key</span>
<span class="linenr">1936: </span><span class=
"org-string">            )</span>
<span class="linenr">1937: </span><span class=
"org-string">            if (prop) {</span>
<span class="linenr">1938: </span><span class=
"org-string">              if (prop.type === 'ObjectProperty') {</span>
<span class="linenr">1939: </span><span class=
"org-string">                // prop has corresponding static default value</span>
<span class="linenr">1940: </span><span class=
"org-string">                defaultString = `</span><span class=
"org-keyword">default</span>: ${scriptSetupSource.slice(
<span class=
"linenr">1941: </span>                  prop.value.start,
<span class="linenr">1942: </span>                  prop.value.end
<span class="linenr">1943: </span>                )}<span class=
"org-string">`</span>
<span class="linenr">1944: </span><span class=
"org-string">              } else {</span>
<span class="linenr">1945: </span><span class=
"org-string">                defaultString = `</span><span class=
"org-keyword">default</span>() ${scriptSetupSource.slice(
<span class=
"linenr">1946: </span>                  prop.body.start,
<span class="linenr">1947: </span>                  prop.body.end
<span class="linenr">1948: </span>                )}<span class=
"org-string">`</span>
<span class="linenr">1949: </span><span class=
"org-string">              }</span>
<span class="linenr">1950: </span><span class=
"org-string">            }</span>
<span class="linenr">1951: </span><span class=
"org-string">          }</span>
<span class="linenr">1952: </span><span class=
"org-string">  </span>
<span class="linenr">1953: </span><span class=
"org-string">          const { type, required } = props[key]</span>
<span class="linenr">1954: </span><span class=
"org-string">          if (!isProd) {</span>
<span class="linenr">1955: </span><span class=
"org-string">            return `</span>${key}: { type: ${toRuntimeTypeString(
<span class="linenr">1956: </span>              type
<span class=
"linenr">1957: </span>            )}, required: ${required}${
<span class=
"linenr">1958: </span>              defaultString ? <span class=
"org-string">`, ${defaultString}`</span> : <span class=
"org-string">``</span>
<span class="linenr">1959: </span>            } }<span class=
"org-string">`</span>
<span class="linenr">1960: </span><span class=
"org-string">          } else if (</span>
<span class="linenr">1961: </span><span class=
"org-string">            type.some(</span>
<span class="linenr">1962: </span><span class=
"org-string">              el =&gt; el === 'Boolean' || (defaultString &amp;& el === 'Function')</span>
<span class="linenr">1963: </span><span class=
"org-string">            )</span>
<span class="linenr">1964: </span><span class=
"org-string">          ) {</span>
<span class="linenr">1965: </span><span class=
"org-string">            // #4783 production: if boolean or defaultString and function exists, should keep the type.</span>
<span class="linenr">1966: </span><span class=
"org-string">            return `</span>${key}: { type: ${toRuntimeTypeString(type)}${
<span class=
"linenr">1967: </span>              defaultString ? <span class=
"org-string">`, ${defaultString}`</span> : <span class=
"org-string">``</span>
<span class="linenr">1968: </span>            } }<span class=
"org-string">`</span>
<span class="linenr">1969: </span><span class=
"org-string">          } else {</span>
<span class="linenr">1970: </span><span class=
"org-string">            // production: checks are useless</span>
<span class="linenr">1971: </span><span class=
"org-string">            return `</span>${key}: ${defaultString ? <span class="org-string">`{ ${defaultString} }`</span> : <span class="org-string">'null'</span>}<span class="org-string">`</span>
<span class="linenr">1972: </span><span class=
"org-string">          }</span>
<span class="linenr">1973: </span><span class=
"org-string">        })</span>
<span class="linenr">1974: </span><span class=
"org-string">        .join(',\n    ')}\n  }`</span>
<span class="linenr">1975: </span>  
<span class="linenr">1976: </span>      <span class=
"org-keyword">if</span> (propsRuntimeDefaults &amp;& !hasStaticDefaults) {
<span class="linenr">1977: </span>        propsDecls = <span class=
"org-string">`${helper('mergeDefaults')}(${propsDecls}, ${source.slice(</span>
<span class="linenr">1978: </span><span class=
"org-string">          propsRuntimeDefaults.start + startOffset,</span>
<span class="linenr">1979: </span><span class=
"org-string">          propsRuntimeDefaults.end + startOffset</span>
<span class="linenr">1980: </span><span class=
"org-string">        )})`</span>
<span class="linenr">1981: </span>      }
<span class="linenr">1982: </span>  
<span class="linenr">1983: </span>      <span class=
"org-keyword">return</span> <span class=
"org-string">`\n  props: ${propsDecls},`</span>
<span class="linenr">1984: </span>    }
<span class="linenr">1985: </span>  
<span class="linenr">1986: </span>  
<span class="linenr">1987: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">genDestructuredDefaultValue</span>(<span class=
"org-variable-name">key</span>) {
<span class="linenr">1988: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">destructured</span> = propsDestructuredBindings[key]
<span class="linenr">1989: </span>      <span class=
"org-keyword">if</span> (destructured &amp;& destructured.<span class="org-keyword">default</span>) {
<span class="linenr">1990: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">value</span> = scriptSetup.content.slice(
<span class=
"linenr">1991: </span>          destructured.<span class=
"org-keyword">default</span>.start,
<span class=
"linenr">1992: </span>          destructured.<span class=
"org-keyword">default</span>.end
<span class="linenr">1993: </span>        )
<span class="linenr">1994: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isLiteral</span> = destructured.<span class=
"org-keyword">default</span>.type.endsWith(<span class=
"org-string">'Literal'</span>)
<span class="linenr">1995: </span>        <span class=
"org-keyword">return</span> isLiteral ? value : <span class=
"org-string">`() =&gt; ${value}`</span>
<span class="linenr">1996: </span>      }
<span class="linenr">1997: </span>    }
<span class="linenr">1998: </span>  
<span class="linenr">1999: </span>    <span class=
"org-keyword">function</span> <span class=
"org-function-name">genSetupPropsType</span>(<span class=
"org-variable-name">node</span>) {
<span class="linenr">2000: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">scriptSetupSource</span> = scriptSetup.content
<span class="linenr">2001: </span>      <span class=
"org-keyword">if</span> (hasStaticWithDefaults()) {
<span class="linenr">2002: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">if withDefaults() is used, we need to remove the optional flags</span>
<span class="linenr">2003: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">on props that have default values</span>
<span class="linenr">2004: </span>        <span class=
"org-keyword">let</span> <span class=
"org-variable-name">res</span> = <span class=
"org-string">`{ `</span>
<span class="linenr">2005: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">members</span> = node.type === <span class=
"org-string">'TSTypeLiteral'</span> ? node.members : node.body
<span class="linenr">2006: </span>        <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">m</span> <span class=
"org-keyword">of</span> members) {
<span class="linenr">2007: </span>          <span class=
"org-keyword">if</span> (
<span class=
"linenr">2008: </span>            (m.type === <span class=
"org-string">'TSPropertySignature'</span> ||
<span class=
"linenr">2009: </span>              m.type === <span class=
"org-string">'TSMethodSignature'</span>) &amp;&
<span class=
"linenr">2010: </span>            m.typeAnnotation &amp;&
<span class=
"linenr">2011: </span>            m.key.type === <span class=
"org-string">'Identifier'</span>
<span class="linenr">2012: </span>          ) {
<span class="linenr">2013: </span>            <span class=
"org-keyword">if</span> (
<span class=
"linenr">2014: </span>              propsRuntimeDefaults.properties.some(
<span class=
"linenr">2015: </span>                (p) =&gt; p.key.name === m.key.name
<span class="linenr">2016: </span>              )
<span class="linenr">2017: </span>            ) {
<span class="linenr">2018: </span>              res +=
<span class="linenr">2019: </span>                m.key.name +
<span class=
"linenr">2020: </span>                (m.type === <span class=
"org-string">'TSMethodSignature'</span> ? <span class=
"org-string">'()'</span> : <span class="org-string">''</span>) +
<span class=
"linenr">2021: </span>                scriptSetupSource.slice(
<span class=
"linenr">2022: </span>                  m.typeAnnotation.start,
<span class=
"linenr">2023: </span>                  m.typeAnnotation.end
<span class="linenr">2024: </span>                ) +
<span class="linenr">2025: </span>                <span class=
"org-string">', '</span>
<span class="linenr">2026: </span>            } <span class=
"org-keyword">else</span> {
<span class="linenr">2027: </span>              res +=
<span class=
"linenr">2028: </span>                scriptSetupSource.slice(m.start, m.typeAnnotation.end) + <span class="org-string">`, `</span>
<span class="linenr">2029: </span>            }
<span class="linenr">2030: </span>          }
<span class="linenr">2031: </span>        }
<span class="linenr">2032: </span>        <span class=
"org-keyword">return</span> (res.length ? res.slice(<span class=
"org-highlight-numbers-number">0</span>, -<span class=
"org-highlight-numbers-number">2</span>) : res) + <span class=
"org-string">` }`</span>
<span class="linenr">2033: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr">2034: </span>        <span class=
"org-keyword">return</span> scriptSetupSource.slice(node.start, node.end)
<span class="linenr">2035: </span>      }
<span class="linenr">2036: </span>    }
<span class="linenr">2037: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">processNormalScript</span>() {
<span class="linenr">2038: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">scriptAst</span>
<span class="linenr">2039: </span>    <span class=
"org-keyword">if</span> (script) {
<span class="linenr">2040: </span>      scriptAst = parse(
<span class="linenr">2041: </span>        script.content,
<span class="linenr">2042: </span>        {
<span class="linenr">2043: </span>          plugins,
<span class=
"linenr">2044: </span>          sourceType: <span class="org-string">'module'</span>
<span class="linenr">2045: </span>        },
<span class="linenr">2046: </span>        scriptStartOffset
<span class="linenr">2047: </span>      )
<span class="linenr">2048: </span>  
<span class="linenr">2049: </span>      <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">node</span> <span class=
"org-keyword">of</span> scriptAst.body) {
<span class="linenr">2050: </span>        <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'ImportDeclaration'</span>) {
<span class="linenr">2051: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">record imports for dedupe</span>
<span class="linenr">2052: </span>          <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">specifier</span> <span class=
"org-keyword">of</span> node.specifiers) {
<span class="linenr">2053: </span>            <span class=
"org-keyword">const</span> <span class=
"org-variable-name">imported</span> =
<span class=
"linenr">2054: </span>              specifier.type === <span class=
"org-string">'ImportSpecifier'</span> &amp;&
<span class=
"linenr">2055: </span>              specifier.imported.type === <span class="org-string">'Identifier'</span> &amp;&
<span class=
"linenr">2056: </span>              specifier.imported.name
<span class="linenr">2057: </span>            registerUserImport(
<span class="linenr">2058: </span>              node.source.value,
<span class=
"linenr">2059: </span>              specifier.local.name,
<span class="linenr">2060: </span>              imported,
<span class=
"linenr">2061: </span>              node.importKind === <span class="org-string">'type'</span> ||
<span class=
"linenr">2062: </span>                (specifier.type === <span class="org-string">'ImportSpecifier'</span> &amp;&
<span class=
"linenr">2063: </span>                  specifier.importKind === <span class="org-string">'type'</span>),
<span class="linenr">2064: </span>              <span class=
"org-constant">false</span>
<span class="linenr">2065: </span>            )
<span class="linenr">2066: </span>          }
<span class="linenr">2067: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'ExportDefaultDeclaration'</span>) {
<span class="linenr">2068: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">export default</span>
<span class="linenr">2069: </span>          defaultExport = node
<span class="linenr">2070: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">export default { ... } --&gt; const __default__ = { ... }</span>
<span class="linenr">2071: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">start</span> = node.start + scriptStartOffset
<span class="linenr">2072: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">end</span> = node.declaration.start + scriptStartOffset
<span class=
"linenr">2073: </span>          s.overwrite(start, end, <span class="org-string">`const ${DEFAULT_VAR} = `</span>)
<span class="linenr">2074: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'ExportNamedDeclaration'</span>) {
<span class="linenr">2075: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">defaultSpecifier</span> = node.specifiers.find(
<span class=
"linenr">2076: </span>            s =&gt; s.exported.type === <span class="org-string">'Identifier'</span> &amp;& s.exported.name === <span class="org-string">'default'</span>
<span class="linenr">2077: </span>          )
<span class="linenr">2078: </span>          <span class=
"org-keyword">if</span> (defaultSpecifier) {
<span class="linenr">2079: </span>            defaultExport = node
<span class="linenr">2080: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">1. remove specifier</span>
<span class="linenr">2081: </span>            <span class=
"org-keyword">if</span> (node.specifiers.length &gt; <span class=
"org-highlight-numbers-number">1</span>) {
<span class="linenr">2082: </span>              s.remove(
<span class=
"linenr">2083: </span>                defaultSpecifier.start + scriptStartOffset,
<span class=
"linenr">2084: </span>                defaultSpecifier.end + scriptStartOffset
<span class="linenr">2085: </span>              )
<span class="linenr">2086: </span>            } <span class=
"org-keyword">else</span> {
<span class="linenr">2087: </span>              s.remove(
<span class=
"linenr">2088: </span>                node.start + scriptStartOffset,
<span class=
"linenr">2089: </span>                node.end + scriptStartOffset
<span class="linenr">2090: </span>              )
<span class="linenr">2091: </span>            }
<span class="linenr">2092: </span>            <span class=
"org-keyword">if</span> (node.source) {
<span class="linenr">2093: </span>              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">export { x as default } from './x'</span>
<span class="linenr">2094: </span>              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">rewrite to `import { x as __default__ } from './x'` and</span>
<span class="linenr">2095: </span>              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">add to top</span>
<span class="linenr">2096: </span>              s.prepend(
<span class="linenr">2097: </span>                <span class=
"org-string">`import { ${defaultSpecifier.local.name} as ${DEFAULT_VAR} } from '${node.source.value}'\n`</span>
<span class="linenr">2098: </span>              )
<span class="linenr">2099: </span>            } <span class=
"org-keyword">else</span> {
<span class="linenr">2100: </span>              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">export { x as default }</span>
<span class="linenr">2101: </span>              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">rewrite to `const __default__ = x` and move to end</span>
<span class="linenr">2102: </span>              s.appendLeft(
<span class="linenr">2103: </span>                scriptEndOffset,
<span class="linenr">2104: </span>                <span class=
"org-string">`\nconst ${DEFAULT_VAR} = ${defaultSpecifier.local.name}\n`</span>
<span class="linenr">2105: </span>              )
<span class="linenr">2106: </span>            }
<span class="linenr">2107: </span>          }
<span class="linenr">2108: </span>          <span class=
"org-keyword">if</span> (node.declaration) {
<span class=
"linenr">2109: </span>            walkDeclaration(node.declaration, scriptBindings, userImportAlias)
<span class="linenr">2110: </span>          }
<span class="linenr">2111: </span>        } <span class=
"org-keyword">else</span> <span class="org-keyword">if</span> (
<span class=
"linenr">2112: </span>          (node.type === <span class=
"org-string">'VariableDeclaration'</span> ||
<span class=
"linenr">2113: </span>            node.type === <span class=
"org-string">'FunctionDeclaration'</span> ||
<span class=
"linenr">2114: </span>            node.type === <span class=
"org-string">'ClassDeclaration'</span> ||
<span class=
"linenr">2115: </span>            node.type === <span class=
"org-string">'TSEnumDeclaration'</span>) &amp;&
<span class="linenr">2116: </span>          !node.declare
<span class="linenr">2117: </span>        ) {
<span class=
"linenr">2118: </span>          walkDeclaration(node, scriptBindings, userImportAlias)
<span class="linenr">2119: </span>        }
<span class="linenr">2120: </span>      }
<span class="linenr">2121: </span>  
<span class="linenr">2122: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">apply reactivity transform</span>
<span class="linenr">2123: </span>      <span class=
"org-keyword">if</span> (enableReactivityTransform &amp;& RT.shouldTransform(script.content)) {
<span class="linenr">2124: </span>        <span class=
"org-keyword">const</span> { rootRefs, importedHelpers } = transformAST(
<span class="linenr">2125: </span>          scriptAst,
<span class="linenr">2126: </span>          s,
<span class="linenr">2127: </span>          scriptStartOffset
<span class="linenr">2128: </span>        )
<span class="linenr">2129: </span>        refBindings = rootRefs
<span class="linenr">2130: </span>        <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">h</span> <span class=
"org-keyword">of</span> importedHelpers) {
<span class="linenr">2131: </span>          helperImports.add(h)
<span class="linenr">2132: </span>        }
<span class="linenr">2133: </span>      }
<span class="linenr">2134: </span>  
<span class="linenr">2135: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">&lt;script&gt; after &lt;script setup&gt;</span>
<span class="linenr">2136: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">we need to move the block up so that `const __default__` is</span>
<span class="linenr">2137: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">declared before being used in the actual component definition</span>
<span class="linenr">2138: </span>      <span class=
"org-keyword">if</span> (scriptStartOffset &gt; startOffset) {
<span class=
"linenr">2139: </span>        s.move(scriptStartOffset, scriptEndOffset, <span class="org-highlight-numbers-number">0</span>)
<span class="linenr">2140: </span>      }
<span class="linenr">2141: </span>    }
<span class="linenr">2142: </span>  
<span class="linenr">2143: </span>    <span class=
"org-keyword">return</span> scriptAst
<span class="linenr">2144: </span>  }
<span class="linenr">2145: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">processSetupScript</span>() {
<span class="linenr">2146: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">scriptSetupAst</span> = babelParser.parse(
<span class="linenr">2147: </span>      scriptSetup.content,
<span class="linenr">2148: </span>      {
<span class="linenr">2149: </span>        plugins: [
<span class="linenr">2150: </span>          ...plugins,
<span class="linenr">2151: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">allow top level await but only inside &lt;script setup&gt;</span>
<span class="linenr">2152: </span>          <span class=
"org-string">'topLevelAwait'</span>
<span class="linenr">2153: </span>        ],
<span class="linenr">2154: </span>        sourceType: <span class=
"org-string">'module'</span>
<span class="linenr">2155: </span>      },
<span class="linenr">2156: </span>      startOffset
<span class="linenr">2157: </span>    )
<span class="linenr">2158: </span>  
<span class="linenr">2159: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">node</span> <span class=
"org-keyword">of</span> scriptSetupAst.body) {
<span class="linenr">2160: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">start</span> = node.start + startOffset
<span class="linenr">2161: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">end</span> = node.end + startOffset
<span class="linenr">2162: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">locate comment</span>
<span class="linenr">2163: </span>      <span class=
"org-keyword">if</span> (node.trailingComments &amp;& node.trailingComments.length &gt; <span class="org-highlight-numbers-number">0</span>) {
<span class="linenr">2164: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">lastCommentNode</span> =
<span class=
"linenr">2165: </span>          node.trailingComments[node.trailingComments.length - <span class="org-highlight-numbers-number">1</span>]
<span class=
"linenr">2166: </span>        end = lastCommentNode.end + startOffset
<span class="linenr">2167: </span>      }
<span class="linenr">2168: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">locate the end of whitespace between this statement and the next</span>
<span class="linenr">2169: </span>      <span class=
"org-keyword">while</span> (end &lt;= source.length) {
<span class="linenr">2170: </span>        <span class=
"org-keyword">if</span> (!<span class=
"org-string">/\s/</span>.test(source.charAt(end))) {
<span class="linenr">2171: </span>          <span class=
"org-keyword">break</span>
<span class="linenr">2172: </span>        }
<span class="linenr">2173: </span>        end++
<span class="linenr">2174: </span>      }
<span class="linenr">2175: </span>  
<span class="linenr">2176: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">(Dropped) `ref: x` bindings</span>
<span class="linenr">2177: </span>      <span class=
"org-keyword">if</span> (
<span class=
"linenr">2178: </span>        node.type === <span class="org-string">'LabeledStatement'</span> &amp;&
<span class=
"linenr">2179: </span>        node.label.name === <span class=
"org-string">'ref'</span> &amp;&
<span class=
"linenr">2180: </span>        node.body.type === <span class=
"org-string">'ExpressionStatement'</span>
<span class="linenr">2181: </span>      ) {
<span class="linenr">2182: </span>        error(
<span class="linenr">2183: </span>          <span class=
"org-string">`ref sugar using the label syntax was an experimental proposal and `</span> +
<span class="linenr">2184: </span>            <span class=
"org-string">`has been dropped based on community feedback. Please check out `</span> +
<span class="linenr">2185: </span>            <span class=
"org-string">`the new proposal at https://github.com/vuejs/rfcs/discussions/369`</span>,
<span class="linenr">2186: </span>          node
<span class="linenr">2187: </span>        )
<span class="linenr">2188: </span>      }
<span class="linenr">2189: </span>  
<span class="linenr">2190: </span>      <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'ImportDeclaration'</span>) {
<span class="linenr">2191: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">import declarations are moved to top</span>
<span class=
"linenr">2192: </span>        s.move(start, end, <span class=
"org-highlight-numbers-number">0</span>)
<span class="linenr">2193: </span>  
<span class="linenr">2194: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">dedupe imports</span>
<span class="linenr">2195: </span>        <span class=
"org-keyword">let</span> <span class=
"org-variable-name">removed</span> = <span class=
"org-highlight-numbers-number">0</span>
<span class="linenr">2196: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">removeSpecifier</span> = (i) =&gt; {
<span class="linenr">2197: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">removeLeft</span> = i &gt; removed
<span class="linenr">2198: </span>          removed++
<span class="linenr">2199: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">current</span> = node.specifiers[i]
<span class="linenr">2200: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">next</span> = node.specifiers[i + <span class=
"org-highlight-numbers-number">1</span>]
<span class="linenr">2201: </span>          s.remove(
<span class="linenr">2202: </span>            removeLeft
<span class=
"linenr">2203: </span>              ? node.specifiers[i - <span class="org-highlight-numbers-number">1</span>].end + startOffset
<span class=
"linenr">2204: </span>              : current.start + startOffset,
<span class=
"linenr">2205: </span>            next &amp;& !removeLeft
<span class=
"linenr">2206: </span>              ? next.start + startOffset
<span class=
"linenr">2207: </span>              : current.end + startOffset
<span class="linenr">2208: </span>          )
<span class="linenr">2209: </span>        }
<span class="linenr">2210: </span>  
<span class="linenr">2211: </span>        <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; node.specifiers.length; i++) {
<span class="linenr">2212: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">specifier</span> = node.specifiers[i]
<span class="linenr">2213: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">local</span> = specifier.local.name
<span class="linenr">2214: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">imported</span> =
<span class=
"linenr">2215: </span>            specifier.type === <span class=
"org-string">'ImportSpecifier'</span> &amp;&
<span class=
"linenr">2216: </span>            specifier.imported.type === <span class="org-string">'Identifier'</span> &amp;&
<span class=
"linenr">2217: </span>            specifier.imported.name
<span class="linenr">2218: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">source</span> = node.source.value
<span class="linenr">2219: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">existing</span> = userImports[local]
<span class="linenr">2220: </span>          <span class=
"org-keyword">if</span> (
<span class=
"linenr">2221: </span>            source === <span class=
"org-string">'vue'</span> &amp;&
<span class=
"linenr">2222: </span>            (imported === DEFINE_PROPS ||
<span class=
"linenr">2223: </span>              imported === DEFINE_EMITS ||
<span class=
"linenr">2224: </span>              imported === DEFINE_EXPOSE)
<span class="linenr">2225: </span>          ) {
<span class="linenr">2226: </span>            removeSpecifier(i)
<span class="linenr">2227: </span>          } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (existing) {
<span class="linenr">2228: </span>            <span class=
"org-keyword">if</span> (existing.source === source &amp;& existing.imported === imported) {
<span class="linenr">2229: </span>              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">already imported in &lt;script setup&gt;, dedupe</span>
<span class="linenr">2230: </span>              removeSpecifier(i)
<span class="linenr">2231: </span>            } <span class=
"org-keyword">else</span> {
<span class="linenr">2232: </span>              error(<span class=
"org-string">`different imports aliased to same local name.`</span>, specifier)
<span class="linenr">2233: </span>            }
<span class="linenr">2234: </span>          } <span class=
"org-keyword">else</span> {
<span class="linenr">2235: </span>            registerUserImport(
<span class="linenr">2236: </span>              source,
<span class="linenr">2237: </span>              local,
<span class="linenr">2238: </span>              imported,
<span class=
"linenr">2239: </span>              node.importKind === <span class="org-string">'type'</span> ||
<span class=
"linenr">2240: </span>                (specifier.type === <span class="org-string">'ImportSpecifier'</span> &amp;&
<span class=
"linenr">2241: </span>                  specifier.importKind === <span class="org-string">'type'</span>),
<span class="linenr">2242: </span>              <span class=
"org-constant">true</span>
<span class="linenr">2243: </span>            )
<span class="linenr">2244: </span>          }
<span class="linenr">2245: </span>        }
<span class="linenr">2246: </span>        <span class=
"org-keyword">if</span> (node.specifiers.length &amp;& removed === node.specifiers.length) {
<span class=
"linenr">2247: </span>          s.remove(node.start + startOffset, node.end + startOffset)
<span class="linenr">2248: </span>        }
<span class="linenr">2249: </span>      }
<span class="linenr">2250: </span>  
<span class="linenr">2251: </span>      <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'ExpressionStatement'</span>) {
<span class="linenr">2252: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">process `defineProps` and `defineEmit(s)` calls</span>
<span class="linenr">2253: </span>        <span class=
"org-keyword">if</span> (
<span class=
"linenr">2254: </span>          processDefineProps(node.expression) ||
<span class=
"linenr">2255: </span>          processDefineEmits(node.expression) ||
<span class=
"linenr">2256: </span>          processWithDefaults(node.expression)
<span class="linenr">2257: </span>        ) {
<span class=
"linenr">2258: </span>          s.remove(node.start + startOffset, node.end + startOffset)
<span class="linenr">2259: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (processDefineExpose(node.expression)) {
<span class="linenr">2260: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">defineExpose({}) -&gt; expose({})</span>
<span class="linenr">2261: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">callee</span> = node.expression.callee
<span class="linenr">2262: </span>          s.overwrite(
<span class=
"linenr">2263: </span>            callee.start + startOffset,
<span class=
"linenr">2264: </span>            callee.end + startOffset,
<span class="linenr">2265: </span>            <span class=
"org-string">'expose'</span>
<span class="linenr">2266: </span>          )
<span class="linenr">2267: </span>        }
<span class="linenr">2268: </span>      }
<span class="linenr">2269: </span>  
<span class="linenr">2270: </span>      <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'VariableDeclaration'</span> &amp;& !node.declare) {
<span class="linenr">2271: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">total</span> = node.declarations.length
<span class="linenr">2272: </span>        <span class=
"org-keyword">let</span> <span class=
"org-variable-name">left</span> = total
<span class="linenr">2273: </span>        <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; total; i++) {
<span class="linenr">2274: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">decl</span> = node.declarations[i]
<span class="linenr">2275: </span>          <span class=
"org-keyword">if</span> (decl.init) {
<span class="linenr">2276: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">defineProps / defineEmits</span>
<span class="linenr">2277: </span>            <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isDefineProps</span> =
<span class=
"linenr">2278: </span>              processDefineProps(decl.init, decl.id) ||
<span class=
"linenr">2279: </span>              processWithDefaults(decl.init, decl.id)
<span class="linenr">2280: </span>            <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isDefineEmits</span> = processDefineEmits(decl.init, decl.id)
<span class="linenr">2281: </span>            <span class=
"org-keyword">if</span> (isDefineProps || isDefineEmits) {
<span class="linenr">2282: </span>              <span class=
"org-keyword">if</span> (left === <span class=
"org-highlight-numbers-number">1</span>) {
<span class=
"linenr">2283: </span>                s.remove(node.start + startOffset, node.end + startOffset)
<span class="linenr">2284: </span>              } <span class=
"org-keyword">else</span> {
<span class="linenr">2285: </span>                <span class=
"org-keyword">let</span> <span class=
"org-variable-name">start</span> = decl.start + startOffset
<span class="linenr">2286: </span>                <span class=
"org-keyword">let</span> <span class=
"org-variable-name">end</span> = decl.end + startOffset
<span class="linenr">2287: </span>                <span class=
"org-keyword">if</span> (i &lt; total - <span class=
"org-highlight-numbers-number">1</span>) {
<span class="linenr">2288: </span>                  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">not the last one, locate the start of the next</span>
<span class=
"linenr">2289: </span>                  end = node.declarations[i + <span class="org-highlight-numbers-number">1</span>].start + startOffset
<span class="linenr">2290: </span>                } <span class=
"org-keyword">else</span> {
<span class="linenr">2291: </span>                  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">last one, locate the end of the prev</span>
<span class=
"linenr">2292: </span>                  start = node.declarations[i - <span class="org-highlight-numbers-number">1</span>].end + startOffset
<span class="linenr">2293: </span>                }
<span class=
"linenr">2294: </span>                s.remove(start, end)
<span class="linenr">2295: </span>                left--
<span class="linenr">2296: </span>              }
<span class="linenr">2297: </span>            }
<span class="linenr">2298: </span>          }
<span class="linenr">2299: </span>        }
<span class="linenr">2300: </span>      }
<span class="linenr">2301: </span>  
<span class="linenr">2302: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">walk declarations to record declared bindings</span>
<span class="linenr">2303: </span>      <span class=
"org-keyword">if</span> (
<span class=
"linenr">2304: </span>        (node.type === <span class=
"org-string">'VariableDeclaration'</span> ||
<span class=
"linenr">2305: </span>          node.type === <span class=
"org-string">'FunctionDeclaration'</span> ||
<span class=
"linenr">2306: </span>          node.type === <span class=
"org-string">'ClassDeclaration'</span>) &amp;&
<span class="linenr">2307: </span>        !node.declare
<span class="linenr">2308: </span>      ) {
<span class=
"linenr">2309: </span>        walkDeclaration(node, setupBindings, userImportAlias)
<span class="linenr">2310: </span>      }
<span class="linenr">2311: </span>  
<span class="linenr">2312: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">walk statements & named exports / variable declarations for top level</span>
<span class="linenr">2313: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">await</span>
<span class="linenr">2314: </span>      <span class=
"org-keyword">if</span> (
<span class=
"linenr">2315: </span>        (node.type === <span class=
"org-string">'VariableDeclaration'</span> &amp;& !node.declare) ||
<span class=
"linenr">2316: </span>        node.type.endsWith(<span class=
"org-string">'Statement'</span>)
<span class="linenr">2317: </span>      ) {
<span class="linenr">2318: </span>        walk(node, {
<span class="linenr">2319: </span>          enter(child, parent) {
<span class="linenr">2320: </span>            <span class=
"org-keyword">if</span> (isFunctionType(child)) {
<span class="linenr">2321: </span>              <span class=
"org-constant">this</span>.skip()
<span class="linenr">2322: </span>            }
<span class="linenr">2323: </span>            <span class=
"org-keyword">if</span> (child.type === <span class=
"org-string">'AwaitExpression'</span>) {
<span class=
"linenr">2324: </span>              hasAwait = <span class=
"org-constant">true</span>
<span class="linenr">2325: </span>              <span class=
"org-keyword">const</span> <span class=
"org-variable-name">needsSemi</span> = scriptSetupAst.body.some(n =&gt; {
<span class="linenr">2326: </span>                <span class=
"org-keyword">return</span> n.type === <span class=
"org-string">'ExpressionStatement'</span> &amp;& n.start === child.start
<span class="linenr">2327: </span>              })
<span class="linenr">2328: </span>              processAwait(
<span class="linenr">2329: </span>                child,
<span class="linenr">2330: </span>                needsSemi,
<span class=
"linenr">2331: </span>                parent.type === <span class=
"org-string">'ExpressionStatement'</span>
<span class="linenr">2332: </span>              )
<span class="linenr">2333: </span>            }
<span class="linenr">2334: </span>          }
<span class="linenr">2335: </span>        })
<span class="linenr">2336: </span>      }
<span class="linenr">2337: </span>  
<span class="linenr">2338: </span>      <span class=
"org-keyword">if</span> (
<span class=
"linenr">2339: </span>        (node.type === <span class=
"org-string">'ExportNamedDeclaration'</span> &amp;& node.exportKind !== <span class="org-string">'type'</span>) ||
<span class=
"linenr">2340: </span>        node.type === <span class="org-string">'ExportAllDeclaration'</span> ||
<span class=
"linenr">2341: </span>        node.type === <span class="org-string">'ExportDefaultDeclaration'</span>
<span class="linenr">2342: </span>      ) {
<span class="linenr">2343: </span>        error(
<span class="linenr">2344: </span>          <span class=
"org-string">`&lt;script setup&gt; cannot contain ES module exports. `</span> +
<span class="linenr">2345: </span>            <span class=
"org-string">`If you are using a previous version of &lt;script setup&gt;, please `</span> +
<span class="linenr">2346: </span>            <span class=
"org-string">`consult the updated RFC at https://github.com/vuejs/rfcs/pull/227.`</span>,
<span class="linenr">2347: </span>          node
<span class="linenr">2348: </span>        )
<span class="linenr">2349: </span>      }
<span class="linenr">2350: </span>  
<span class="linenr">2351: </span>      <span class=
"org-keyword">if</span> (isTS) {
<span class="linenr">2352: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">runtime enum</span>
<span class="linenr">2353: </span>        <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'TSEnumDeclaration'</span>) {
<span class=
"linenr">2354: </span>          registerBinding(setupBindings, node.id, BindingTypes.SETUP_CONST)
<span class="linenr">2355: </span>        }
<span class="linenr">2356: </span>  
<span class="linenr">2357: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">move all Type declarations to outer scope</span>
<span class="linenr">2358: </span>        <span class=
"org-keyword">if</span> (
<span class=
"linenr">2359: </span>          node.type.startsWith(<span class=
"org-string">'TS'</span>) ||
<span class=
"linenr">2360: </span>          (node.type === <span class=
"org-string">'ExportNamedDeclaration'</span> &amp;&
<span class=
"linenr">2361: </span>            node.exportKind === <span class=
"org-string">'type'</span>) ||
<span class=
"linenr">2362: </span>          (node.type === <span class=
"org-string">'VariableDeclaration'</span> &amp;& node.declare)
<span class="linenr">2363: </span>        ) {
<span class=
"linenr">2364: </span>          recordType(node, declaredTypes)
<span class=
"linenr">2365: </span>          s.move(start, end, <span class=
"org-highlight-numbers-number">0</span>)
<span class="linenr">2366: </span>        }
<span class="linenr">2367: </span>      }
<span class="linenr">2368: </span>    }
<span class="linenr">2369: </span>  
<span class="linenr">2370: </span>    <span class=
"org-keyword">return</span> scriptSetupAst
<span class="linenr">2371: </span>  }
<span class="linenr">2372: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">applyReactivityTransform</span>() {
<span class="linenr">2373: </span>    <span class=
"org-keyword">if</span> (
<span class=
"linenr">2374: </span>      (enableReactivityTransform &amp;&
<span class="linenr">2375: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">normal &lt;script&gt; had ref bindings that maybe used in &lt;script setup&gt;</span>
<span class=
"linenr">2376: </span>        (refBindings || RT.shouldTransform(scriptSetup.content))) ||
<span class="linenr">2377: </span>      propsDestructureDecl
<span class="linenr">2378: </span>    ) {
<span class="linenr">2379: </span>      <span class=
"org-keyword">const</span> { rootRefs, importedHelpers } = transformAST(
<span class="linenr">2380: </span>        scriptSetupAst,
<span class="linenr">2381: </span>        s,
<span class="linenr">2382: </span>        startOffset,
<span class="linenr">2383: </span>        refBindings,
<span class="linenr">2384: </span>        propsDestructuredBindings
<span class="linenr">2385: </span>      )
<span class=
"linenr">2386: </span>      refBindings = refBindings ? [...refBindings, ...rootRefs] : rootRefs
<span class="linenr">2387: </span>      <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">h</span> <span class=
"org-keyword">of</span> importedHelpers) {
<span class="linenr">2388: </span>        helperImports.add(h)
<span class="linenr">2389: </span>      }
<span class="linenr">2390: </span>    }
<span class="linenr">2391: </span>  }
<span class="linenr">2392: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">extractRuntimePropsEmits</span>() {
<span class="linenr">2393: </span>    <span class=
"org-keyword">if</span> (propsTypeDecl) {
<span class=
"linenr">2394: </span>      extractRuntimeProps(propsTypeDecl, typeDeclaredProps, declaredTypes, isProd)
<span class="linenr">2395: </span>    }
<span class="linenr">2396: </span>    <span class=
"org-keyword">if</span> (emitsTypeDecl) {
<span class=
"linenr">2397: </span>      extractRuntimeEmits(emitsTypeDecl, typeDeclaredEmits)
<span class="linenr">2398: </span>    }
<span class="linenr">2399: </span>  }
<span class="linenr">2400: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">checkUseOptions</span>() {
<span class=
"linenr">2401: </span>    checkInvalidScopeReference(propsRuntimeDecl, DEFINE_PROPS)
<span class=
"linenr">2402: </span>    checkInvalidScopeReference(propsRuntimeDefaults, DEFINE_PROPS)
<span class=
"linenr">2403: </span>    checkInvalidScopeReference(propsDestructureDecl, DEFINE_PROPS)
<span class=
"linenr">2404: </span>    checkInvalidScopeReference(emitsRuntimeDecl, DEFINE_PROPS)
<span class="linenr">2405: </span>  }
<span class="linenr">2406: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">removeNonScriptContent</span>() {
<span class="linenr">2407: </span>    <span class=
"org-keyword">if</span> (script) {
<span class="linenr">2408: </span>      <span class=
"org-keyword">if</span> (startOffset &lt; scriptStartOffset) {
<span class="linenr">2409: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">&lt;script setup&gt; before &lt;script&gt;</span>
<span class="linenr">2410: </span>        s.remove(<span class=
"org-highlight-numbers-number">0</span>, startOffset)
<span class=
"linenr">2411: </span>        s.remove(endOffset, scriptStartOffset)
<span class=
"linenr">2412: </span>        s.remove(scriptEndOffset, source.length)
<span class="linenr">2413: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr">2414: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">&lt;script&gt; before &lt;script setup&gt;</span>
<span class="linenr">2415: </span>        s.remove(<span class=
"org-highlight-numbers-number">0</span>, scriptStartOffset)
<span class=
"linenr">2416: </span>        s.remove(scriptEndOffset, startOffset)
<span class=
"linenr">2417: </span>        s.remove(endOffset, source.length)
<span class="linenr">2418: </span>      }
<span class="linenr">2419: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr">2420: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">only &lt;script setup&gt;</span>
<span class="linenr">2421: </span>      s.remove(<span class=
"org-highlight-numbers-number">0</span>, startOffset)
<span class=
"linenr">2422: </span>      s.remove(endOffset, source.length)
<span class="linenr">2423: </span>    }
<span class="linenr">2424: </span>  }
<span class="linenr">2425: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">analyzeBindingMetadata</span>() {
<span class="linenr">2426: </span>    <span class=
"org-keyword">if</span> (scriptAst) {
<span class=
"linenr">2427: </span>      Object.assign(bindingMetadata, analyzeScriptBindings(scriptAst.body))
<span class="linenr">2428: </span>    }
<span class="linenr">2429: </span>    <span class=
"org-keyword">if</span> (propsRuntimeDecl) {
<span class="linenr">2430: </span>      <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">of</span> getObjectOrArrayExpressionKeys(propsRuntimeDecl)) {
<span class=
"linenr">2431: </span>        bindingMetadata[key] = BindingTypes.PROPS
<span class="linenr">2432: </span>      }
<span class="linenr">2433: </span>    }
<span class="linenr">2434: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">in</span> typeDeclaredProps) {
<span class=
"linenr">2435: </span>      bindingMetadata[key] = BindingTypes.PROPS
<span class="linenr">2436: </span>    }
<span class="linenr">2437: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">props aliases</span>
<span class="linenr">2438: </span>    <span class=
"org-keyword">if</span> (propsDestructureDecl) {
<span class="linenr">2439: </span>      <span class=
"org-keyword">if</span> (propsDestructureRestId) {
<span class=
"linenr">2440: </span>        bindingMetadata[propsDestructureRestId] = BindingTypes.SETUP_CONST
<span class="linenr">2441: </span>      }
<span class="linenr">2442: </span>      <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">in</span> propsDestructuredBindings) {
<span class="linenr">2443: </span>        <span class=
"org-keyword">const</span> { local } = propsDestructuredBindings[key]
<span class="linenr">2444: </span>        <span class=
"org-keyword">if</span> (local !== key) {
<span class=
"linenr">2445: </span>          bindingMetadata[local] = BindingTypes.PROPS_ALIASED
<span class=
"linenr">2446: </span>          ;(bindingMetadata.__propsAliases ||
<span class=
"linenr">2447: </span>            (bindingMetadata.__propsAliases = {}))[local] = key
<span class="linenr">2448: </span>        }
<span class="linenr">2449: </span>      }
<span class="linenr">2450: </span>    }
<span class="linenr">2451: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> [key, { isType, imported, source }] <span class="org-keyword">of</span> Object.entries(
<span class="linenr">2452: </span>      userImports
<span class="linenr">2453: </span>    )) {
<span class="linenr">2454: </span>      <span class=
"org-keyword">if</span> (isType) <span class=
"org-keyword">continue</span>
<span class="linenr">2455: </span>      bindingMetadata[key] =
<span class=
"linenr">2456: </span>        (imported === <span class="org-string">'default'</span> &amp;& source.endsWith(<span class="org-string">'.vue'</span>)) || source === <span class="org-string">'vue'</span>
<span class=
"linenr">2457: </span>          ? BindingTypes.SETUP_CONST
<span class=
"linenr">2458: </span>          : BindingTypes.SETUP_MAYBE_REF
<span class="linenr">2459: </span>    }
<span class="linenr">2460: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">in</span> scriptBindings) {
<span class=
"linenr">2461: </span>      bindingMetadata[key] = scriptBindings[key]
<span class="linenr">2462: </span>    }
<span class="linenr">2463: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">in</span> setupBindings) {
<span class=
"linenr">2464: </span>      bindingMetadata[key] = setupBindings[key]
<span class="linenr">2465: </span>    }
<span class="linenr">2466: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">known ref bindings</span>
<span class="linenr">2467: </span>    <span class=
"org-keyword">if</span> (refBindings) {
<span class="linenr">2468: </span>      <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">of</span> refBindings) {
<span class=
"linenr">2469: </span>        bindingMetadata[key] = BindingTypes.SETUP_REF
<span class="linenr">2470: </span>      }
<span class="linenr">2471: </span>    }
<span class="linenr">2472: </span>  }
<span class="linenr">2473: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">injectUseCssVarsCalls</span>() {
<span class="linenr">2474: </span>    <span class=
"org-keyword">if</span> (cssVars.length) {
<span class=
"linenr">2475: </span>      helperImports.add(CSS_VARS_HELPER)
<span class=
"linenr">2476: </span>      helperImports.add(<span class=
"org-string">'unref'</span>)
<span class="linenr">2477: </span>      s.prependRight(
<span class="linenr">2478: </span>        startOffset,
<span class="linenr">2479: </span>        <span class=
"org-string">`\n${genCssVarsCode(cssVars, bindingMetadata, scopeId, isProd)}\n`</span>
<span class="linenr">2480: </span>      )
<span class="linenr">2481: </span>    }
<span class="linenr">2482: </span>  }
<span class="linenr">2483: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">finalizeSetupArgumentSignature</span>() {
<span class="linenr">2484: </span>    <span class=
"org-keyword">if</span> (propsTypeDecl) {
<span class="linenr">2485: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">mark as any and only cast on assignment</span>
<span class="linenr">2486: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">since the user defined complex types may be incompatible with the</span>
<span class="linenr">2487: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">inferred type from generated runtime declarations</span>
<span class="linenr">2488: </span>      args += <span class=
"org-string">`: any`</span>
<span class="linenr">2489: </span>    }
<span class="linenr">2490: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">inject user assignment of props</span>
<span class="linenr">2491: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">we use a default __props so that template expressions referencing props</span>
<span class="linenr">2492: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">can use it directly</span>
<span class="linenr">2493: </span>    <span class=
"org-keyword">if</span> (propsIdentifier) {
<span class="linenr">2494: </span>      s.prependLeft(
<span class="linenr">2495: </span>        startOffset,
<span class="linenr">2496: </span>        <span class=
"org-string">`\nconst ${propsIdentifier} = __props${</span>
<span class="linenr">2497: </span><span class=
"org-string">          propsTypeDecl ? `</span> as ${genSetupPropsType(propsTypeDecl)}<span class="org-string">` : ``</span>
<span class="linenr">2498: </span><span class=
"org-string">        }\n`</span>
<span class="linenr">2499: </span>      )
<span class="linenr">2500: </span>    }
<span class="linenr">2501: </span>    <span class=
"org-keyword">if</span> (propsDestructureRestId) {
<span class="linenr">2502: </span>      s.prependLeft(
<span class="linenr">2503: </span>        startOffset,
<span class="linenr">2504: </span>        <span class=
"org-string">`\nconst ${propsDestructureRestId} = ${helper(</span>
<span class="linenr">2505: </span><span class=
"org-string">          `</span>createPropsRestProxy<span class=
"org-string">`</span>
<span class="linenr">2506: </span><span class=
"org-string">        )}(__props, ${JSON.stringify(Object.keys(propsDestructuredBindings))})\n`</span>
<span class="linenr">2507: </span>      )
<span class="linenr">2508: </span>    }
<span class="linenr">2509: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">inject temp variables for async context preservation</span>
<span class="linenr">2510: </span>    <span class=
"org-keyword">if</span> (hasAwait) {
<span class="linenr">2511: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">any</span> = isTS ? <span class=
"org-string">`: any`</span> : <span class="org-string">``</span>
<span class=
"linenr">2512: </span>      s.prependLeft(startOffset, <span class=
"org-string">`\nlet __temp${any}, __restore${any}\n`</span>)
<span class="linenr">2513: </span>    }
<span class="linenr">2514: </span>  
<span class="linenr">2515: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">destructureElements</span> =
<span class=
"linenr">2516: </span>      hasDefineExposeCall || !options.inlineTemplate ? [<span class="org-string">`expose`</span>] : []
<span class="linenr">2517: </span>    <span class=
"org-keyword">if</span> (emitIdentifier) {
<span class="linenr">2518: </span>      destructureElements.push(
<span class=
"linenr">2519: </span>        emitIdentifier === <span class=
"org-string">`emit`</span> ? <span class=
"org-string">`emit`</span> : <span class=
"org-string">`emit: ${emitIdentifier}`</span>
<span class="linenr">2520: </span>      )
<span class="linenr">2521: </span>    }
<span class="linenr">2522: </span>    <span class=
"org-keyword">if</span> (destructureElements.length) {
<span class="linenr">2523: </span>      args += <span class=
"org-string">`, { ${destructureElements.join(', ')} }`</span>
<span class="linenr">2524: </span>      <span class=
"org-keyword">if</span> (emitsTypeDecl) {
<span class="linenr">2525: </span>        args += <span class=
"org-string">`: { emit: (${scriptSetup.content.slice(</span>
<span class="linenr">2526: </span><span class=
"org-string">          emitsTypeDecl.start,</span>
<span class="linenr">2527: </span><span class=
"org-string">          emitsTypeDecl.end</span>
<span class="linenr">2528: </span><span class=
"org-string">        )}), expose: any, slots: any, attrs: any }`</span>
<span class="linenr">2529: </span>      }
<span class="linenr">2530: </span>    }
<span class="linenr">2531: </span>  }
<span class="linenr">2532: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">finalizeSetupArgumentSignature</span>() {
<span class="linenr">2533: </span>    <span class=
"org-keyword">if</span> (propsTypeDecl) {
<span class="linenr">2534: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">mark as any and only cast on assignment</span>
<span class="linenr">2535: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">since the user defined complex types may be incompatible with the</span>
<span class="linenr">2536: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">inferred type from generated runtime declarations</span>
<span class="linenr">2537: </span>      args += <span class=
"org-string">`: any`</span>
<span class="linenr">2538: </span>    }
<span class="linenr">2539: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">inject user assignment of props</span>
<span class="linenr">2540: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">we use a default __props so that template expressions referencing props</span>
<span class="linenr">2541: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">can use it directly</span>
<span class="linenr">2542: </span>    <span class=
"org-keyword">if</span> (propsIdentifier) {
<span class="linenr">2543: </span>      s.prependLeft(
<span class="linenr">2544: </span>        startOffset,
<span class="linenr">2545: </span>        <span class=
"org-string">`\nconst ${propsIdentifier} = __props${</span>
<span class="linenr">2546: </span><span class=
"org-string">          propsTypeDecl ? `</span> as ${genSetupPropsType(propsTypeDecl)}<span class="org-string">` : ``</span>
<span class="linenr">2547: </span><span class=
"org-string">        }\n`</span>
<span class="linenr">2548: </span>      )
<span class="linenr">2549: </span>    }
<span class="linenr">2550: </span>    <span class=
"org-keyword">if</span> (propsDestructureRestId) {
<span class="linenr">2551: </span>      s.prependLeft(
<span class="linenr">2552: </span>        startOffset,
<span class="linenr">2553: </span>        <span class=
"org-string">`\nconst ${propsDestructureRestId} = ${helper(</span>
<span class="linenr">2554: </span><span class=
"org-string">          `</span>createPropsRestProxy<span class=
"org-string">`</span>
<span class="linenr">2555: </span><span class=
"org-string">        )}(__props, ${JSON.stringify(Object.keys(propsDestructuredBindings))})\n`</span>
<span class="linenr">2556: </span>      )
<span class="linenr">2557: </span>    }
<span class="linenr">2558: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">inject temp variables for async context preservation</span>
<span class="linenr">2559: </span>    <span class=
"org-keyword">if</span> (hasAwait) {
<span class="linenr">2560: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">any</span> = isTS ? <span class=
"org-string">`: any`</span> : <span class="org-string">``</span>
<span class=
"linenr">2561: </span>      s.prependLeft(startOffset, <span class=
"org-string">`\nlet __temp${any}, __restore${any}\n`</span>)
<span class="linenr">2562: </span>    }
<span class="linenr">2563: </span>  
<span class="linenr">2564: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">destructureElements</span> =
<span class=
"linenr">2565: </span>      hasDefineExposeCall || !options.inlineTemplate ? [<span class="org-string">`expose`</span>] : []
<span class="linenr">2566: </span>    <span class=
"org-keyword">if</span> (emitIdentifier) {
<span class="linenr">2567: </span>      destructureElements.push(
<span class=
"linenr">2568: </span>        emitIdentifier === <span class=
"org-string">`emit`</span> ? <span class=
"org-string">`emit`</span> : <span class=
"org-string">`emit: ${emitIdentifier}`</span>
<span class="linenr">2569: </span>      )
<span class="linenr">2570: </span>    }
<span class="linenr">2571: </span>    <span class=
"org-keyword">if</span> (destructureElements.length) {
<span class="linenr">2572: </span>      args += <span class=
"org-string">`, { ${destructureElements.join(', ')} }`</span>
<span class="linenr">2573: </span>      <span class=
"org-keyword">if</span> (emitsTypeDecl) {
<span class="linenr">2574: </span>        args += <span class=
"org-string">`: { emit: (${scriptSetup.content.slice(</span>
<span class="linenr">2575: </span><span class=
"org-string">          emitsTypeDecl.start,</span>
<span class="linenr">2576: </span><span class=
"org-string">          emitsTypeDecl.end</span>
<span class="linenr">2577: </span><span class=
"org-string">        )}), expose: any, slots: any, attrs: any }`</span>
<span class="linenr">2578: </span>      }
<span class="linenr">2579: </span>    }
<span class="linenr">2580: </span>  }
<span class="linenr">2581: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">generateReturnStatement</span>() {
<span class="linenr">2582: </span>    <span class=
"org-keyword">if</span> (options.inlineTemplate) {
<span class="linenr">2583: </span>      <span class=
"org-keyword">if</span> (sfc.template &amp;& !sfc.template.src) {
<span class="linenr">2584: </span>        <span class=
"org-keyword">if</span> (options.templateOptions &amp;& options.templateOptions.ssr) {
<span class=
"linenr">2585: </span>          hasInlinedSsrRenderFn = <span class="org-constant">true</span>
<span class="linenr">2586: </span>        }
<span class="linenr">2587: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">inline render function mode - we are going to compile the template and</span>
<span class="linenr">2588: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">inline it right here</span>
<span class="linenr">2589: </span>        <span class=
"org-keyword">const</span> { code, ast, preamble, tips, errors } = compileTemplate({
<span class="linenr">2590: </span>          filename,
<span class=
"linenr">2591: </span>          source: sfc.template.content,
<span class=
"linenr">2592: </span>          inMap: sfc.template.map,
<span class=
"linenr">2593: </span>          ...options.templateOptions,
<span class="linenr">2594: </span>          id: scopeId,
<span class=
"linenr">2595: </span>          scoped: sfc.styles.some(s =&gt; s.scoped),
<span class="linenr">2596: </span>          isProd: options.isProd,
<span class=
"linenr">2597: </span>          ssrCssVars: sfc.cssVars,
<span class="linenr">2598: </span>          compilerOptions: {
<span class=
"linenr">2599: </span>            ...(options.templateOptions &amp;&
<span class=
"linenr">2600: </span>              options.templateOptions.compilerOptions),
<span class="linenr">2601: </span>            inline: <span class=
"org-constant">true</span>,
<span class="linenr">2602: </span>            isTS,
<span class="linenr">2603: </span>            bindingMetadata
<span class="linenr">2604: </span>          }
<span class="linenr">2605: </span>        })
<span class="linenr">2606: </span>  
<span class="linenr">2607: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">err</span> = errors[<span class=
"org-highlight-numbers-number">0</span>]
<span class="linenr">2608: </span>        <span class=
"org-keyword">if</span> (<span class=
"org-keyword">typeof</span> err === <span class=
"org-string">'string'</span>) {
<span class="linenr">2609: </span>          <span class=
"org-keyword">throw</span> <span class=
"org-keyword">new</span> <span class="org-type">Error</span>(err)
<span class="linenr">2610: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (err) {
<span class="linenr">2611: </span>          <span class=
"org-keyword">if</span> (err.loc) {
<span class="linenr">2612: </span>            err.message +=
<span class="linenr">2613: </span>              <span class=
"org-string">`\n\n`</span> +
<span class="linenr">2614: </span>              sfc.filename +
<span class="linenr">2615: </span>              <span class=
"org-string">'\n'</span> +
<span class="linenr">2616: </span>              generateCodeFrame(
<span class="linenr">2617: </span>                source,
<span class=
"linenr">2618: </span>                err.loc.start.offset,
<span class=
"linenr">2619: </span>                err.loc.end.offset
<span class="linenr">2620: </span>              ) +
<span class="linenr">2621: </span>              <span class=
"org-string">`\n`</span>
<span class="linenr">2622: </span>          }
<span class="linenr">2623: </span>          <span class=
"org-keyword">throw</span> err
<span class="linenr">2624: </span>        }
<span class="linenr">2625: </span>        <span class=
"org-keyword">if</span> (preamble) {
<span class="linenr">2626: </span>          s.prepend(preamble)
<span class="linenr">2627: </span>        }
<span class="linenr">2628: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">avoid duplicated unref import</span>
<span class="linenr">2629: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">as this may get injected by the render function preamble OR the</span>
<span class="linenr">2630: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">css vars codegen</span>
<span class="linenr">2631: </span>        <span class=
"org-keyword">if</span> (ast &amp;& ast.helpers.includes(UNREF)) {
<span class=
"linenr">2632: </span>          helperImports.<span class=
"org-keyword">delete</span>(<span class=
"org-string">'unref'</span>)
<span class="linenr">2633: </span>        }
<span class="linenr">2634: </span>        returned = code
<span class="linenr">2635: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr">2636: </span>        returned = <span class=
"org-string">`() =&gt; {}`</span>
<span class="linenr">2637: </span>      }
<span class="linenr">2638: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr">2639: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">return bindings from script and script setup</span>
<span class="linenr">2640: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">allBindings</span>= {
<span class="linenr">2641: </span>        ...scriptBindings,
<span class="linenr">2642: </span>        ...setupBindings
<span class="linenr">2643: </span>      }
<span class="linenr">2644: </span>      <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">in</span> userImports) {
<span class="linenr">2645: </span>        <span class=
"org-keyword">if</span> (!userImports[key].isType &amp;& userImports[key].isUsedInTemplate) {
<span class=
"linenr">2646: </span>          allBindings[key] = <span class=
"org-constant">true</span>
<span class="linenr">2647: </span>        }
<span class="linenr">2648: </span>      }
<span class="linenr">2649: </span>      returned = <span class=
"org-string">`{ ${Object.keys(allBindings).join(', ')} }`</span>
<span class="linenr">2650: </span>    }
<span class="linenr">2651: </span>  
<span class="linenr">2652: </span>    <span class=
"org-keyword">if</span> (!options.inlineTemplate) {
<span class="linenr">2653: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">in non-inline mode, the `__isScriptSetup: true` flag is used by</span>
<span class="linenr">2654: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">componentPublicInstance proxy to allow properties that start with $ or _</span>
<span class="linenr">2655: </span>      s.appendRight(
<span class="linenr">2656: </span>        endOffset,
<span class="linenr">2657: </span>        <span class=
"org-string">`\nconst __returned__ = ${returned}\n`</span> +
<span class="linenr">2658: </span>          <span class=
"org-string">`Object.defineProperty(__returned__, '__isScriptSetup', { enumerable: false, value: true })\n`</span> +
<span class="linenr">2659: </span>          <span class=
"org-string">`return __returned__`</span> +
<span class="linenr">2660: </span>          <span class=
"org-string">`\n}\n\n`</span>
<span class="linenr">2661: </span>      )
<span class="linenr">2662: </span>    } <span class=
"org-keyword">else</span> {
<span class=
"linenr">2663: </span>      s.appendRight(endOffset, <span class=
"org-string">`\nreturn ${returned}\n}\n\n`</span>)
<span class="linenr">2664: </span>    }
<span class="linenr">2665: </span>  }
<span class="linenr">2666: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">finalizeDefaultExport</span>() {
<span class="linenr">2667: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">runtimeOptions</span> = <span class=
"org-string">``</span>
<span class="linenr">2668: </span>    <span class=
"org-keyword">if</span> (hasInlinedSsrRenderFn) {
<span class=
"linenr">2669: </span>      runtimeOptions += <span class=
"org-string">`\n  __ssrInlineRender: true,`</span>
<span class="linenr">2670: </span>    }
<span class="linenr">2671: </span>    <span class=
"org-keyword">if</span> (propsRuntimeDecl) {
<span class="linenr">2672: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">declCode</span> = scriptSetup.content
<span class=
"linenr">2673: </span>        .slice(propsRuntimeDecl.start, propsRuntimeDecl.end)
<span class="linenr">2674: </span>        .trim()
<span class="linenr">2675: </span>      <span class=
"org-keyword">if</span> (propsDestructureDecl) {
<span class="linenr">2676: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">defaults</span> = []
<span class="linenr">2677: </span>        <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">in</span> propsDestructuredBindings) {
<span class="linenr">2678: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">d</span> = genDestructuredDefaultValue(key)
<span class="linenr">2679: </span>          <span class=
"org-keyword">if</span> (d) defaults.push(<span class=
"org-string">`${key}: ${d}`</span>)
<span class="linenr">2680: </span>        }
<span class="linenr">2681: </span>        <span class=
"org-keyword">if</span> (defaults.length) {
<span class="linenr">2682: </span>          declCode = <span class=
"org-string">`${helper(</span>
<span class="linenr">2683: </span><span class=
"org-string">            `</span>mergeDefaults<span class=
"org-string">`</span>
<span class="linenr">2684: </span><span class=
"org-string">          )}(${declCode}, {\n  ${defaults.join(',\n  ')}\n})`</span>
<span class="linenr">2685: </span>        }
<span class="linenr">2686: </span>      }
<span class=
"linenr">2687: </span>      runtimeOptions += <span class=
"org-string">`\n  props: ${declCode},`</span>
<span class="linenr">2688: </span>    } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (propsTypeDecl) {
<span class=
"linenr">2689: </span>      runtimeOptions += genRuntimeProps(typeDeclaredProps)
<span class="linenr">2690: </span>    }
<span class="linenr">2691: </span>    <span class=
"org-keyword">if</span> (emitsRuntimeDecl) {
<span class=
"linenr">2692: </span>      runtimeOptions += <span class=
"org-string">`\n  emits: ${scriptSetup.content</span>
<span class="linenr">2693: </span><span class=
"org-string">        .slice(emitsRuntimeDecl.start, emitsRuntimeDecl.end)</span>
<span class="linenr">2694: </span><span class=
"org-string">        .trim()},`</span>
<span class="linenr">2695: </span>    } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (emitsTypeDecl) {
<span class=
"linenr">2696: </span>      runtimeOptions += genRuntimeEmits(typeDeclaredEmits)
<span class="linenr">2697: </span>    }
<span class="linenr">2698: </span>  
<span class="linenr">2699: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">&lt;script setup&gt; components are closed by default. If the user did not</span>
<span class="linenr">2700: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">explicitly call `defineExpose`, call expose() with no args.</span>
<span class="linenr">2701: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">exposeCall</span> =
<span class=
"linenr">2702: </span>      hasDefineExposeCall || options.inlineTemplate ? <span class="org-string">``</span> : <span class="org-string">`  expose();\n`</span>
<span class="linenr">2703: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">wrap setup code with function.</span>
<span class="linenr">2704: </span>    <span class=
"org-keyword">if</span> (isTS) {
<span class="linenr">2705: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">for TS, make sure the exported type is still valid type with</span>
<span class="linenr">2706: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">correct props information</span>
<span class="linenr">2707: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">we have to use object spread for types to be merged properly</span>
<span class="linenr">2708: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">user's TS setting should compile it down to proper targets</span>
<span class="linenr">2709: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">export default defineComponent({ ...__default__, ... })</span>
<span class="linenr">2710: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">def</span> = defaultExport ? <span class=
"org-string">`\n  ...${DEFAULT_VAR},`</span> : <span class=
"org-string">``</span>
<span class="linenr">2711: </span>      s.prependLeft(
<span class="linenr">2712: </span>        startOffset,
<span class="linenr">2713: </span>        <span class=
"org-string">`\nexport default /*#__PURE__*/${helper(</span>
<span class="linenr">2714: </span><span class=
"org-string">          `</span>defineComponent<span class=
"org-string">`</span>
<span class="linenr">2715: </span><span class=
"org-string">        )}({${def}${runtimeOptions}\n  ${</span>
<span class="linenr">2716: </span><span class=
"org-string">          hasAwait ? `</span><span class=
"org-keyword">async</span> <span class="org-string">` : ``</span>
<span class="linenr">2717: </span><span class=
"org-string">        }setup(${args}) {\n${exposeCall}`</span>
<span class="linenr">2718: </span>      )
<span class=
"linenr">2719: </span>      s.appendRight(endOffset, <span class=
"org-string">`})`</span>)
<span class="linenr">2720: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr">2721: </span>      <span class=
"org-keyword">if</span> (defaultExport) {
<span class="linenr">2722: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">without TS, can't rely on rest spread, so we use Object.assign</span>
<span class="linenr">2723: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">export default Object.assign(__default__, { ... })</span>
<span class="linenr">2724: </span>        s.prependLeft(
<span class="linenr">2725: </span>          startOffset,
<span class="linenr">2726: </span>          <span class=
"org-string">`\nexport default /*#__PURE__*/Object.assign(${DEFAULT_VAR}, {${runtimeOptions}\n  `</span> +
<span class="linenr">2727: </span>            <span class=
"org-string">`${hasAwait ? `</span><span class=
"org-keyword">async</span> <span class=
"org-string">` : ``}setup(${args}) {\n${exposeCall}`</span>
<span class="linenr">2728: </span>        )
<span class=
"linenr">2729: </span>        s.appendRight(endOffset, <span class=
"org-string">`})`</span>)
<span class="linenr">2730: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr">2731: </span>        s.prependLeft(
<span class="linenr">2732: </span>          startOffset,
<span class="linenr">2733: </span>          <span class=
"org-string">`\nexport default {${runtimeOptions}\n  `</span> +
<span class="linenr">2734: </span>            <span class=
"org-string">`${hasAwait ? `</span><span class=
"org-keyword">async</span> <span class=
"org-string">` : ``}setup(${args}) {\n${exposeCall}`</span>
<span class="linenr">2735: </span>        )
<span class=
"linenr">2736: </span>        s.appendRight(endOffset, <span class=
"org-string">`}`</span>)
<span class="linenr">2737: </span>      }
<span class="linenr">2738: </span>    }
<span class="linenr">2739: </span>  }
<span class="linenr">2740: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">finalizeVueHelperImports</span>() {
<span class="linenr">2741: </span>    <span class=
"org-keyword">if</span> (helperImports.size &gt; <span class=
"org-highlight-numbers-number">0</span>) {
<span class="linenr">2742: </span>      s.prepend(
<span class="linenr">2743: </span>        <span class=
"org-string">`import { ${[...helperImports]</span>
<span class="linenr">2744: </span><span class=
"org-string">          .map(h =&gt; `</span>${h} as _${h}<span class="org-string">`)</span>
<span class="linenr">2745: </span><span class=
"org-string">          .join(', ')} } from 'vue'\n`</span>
<span class="linenr">2746: </span>      )
<span class="linenr">2747: </span>    }
<span class="linenr">2748: </span>  }
<span class="linenr">2749: </span>
<span class="linenr">2750: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">1. process normal &lt;script&gt; first if it exists</span>
<span class="linenr">2751: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">scriptAst</span> = processNormalScript()
<span class="linenr">2752: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">2. parse &lt;script setup&gt; and  walk over top level statements</span>
<span class="linenr">2753: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">scriptSetupAst</span> = processSetupScript()
<span class="linenr">2754: </span>
<span class="linenr">2755: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">3. Apply reactivity transform</span>
<span class="linenr">2756: </span>  applyReactivityTransform()
<span class="linenr">2757: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">4. extract runtime props/emits code from setup context type</span>
<span class="linenr">2758: </span>  extractRuntimePropsEmits()
<span class="linenr">2759: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">5. check useOptions args to make sure it doesn't reference setup scope</span>
<span class="linenr">2760: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">variables</span>
<span class="linenr">2761: </span>  checkUseOptions()
<span class="linenr">2762: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">6. remove non-script content</span>
<span class="linenr">2763: </span>  removeNonScriptContent()
<span class="linenr">2764: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">7. analyze binding metadata</span>
<span class="linenr">2765: </span>  analyzeBindingMetadata()
<span class="linenr">2766: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">8. inject `useCssVars` calls</span>
<span class="linenr">2767: </span>  injectUseCssVarsCalls()
<span class="linenr">2768: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">9. finalize setup() argument signature</span>
<span class="linenr">2769: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">args</span> = <span class=
"org-string">`__props`</span>
<span class=
"linenr">2770: </span>  finalizeSetupArgumentSignature()
<span class="linenr">2771: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">10. generate return statement</span>
<span class="linenr">2772: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">returned</span>
<span class="linenr">2773: </span>  generateReturnStatement()
<span class="linenr">2774: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">11. finalize default export</span>
<span class="linenr">2775: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">runtimeOptions</span> = <span class=
"org-string">''</span>
<span class="linenr">2776: </span>  finalizeDefaultExport()
<span class="linenr">2777: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">12. finalize Vue helper imports</span>
<span class="linenr">2778: </span>  finalizeVueHelperImports()
<span class="linenr">2779: </span>
<span class="linenr">2780: </span>  s.trim()
<span class="linenr">2781: </span>
<span class="linenr">2782: </span>  <span class=
"org-keyword">return</span> {
<span class="linenr">2783: </span>    ...scriptSetup,
<span class="linenr">2784: </span>    bindings: bindingMetadata,
<span class="linenr">2785: </span>    imports: userImports,
<span class="linenr">2786: </span>    content: s.toString(),
<span class="linenr">2787: </span>    map: genSourceMap
<span class="linenr">2788: </span>      ? (s.generateMap({
<span class="linenr">2789: </span>          source: filename,
<span class="linenr">2790: </span>          hires: <span class=
"org-constant">true</span>,
<span class=
"linenr">2791: </span>          includeContent: <span class=
"org-constant">true</span>
<span class="linenr">2792: </span>        }))
<span class="linenr">2793: </span>      : <span class=
"org-constant">undefined</span>,
<span class="linenr">2794: </span>    scriptAst: scriptAst?.body,
<span class=
"linenr">2795: </span>    scriptSetupAst: scriptSetupAst?.body
<span class="linenr">2796: </span>  }
<span class="linenr">2797: </span>}
</pre>
      </div>
    </details>
    <div id="outline-container-org756af32" class="outline-2">
      <h2 id="org756af32"><span class="section-number-2">1.</span>
      script</h2>
      <div class="outline-text-2" id="text-1">
        <br>
        <details class="code-details" style=
        "padding: 1em; background-color: #e5f5e5; /* background-color: pink; */ border-radius: 15px; color: hsl(157 75%); font-size: 0.9em; box-shadow: 0.05em 0.1em 5px 0.01em #00000057;">
          <summary>
            <strong><font face="Courier" size="3" color=
            "red">script codes</font></strong>
          </summary>
          <div class="org-src-container">
            <pre class="src src-js" id="org5bb6dd1"><span class=
            "org-doc">/** jsx?|tsx? file header */</span>
<span class="org-keyword">let</span> <span class=
"org-variable-name">debugOn</span> = <span class=
"org-constant">true</span>
<span class="org-keyword">let</span> <span class=
"org-variable-name">currentLogKey</span> = <span class=
"org-string">'cc'</span>
<span class="org-keyword">let</span> <span class=
"org-variable-name">__BROWSER__</span> = <span class=
"org-keyword">typeof</span> window !== <span class=
"org-string">'undefined'</span>
<span class="org-keyword">let</span> <span class=
"org-variable-name">logs</span> = {}
<span class="org-keyword">const</span> <span class=
"org-variable-name">__DEV__</span> = <span class=
"org-constant">true</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">log</span> = (fn, message) =&gt; {
  <span class="org-keyword">if</span> (debugOn) {
    <span class="org-keyword">if</span> (message === <span class=
"org-constant">undefined</span>) {
      console.log(fn)
    } <span class="org-keyword">else</span> {
      console.log(<span class=
"org-string">`[${fn}] ${message}`</span>)
    }
  }
}
<span class="org-keyword">const</span> <span class=
"org-variable-name">logOn</span> = () =&gt; (debugOn = <span class=
"org-constant">true</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">logOff</span> = () =&gt; (debugOn = <span class="org-constant">false</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">logEnd</span> = (hint = <span class=
"org-string">'END'</span>) =&gt; {
  <span class="org-keyword">const</span> <span class=
"org-variable-name">m</span> = <span class=
"org-string">`--------- ${hint} ---------`</span>
  <span class=
"org-keyword">if</span> (debugOn) pushLog(m, <span class=
"org-string">'title'</span>)
  <span class="org-keyword">return</span> m
}
<span class="org-keyword">const</span> <span class=
"org-variable-name">logBr</span> = () =&gt; console.log(<span class="org-string">'\n'</span>)
<span class="org-keyword">let</span> <span class=
"org-variable-name">debugTraverseOn</span> = <span class=
"org-constant">false</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">logTraverseOn</span> = () =&gt; (debugTraverseOn = <span class="org-constant">true</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">logTraverseOff</span> = () =&gt; (debugTraverseOn = <span class="org-constant">false</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">logg</span> = (hint, ...msg) =&gt; {
  <span class=
"org-keyword">if</span> (!debugTraverseOn &amp;& hint === <span class="org-string">'traverseNode'</span>) <span class="org-keyword">return</span>
  <span class="org-keyword">if</span> (debugOn) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">m</span> = logEnd(hint)
    msg.forEach((m) =&gt; pushLog(m))
  }
}
<span class="org-keyword">function</span> <span class=
"org-function-name">pushLog</span>(<span class=
"org-variable-name">m</span>, <span class=
"org-variable-name">type</span> = <span class=
"org-string">'normal'</span>) {
  ;(logs[currentLogKey] || (logs[currentLogKey] = [])).push({ value: m, type })
  log(m)
}
<span class="org-keyword">function</span> <span class=
"org-function-name">clearLog</span>(<span class=
"org-variable-name">key</span>) {
  <span class="org-keyword">if</span> (key) {
    logs[key] = []
  } <span class="org-keyword">else</span> {
    logs = {}
  }
}

<span class="org-keyword">let</span> <span class=
"org-variable-name">w</span> = {}
<span class="org-keyword">let</span> <span class=
"org-variable-name">debugEle</span> = <span class=
"org-constant">null</span>
<span class="org-keyword">if</span> (__BROWSER__) {
  w = <span class=
"org-keyword">typeof</span> window !== <span class=
"org-string">'undefined'</span> ? window : {}
}
w.log = (msg, isLine = <span class=
"org-constant">false</span>) =&gt; {
  <span class="org-keyword">if</span> (debugEle) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">cls</span> = [<span class=
"org-string">'debug'</span>, isLine ? <span class=
"org-string">'line'</span> : <span class=
"org-string">''</span>].filter(Boolen)
    ele.innerHTML = <span class=
"org-string">`${debugEl.innerHTML}&lt;pre class="${cls.join(' ')}"&gt;&lt;code&gt;${</span>
<span class=
"org-string">      typeof msg === 'object' ? syntaxHighlight(msg) : msg</span>
<span class="org-string">    }&lt;/code&gt;&lt;/pre&gt;`</span>
    <span class="org-keyword">return</span> ele.innerHTML
  }
}

<span class="org-keyword">function</span> <span class=
"org-function-name">syntaxHighlight</span>(<span class=
"org-variable-name">json</span>) {
  <span class="org-keyword">if</span> (<span class=
"org-keyword">typeof</span> json != <span class=
"org-string">'string'</span>) {
    json = JSON.stringify(json, <span class=
"org-constant">undefined</span>, <span class=
"org-highlight-numbers-number">2</span>)
  }
  json = json.replace(<span class=
"org-string">/&amp;/</span>g, <span class=
"org-string">'&amp;amp;'</span>).replace(<span class=
"org-string">/&lt;/</span>g, <span class=
"org-string">'&amp;lt;'</span>).replace(<span class=
"org-string">/&gt;/</span>g, <span class=
"org-string">'&amp;gt;'</span>)
  <span class="org-keyword">return</span> json.replace(
    <span class=
"org-string">/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/</span>g,
    <span class="org-keyword">function</span> (<span class=
"org-variable-name">match</span>) {
      <span class="org-keyword">var</span> <span class=
"org-variable-name">cls</span> = <span class=
"org-string">'number'</span>
      <span class="org-keyword">if</span> (<span class=
"org-string">/^"/</span>.test(match)) {
        <span class="org-keyword">if</span> (<span class=
"org-string">/:$/</span>.test(match)) {
          cls = <span class="org-string">'key'</span>
        } <span class="org-keyword">else</span> {
          cls = <span class="org-string">'string'</span>
        }
      } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (<span class=
"org-string">/true|false/</span>.test(match)) {
        cls = <span class="org-string">'boolean'</span>
      } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (<span class=
"org-string">/null/</span>.test(match)) {
        cls = <span class="org-string">'null'</span>
      }
      <span class="org-keyword">return</span> <span class=
"org-string">'&lt;span class="'</span> + cls + <span class=
"org-string">'"&gt;'</span> + match + <span class=
"org-string">'&lt;/span&gt;'</span>
    }
  )
}

<span class="org-keyword">let</span> <span class=
"org-variable-name">babelParser</span>
<span class="org-keyword">if</span> (!__BROWSER__) {
  babelParser = require(process.env.NODE_LIB + <span class=
"org-string">'/@babel/parser'</span>)
}
<span class="org-comment-delimiter">// </span><span class=
"org-comment">The default decoder only provides escapes for characters reserved as part of</span>
<span class="org-comment-delimiter">// </span><span class=
"org-comment">the template syntax, and is only used if the custom renderer did not provide</span>
<span class="org-comment-delimiter">// </span><span class=
"org-comment">a platform-specific decoder.</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">decodeRE</span> = <span class=
"org-string">/&amp;(gt|lt|amp|apos|quot);/</span>g
<span class="org-keyword">const</span> <span class=
"org-variable-name">decodeMap</span> = {
  gt: <span class="org-string">'&gt;'</span>,
  lt: <span class="org-string">'&lt;'</span>,
  amp: <span class="org-string">'&amp;'</span>,
  apos: <span class="org-string">"'"</span>,
  quot: <span class="org-string">'"'</span>
}

<span class="org-keyword">const</span> <span class=
"org-variable-name">EMPTY_OBJ</span> = {}
<span class="org-keyword">const</span> <span class=
"org-variable-name">NO</span> = () =&gt; <span class=
"org-constant">false</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">NOOP</span> = () =&gt; {}
<span class="org-keyword">const</span> <span class=
"org-variable-name">locStub</span> = {
  source: <span class="org-string">''</span>,
  start: { line: <span class=
"org-highlight-numbers-number">1</span>, column: <span class=
"org-highlight-numbers-number">1</span>, offset: <span class=
"org-highlight-numbers-number">0</span> },
  end: { line: <span class=
"org-highlight-numbers-number">1</span>, column: <span class=
"org-highlight-numbers-number">1</span>, offset: <span class=
"org-highlight-numbers-number">0</span> }
}

<span class="org-keyword">const</span> <span class=
"org-variable-name">ConstantTypes</span> = {
  NOT_CONSTANT: <span class=
"org-highlight-numbers-number">0</span>,
  CAN_SKIP_PATCH: <span class=
"org-highlight-numbers-number">1</span>,
  CAN_HOIST: <span class="org-highlight-numbers-number">2</span>,
  CAN_STRINGIFY: <span class=
"org-highlight-numbers-number">3</span>
}

<span class="org-keyword">const</span> <span class=
"org-variable-name">ElementTypes</span> = {
  ELEMENT: <span class="org-highlight-numbers-number">0</span>,
  COMPONENT: <span class="org-highlight-numbers-number">1</span>,
  SLOT: <span class="org-highlight-numbers-number">2</span>,
  TEMPLATE: <span class="org-highlight-numbers-number">3</span>
}

<span class="org-keyword">const</span> <span class=
"org-variable-name">Namespaces</span> = {
  HTML: <span class="org-highlight-numbers-number">0</span>
}

<span class="org-keyword">const</span> <span class=
"org-variable-name">NodeTypes</span> = {
  ROOT: <span class="org-highlight-numbers-number">0</span>,
  ELEMENT: <span class="org-highlight-numbers-number">1</span>,
  TEXT: <span class="org-highlight-numbers-number">2</span>,
  COMMENT: <span class="org-highlight-numbers-number">3</span>,
  SIMPLE_EXPRESSION: <span class=
"org-highlight-numbers-number">4</span>,
  INTERPOLATION: <span class=
"org-highlight-numbers-number">5</span>,
  ATTRIBUTE: <span class="org-highlight-numbers-number">6</span>,
  DIRECTIVE: <span class="org-highlight-numbers-number">7</span>,
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">containers</span>
  COMPOUND_EXPRESSION: <span class=
"org-highlight-numbers-number">8</span>,
  IF: <span class="org-highlight-numbers-number">9</span>,
  IF_BRANCH: <span class="org-highlight-numbers-number">10</span>,
  FOR: <span class="org-highlight-numbers-number">11</span>,
  TEXT_CALL: <span class="org-highlight-numbers-number">12</span>,
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">codegen</span>
  VNODE_CALL: <span class="org-highlight-numbers-number">13</span>,
  JS_CALL_EXPRESSION: <span class=
"org-highlight-numbers-number">14</span>,
  JS_OBJECT_EXPRESSION: <span class=
"org-highlight-numbers-number">15</span>,
  JS_PROPERTY: <span class=
"org-highlight-numbers-number">16</span>,
  JS_ARRAY_EXPRESSION: <span class=
"org-highlight-numbers-number">17</span>,
  JS_FUNCTION_EXPRESSION: <span class=
"org-highlight-numbers-number">18</span>,
  JS_CONDITIONAL_EXPRESSION: <span class=
"org-highlight-numbers-number">19</span>,
  JS_CACHE_EXPRESSION: <span class=
"org-highlight-numbers-number">20</span>,

  <span class="org-comment-delimiter">// </span><span class=
"org-comment">ssr codegen</span>
  JS_BLOCK_STATEMENT: <span class=
"org-highlight-numbers-number">21</span>,
  JS_TEMPLATE_LITERAL: <span class=
"org-highlight-numbers-number">22</span>,
  JS_IF_STATEMENT: <span class=
"org-highlight-numbers-number">23</span>,
  JS_ASSIGNMENT_EXPRESSION: <span class=
"org-highlight-numbers-number">24</span>,
  JS_SEQUENCE_EXPRESSION: <span class=
"org-highlight-numbers-number">25</span>,
  JS_RETURN_STATEMENT: <span class=
"org-highlight-numbers-number">26</span>
}

<span class="org-keyword">const</span> <span class=
"org-variable-name">defaultParserOptions</span> = {
  delimiters: [<span class="org-string">`{{`</span>, <span class=
"org-string">`}}`</span>],
  getNamespace: () =&gt; Namespaces.HTML,
  getTextMode: () =&gt; TextModes.DATA,
  isVoidTag: NO,
  isPreTag: NO,
  isCustomElement: NO,
  decodeEntities: (rawText) =&gt;
    rawText.replace(decodeRE, (_, p1) =&gt; decodeMap[p1]),
  onError: defaultOnError,
  onWarn: defaultOnWarn,
  comments: __DEV__
}

<span class="org-keyword">const</span> <span class=
"org-variable-name">TagType</span> = {
  Start: <span class="org-highlight-numbers-number">0</span>,
  End: <span class="org-highlight-numbers-number">1</span>
}

<span class="org-keyword">const</span> <span class=
"org-variable-name">TextModes</span> = {
  DATA: <span class="org-highlight-numbers-number">0</span>,
  RCDATA: <span class="org-highlight-numbers-number">1</span>,
  RAWTEXT: <span class="org-highlight-numbers-number">2</span>,
  CDATA: <span class="org-highlight-numbers-number">3</span>,
  ATTRIBUTE_VALUE: <span class=
"org-highlight-numbers-number">4</span>
}

<span class="org-keyword">const</span> <span class=
"org-variable-name">extend</span> = Object.assign

<span class="org-keyword">function</span> <span class=
"org-function-name">defaultOnError</span>(<span class=
"org-variable-name">error</span>) {
  <span class="org-keyword">throw</span> error
}

<span class="org-keyword">function</span> <span class=
"org-function-name">defaultOnWarn</span>(<span class=
"org-variable-name">msg</span>) {
  __DEV__ &amp;& console.warn(<span class=
"org-string">`[Vue warn] ${msg.message}`</span>)
}

<span class="org-keyword">function</span> <span class=
"org-function-name">makeMap</span>(<span class=
"org-variable-name">str</span>, <span class=
"org-variable-name">expectsLowerCase</span>) {
  <span class="org-keyword">const</span> <span class=
"org-variable-name">map</span> = Object.create(<span class=
"org-constant">null</span>)
  <span class="org-keyword">const</span> <span class=
"org-variable-name">list</span> = str.split(<span class=
"org-string">','</span>)
  <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; list.length; i++) {
    map[list[i]] = <span class="org-constant">true</span>
  }
  <span class="org-keyword">return</span> expectsLowerCase
    ? (val) =&gt; !!map[val.toLowerCase()]
    : (val) =&gt; !!map[val]
}

<span class="org-keyword">const</span> <span class=
"org-variable-name">hasOwnProperty</span> = Object.<span class=
"org-constant">prototype</span>.hasOwnProperty
<span class="org-keyword">const</span> <span class=
"org-variable-name">hasOwn</span> = (val, key) =&gt; hasOwnProperty.call(val, key)

<span class="org-keyword">const</span> <span class=
"org-variable-name">isArray</span> = Array.isArray
<span class="org-keyword">const</span> <span class=
"org-variable-name">isMap</span> = (val) =&gt; toTypeString(val) === <span class="org-string">'[object Map]'</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">isSet</span> = (val) =&gt; toTypeString(val) === <span class="org-string">'[object Set]'</span>

<span class="org-keyword">const</span> <span class=
"org-variable-name">isDate</span> = (val) =&gt; val <span class=
"org-keyword">instanceof</span> <span class="org-type">Date</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">isFunction</span> = (val) =&gt; <span class=
"org-keyword">typeof</span> val === <span class=
"org-string">'function'</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">isString</span> = (val) =&gt; <span class=
"org-keyword">typeof</span> val === <span class=
"org-string">'string'</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">isSymbol</span> = (val) =&gt; <span class=
"org-keyword">typeof</span> val === <span class=
"org-string">'symbol'</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">isObject</span> = (val) =&gt; val !== <span class="org-constant">null</span> &amp;& <span class="org-keyword">typeof</span> val === <span class="org-string">'object'</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">onRE</span> = <span class=
"org-string">/^on[^a-z]/</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">isOn</span> = (key) =&gt; onRE.test(key)

<span class="org-keyword">const</span> <span class=
"org-variable-name">isPromise</span> = (val) =&gt; {
  <span class=
"org-keyword">return</span> isObject(val) &amp;& isFunction(val.then) &amp;& isFunction(val.<span class="org-keyword">catch</span>)
}

<span class="org-keyword">const</span> <span class=
"org-variable-name">objectToString</span> = Object.<span class=
"org-constant">prototype</span>.toString
<span class="org-keyword">const</span> <span class=
"org-variable-name">toTypeString</span> = (value) =&gt; objectToString.call(value)

<span class="org-keyword">const</span> <span class=
"org-variable-name">toRawType</span> = (value) =&gt; {
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">extract "RawType" from strings like "[object RawType]"</span>
  <span class=
"org-keyword">return</span> toTypeString(value).slice(<span class=
"org-highlight-numbers-number">8</span>, -<span class=
"org-highlight-numbers-number">1</span>)
}

<span class="org-keyword">function</span> <span class=
"org-function-name">isText</span>(<span class=
"org-variable-name">node</span>) {
<span id="coderef-isText" class="coderef-off">  <span class=
"org-comment-delimiter">//</span> (isText)</span>
  <span class=
"org-keyword">return</span> node.type === NodeTypes.INTERPOLATION || node.type === NodeTypes.TEXT
}

<span class="org-keyword">const</span> <span class=
"org-variable-name">isPlainObject</span> = (val) =&gt; toTypeString(val) === <span class="org-string">'[object Object]'</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">isIntegerKey</span> = (key) =&gt;
  isString(key) &amp;&
  key !== <span class="org-string">'NaN'</span> &amp;&
  key[<span class=
"org-highlight-numbers-number">0</span>] !== <span class=
"org-string">'-'</span> &amp;&
  <span class="org-string">''</span> + parseInt(key, <span class=
"org-highlight-numbers-number">10</span>) === key

<span class="org-keyword">const</span> <span class=
"org-variable-name">isReservedProp</span> = <span class=
"org-comment-delimiter">/*</span><span class=
"org-comment">#__PURE__</span><span class=
"org-comment-delimiter">*/</span> makeMap(
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">the leading comma is intentional so empty string "" is also included</span>
  <span class="org-string">',key,ref,ref_for,ref_key,'</span> +
    <span class=
"org-string">'onVnodeBeforeMount,onVnodeMounted,'</span> +
    <span class=
"org-string">'onVnodeBeforeUpdate,onVnodeUpdated,'</span> +
    <span class=
"org-string">'onVnodeBeforeUnmount,onVnodeUnmounted'</span>
)

<span class="org-keyword">const</span> <span class=
"org-variable-name">GLOBALS_WHITE_LISTED</span> =
  <span class=
"org-string">'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,'</span> +
  <span class=
"org-string">'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,'</span> +
  <span class=
"org-string">'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt'</span>

<span class="org-keyword">const</span> <span class=
"org-variable-name">isGloballyWhitelisted</span> = <span class=
"org-comment-delimiter">/*</span><span class=
"org-comment">#__PURE__</span><span class=
"org-comment-delimiter">*/</span> makeMap(GLOBALS_WHITE_LISTED)

<span class="org-keyword">const</span> <span class=
"org-variable-name">nonIdentifierRE</span> = <span class=
"org-string">/^\d|[^\$\w]/</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">isSimpleIdentifier</span> = (name) =&gt; !nonIdentifierRE.test(name)

<span class="org-keyword">const</span> <span class=
"org-variable-name">isBuiltInDirective</span> = <span class=
"org-comment-delimiter">/*</span><span class=
"org-comment">#__PURE__</span><span class=
"org-comment-delimiter">*/</span> makeMap(
  <span class=
"org-string">'bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo'</span>
)

<span class="org-keyword">function</span> <span class=
"org-function-name">getCursor</span>(<span class=
"org-variable-name">context</span>) {
  <span class=
"org-keyword">const</span> { column, line, offset } = context
  <span class="org-keyword">return</span> { column, line, offset }
}

<span class="org-keyword">function</span> <span class=
"org-function-name">getSelection</span>(<span class=
"org-variable-name">context</span>, <span class=
"org-variable-name">start</span>, <span class=
"org-variable-name">end</span>) {
  end = end || getCursor(context)
  <span class="org-keyword">return</span> {
    start,
    end,
    source: context.originalSource.slice(start.offset, end.offset)
  }
}

<span class="org-keyword">function</span> <span class=
"org-function-name">last</span>(<span class=
"org-variable-name">xs</span>) {
  <span class=
"org-keyword">return</span> xs[xs.length - <span class=
"org-highlight-numbers-number">1</span>]
}

<span class="org-keyword">function</span> <span class=
"org-function-name">startsWith</span>(<span class=
"org-variable-name">source</span>, <span class=
"org-variable-name">searchString</span>) {
  <span class=
"org-keyword">return</span> source.startsWith(searchString)
}

<span class="org-keyword">function</span> <span class=
"org-function-name">advancePositionWithMutation</span>(
  <span class="org-variable-name">pos</span>,
  <span class="org-variable-name">source</span>,
  numberOfCharacters = source.length
) {
  <span class="org-keyword">let</span> <span class=
"org-variable-name">linesCount</span> = <span class=
"org-highlight-numbers-number">0</span>
  <span class="org-keyword">let</span> <span class=
"org-variable-name">lastNewLinePos</span> = -<span class=
"org-highlight-numbers-number">1</span>
  <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; numberOfCharacters; i++) {
    <span class=
"org-keyword">if</span> (source.charCodeAt(i) === <span class=
"org-highlight-numbers-number">10</span> <span class=
"org-comment-delimiter">/* </span><span class=
"org-comment">newline char code</span><span class=
"org-comment-delimiter"> */</span>) {
      linesCount++
      lastNewLinePos = i
    }
  }

  pos.offset += numberOfCharacters
  pos.line += linesCount
  pos.column =
    lastNewLinePos === -<span class=
"org-highlight-numbers-number">1</span>
      ? pos.column + numberOfCharacters
      : numberOfCharacters - lastNewLinePos

  <span class="org-keyword">return</span> pos
}

<span class="org-keyword">function</span> <span class=
"org-function-name">advancePositionWithClone</span>(
  <span class="org-variable-name">pos</span>,
  <span class="org-variable-name">source</span>,
  numberOfCharacters = source.length
) {
  <span class=
"org-keyword">return</span> advancePositionWithMutation(
    extend({}, pos),
    source,
    numberOfCharacters
  )
}

<span class="org-keyword">function</span> <span class=
"org-function-name">advanceBy</span>(<span class=
"org-variable-name">context</span>, <span class=
"org-variable-name">numberOfCharacters</span>) {
  <span class="org-keyword">const</span> { source } = context
  advancePositionWithMutation(context, source, numberOfCharacters)
  context.source = source.slice(numberOfCharacters)
}

<span class="org-keyword">function</span> <span class=
"org-function-name">advanceSpaces</span>(<span class=
"org-variable-name">context</span>) {
  <span class="org-keyword">const</span> <span class=
"org-variable-name">match</span> = <span class=
"org-string">/^[\t\r\n\f ]+/</span>.exec(context.source)
  <span class="org-keyword">if</span> (match) {
    advanceBy(context, match[<span class=
"org-highlight-numbers-number">0</span>].length)
  }
}

<span class="org-keyword">function</span> <span class=
"org-function-name">getNewPosition</span>(<span class=
"org-variable-name">context</span>, <span class=
"org-variable-name">start</span>, <span class=
"org-variable-name">numberOfCharacters</span>) {
  <span class="org-keyword">return</span> advancePositionWithClone(
    start,
    context.originalSource.slice(start.offset, numberOfCharacters),
    numberOfCharacters
  )
}

<span class="org-keyword">function</span> <span class=
"org-function-name">emitError</span>(<span class=
"org-variable-name">context</span>, <span class=
"org-variable-name">code</span>, <span class=
"org-variable-name">offset</span>, <span class=
"org-variable-name">loc</span> = <span class=
"org-variable-name">getCursor</span>(<span class=
"org-variable-name">context</span>)) {
  <span class="org-keyword">if</span> (offset) {
    loc.offset += offset
    loc.column += offset
  }
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">ignore...</span>
}

<span class="org-keyword">function</span> <span class=
"org-function-name">isEnd</span>(<span class=
"org-variable-name">context</span>, <span class=
"org-variable-name">mode</span>, <span class=
"org-variable-name">ancestors</span>) {
  <span class="org-keyword">const</span> <span class=
"org-variable-name">s</span> = context.source

  <span class="org-keyword">switch</span> (mode) {
    <span class="org-keyword">case</span> TextModes.DATA:
      <span class=
"org-keyword">if</span> (startsWith(s, <span class=
"org-string">'&lt;/'</span>)) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment"><span class="org-bold"><span class=
"org-warning">TODO:</span></span></span><span class=
"org-comment"> probably bad performance</span>
        <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = ancestors.length - <span class=
"org-highlight-numbers-number">1</span>; i &gt;= <span class=
"org-highlight-numbers-number">0</span>; --i) {
          <span class=
"org-keyword">if</span> (startsWithEndTagOpen(s, ancestors[i].tag)) {
            <span class="org-keyword">return</span> <span class=
"org-constant">true</span>
          }
        }
      }
      <span class="org-keyword">break</span>

    <span class="org-keyword">case</span> TextModes.RCDATA:
    <span class="org-keyword">case</span> TextModes.RAWTEXT: {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">parent</span> = last(ancestors)
      <span class=
"org-keyword">if</span> (parent &amp;& startsWithEndTagOpen(s, parent.tag)) {
        <span class="org-keyword">return</span> <span class=
"org-constant">true</span>
      }
      <span class="org-keyword">break</span>
    }

    <span class="org-keyword">case</span> TextModes.CDATA:
      <span class=
"org-keyword">if</span> (startsWith(s, <span class=
"org-string">']]&gt;'</span>)) {
        <span class="org-keyword">return</span> <span class=
"org-constant">true</span>
      }
      <span class="org-keyword">break</span>
  }

  <span class="org-keyword">return</span> !s
}

<span class="org-keyword">function</span> <span class=
"org-function-name">startsWithEndTagOpen</span>(<span class=
"org-variable-name">source</span>, <span class=
"org-variable-name">tag</span>) {
  <span class="org-keyword">return</span> (
    startsWith(source, <span class=
"org-string">'&lt;/'</span>) &amp;&
    source.slice(<span class=
"org-highlight-numbers-number">2</span>, <span class=
"org-highlight-numbers-number">2</span> + tag.length).toLowerCase() === tag.toLowerCase() &amp;&
    /[\t\r\n\f /&gt;]/.test(source[<span class=
"org-highlight-numbers-number">2</span> + tag.length] || <span class="org-string">'&gt;'</span>)
  )
}

<span class="org-keyword">const</span> <span class=
"org-variable-name">cacheStringFunction</span> = (fn) =&gt; {
  <span class="org-keyword">const</span> <span class=
"org-variable-name">cache</span> = Object.create(<span class=
"org-constant">null</span>)
  <span class="org-keyword">return</span> (str) =&gt; {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">hit</span> = cache[str]
    <span class=
"org-keyword">return</span> hit || (cache[str] = fn(str))
  }
}

<span class="org-keyword">const</span> <span class=
"org-variable-name">camelizeRE</span> = <span class=
"org-string">/-(\w)/</span>g
<span class="org-keyword">const</span> <span class=
"org-variable-name">camelize</span> = cacheStringFunction((str) =&gt; {
  <span class=
"org-keyword">return</span> str.replace(camelizeRE, (_, c) =&gt; (c ? c.toUpperCase() : <span class="org-string">''</span>))
})

<span class="org-keyword">const</span> <span class=
"org-variable-name">hyphenateRE</span> = <span class=
"org-string">/\B([A-Z])/</span>g
<span class="org-keyword">const</span> <span class=
"org-variable-name">hyphenate</span> = cacheStringFunction((str) =&gt;
  str.replace(hyphenateRE, <span class=
"org-string">'-$1'</span>).toLowerCase()
)
<span class="org-keyword">const</span> <span class=
"org-variable-name">capitalize</span> = cacheStringFunction(
  (str) =&gt; str.charAt(<span class=
"org-highlight-numbers-number">0</span>).toUpperCase() + str.slice(<span class="org-highlight-numbers-number">1</span>)
)
<span class="org-keyword">const</span> <span class=
"org-variable-name">toHandlerKey</span> = cacheStringFunction((str) =&gt;
  str ? <span class=
"org-string">`on${capitalize(str)}`</span> : <span class=
"org-string">``</span>
)

<span class="org-keyword">const</span> <span class=
"org-variable-name">isBuiltInType</span> = (tag, expected) =&gt;
  tag === expected || tag === hyphenate(expected)

<span class="org-keyword">function</span> <span class=
"org-function-name">isCoreComponent</span>(<span class=
"org-variable-name">tag</span>) {
  <span class=
"org-keyword">if</span> (isBuiltInType(tag, <span class=
"org-string">'Teleport'</span>)) {
    <span class="org-keyword">return</span> TELEPORT
  } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (isBuiltInType(tag, <span class=
"org-string">'Suspense'</span>)) {
    <span class="org-keyword">return</span> SUSPENSE
  } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (isBuiltInType(tag, <span class=
"org-string">'KeepAlive'</span>)) {
    <span class="org-keyword">return</span> KEEP_ALIVE
  } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (isBuiltInType(tag, <span class=
"org-string">'BaseTransition'</span>)) {
    <span class="org-keyword">return</span> BASE_TRANSITION
  }
}

<span class="org-keyword">const</span> <span class=
"org-variable-name">isSpecialTemplateDirective</span> = <span class="org-comment-delimiter">/*</span><span class="org-comment">#__PURE__</span><span class="org-comment-delimiter">*/</span> makeMap(
  <span class="org-string">`if,else,else-if,for,slot`</span>
)

<span class="org-keyword">function</span> <span class=
"org-function-name">getVNodeHelper</span>(<span class=
"org-variable-name">ssr</span>, <span class=
"org-variable-name">isComponent</span>) {
  <span class=
"org-keyword">return</span> ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE
}

<span class="org-keyword">function</span> <span class=
"org-function-name">getVNodeBlockHelper</span>(<span class=
"org-variable-name">ssr</span>, <span class=
"org-variable-name">isComponent</span>) {
  <span class=
"org-keyword">return</span> ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK
}

<span class="org-keyword">function</span> <span class=
"org-function-name">isSingleElementRoot</span>(<span class=
"org-variable-name">root</span>, <span class=
"org-variable-name">child</span>) {
  <span class="org-keyword">const</span> { children } = root
  <span class="org-keyword">return</span> (
    children.length === <span class=
"org-highlight-numbers-number">1</span> &amp;&
    child.type === NodeTypes.ELEMENT &amp;&
    !isSlotOutlet(child)
  )
}

<span class="org-keyword">function</span> <span class=
"org-function-name">isSlotOutlet</span>(<span class=
"org-variable-name">node</span>) {
  <span class=
"org-keyword">return</span> node.type === NodeTypes.ELEMENT &amp;& node.tagType === ElementTypes.SLOT
}

<span class="org-keyword">function</span> <span class=
"org-function-name">findDir</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">name</span>, <span class=
"org-variable-name">allowEmpty</span> = <span class=
"org-constant">false</span>) {
  <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; node.props.length; i++) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">p</span> = node.props[i]
    <span class="org-keyword">if</span> (
      p.type === NodeTypes.DIRECTIVE &amp;&
      (allowEmpty || p.exp) &amp;&
      (isString(name) ? p.name === name : name.test(p.name))
    ) {
      <span class="org-keyword">return</span> p
    }
  }
}

<span class="org-keyword">function</span> <span class=
"org-function-name">findProp</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">name</span>, <span class=
"org-variable-name">dynamicOnly</span> = <span class=
"org-constant">false</span>, <span class=
"org-variable-name">allowEmpty</span> = <span class=
"org-constant">false</span>) {
  <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; node.props.length; i++) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">p</span> = node.props[i]
    <span class=
"org-keyword">if</span> (p.type === NodeTypes.ATTRIBUTE) {
      <span class=
"org-keyword">if</span> (dynamicOnly) <span class="org-keyword">continue</span>
      <span class=
"org-keyword">if</span> (p.name === name &amp;& (p.value || allowEmpty)) {
        <span class="org-keyword">return</span> p
      }
    } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (
      p.name === <span class="org-string">'bind'</span> &amp;&
      (p.exp || allowEmpty) &amp;&
      isStaticArgOf(p.arg, name)
    ) {
      <span class="org-keyword">return</span> p
    }
  }
}

<span class="org-keyword">const</span> <span class=
"org-variable-name">isStaticExp</span> = (p) =&gt; p.type === NodeTypes.SIMPLE_EXPRESSION &amp;& p.isStatic

<span class="org-keyword">function</span> <span class=
"org-function-name">isStaticArgOf</span>(<span class=
"org-variable-name">arg</span>, <span class=
"org-variable-name">name</span>) {
  <span class=
"org-keyword">return</span> !!(arg &amp;& isStaticExp(arg) &amp;& arg.content === name)
}

<span class="org-keyword">function</span> <span class=
"org-function-name">isVSlot</span>(<span class=
"org-variable-name">p</span>) {
  <span class=
"org-keyword">return</span> p.type === NodeTypes.DIRECTIVE &amp;& p.name === <span class="org-string">'slot'</span>
}

<span class="org-keyword">function</span> <span class=
"org-function-name">getMemoedVNodeCall</span>(<span class=
"org-variable-name">node</span>) {
  <span class=
"org-keyword">if</span> (node.type === NodeTypes.JS_CALL_EXPRESSION &amp;& node.callee === WITH_MEMO) {
    <span class="org-keyword">return</span> node.<span class=
"org-constant">arguments</span>[<span class=
"org-highlight-numbers-number">1</span>].returns
  } <span class="org-keyword">else</span> {
    <span class="org-keyword">return</span> node
  }
}

<span class="org-keyword">function</span> <span class=
"org-function-name">getInnerRange</span>(<span class=
"org-variable-name">loc</span>, <span class=
"org-variable-name">offset</span>, <span class=
"org-variable-name">length</span>) {
  <span class="org-keyword">const</span> <span class=
"org-variable-name">source</span> = loc.source.slice(offset, offset + length)
  <span class="org-keyword">const</span> <span class=
"org-variable-name">newLoc</span> = {
    source,
    start: advancePositionWithClone(loc.start, loc.source, offset),
    end: loc.end
  }

  <span class="org-keyword">if</span> (length != <span class=
"org-constant">null</span>) {
    newLoc.end = advancePositionWithClone(
      loc.start,
      loc.source,
      offset + length
    )
  }

  <span class="org-keyword">return</span> newLoc
}

<span class="org-keyword">function</span> <span class=
"org-function-name">toValidAssetId</span>(<span class=
"org-variable-name">name</span>, <span class=
"org-variable-name">type</span>) {
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">see issue#4422, we need adding identifier on validAssetId if variable `name` has specific character</span>
  <span class="org-keyword">return</span> <span class=
"org-string">`_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) =&gt; {</span>
<span class=
"org-string">    return searchValue === '-' ? '_' : name.charCodeAt(replaceValue).toString()</span>
<span class="org-string">  })}`</span>
}

<span class="org-keyword">function</span> <span class=
"org-function-name">isTemplateNode</span>(<span class=
"org-variable-name">node</span>) {
  <span class="org-keyword">return</span> (
    node.type === NodeTypes.ELEMENT &amp;& node.tagType === ElementTypes.TEMPLATE
  )
}

<span class="org-keyword">function</span> <span class=
"org-function-name">isComponent</span>(<span class=
"org-variable-name">tag</span>, <span class=
"org-variable-name">props</span>, <span class=
"org-variable-name">context</span>) {
  <span class="org-keyword">const</span> <span class=
"org-variable-name">options</span> = context.options
  <span class=
"org-keyword">if</span> (options.isCustomElement(tag)) {
    <span class="org-keyword">return</span> <span class=
"org-constant">false</span>
  }
  <span class="org-keyword">if</span> (
    tag === <span class="org-string">'component'</span> ||
    /^[A-Z]/.test(tag) ||
    isCoreComponent(tag) ||
    (options.isBuiltInComponent &amp;& options.isBuiltInComponent(tag)) ||
    (options.isNativeTag &amp;& !options.isNativeTag(tag))
  ) {
    <span class="org-keyword">return</span> <span class=
"org-constant">true</span>
  }
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">at this point the tag should be a native tag, but check for potential "is"</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">casting</span>
  <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; props.length; i++) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">p</span> = props[i]
    <span class=
"org-keyword">if</span> (p.type === NodeTypes.ATTRIBUTE) {
      <span class="org-keyword">if</span> (p.name === <span class=
"org-string">'is'</span> &amp;& p.value) {
        <span class=
"org-keyword">if</span> (p.value.content.startsWith(<span class=
"org-string">'vue:'</span>)) {
          <span class="org-keyword">return</span> <span class=
"org-constant">true</span>
        }
      }
    } <span class="org-keyword">else</span> {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">directive</span>
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">v-is (</span><span class="org-comment"><span class=
"org-bold"><span class=
"org-warning">TODO</span></span></span><span class=
"org-comment"> Deprecate)</span>
      <span class="org-keyword">if</span> (p.name === <span class=
"org-string">'is'</span>) {
        <span class="org-keyword">return</span> <span class=
"org-constant">true</span>
      }
    }
  }
}

<span class="org-keyword">function</span> <span class=
"org-function-name">pushNode</span>(<span class=
"org-variable-name">nodes</span>, <span class=
"org-variable-name">node</span>) {
  <span class=
"org-keyword">if</span> (node.type === NodeTypes.TEXT) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">prev</span> = last(nodes)
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">Merge if both this and the previous node are text and those are</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">consecutive. This happens for cases like "a &lt; b".</span>
    <span class="org-keyword">if</span> (
      prev &amp;&
      prev.type === NodeTypes.TEXT &amp;&
      prev.loc.end.offset === node.loc.start.offset
    ) {
      prev.content += node.content
      prev.loc.end = node.loc.end
      prev.loc.source += node.loc.source
      <span class="org-keyword">return</span>
    }
  }

  nodes.push(node)
}

<span class="org-keyword">const</span> <span class=
"org-variable-name">FRAGMENT</span> = Symbol(__DEV__ ? <span class=
"org-string">`Fragment`</span> : <span class=
"org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">TELEPORT</span> = Symbol(__DEV__ ? <span class=
"org-string">`Teleport`</span> : <span class=
"org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">SUSPENSE</span> = Symbol(__DEV__ ? <span class=
"org-string">`Suspense`</span> : <span class=
"org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">KEEP_ALIVE</span> = Symbol(__DEV__ ? <span class="org-string">`KeepAlive`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">BASE_TRANSITION</span> = Symbol(__DEV__ ? <span class="org-string">`BaseTransition`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">OPEN_BLOCK</span> = Symbol(__DEV__ ? <span class="org-string">`openBlock`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">CREATE_BLOCK</span> = Symbol(__DEV__ ? <span class="org-string">`createBlock`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">CREATE_ELEMENT_BLOCK</span> = Symbol(__DEV__ ? <span class="org-string">`createElementBlock`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">CREATE_VNODE</span> = Symbol(__DEV__ ? <span class="org-string">`createVNode`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">CREATE_ELEMENT_VNODE</span> = Symbol(__DEV__ ? <span class="org-string">`createElementVNode`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">CREATE_COMMENT</span> = Symbol(__DEV__ ? <span class="org-string">`createCommentVNode`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">CREATE_TEXT</span> = Symbol(__DEV__ ? <span class="org-string">`createTextVNode`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">CREATE_STATIC</span> = Symbol(__DEV__ ? <span class="org-string">`createStaticVNode`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">RESOLVE_COMPONENT</span> = Symbol(__DEV__ ? <span class="org-string">`resolveComponent`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">RESOLVE_DYNAMIC_COMPONENT</span> = Symbol(
  __DEV__ ? <span class=
"org-string">`resolveDynamicComponent`</span> : <span class=
"org-string">``</span>
)
<span class="org-keyword">const</span> <span class=
"org-variable-name">RESOLVE_DIRECTIVE</span> = Symbol(__DEV__ ? <span class="org-string">`resolveDirective`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">RESOLVE_FILTER</span> = Symbol(__DEV__ ? <span class="org-string">`resolveFilter`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">WITH_DIRECTIVES</span> = Symbol(__DEV__ ? <span class="org-string">`withDirectives`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">RENDER_LIST</span> = Symbol(__DEV__ ? <span class="org-string">`renderList`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">RENDER_SLOT</span> = Symbol(__DEV__ ? <span class="org-string">`renderSlot`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">CREATE_SLOTS</span> = Symbol(__DEV__ ? <span class="org-string">`createSlots`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">TO_DISPLAY_STRING</span> = Symbol(__DEV__ ? <span class="org-string">`toDisplayString`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">MERGE_PROPS</span> = Symbol(__DEV__ ? <span class="org-string">`mergeProps`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">NORMALIZE_CLASS</span> = Symbol(__DEV__ ? <span class="org-string">`normalizeClass`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">NORMALIZE_STYLE</span> = Symbol(__DEV__ ? <span class="org-string">`normalizeStyle`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">NORMALIZE_PROPS</span> = Symbol(__DEV__ ? <span class="org-string">`normalizeProps`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">GUARD_REACTIVE_PROPS</span> = Symbol(__DEV__ ? <span class="org-string">`guardReactiveProps`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">TO_HANDLERS</span> = Symbol(__DEV__ ? <span class="org-string">`toHandlers`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">CAMELIZE</span> = Symbol(__DEV__ ? <span class=
"org-string">`camelize`</span> : <span class=
"org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">CAPITALIZE</span> = Symbol(__DEV__ ? <span class="org-string">`capitalize`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">TO_HANDLER_KEY</span> = Symbol(__DEV__ ? <span class="org-string">`toHandlerKey`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">SET_BLOCK_TRACKING</span> = Symbol(__DEV__ ? <span class="org-string">`setBlockTracking`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">PUSH_SCOPE_ID</span> = Symbol(__DEV__ ? <span class="org-string">`pushScopeId`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">POP_SCOPE_ID</span> = Symbol(__DEV__ ? <span class="org-string">`popScopeId`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">WITH_CTX</span> = Symbol(__DEV__ ? <span class=
"org-string">`withCtx`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">UNREF</span> = Symbol(__DEV__ ? <span class=
"org-string">`unref`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">IS_REF</span> = Symbol(__DEV__ ? <span class=
"org-string">`isRef`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">WITH_MEMO</span> = Symbol(__DEV__ ? <span class="org-string">`withMemo`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">IS_MEMO_SAME</span> = Symbol(__DEV__ ? <span class="org-string">`isMemoSame`</span> : <span class="org-string">``</span>)

<span class="org-comment-delimiter">// </span><span class=
"org-comment">Name mapping for runtime helpers that need to be imported from 'vue' in</span>
<span class="org-comment-delimiter">// </span><span class=
"org-comment">generated code. Make sure these are correctly exported in the runtime!</span>
<span class="org-comment-delimiter">// </span><span class=
"org-comment">Using `any` here because TS doesn't allow symbols as index type.</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">helperNameMap</span> = {
  [FRAGMENT]: <span class="org-string">`Fragment`</span>,
  [TELEPORT]: <span class="org-string">`Teleport`</span>,
  [SUSPENSE]: <span class="org-string">`Suspense`</span>,
  [KEEP_ALIVE]: <span class="org-string">`KeepAlive`</span>,
  [BASE_TRANSITION]: <span class=
"org-string">`BaseTransition`</span>,
  [OPEN_BLOCK]: <span class="org-string">`openBlock`</span>,
  [CREATE_BLOCK]: <span class="org-string">`createBlock`</span>,
  [CREATE_ELEMENT_BLOCK]: <span class=
"org-string">`createElementBlock`</span>,
  [CREATE_VNODE]: <span class="org-string">`createVNode`</span>,
  [CREATE_ELEMENT_VNODE]: <span class=
"org-string">`createElementVNode`</span>,
  [CREATE_COMMENT]: <span class=
"org-string">`createCommentVNode`</span>,
  [CREATE_TEXT]: <span class="org-string">`createTextVNode`</span>,
  [CREATE_STATIC]: <span class=
"org-string">`createStaticVNode`</span>,
  [RESOLVE_COMPONENT]: <span class=
"org-string">`resolveComponent`</span>,
  [RESOLVE_DYNAMIC_COMPONENT]: <span class=
"org-string">`resolveDynamicComponent`</span>,
  [RESOLVE_DIRECTIVE]: <span class=
"org-string">`resolveDirective`</span>,
  [RESOLVE_FILTER]: <span class=
"org-string">`resolveFilter`</span>,
  [WITH_DIRECTIVES]: <span class=
"org-string">`withDirectives`</span>,
  [RENDER_LIST]: <span class="org-string">`renderList`</span>,
  [RENDER_SLOT]: <span class="org-string">`renderSlot`</span>,
  [CREATE_SLOTS]: <span class="org-string">`createSlots`</span>,
  [TO_DISPLAY_STRING]: <span class=
"org-string">`toDisplayString`</span>,
  [MERGE_PROPS]: <span class="org-string">`mergeProps`</span>,
  [NORMALIZE_CLASS]: <span class=
"org-string">`normalizeClass`</span>,
  [NORMALIZE_STYLE]: <span class=
"org-string">`normalizeStyle`</span>,
  [NORMALIZE_PROPS]: <span class=
"org-string">`normalizeProps`</span>,
  [GUARD_REACTIVE_PROPS]: <span class=
"org-string">`guardReactiveProps`</span>,
  [TO_HANDLERS]: <span class="org-string">`toHandlers`</span>,
  [CAMELIZE]: <span class="org-string">`camelize`</span>,
  [CAPITALIZE]: <span class="org-string">`capitalize`</span>,
  [TO_HANDLER_KEY]: <span class="org-string">`toHandlerKey`</span>,
  [SET_BLOCK_TRACKING]: <span class=
"org-string">`setBlockTracking`</span>,
  [PUSH_SCOPE_ID]: <span class="org-string">`pushScopeId`</span>,
  [POP_SCOPE_ID]: <span class="org-string">`popScopeId`</span>,
  [WITH_CTX]: <span class="org-string">`withCtx`</span>,
  [UNREF]: <span class="org-string">`unref`</span>,
  [IS_REF]: <span class="org-string">`isRef`</span>,
  [WITH_MEMO]: <span class="org-string">`withMemo`</span>,
  [IS_MEMO_SAME]: <span class="org-string">`isMemoSame`</span>
}

<span class="org-keyword">function</span> <span class=
"org-function-name">registerRuntimeHelpers</span>(<span class=
"org-variable-name">helpers</span>) {
  Object.getOwnPropertySymbols(helpers).forEach((s) =&gt; {
    helperNameMap[s] = helpers[s]
  })
}

<span class="org-doc">/**</span>
<span class=
"org-doc"> * Patch flags are optimization hints generated by the compiler.</span>
<span class=
"org-doc"> * when a block with dynamicChildren is encountered during diff, the algorithm</span>
<span class=
"org-doc"> * enters "optimized mode". In this mode, we know that the vdom is produced by</span>
<span class=
"org-doc"> * a render function generated by the compiler, so the algorithm only needs to</span>
<span class=
"org-doc"> * handle updates explicitly marked by these patch flags.</span>
<span class="org-doc"> *</span>
<span class=
"org-doc"> * Patch flags can be combined using the | bitwise operator and can be checked</span>
<span class="org-doc"> * using the & operator, e.g.</span>
<span class="org-doc"> *</span>
<span class="org-doc"> * ```js</span>
<span class="org-doc"> * const flag = TEXT | CLASS</span>
<span class="org-doc"> * if (flag & TEXT) { ... }</span>
<span class="org-doc"> * ```</span>
<span class="org-doc"> *</span>
<span class=
"org-doc"> * Check the `patchElement` function in '../../runtime-core/src/renderer.ts' to see how the</span>
<span class="org-doc"> * flags are handled during diff.</span>
<span class="org-doc"> */</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">PatchFlags</span> = {
  <span class="org-doc">/**</span>
<span class=
"org-doc">   * Indicates an element with dynamic textContent (children fast path)</span>
<span class="org-doc">   */</span>
  TEXT: <span class="org-highlight-numbers-number">1</span>,

  <span class="org-doc">/**</span>
<span class=
"org-doc">   * Indicates an element with dynamic class binding.</span>
<span class="org-doc">   */</span>
  CLASS: <span class=
"org-highlight-numbers-number">1</span> &lt;&lt; <span class=
"org-highlight-numbers-number">1</span>,

  <span class="org-doc">/**</span>
<span class=
"org-doc">   * Indicates an element with dynamic style</span>
<span class=
"org-doc">   * The compiler pre-compiles static string styles into static objects</span>
<span class=
"org-doc">   * + detects and hoists inline static objects</span>
<span class=
"org-doc">   * e.g. `style="color: red"` and `:style="{ color: 'red' }"` both get hoisted</span>
<span class="org-doc">   * as:</span>
<span class="org-doc">   * ```js</span>
<span class="org-doc">   * const style = { color: 'red' }</span>
<span class=
"org-doc">   * render() { return e('div', { style }) }</span>
<span class="org-doc">   * ```</span>
<span class="org-doc">   */</span>
  STYLE: <span class=
"org-highlight-numbers-number">1</span> &lt;&lt; <span class=
"org-highlight-numbers-number">2</span>,

  <span class="org-doc">/**</span>
<span class=
"org-doc">   * Indicates an element that has non-class/style dynamic props.</span>
<span class=
"org-doc">   * Can also be on a component that has any dynamic props (includes</span>
<span class=
"org-doc">   * class/style). when this flag is present, the vnode also has a dynamicProps</span>
<span class=
"org-doc">   * array that contains the keys of the props that may change so the runtime</span>
<span class=
"org-doc">   * can diff them faster (without having to worry about removed props)</span>
<span class="org-doc">   */</span>
  PROPS: <span class=
"org-highlight-numbers-number">1</span> &lt;&lt; <span class=
"org-highlight-numbers-number">3</span>,

  <span class="org-doc">/**</span>
<span class=
"org-doc">   * Indicates an element with props with dynamic keys. When keys change, a full</span>
<span class=
"org-doc">   * diff is always needed to remove the old key. This flag is mutually</span>
<span class=
"org-doc">   * exclusive with CLASS, STYLE and PROPS.</span>
<span class="org-doc">   */</span>
  FULL_PROPS: <span class=
"org-highlight-numbers-number">1</span> &lt;&lt; <span class=
"org-highlight-numbers-number">4</span>,

  <span class="org-doc">/**</span>
<span class=
"org-doc">   * Indicates an element with event listeners (which need to be attached</span>
<span class="org-doc">   * during hydration)</span>
<span class="org-doc">   */</span>
  HYDRATE_EVENTS: <span class=
"org-highlight-numbers-number">1</span> &lt;&lt; <span class=
"org-highlight-numbers-number">5</span>,

  <span class="org-doc">/**</span>
<span class=
"org-doc">   * Indicates a fragment whose children order doesn't change.</span>
<span class="org-doc">   */</span>
  STABLE_FRAGMENT: <span class=
"org-highlight-numbers-number">1</span> &lt;&lt; <span class=
"org-highlight-numbers-number">6</span>,

  <span class="org-doc">/**</span>
<span class=
"org-doc">   * Indicates a fragment with keyed or partially keyed children</span>
<span class="org-doc">   */</span>
  KEYED_FRAGMENT: <span class=
"org-highlight-numbers-number">1</span> &lt;&lt; <span class=
"org-highlight-numbers-number">7</span>,

  <span class="org-doc">/**</span>
<span class=
"org-doc">   * Indicates a fragment with unkeyed children.</span>
<span class="org-doc">   */</span>
  UNKEYED_FRAGMENT: <span class=
"org-highlight-numbers-number">1</span> &lt;&lt; <span class=
"org-highlight-numbers-number">8</span>,

  <span class="org-doc">/**</span>
<span class=
"org-doc">   * Indicates an element that only needs non-props patching, e.g. ref or</span>
<span class=
"org-doc">   * directives (onVnodeXXX hooks). since every patched vnode checks for refs</span>
<span class=
"org-doc">   * and onVnodeXXX hooks, it simply marks the vnode so that a parent block</span>
<span class="org-doc">   * will track it.</span>
<span class="org-doc">   */</span>
  NEED_PATCH: <span class=
"org-highlight-numbers-number">1</span> &lt;&lt; <span class=
"org-highlight-numbers-number">9</span>,

  <span class="org-doc">/**</span>
<span class=
"org-doc">   * Indicates a component with dynamic slots (e.g. slot that references a v-for</span>
<span class=
"org-doc">   * iterated value, or dynamic slot names).</span>
<span class=
"org-doc">   * Components with this flag are always force updated.</span>
<span class="org-doc">   */</span>
  DYNAMIC_SLOTS: <span class=
"org-highlight-numbers-number">1</span> &lt;&lt; <span class=
"org-highlight-numbers-number">10</span>,

  <span class="org-doc">/**</span>
<span class=
"org-doc">   * Indicates a fragment that was created only because the user has placed</span>
<span class=
"org-doc">   * comments at the root level of a template. This is a dev-only flag since</span>
<span class=
"org-doc">   * comments are stripped in production.</span>
<span class="org-doc">   */</span>
  DEV_ROOT_FRAGMENT: <span class=
"org-highlight-numbers-number">1</span> &lt;&lt; <span class=
"org-highlight-numbers-number">11</span>,

  <span class="org-doc">/**</span>
<span class=
"org-doc">   * SPECIAL FLAGS -------------------------------------------------------------</span>
<span class=
"org-doc">   * Special flags are negative integers. They are never matched against using</span>
<span class=
"org-doc">   * bitwise operators (bitwise matching should only happen in branches where</span>
<span class=
"org-doc">   * patchFlag &gt; 0), and are mutually exclusive. When checking for a special</span>
<span class=
"org-doc">   * flag, simply check patchFlag === FLAG.</span>
<span class="org-doc">   */</span>

  <span class="org-doc">/**</span>
<span class=
"org-doc">   * Indicates a hoisted static vnode. This is a hint for hydration to skip</span>
<span class=
"org-doc">   * the entire sub tree since static content never needs to be updated.</span>
<span class="org-doc">   */</span>
  HOISTED: -<span class="org-highlight-numbers-number">1</span>,
  <span class="org-doc">/**</span>
<span class=
"org-doc">   * A special flag that indicates that the diffing algorithm should bail out</span>
<span class=
"org-doc">   * of optimized mode. For example, on block fragments created by renderSlot()</span>
<span class=
"org-doc">   * when encountering non-compiler generated slots (i.e. manually written</span>
<span class=
"org-doc">   * render functions, which should always be fully diffed)</span>
<span class="org-doc">   * OR manually cloneVNodes</span>
<span class="org-doc">   */</span>
  BAIL: -<span class="org-highlight-numbers-number">2</span>
}

<span class="org-doc">/**</span>
<span class="org-doc"> * dev only flag -&gt; name mapping</span>
<span class="org-doc"> */</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">PatchFlagNames</span> = {
  [PatchFlags.TEXT]: <span class="org-string">`TEXT`</span>,
  [PatchFlags.CLASS]: <span class="org-string">`CLASS`</span>,
  [PatchFlags.STYLE]: <span class="org-string">`STYLE`</span>,
  [PatchFlags.PROPS]: <span class="org-string">`PROPS`</span>,
  [PatchFlags.FULL_PROPS]: <span class=
"org-string">`FULL_PROPS`</span>,
  [PatchFlags.HYDRATE_EVENTS]: <span class=
"org-string">`HYDRATE_EVENTS`</span>,
  [PatchFlags.STABLE_FRAGMENT]: <span class=
"org-string">`STABLE_FRAGMENT`</span>,
  [PatchFlags.KEYED_FRAGMENT]: <span class=
"org-string">`KEYED_FRAGMENT`</span>,
  [PatchFlags.UNKEYED_FRAGMENT]: <span class=
"org-string">`UNKEYED_FRAGMENT`</span>,
  [PatchFlags.NEED_PATCH]: <span class=
"org-string">`NEED_PATCH`</span>,
  [PatchFlags.DYNAMIC_SLOTS]: <span class=
"org-string">`DYNAMIC_SLOTS`</span>,
  [PatchFlags.DEV_ROOT_FRAGMENT]: <span class=
"org-string">`DEV_ROOT_FRAGMENT`</span>,
  [PatchFlags.HOISTED]: <span class="org-string">`HOISTED`</span>,
  [PatchFlags.BAIL]: <span class="org-string">`BAIL`</span>
}

<span class="org-keyword">function</span> <span class=
"org-function-name">genFlagText</span>(<span class=
"org-variable-name">flag</span>, <span class=
"org-variable-name">names</span> = <span class=
"org-variable-name">PatchFlagNames</span>) {
  <span class="org-keyword">if</span> (isArray(flag)) {
    <span class="org-keyword">let</span> <span class=
"org-variable-name">f</span> = <span class=
"org-highlight-numbers-number">0</span>
    flag.forEach((ff) =&gt; {
      f |= ff
    })
    <span class="org-keyword">return</span> <span class=
"org-string">`${f} /* ${flag.map((f) =&gt; names[f]).join(', ')} */`</span>
  } <span class="org-keyword">else</span> {
    <span class="org-keyword">return</span> <span class=
"org-string">`${flag} /* ${names[flag]} */`</span>
  }
}

<span class="org-keyword">const</span> <span class=
"org-variable-name">propsHelperSet</span> = <span class=
"org-keyword">new</span> <span class=
"org-type">Set</span>([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS])

<span class="org-keyword">function</span> <span class=
"org-function-name">getUnnormalizedProps</span>(<span class=
"org-variable-name">props</span>, <span class=
"org-variable-name">callPath</span> = []) {
  <span class="org-keyword">if</span> (
    props &amp;&
    !isString(props) &amp;&
    props.type === NodeTypes.JS_CALL_EXPRESSION
  ) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">callee</span> = props.callee
    <span class=
"org-keyword">if</span> (!isString(callee) &amp;& propsHelperSet.has(callee)) {
      <span class=
"org-keyword">return</span> getUnnormalizedProps(props.<span class=
"org-constant">arguments</span>[<span class=
"org-highlight-numbers-number">0</span>], callPath.concat(props))
    }
  }
  <span class="org-keyword">return</span> [props, callPath]
}

<span class="org-keyword">function</span> <span class=
"org-function-name">injectProp</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">prop</span>, <span class=
"org-variable-name">context</span>) {
  <span class="org-keyword">let</span> <span class=
"org-variable-name">propsWithInjection</span>
  <span class="org-doc">/**</span>
<span class="org-doc">   * 1. mergeProps(...)</span>
<span class="org-doc">   * 2. toHandlers(...)</span>
<span class="org-doc">   * 3. normalizeProps(...)</span>
<span class=
"org-doc">   * 4. normalizeProps(guardReactiveProps(...))</span>
<span class="org-doc">   *</span>
<span class=
"org-doc">   * we need to get the real props before normalization</span>
<span class="org-doc">   */</span>
  <span class="org-keyword">let</span> <span class=
"org-variable-name">props</span> =
    node.type === NodeTypes.VNODE_CALL ? node.props : node.<span class="org-constant">arguments</span>[<span class="org-highlight-numbers-number">2</span>]
  <span class="org-keyword">let</span> <span class=
"org-variable-name">callPath</span> = []
  <span class="org-keyword">let</span> <span class=
"org-variable-name">parentCall</span>
  <span class="org-keyword">if</span> (
    props &amp;&
    !isString(props) &amp;&
    props.type === NodeTypes.JS_CALL_EXPRESSION
  ) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">ret</span> = getUnnormalizedProps(props)
    props = ret[<span class=
"org-highlight-numbers-number">0</span>]
    callPath = ret[<span class=
"org-highlight-numbers-number">1</span>]
    parentCall = callPath[callPath.length - <span class=
"org-highlight-numbers-number">1</span>]
  }

  <span class="org-keyword">if</span> (props == <span class=
"org-constant">null</span> || isString(props)) {
    propsWithInjection = createObjectExpression([prop])
  } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (props.type === NodeTypes.JS_CALL_EXPRESSION) {
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">merged props... add ours</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">only inject key to object literal if it's the first argument so that</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">if doesn't override user provided keys</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">first</span> = props.<span class=
"org-constant">arguments</span>[<span class=
"org-highlight-numbers-number">0</span>] | JSChildNode
    <span class=
"org-keyword">if</span> (!isString(first) &amp;& first.type === NodeTypes.JS_OBJECT_EXPRESSION) {
      first.properties.unshift(prop)
    } <span class="org-keyword">else</span> {
      <span class=
"org-keyword">if</span> (props.callee === TO_HANDLERS) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">#2366</span>
        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
          createObjectExpression([prop]),
          props
        ])
      } <span class="org-keyword">else</span> {
        props.<span class=
"org-constant">arguments</span>.unshift(createObjectExpression([prop]))
      }
    }
    !propsWithInjection &amp;& (propsWithInjection = props)
  } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (props.type === NodeTypes.JS_OBJECT_EXPRESSION) {
    <span class="org-keyword">let</span> <span class=
"org-variable-name">alreadyExists</span> = <span class=
"org-constant">false</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">check existing key to avoid overriding user provided keys</span>
    <span class=
"org-keyword">if</span> (prop.key.type === NodeTypes.SIMPLE_EXPRESSION) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">propKeyName</span> = prop.key.content
      alreadyExists = props.properties.some(
        (p) =&gt;
          p.key.type === NodeTypes.SIMPLE_EXPRESSION &amp;&
          p.key.content === propKeyName
      )
    }
    <span class="org-keyword">if</span> (!alreadyExists) {
      props.properties.unshift(prop)
    }
    propsWithInjection = props
  } <span class="org-keyword">else</span> {
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">single v-bind with expression, return a merged replacement</span>
    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
      createObjectExpression([prop]),
      props
    ])
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(props))`,</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">it will be rewritten as `normalizeProps(mergeProps({ key: 0 }, props))`,</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">the `guardReactiveProps` will no longer be needed</span>
    <span class=
"org-keyword">if</span> (parentCall &amp;& parentCall.callee === GUARD_REACTIVE_PROPS) {
      parentCall = callPath[callPath.length - <span class=
"org-highlight-numbers-number">2</span>]
    }
  }
  <span class=
"org-keyword">if</span> (node.type === NodeTypes.VNODE_CALL) {
    <span class="org-keyword">if</span> (parentCall) {
      parentCall.<span class=
"org-constant">arguments</span>[<span class=
"org-highlight-numbers-number">0</span>] = propsWithInjection
    } <span class="org-keyword">else</span> {
      node.props = propsWithInjection
    }
  } <span class="org-keyword">else</span> {
    <span class="org-keyword">if</span> (parentCall) {
      parentCall.<span class=
"org-constant">arguments</span>[<span class=
"org-highlight-numbers-number">0</span>] = propsWithInjection
    } <span class="org-keyword">else</span> {
      node.<span class="org-constant">arguments</span>[<span class=
"org-highlight-numbers-number">2</span>] = propsWithInjection
    }
  }
}

<span class="org-keyword">const</span> <span class=
"org-variable-name">BindingTypes</span> = {
  <span class="org-doc">/**</span>
<span class="org-doc">   * returned from data()</span>
<span class="org-doc">   */</span>
  DATA: <span class="org-string">'data'</span>,
  <span class="org-doc">/**</span>
<span class="org-doc">   * declared as a prop</span>
<span class="org-doc">   */</span>
  PROPS: <span class="org-string">'props'</span>,
  <span class="org-doc">/**</span>
<span class=
"org-doc">   * a local alias of a `&lt;script setup&gt;` destructured prop.</span>
<span class=
"org-doc">   * the original is stored in __propsAliases of the bindingMetadata object.</span>
<span class="org-doc">   */</span>
  PROPS_ALIASED: <span class="org-string">'props-aliased'</span>,
  <span class="org-doc">/**</span>
<span class=
"org-doc">   * a let binding (may or may not be a ref)</span>
<span class="org-doc">   */</span>
  SETUP_LET: <span class="org-string">'setup-let'</span>,
  <span class="org-doc">/**</span>
<span class=
"org-doc">   * a const binding that can never be a ref.</span>
<span class=
"org-doc">   * these bindings don't need `unref()` calls when processed in inlined</span>
<span class="org-doc">   * template expressions.</span>
<span class="org-doc">   */</span>
  SETUP_CONST: <span class="org-string">'setup-const'</span>,
  <span class="org-doc">/**</span>
<span class=
"org-doc">   * a const binding that may be a ref.</span>
<span class="org-doc">   */</span>
  SETUP_MAYBE_REF: <span class=
"org-string">'setup-maybe-ref'</span>,
  <span class="org-doc">/**</span>
<span class=
"org-doc">   * bindings that are guaranteed to be refs</span>
<span class="org-doc">   */</span>
  SETUP_REF: <span class="org-string">'setup-ref'</span>,
  <span class="org-doc">/**</span>
<span class=
"org-doc">   * declared by other options, e.g. computed, inject</span>
<span class="org-doc">   */</span>
  OPTIONS: <span class="org-string">'options'</span>
}

<span class="org-keyword">class</span> WalkerBase {
  constructor() {
    <span class="org-doc">/** @type {boolean} */</span>
    <span class=
"org-constant">this</span>.should_skip = <span class=
"org-constant">false</span>

    <span class="org-doc">/** @type {boolean} */</span>
    <span class=
"org-constant">this</span>.should_remove = <span class=
"org-constant">false</span>

    <span class="org-doc">/** @type {BaseNode | null} */</span>
    <span class=
"org-constant">this</span>.replacement = <span class=
"org-constant">null</span>

    <span class="org-doc">/** @type {WalkerContext} */</span>
    <span class="org-constant">this</span>.context = {
      skip: () =&gt; (<span class=
"org-constant">this</span>.should_skip = <span class=
"org-constant">true</span>),
      remove: () =&gt; (<span class=
"org-constant">this</span>.should_remove = <span class=
"org-constant">true</span>),
      replace: (node) =&gt; (<span class=
"org-constant">this</span>.replacement = node)
    }
  }

  replace(parent, prop, index, node) {
    <span class="org-keyword">if</span> (parent) {
      <span class="org-keyword">if</span> (index !== <span class=
"org-constant">null</span>) {
        parent[prop][index] = node
      } <span class="org-keyword">else</span> {
        parent[prop] = node
      }
    }
  }

  remove(parent, prop, index) {
    <span class="org-keyword">if</span> (parent) {
      <span class="org-keyword">if</span> (index !== <span class=
"org-constant">null</span>) {
        parent[prop].splice(index, <span class=
"org-highlight-numbers-number">1</span>)
      } <span class="org-keyword">else</span> {
        <span class="org-keyword">delete</span> parent[prop]
      }
    }
  }
}

<span class="org-keyword">class</span> SyncWalker <span class=
"org-keyword">extends</span> WalkerBase {
  constructor(enter, leave) {
    <span class="org-keyword">super</span>()

    <span class="org-doc">/** @type {SyncHandler} */</span>
    <span class="org-constant">this</span>.enter = enter

    <span class="org-doc">/** @type {SyncHandler} */</span>
    <span class="org-constant">this</span>.leave = leave
  }

  visit(node, parent, prop, index) {
    <span class="org-keyword">if</span> (node) {
      <span class="org-keyword">if</span> (<span class=
"org-constant">this</span>.enter) {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">_should_skip</span> = <span class=
"org-constant">this</span>.should_skip
        <span class="org-keyword">const</span> <span class=
"org-variable-name">_should_remove</span> = <span class=
"org-constant">this</span>.should_remove
        <span class="org-keyword">const</span> <span class=
"org-variable-name">_replacement</span> = <span class=
"org-constant">this</span>.replacement
        <span class=
"org-constant">this</span>.should_skip = <span class=
"org-constant">false</span>
        <span class=
"org-constant">this</span>.should_remove = <span class=
"org-constant">false</span>
        <span class=
"org-constant">this</span>.replacement = <span class=
"org-constant">null</span>

        <span class=
"org-constant">this</span>.enter.call(<span class=
"org-constant">this</span>.context, node, parent, prop, index)

        <span class="org-keyword">if</span> (<span class=
"org-constant">this</span>.replacement) {
          node = <span class="org-constant">this</span>.replacement
          <span class=
"org-constant">this</span>.replace(parent, prop, index, node)
        }

        <span class="org-keyword">if</span> (<span class=
"org-constant">this</span>.should_remove) {
          <span class=
"org-constant">this</span>.remove(parent, prop, index)
        }

        <span class="org-keyword">const</span> <span class=
"org-variable-name">skipped</span> = <span class=
"org-constant">this</span>.should_skip
        <span class="org-keyword">const</span> <span class=
"org-variable-name">removed</span> = <span class=
"org-constant">this</span>.should_remove

        <span class=
"org-constant">this</span>.should_skip = _should_skip
        <span class=
"org-constant">this</span>.should_remove = _should_remove
        <span class=
"org-constant">this</span>.replacement = _replacement

        <span class="org-keyword">if</span> (skipped) <span class=
"org-keyword">return</span> node
        <span class="org-keyword">if</span> (removed) <span class=
"org-keyword">return</span> <span class="org-constant">null</span>
      }

      <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">in</span> node) {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">value</span> = node[key]

        <span class="org-keyword">if</span> (<span class=
"org-keyword">typeof</span> value !== <span class=
"org-string">'object'</span>) {
          <span class="org-keyword">continue</span>
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (Array.isArray(value)) {
          <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; value.length; i += <span class="org-highlight-numbers-number">1</span>) {
            <span class=
"org-keyword">if</span> (value[i] !== <span class=
"org-constant">null</span> &amp;& <span class=
"org-keyword">typeof</span> value[i].type === <span class=
"org-string">'string'</span>) {
              <span class="org-keyword">if</span> (!<span class=
"org-constant">this</span>.visit(value[i], node, key, i)) {
                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">removed</span>
                i--
              }
            }
          }
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (value !== <span class=
"org-constant">null</span> &amp;& <span class=
"org-keyword">typeof</span> value.type === <span class=
"org-string">'string'</span>) {
          <span class=
"org-constant">this</span>.visit(value, node, key, <span class=
"org-constant">null</span>)
        }
      }

      <span class="org-keyword">if</span> (<span class=
"org-constant">this</span>.leave) {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">_replacement</span> = <span class=
"org-constant">this</span>.replacement
        <span class="org-keyword">const</span> <span class=
"org-variable-name">_should_remove</span> = <span class=
"org-constant">this</span>.should_remove
        <span class=
"org-constant">this</span>.replacement = <span class=
"org-constant">null</span>
        <span class=
"org-constant">this</span>.should_remove = <span class=
"org-constant">false</span>

        <span class=
"org-constant">this</span>.leave.call(<span class=
"org-constant">this</span>.context, node, parent, prop, index)

        <span class="org-keyword">if</span> (<span class=
"org-constant">this</span>.replacement) {
          node = <span class="org-constant">this</span>.replacement
          <span class=
"org-constant">this</span>.replace(parent, prop, index, node)
        }

        <span class="org-keyword">if</span> (<span class=
"org-constant">this</span>.should_remove) {
          <span class=
"org-constant">this</span>.remove(parent, prop, index)
        }

        <span class="org-keyword">const</span> <span class=
"org-variable-name">removed</span> = <span class=
"org-constant">this</span>.should_remove

        <span class=
"org-constant">this</span>.replacement = _replacement
        <span class=
"org-constant">this</span>.should_remove = _should_remove

        <span class="org-keyword">if</span> (removed) <span class=
"org-keyword">return</span> <span class="org-constant">null</span>
      }
    }

    <span class="org-keyword">return</span> node
  }
}

<span class="org-keyword">class</span> AsyncWalker <span class=
"org-keyword">extends</span> WalkerBase {
  constructor(enter, leave) {
    <span class="org-keyword">super</span>()

    <span class="org-doc">/** @type {AsyncHandler} */</span>
    <span class="org-constant">this</span>.enter = enter

    <span class="org-doc">/** @type {AsyncHandler} */</span>
    <span class="org-constant">this</span>.leave = leave
  }

  <span class=
"org-keyword">async</span> visit(node, parent, prop, index) {
    <span class="org-keyword">if</span> (node) {
      <span class="org-keyword">if</span> (<span class=
"org-constant">this</span>.enter) {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">_should_skip</span> = <span class=
"org-constant">this</span>.should_skip
        <span class="org-keyword">const</span> <span class=
"org-variable-name">_should_remove</span> = <span class=
"org-constant">this</span>.should_remove
        <span class="org-keyword">const</span> <span class=
"org-variable-name">_replacement</span> = <span class=
"org-constant">this</span>.replacement
        <span class=
"org-constant">this</span>.should_skip = <span class=
"org-constant">false</span>
        <span class=
"org-constant">this</span>.should_remove = <span class=
"org-constant">false</span>
        <span class=
"org-constant">this</span>.replacement = <span class=
"org-constant">null</span>

        <span class="org-keyword">await</span> <span class=
"org-constant">this</span>.enter.call(<span class=
"org-constant">this</span>.context, node, parent, prop, index)

        <span class="org-keyword">if</span> (<span class=
"org-constant">this</span>.replacement) {
          node = <span class="org-constant">this</span>.replacement
          <span class=
"org-constant">this</span>.replace(parent, prop, index, node)
        }

        <span class="org-keyword">if</span> (<span class=
"org-constant">this</span>.should_remove) {
          <span class=
"org-constant">this</span>.remove(parent, prop, index)
        }

        <span class="org-keyword">const</span> <span class=
"org-variable-name">skipped</span> = <span class=
"org-constant">this</span>.should_skip
        <span class="org-keyword">const</span> <span class=
"org-variable-name">removed</span> = <span class=
"org-constant">this</span>.should_remove

        <span class=
"org-constant">this</span>.should_skip = _should_skip
        <span class=
"org-constant">this</span>.should_remove = _should_remove
        <span class=
"org-constant">this</span>.replacement = _replacement

        <span class="org-keyword">if</span> (skipped) <span class=
"org-keyword">return</span> node
        <span class="org-keyword">if</span> (removed) <span class=
"org-keyword">return</span> <span class="org-constant">null</span>
      }

      <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">in</span> node) {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">value</span> = node[key]

        <span class="org-keyword">if</span> (<span class=
"org-keyword">typeof</span> value !== <span class=
"org-string">'object'</span>) {
          <span class="org-keyword">continue</span>
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (Array.isArray(value)) {
          <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; value.length; i += <span class="org-highlight-numbers-number">1</span>) {
            <span class=
"org-keyword">if</span> (value[i] !== <span class=
"org-constant">null</span> &amp;& <span class=
"org-keyword">typeof</span> value[i].type === <span class=
"org-string">'string'</span>) {
              <span class="org-keyword">if</span> (!(<span class=
"org-keyword">await</span> <span class=
"org-constant">this</span>.visit(value[i], node, key, i))) {
                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">removed</span>
                i--
              }
            }
          }
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (value !== <span class=
"org-constant">null</span> &amp;& <span class=
"org-keyword">typeof</span> value.type === <span class=
"org-string">'string'</span>) {
          <span class="org-keyword">await</span> <span class=
"org-constant">this</span>.visit(value, node, key, <span class=
"org-constant">null</span>)
        }
      }

      <span class="org-keyword">if</span> (<span class=
"org-constant">this</span>.leave) {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">_replacement</span> = <span class=
"org-constant">this</span>.replacement
        <span class="org-keyword">const</span> <span class=
"org-variable-name">_should_remove</span> = <span class=
"org-constant">this</span>.should_remove
        <span class=
"org-constant">this</span>.replacement = <span class=
"org-constant">null</span>
        <span class=
"org-constant">this</span>.should_remove = <span class=
"org-constant">false</span>

        <span class="org-keyword">await</span> <span class=
"org-constant">this</span>.leave.call(<span class=
"org-constant">this</span>.context, node, parent, prop, index)

        <span class="org-keyword">if</span> (<span class=
"org-constant">this</span>.replacement) {
          node = <span class="org-constant">this</span>.replacement
          <span class=
"org-constant">this</span>.replace(parent, prop, index, node)
        }

        <span class="org-keyword">if</span> (<span class=
"org-constant">this</span>.should_remove) {
          <span class=
"org-constant">this</span>.remove(parent, prop, index)
        }

        <span class="org-keyword">const</span> <span class=
"org-variable-name">removed</span> = <span class=
"org-constant">this</span>.should_remove

        <span class=
"org-constant">this</span>.replacement = _replacement
        <span class=
"org-constant">this</span>.should_remove = _should_remove

        <span class="org-keyword">if</span> (removed) <span class=
"org-keyword">return</span> <span class="org-constant">null</span>
      }
    }

    <span class="org-keyword">return</span> node
  }
}

<span class="org-keyword">function</span> <span class=
"org-function-name">walk</span>(<span class=
"org-variable-name">ast</span>, { <span class=
"org-variable-name">enter</span>, <span class=
"org-variable-name">leave</span> }) {
  <span class="org-keyword">const</span> <span class=
"org-variable-name">instance</span> = <span class=
"org-keyword">new</span> <span class=
"org-type">SyncWalker</span>(enter, leave)
  <span class=
"org-keyword">return</span> instance.visit(ast, <span class=
"org-constant">null</span>)
}

<span class="org-keyword">async</span> <span class=
"org-keyword">function</span> asyncWalk(<span class=
"org-variable-name">ast</span>, { <span class=
"org-variable-name">enter</span>, <span class=
"org-variable-name">leave</span> }) {
  <span class="org-keyword">const</span> <span class=
"org-variable-name">instance</span> = <span class=
"org-keyword">new</span> <span class=
"org-type">AsyncWalker</span>(enter, leave)
  <span class="org-keyword">return</span> <span class=
"org-keyword">await</span> instance.visit(ast, <span class=
"org-constant">null</span>)
}

<span class="org-keyword">function</span> <span class=
"org-function-name">isInDestructureAssignment</span>(<span class=
"org-variable-name">parent</span>, <span class=
"org-variable-name">parentStack</span>) {
  <span class="org-keyword">if</span> (
    parent &amp;&
    (parent.type === <span class=
"org-string">'ObjectProperty'</span> || parent.type === <span class="org-string">'ArrayPattern'</span>)
  ) {
    <span class="org-keyword">let</span> <span class=
"org-variable-name">i</span> = parentStack.length
    <span class="org-keyword">while</span> (i--) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">p</span> = parentStack[i]
      <span class="org-keyword">if</span> (p.type === <span class=
"org-string">'AssignmentExpression'</span>) {
        <span class="org-keyword">return</span> <span class=
"org-constant">true</span>
      } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (p.type !== <span class=
"org-string">'ObjectProperty'</span> &amp;& !p.type.endsWith(<span class="org-string">'Pattern'</span>)) {
        <span class="org-keyword">break</span>
      }
    }
  }
  <span class="org-keyword">return</span> <span class=
"org-constant">false</span>
}

<span class="org-keyword">function</span> <span class=
"org-function-name">walkIdentifiers</span>(
  <span class="org-variable-name">root</span>,
  <span class="org-variable-name">onIdentifier</span>,
  includeAll = <span class="org-constant">false</span>,
  parentStack = [],
  knownIds = Object.create(<span class="org-constant">null</span>)
) {
  <span class="org-keyword">if</span> (__BROWSER__) {
    <span class="org-keyword">return</span>
  }

  <span class="org-keyword">const</span> <span class=
"org-variable-name">rootExp</span> =
    root.type === <span class="org-string">'Program'</span> &amp;&
    root.body[<span class=
"org-highlight-numbers-number">0</span>].type === <span class=
"org-string">'ExpressionStatement'</span> &amp;&
    root.body[<span class=
"org-highlight-numbers-number">0</span>].expression

  walk(root, {
    enter(node, parent) {
      parent &amp;& parentStack.push(parent)
      <span class="org-keyword">if</span> (
        parent &amp;&
        parent.type.startsWith(<span class=
"org-string">'TS'</span>) &amp;&
        parent.type !== <span class=
"org-string">'TSAsExpression'</span> &amp;&
        parent.type !== <span class=
"org-string">'TSNonNullExpression'</span> &amp;&
        parent.type !== <span class=
"org-string">'TSTypeAssertion'</span>
      ) {
        <span class="org-keyword">return</span> <span class=
"org-constant">this</span>.skip()
      }
      <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'Identifier'</span>) {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">isLocal</span> = !!knownIds[node.name]
        <span class="org-keyword">const</span> <span class=
"org-variable-name">isRefed</span> = isReferencedIdentifier(node, parent, parentStack)
        <span class=
"org-keyword">if</span> (includeAll || (isRefed &amp;& !isLocal)) {
          onIdentifier(node, parent, parentStack, isRefed, isLocal)
        }
      } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (
        node.type === <span class=
"org-string">'ObjectProperty'</span> &amp;&
        parent.type === <span class=
"org-string">'ObjectPattern'</span>
      ) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">mark property in destructure pattern</span>
        node.inPattern = <span class="org-constant">true</span>
      } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (isFunctionType(node)) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">walk function expressions and add its arguments to known identifiers</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">so that we don't prefix them</span>
        walkFunctionParams(node, (id) =&gt;
          markScopeIdentifier(node, id, knownIds)
        )
      } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'BlockStatement'</span>) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">#3445 record block-level local variables</span>
        walkBlockDeclarations(node, (id) =&gt;
          markScopeIdentifier(node, id, knownIds)
        )
      }
    },
    leave(node, parent) {
      parent &amp;& parentStack.pop()
      <span class=
"org-keyword">if</span> (node !== rootExp &amp;& node.scopeIds) {
        <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">id</span> <span class=
"org-keyword">of</span> node.scopeIds) {
          knownIds[id]--
          <span class=
"org-keyword">if</span> (knownIds[id] === <span class=
"org-highlight-numbers-number">0</span>) {
            <span class="org-keyword">delete</span> knownIds[id]
          }
        }
      }
    }
  })
}

<span class="org-keyword">function</span> <span class=
"org-function-name">isReferencedIdentifier</span>(<span class=
"org-variable-name">id</span>, <span class=
"org-variable-name">parent</span>, <span class=
"org-variable-name">parentStack</span>) {
  <span class="org-keyword">if</span> (__BROWSER__) {
    <span class="org-keyword">return</span> <span class=
"org-constant">false</span>
  }

  <span class="org-keyword">if</span> (!parent) {
    <span class="org-keyword">return</span> <span class=
"org-constant">true</span>
  }

  <span class="org-comment-delimiter">// </span><span class=
"org-comment">is a special keyword but parsed as identifier</span>
  <span class="org-keyword">if</span> (id.name === <span class=
"org-string">'arguments'</span>) {
    <span class="org-keyword">return</span> <span class=
"org-constant">false</span>
  }

  <span class="org-keyword">if</span> (isReferenced(id, parent)) {
    <span class="org-keyword">return</span> <span class=
"org-constant">true</span>
  }

  <span class="org-comment-delimiter">// </span><span class=
"org-comment">babel's isReferenced check returns false for ids being assigned to, so we</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">need to cover those cases here</span>
  <span class="org-keyword">switch</span> (parent.type) {
    <span class="org-keyword">case</span> <span class=
"org-string">'AssignmentExpression'</span>:
    <span class="org-keyword">case</span> <span class=
"org-string">'AssignmentPattern'</span>:
      <span class="org-keyword">return</span> <span class=
"org-constant">true</span>
    <span class="org-keyword">case</span> <span class=
"org-string">'ObjectPattern'</span>:
    <span class="org-keyword">case</span> <span class=
"org-string">'ArrayPattern'</span>:
      <span class=
"org-keyword">return</span> isInDestructureAssignment(parent, parentStack)
  }

  <span class="org-keyword">return</span> <span class=
"org-constant">false</span>
}

<span class="org-keyword">function</span> <span class=
"org-function-name">isInDestructureAssignment</span>(<span class=
"org-variable-name">parent</span>, <span class=
"org-variable-name">parentStack</span>) {
  <span class="org-keyword">if</span> (
    parent &amp;&
    (parent.type === <span class=
"org-string">'ObjectProperty'</span> || parent.type === <span class="org-string">'ArrayPattern'</span>)
  ) {
    <span class="org-keyword">let</span> <span class=
"org-variable-name">i</span> = parentStack.length
    <span class="org-keyword">while</span> (i--) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">p</span> = parentStack[i]
      <span class="org-keyword">if</span> (p.type === <span class=
"org-string">'AssignmentExpression'</span>) {
        <span class="org-keyword">return</span> <span class=
"org-constant">true</span>
      } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (p.type !== <span class=
"org-string">'ObjectProperty'</span> &amp;& !p.type.endsWith(<span class="org-string">'Pattern'</span>)) {
        <span class="org-keyword">break</span>
      }
    }
  }
  <span class="org-keyword">return</span> <span class=
"org-constant">false</span>
}

<span class="org-keyword">function</span> <span class=
"org-function-name">walkFunctionParams</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">onIdent</span>) {
  <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">p</span> <span class=
"org-keyword">of</span> node.params) {
    <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">id</span> <span class=
"org-keyword">of</span> extractIdentifiers(p)) {
      onIdent(id)
    }
  }
}

<span class="org-keyword">function</span> <span class=
"org-function-name">walkBlockDeclarations</span>(<span class=
"org-variable-name">block</span>, <span class=
"org-variable-name">onIdent</span>) {
  <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">stmt</span> <span class=
"org-keyword">of</span> block.body) {
    <span class="org-keyword">if</span> (stmt.type === <span class=
"org-string">'VariableDeclaration'</span>) {
      <span class=
"org-keyword">if</span> (stmt.declare) <span class=
"org-keyword">continue</span>
      <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">decl</span> <span class=
"org-keyword">of</span> stmt.declarations) {
        <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">id</span> <span class=
"org-keyword">of</span> extractIdentifiers(decl.id)) {
          onIdent(id)
        }
      }
    } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (
      stmt.type === <span class=
"org-string">'FunctionDeclaration'</span> ||
      stmt.type === <span class=
"org-string">'ClassDeclaration'</span>
    ) {
      <span class=
"org-keyword">if</span> (stmt.declare || !stmt.id) <span class=
"org-keyword">continue</span>
      onIdent(stmt.id)
    }
  }
}

<span class="org-keyword">function</span> <span class=
"org-function-name">extractIdentifiers</span>(<span class=
"org-variable-name">param</span>, <span class=
"org-variable-name">nodes</span> = []) {
  <span class="org-keyword">switch</span> (param.type) {
    <span class="org-keyword">case</span> <span class=
"org-string">'Identifier'</span>:
      nodes.push(param)
      <span class="org-keyword">break</span>

    <span class="org-keyword">case</span> <span class=
"org-string">'MemberExpression'</span>:
      <span class="org-keyword">let</span> <span class=
"org-variable-name">object</span> = param
      <span class=
"org-keyword">while</span> (object.type === <span class=
"org-string">'MemberExpression'</span>) {
        object = object.object
      }
      nodes.push(object)
      <span class="org-keyword">break</span>

    <span class="org-keyword">case</span> <span class=
"org-string">'ObjectPattern'</span>:
      <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">prop</span> <span class=
"org-keyword">of</span> param.properties) {
        <span class=
"org-keyword">if</span> (prop.type === <span class=
"org-string">'RestElement'</span>) {
          extractIdentifiers(prop.argument, nodes)
        } <span class="org-keyword">else</span> {
          extractIdentifiers(prop.value, nodes)
        }
      }
      <span class="org-keyword">break</span>

    <span class="org-keyword">case</span> <span class=
"org-string">'ArrayPattern'</span>:
      param.elements.forEach((element) =&gt; {
        <span class=
"org-keyword">if</span> (element) extractIdentifiers(element, nodes)
      })
      <span class="org-keyword">break</span>

    <span class="org-keyword">case</span> <span class=
"org-string">'RestElement'</span>:
      extractIdentifiers(param.argument, nodes)
      <span class="org-keyword">break</span>

    <span class="org-keyword">case</span> <span class=
"org-string">'AssignmentPattern'</span>:
      extractIdentifiers(param.left, nodes)
      <span class="org-keyword">break</span>
  }

  <span class="org-keyword">return</span> nodes
}

<span class="org-keyword">function</span> <span class=
"org-function-name">markScopeIdentifier</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">child</span>, <span class=
"org-variable-name">knownIds</span>) {
  <span class="org-keyword">const</span> { name } = child
  <span class=
"org-keyword">if</span> (node.scopeIds &amp;& node.scopeIds.has(name)) {
    <span class="org-keyword">return</span>
  }
  <span class="org-keyword">if</span> (name <span class=
"org-keyword">in</span> knownIds) {
    knownIds[name]++
  } <span class="org-keyword">else</span> {
    knownIds[name] = <span class=
"org-highlight-numbers-number">1</span>
  }
  ;(node.scopeIds || (node.scopeIds = <span class=
"org-keyword">new</span> <span class=
"org-type">Set</span>())).add(name)
}

<span class="org-keyword">const</span> <span class=
"org-variable-name">isFunctionType</span> = (node) =&gt; {
  <span class="org-keyword">return</span> <span class=
"org-string">/Function(?:Expression|Declaration)$|Method$/</span>.test(node.type)
}

<span class="org-keyword">const</span> <span class=
"org-variable-name">isStaticProperty</span> = (node) =&gt;
  node &amp;&
  (node.type === <span class=
"org-string">'ObjectProperty'</span> || node.type === <span class=
"org-string">'ObjectMethod'</span>) &amp;&
  !node.computed

<span class="org-keyword">const</span> <span class=
"org-variable-name">isStaticPropertyKey</span> = (node, parent) =&gt;
  isStaticProperty(parent) &amp;& parent.key === node

<span class="org-doc">/**</span>
<span class=
"org-doc"> * Copied from https://github.com/babel/babel/blob/main/packages/babel-types/src/validators/isReferenced.ts</span>
<span class=
"org-doc"> * To avoid runtime dependency on @babel/types (which includes process references)</span>
<span class=
"org-doc"> * This file should not change very often in babel but we may need to keep it</span>
<span class="org-doc"> * up-to-date from time to time.</span>
<span class="org-doc"> *</span>
<span class=
"org-doc"> * https://github.com/babel/babel/blob/main/LICENSE</span>
<span class="org-doc"> *</span>
<span class="org-doc"> */</span>
<span class="org-keyword">function</span> <span class=
"org-function-name">isReferenced</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">parent</span>, <span class=
"org-variable-name">grandparent</span>) {
  <span class="org-keyword">switch</span> (parent.type) {
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">yes: PARENT[NODE]</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">yes: NODE.child</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">no: parent.NODE</span>
    <span class="org-keyword">case</span> <span class=
"org-string">'MemberExpression'</span>:
    <span class="org-keyword">case</span> <span class=
"org-string">'OptionalMemberExpression'</span>:
      <span class=
"org-keyword">if</span> (parent.property === node) {
        <span class="org-keyword">return</span> !!parent.computed
      }
      <span class=
"org-keyword">return</span> parent.object === node

    <span class="org-keyword">case</span> <span class=
"org-string">'JSXMemberExpression'</span>:
      <span class=
"org-keyword">return</span> parent.object === node
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">no: let NODE = init;</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">yes: let id = NODE;</span>
    <span class="org-keyword">case</span> <span class=
"org-string">'VariableDeclarator'</span>:
      <span class="org-keyword">return</span> parent.init === node

    <span class="org-comment-delimiter">// </span><span class=
"org-comment">yes: () =&gt; NODE</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">no: (NODE) =&gt; {}</span>
    <span class="org-keyword">case</span> <span class=
"org-string">'ArrowFunctionExpression'</span>:
      <span class="org-keyword">return</span> parent.body === node

    <span class="org-comment-delimiter">// </span><span class=
"org-comment">no: class { #NODE; }</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">no: class { get #NODE() {} }</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">no: class { #NODE() {} }</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">no: class { fn() { return this.#NODE; } }</span>
    <span class="org-keyword">case</span> <span class=
"org-string">'PrivateName'</span>:
      <span class="org-keyword">return</span> <span class=
"org-constant">false</span>

    <span class="org-comment-delimiter">// </span><span class=
"org-comment">no: class { NODE() {} }</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">yes: class { [NODE]() {} }</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">no: class { foo(NODE) {} }</span>
    <span class="org-keyword">case</span> <span class=
"org-string">'ClassMethod'</span>:
    <span class="org-keyword">case</span> <span class=
"org-string">'ClassPrivateMethod'</span>:
    <span class="org-keyword">case</span> <span class=
"org-string">'ObjectMethod'</span>:
      <span class="org-keyword">if</span> (parent.key === node) {
        <span class="org-keyword">return</span> !!parent.computed
      }
      <span class="org-keyword">return</span> <span class=
"org-constant">false</span>

    <span class="org-comment-delimiter">// </span><span class=
"org-comment">yes: { [NODE]: "" }</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">no: { NODE: "" }</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">depends: { NODE }</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">depends: { key: NODE }</span>
    <span class="org-keyword">case</span> <span class=
"org-string">'ObjectProperty'</span>:
      <span class="org-keyword">if</span> (parent.key === node) {
        <span class="org-keyword">return</span> !!parent.computed
      }
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">parent.value === node</span>
      <span class=
"org-keyword">return</span> !grandparent || grandparent.type !== <span class="org-string">'ObjectPattern'</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">no: class { NODE = value; }</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">yes: class { [NODE] = value; }</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">yes: class { key = NODE; }</span>
    <span class="org-keyword">case</span> <span class=
"org-string">'ClassProperty'</span>:
      <span class="org-keyword">if</span> (parent.key === node) {
        <span class="org-keyword">return</span> !!parent.computed
      }
      <span class="org-keyword">return</span> <span class=
"org-constant">true</span>
    <span class="org-keyword">case</span> <span class=
"org-string">'ClassPrivateProperty'</span>:
      <span class="org-keyword">return</span> parent.key !== node

    <span class="org-comment-delimiter">// </span><span class=
"org-comment">no: class NODE {}</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">yes: class Foo extends NODE {}</span>
    <span class="org-keyword">case</span> <span class=
"org-string">'ClassDeclaration'</span>:
    <span class="org-keyword">case</span> <span class=
"org-string">'ClassExpression'</span>:
      <span class=
"org-keyword">return</span> parent.superClass === node

    <span class="org-comment-delimiter">// </span><span class=
"org-comment">yes: left = NODE;</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">no: NODE = right;</span>
    <span class="org-keyword">case</span> <span class=
"org-string">'AssignmentExpression'</span>:
      <span class="org-keyword">return</span> parent.right === node

    <span class="org-comment-delimiter">// </span><span class=
"org-comment">no: [NODE = foo] = [];</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">yes: [foo = NODE] = [];</span>
    <span class="org-keyword">case</span> <span class=
"org-string">'AssignmentPattern'</span>:
      <span class="org-keyword">return</span> parent.right === node

    <span class="org-comment-delimiter">// </span><span class=
"org-comment">no: NODE: for (;;) {}</span>
    <span class="org-keyword">case</span> <span class=
"org-string">'LabeledStatement'</span>:
      <span class="org-keyword">return</span> <span class=
"org-constant">false</span>

    <span class="org-comment-delimiter">// </span><span class=
"org-comment">no: try {} catch (NODE) {}</span>
    <span class="org-keyword">case</span> <span class=
"org-string">'CatchClause'</span>:
      <span class="org-keyword">return</span> <span class=
"org-constant">false</span>

    <span class="org-comment-delimiter">// </span><span class=
"org-comment">no: function foo(...NODE) {}</span>
    <span class="org-keyword">case</span> <span class=
"org-string">'RestElement'</span>:
      <span class="org-keyword">return</span> <span class=
"org-constant">false</span>

    <span class="org-keyword">case</span> <span class=
"org-string">'BreakStatement'</span>:
    <span class="org-keyword">case</span> <span class=
"org-string">'ContinueStatement'</span>:
      <span class="org-keyword">return</span> <span class=
"org-constant">false</span>

    <span class="org-comment-delimiter">// </span><span class=
"org-comment">no: function NODE() {}</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">no: function foo(NODE) {}</span>
    <span class="org-keyword">case</span> <span class=
"org-string">'FunctionDeclaration'</span>:
    <span class="org-keyword">case</span> <span class=
"org-string">'FunctionExpression'</span>:
      <span class="org-keyword">return</span> <span class=
"org-constant">false</span>

    <span class="org-comment-delimiter">// </span><span class=
"org-comment">no: export NODE from "foo";</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">no: export * as NODE from "foo";</span>
    <span class="org-keyword">case</span> <span class=
"org-string">'ExportNamespaceSpecifier'</span>:
    <span class="org-keyword">case</span> <span class=
"org-string">'ExportDefaultSpecifier'</span>:
      <span class="org-keyword">return</span> <span class=
"org-constant">false</span>

    <span class="org-comment-delimiter">// </span><span class=
"org-comment">no: export { foo as NODE };</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">yes: export { NODE as foo };</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">no: export { NODE as foo } from "foo";</span>
    <span class="org-keyword">case</span> <span class=
"org-string">'ExportSpecifier'</span>:
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">@ts-expect-error</span>
      <span class="org-keyword">if</span> (grandparent?.source) {
        <span class="org-keyword">return</span> <span class=
"org-constant">false</span>
      }
      <span class="org-keyword">return</span> parent.local === node

    <span class="org-comment-delimiter">// </span><span class=
"org-comment">no: import NODE from "foo";</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">no: import * as NODE from "foo";</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">no: import { NODE as foo } from "foo";</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">no: import { foo as NODE } from "foo";</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">no: import NODE from "bar";</span>
    <span class="org-keyword">case</span> <span class=
"org-string">'ImportDefaultSpecifier'</span>:
    <span class="org-keyword">case</span> <span class=
"org-string">'ImportNamespaceSpecifier'</span>:
    <span class="org-keyword">case</span> <span class=
"org-string">'ImportSpecifier'</span>:
      <span class="org-keyword">return</span> <span class=
"org-constant">false</span>

    <span class="org-comment-delimiter">// </span><span class=
"org-comment">no: import "foo" assert { NODE: "json" }</span>
    <span class="org-keyword">case</span> <span class=
"org-string">'ImportAttribute'</span>:
      <span class="org-keyword">return</span> <span class=
"org-constant">false</span>

    <span class="org-comment-delimiter">// </span><span class=
"org-comment">no: &lt;div NODE="foo" /&gt;</span>
    <span class="org-keyword">case</span> <span class=
"org-string">'JSXAttribute'</span>:
      <span class="org-keyword">return</span> <span class=
"org-constant">false</span>

    <span class="org-comment-delimiter">// </span><span class=
"org-comment">no: [NODE] = [];</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">no: ({ NODE }) = [];</span>
    <span class="org-keyword">case</span> <span class=
"org-string">'ObjectPattern'</span>:
    <span class="org-keyword">case</span> <span class=
"org-string">'ArrayPattern'</span>:
      <span class="org-keyword">return</span> <span class=
"org-constant">false</span>

    <span class="org-comment-delimiter">// </span><span class=
"org-comment">no: new.NODE</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">no: NODE.target</span>
    <span class="org-keyword">case</span> <span class=
"org-string">'MetaProperty'</span>:
      <span class="org-keyword">return</span> <span class=
"org-constant">false</span>

    <span class="org-comment-delimiter">// </span><span class=
"org-comment">yes: type X = { someProperty: NODE }</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">no: type X = { NODE: OtherType }</span>
    <span class="org-keyword">case</span> <span class=
"org-string">'ObjectTypeProperty'</span>:
      <span class="org-keyword">return</span> parent.key !== node

    <span class="org-comment-delimiter">// </span><span class=
"org-comment">yes: enum X { Foo = NODE }</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">no: enum X { NODE }</span>
    <span class="org-keyword">case</span> <span class=
"org-string">'TSEnumMember'</span>:
      <span class="org-keyword">return</span> parent.id !== node

    <span class="org-comment-delimiter">// </span><span class=
"org-comment">yes: { [NODE]: value }</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">no: { NODE: value }</span>
    <span class="org-keyword">case</span> <span class=
"org-string">'TSPropertySignature'</span>:
      <span class="org-keyword">if</span> (parent.key === node) {
        <span class="org-keyword">return</span> !!parent.computed
      }

      <span class="org-keyword">return</span> <span class=
"org-constant">true</span>
  }

  <span class="org-keyword">return</span> <span class=
"org-constant">true</span>
}

<span class="org-keyword">const</span> <span class=
"org-variable-name">validFirstIdentCharRE</span> = <span class=
"org-string">/[A-Za-z_$\xA0-\uFFFF]/</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">validIdentCharRE</span> = <span class=
"org-string">/[\.\?\w$\xA0-\uFFFF]/</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">whitespaceRE</span> = <span class=
"org-string">/\s+[.[]\s*|\s*[.[]\s+/</span>g

<span class="org-keyword">const</span> <span class=
"org-variable-name">MemberExpLexState</span> = {
  inMemberExp: <span class="org-highlight-numbers-number">0</span>,
  inBrackets: <span class="org-highlight-numbers-number">1</span>,
  inParens: <span class="org-highlight-numbers-number">2</span>,
  inString: <span class="org-highlight-numbers-number">3</span>
}

<span class="org-keyword">const</span> <span class=
"org-variable-name">isMemberExpressionBrowser</span> = (path) =&gt; {
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">remove whitespaces around . or [ first</span>
  path = path.trim().replace(whitespaceRE, (s) =&gt; s.trim())

  <span class="org-keyword">let</span> <span class=
"org-variable-name">state</span> = MemberExpLexState.inMemberExp
  <span class="org-keyword">let</span> <span class=
"org-variable-name">stateStack</span> = []
  <span class="org-keyword">let</span> <span class=
"org-variable-name">currentOpenBracketCount</span> = <span class=
"org-highlight-numbers-number">0</span>
  <span class="org-keyword">let</span> <span class=
"org-variable-name">currentOpenParensCount</span> = <span class=
"org-highlight-numbers-number">0</span>
  <span class="org-keyword">let</span> <span class=
"org-variable-name">currentStringType</span> = <span class=
"org-constant">null</span>

  <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; path.length; i++) {
    <span class="org-keyword">const</span> <span class=
"org-type">char</span> = path.charAt(i)
    <span class="org-keyword">switch</span> (state) {
      <span class=
"org-keyword">case</span> MemberExpLexState.inMemberExp:
        <span class="org-keyword">if</span> (<span class=
"org-type">char</span> === <span class="org-string">'['</span>) {
          stateStack.push(state)
          state = MemberExpLexState.inBrackets
          currentOpenBracketCount++
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (<span class=
"org-type">char</span> === <span class="org-string">'('</span>) {
          stateStack.push(state)
          state = MemberExpLexState.inParens
          currentOpenParensCount++
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (
          !(i === <span class=
"org-highlight-numbers-number">0</span> ? validFirstIdentCharRE : validIdentCharRE).test(<span class="org-type">char</span>)
        ) {
          <span class="org-keyword">return</span> <span class=
"org-constant">false</span>
        }
        <span class="org-keyword">break</span>
      <span class=
"org-keyword">case</span> MemberExpLexState.inBrackets:
        <span class="org-keyword">if</span> (<span class=
"org-type">char</span> === <span class=
"org-string">`'`</span> || <span class=
"org-type">char</span> === <span class=
"org-string">`"`</span> || <span class=
"org-type">char</span> === <span class="org-string">'`'</span>) {
          stateStack.push(state)
          state = MemberExpLexState.inString
          currentStringType = <span class="org-type">char</span>
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (<span class=
"org-type">char</span> === <span class="org-string">`[`</span>) {
          currentOpenBracketCount++
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (<span class=
"org-type">char</span> === <span class="org-string">`]`</span>) {
          <span class=
"org-keyword">if</span> (!--currentOpenBracketCount) {
            state = stateStack.pop()
          }
        }
        <span class="org-keyword">break</span>
      <span class=
"org-keyword">case</span> MemberExpLexState.inParens:
        <span class="org-keyword">if</span> (<span class=
"org-type">char</span> === <span class=
"org-string">`'`</span> || <span class=
"org-type">char</span> === <span class=
"org-string">`"`</span> || <span class=
"org-type">char</span> === <span class="org-string">'`'</span>) {
          stateStack.push(state)
          state = MemberExpLexState.inString
          currentStringType = <span class="org-type">char</span>
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (<span class=
"org-type">char</span> === <span class="org-string">`(`</span>) {
          currentOpenParensCount++
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (<span class=
"org-type">char</span> === <span class="org-string">`)`</span>) {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">if the exp ends as a call then it should not be considered valid</span>
          <span class=
"org-keyword">if</span> (i === path.length - <span class=
"org-highlight-numbers-number">1</span>) {
            <span class="org-keyword">return</span> <span class=
"org-constant">false</span>
          }
          <span class=
"org-keyword">if</span> (!--currentOpenParensCount) {
            state = stateStack.pop()
          }
        }
        <span class="org-keyword">break</span>
      <span class=
"org-keyword">case</span> MemberExpLexState.inString:
        <span class="org-keyword">if</span> (<span class=
"org-type">char</span> === currentStringType) {
          state = stateStack.pop()
          currentStringType = <span class=
"org-constant">null</span>
        }
        <span class="org-keyword">break</span>
    }
  }
  <span class=
"org-keyword">return</span> !currentOpenBracketCount &amp;& !currentOpenParensCount
}

<span class="org-keyword">const</span> <span class=
"org-variable-name">isMemberExpressionNode</span> = __BROWSER__
  ? NOOP
  : (path, context) =&gt; {
      <span class="org-keyword">try</span> {
        <span class="org-keyword">let</span> <span class=
"org-variable-name">ret</span> = babelParser.parseExpression(path, {
          plugins: context.expressionPlugins
        })
        <span class=
"org-keyword">if</span> (ret.type === <span class=
"org-string">'TSAsExpression'</span> || ret.type === <span class=
"org-string">'TSTypeAssertion'</span>) {
          ret = ret.expression
        }
        <span class="org-keyword">return</span> (
          ret.type === <span class=
"org-string">'MemberExpression'</span> ||
          ret.type === <span class=
"org-string">'OptionalMemberExpression'</span> ||
          ret.type === <span class="org-string">'Identifier'</span>
        )
      } <span class="org-keyword">catch</span> (e) {
        <span class="org-keyword">return</span> <span class=
"org-constant">false</span>
      }
    }

<span class="org-keyword">const</span> <span class=
"org-variable-name">isMemberExpression</span> = __BROWSER__
  ? isMemberExpressionBrowser
  : isMemberExpressionNode

<span class="org-comment-delimiter">// </span><span class=
"org-comment">Check if a node contains expressions that reference current context scope ids</span>
<span class="org-keyword">function</span> <span class=
"org-function-name">hasScopeRef</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">ids</span>) {
  <span class=
"org-keyword">if</span> (!node || Object.keys(ids).length === <span class="org-highlight-numbers-number">0</span>) {
    <span class="org-keyword">return</span> <span class=
"org-constant">false</span>
  }
  <span class="org-keyword">switch</span> (node.type) {
    <span class="org-keyword">case</span> NodeTypes.ELEMENT:
      <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; node.props.length; i++) {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">p</span> = node.props[i]
        <span class="org-keyword">if</span> (
          p.type === NodeTypes.DIRECTIVE &amp;&
          (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))
        ) {
          <span class="org-keyword">return</span> <span class=
"org-constant">true</span>
        }
      }
      <span class=
"org-keyword">return</span> node.children.some((c) =&gt; hasScopeRef(c, ids))
    <span class="org-keyword">case</span> NodeTypes.FOR:
      <span class=
"org-keyword">if</span> (hasScopeRef(node.source, ids)) {
        <span class="org-keyword">return</span> <span class=
"org-constant">true</span>
      }
      <span class=
"org-keyword">return</span> node.children.some((c) =&gt; hasScopeRef(c, ids))
    <span class="org-keyword">case</span> NodeTypes.IF:
      <span class=
"org-keyword">return</span> node.branches.some((b) =&gt; hasScopeRef(b, ids))
    <span class="org-keyword">case</span> NodeTypes.IF_BRANCH:
      <span class=
"org-keyword">if</span> (hasScopeRef(node.condition, ids)) {
        <span class="org-keyword">return</span> <span class=
"org-constant">true</span>
      }
      <span class=
"org-keyword">return</span> node.children.some((c) =&gt; hasScopeRef(c, ids))
    <span class=
"org-keyword">case</span> NodeTypes.SIMPLE_EXPRESSION:
      <span class="org-keyword">return</span> (
        !node.isStatic &amp;&
        isSimpleIdentifier(node.content) &amp;&
        !!ids[node.content]
      )
    <span class=
"org-keyword">case</span> NodeTypes.COMPOUND_EXPRESSION:
      <span class=
"org-keyword">return</span> node.children.some((c) =&gt; isObject(c) &amp;& hasScopeRef(c, ids))
    <span class="org-keyword">case</span> NodeTypes.INTERPOLATION:
    <span class="org-keyword">case</span> NodeTypes.TEXT_CALL:
      <span class=
"org-keyword">return</span> hasScopeRef(node.content, ids)
    <span class="org-keyword">case</span> NodeTypes.TEXT:
    <span class="org-keyword">case</span> NodeTypes.COMMENT:
      <span class="org-keyword">return</span> <span class=
"org-constant">false</span>
    <span class="org-keyword">default</span>:
      <span class="org-keyword">if</span> (__DEV__) {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">exhaustiveCheck</span> = node
        exhaustiveCheck
      }
      <span class="org-keyword">return</span> <span class=
"org-constant">false</span>
  }
}

<span class="org-keyword">const</span> <span class=
"org-variable-name">SlotFlags</span> = {
<span id="coderef-SlotFlags" class="coderef-off">  <span class=
"org-comment-delimiter">//</span> (SlotFlags)</span>
  <span class="org-doc">/**</span>
<span class=
"org-doc">   * Stable slots that only reference slot props or context state. The slot</span>
<span class=
"org-doc">   * can fully capture its own dependencies so when passed down the parent won't</span>
<span class=
"org-doc">   * need to force the child to update.</span>
<span class="org-doc">   */</span>
  STABLE: <span class="org-highlight-numbers-number">1</span>,
  <span class="org-doc">/**</span>
<span class=
"org-doc">   * Slots that reference scope variables (v-for or an outer slot prop), or</span>
<span class=
"org-doc">   * has conditional structure (v-if, v-for). The parent will need to force</span>
<span class=
"org-doc">   * the child to update because the slot does not fully capture its dependencies.</span>
<span class="org-doc">   */</span>
  DYNAMIC: <span class="org-highlight-numbers-number">2</span>,
  <span class="org-doc">/**</span>
<span class=
"org-doc">   * `&lt;slot/&gt;` being forwarded into a child component. Whether the parent needs</span>
<span class=
"org-doc">   * to update the child is dependent on what kind of slots the parent itself</span>
<span class=
"org-doc">   * received. This has to be refined at runtime, when the child's vnode</span>
<span class=
"org-doc">   * is being created (in `normalizeChildren`)</span>
<span class="org-doc">   */</span>
  FORWARDED: <span class="org-highlight-numbers-number">3</span>
}

<span class="org-doc">/**</span>
<span class="org-doc"> * Dev only</span>
<span class="org-doc"> */</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">slotFlagsText</span> = {
  [SlotFlags.STABLE]: <span class="org-string">'STABLE'</span>,
  [SlotFlags.DYNAMIC]: <span class="org-string">'DYNAMIC'</span>,
  [SlotFlags.FORWARDED]: <span class=
"org-string">'FORWARDED'</span>
}

<span class="org-keyword">function</span> <span class=
"org-function-name">createElementWithCodegen</span>(
  <span class="org-variable-name">tag</span>,
  <span class="org-variable-name">props</span>,
  <span class="org-variable-name">children</span>,
  <span class="org-variable-name">patchFlag</span>,
  dynamicProps
) {
  <span class="org-keyword">return</span> {
    type: NodeTypes.ELEMENT,
    loc: locStub,
    ns: Namespaces.HTML,
    tag: <span class="org-string">'div'</span>,
    tagType: ElementTypes.ELEMENT,
    isSelfClosing: <span class="org-constant">false</span>,
    props: [],
    children: [],
    codegenNode: {
      type: NodeTypes.VNODE_CALL,
      tag,
      props,
      children,
      patchFlag,
      dynamicProps,
      directives: <span class="org-constant">undefined</span>,
      isBlock: <span class="org-constant">false</span>,
      disableTracking: <span class="org-constant">false</span>,
      isComponent: <span class="org-constant">false</span>,
      loc: locStub
    }
  }
}

<span class="org-comment-delimiter">// </span><span class=
"org-comment">codegen utils</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">PURE_ANNOTATION</span> = <span class=
"org-string">`/*#__PURE__*/`</span>

<span class="org-keyword">function</span> <span class=
"org-function-name">isText$1</span>(<span class=
"org-variable-name">n</span>) {
  <span class="org-keyword">return</span> (
    isString(n) ||
    n.type === NodeTypes.SIMPLE_EXPRESSION ||
    n.type === NodeTypes.TEXT ||
    n.type === NodeTypes.INTERPOLATION ||
    n.type === NodeTypes.COMPOUND_EXPRESSION
  )
}

<span class="org-comment-delimiter">// </span><span class=
"org-comment">过滤掉后面空值参数fn(a, b, c, null, undefined, '') =&gt; fn(a,b,c)</span>
<span class="org-keyword">function</span> <span class=
"org-function-name">genNullableArgs</span>(<span class=
"org-variable-name">args</span>) {
  <span class="org-keyword">let</span> <span class=
"org-variable-name">i</span> = args.length
  <span class="org-keyword">while</span> (i--) {
    <span class="org-keyword">if</span> (args[i] != <span class=
"org-constant">null</span>) <span class="org-keyword">break</span>
  }
  <span class="org-keyword">return</span> args.slice(<span class=
"org-highlight-numbers-number">0</span>, i + <span class=
"org-highlight-numbers-number">1</span>).map((arg) =&gt; arg || <span class="org-string">`null`</span>)
}

<span class="org-comment-delimiter">// </span><span class=
"org-comment">生成对象的 key 值，可能是个表达式，如： { [a + b + c]: value }</span>
<span class="org-keyword">function</span> <span class=
"org-function-name">genExpressionAsPropertyKey</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
  <span class="org-keyword">const</span> { push } = context
  <span class=
"org-keyword">if</span> (node.type === NodeTypes.COMPOUND_EXPRESSION) {
    push(<span class="org-string">`[`</span>)
    genCompoundExpression(node, context)
    push(<span class="org-string">`]`</span>)
  } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (node.isStatic) {
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">only quote keys if necessary</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">text</span> = isSimpleIdentifier(node.content)
      ? node.content
      : JSON.stringify(node.content)
    push(text, node)
  } <span class="org-keyword">else</span> {
    push(<span class="org-string">`[${node.content}]`</span>, node)
  }
}
  <span class="org-keyword">function</span> <span class=
"org-function-name">createParserContext</span>(<span class=
"org-variable-name">content</span>, <span class=
"org-variable-name">rawOptions</span>) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">options</span> = extend({}, defaultParserOptions)
  
    <span class="org-keyword">let</span> <span class=
"org-variable-name">key</span>
    <span class="org-keyword">for</span> (key <span class=
"org-keyword">in</span> rawOptions) {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">@ts-ignore</span>
      options[key] =
        rawOptions[key] === <span class=
"org-constant">undefined</span>
          ? defaultParserOptions[key]
          : rawOptions[key]
    }
    <span class="org-keyword">return</span> {
      options,
      column: <span class="org-highlight-numbers-number">1</span>,
      line: <span class="org-highlight-numbers-number">1</span>,
      offset: <span class="org-highlight-numbers-number">0</span>,
      originalSource: content,
      source: content,
      inPre: <span class="org-constant">false</span>,
      inVPre: <span class="org-constant">false</span>,
      onWarn: options.onWarn
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">createRoot</span>(<span class=
"org-variable-name">children</span>, <span class=
"org-variable-name">loc</span> = <span class=
"org-variable-name">locStub</span>) {
    <span class="org-keyword">return</span> {
      type: NodeTypes.ROOT,
      children,
      helpers: [],
      components: [],
      directives: [],
      hoists: [],
      imports: [],
      cached: <span class="org-highlight-numbers-number">0</span>,
      temps: <span class="org-highlight-numbers-number">0</span>,
      codegenNode: <span class="org-constant">undefined</span>,
      loc
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">parseChildren</span>(<span class=
"org-variable-name">context</span>, <span class=
"org-variable-name">mode</span>, <span class=
"org-variable-name">ancestors</span>) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">parent</span> = last(ancestors)
    <span class="org-keyword">const</span> <span class=
"org-variable-name">ns</span> = parent ? parent.ns : Namespaces.HTML
    <span class="org-keyword">const</span> <span class=
"org-variable-name">nodes</span> = [] <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">-&gt; ancestors</span>
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">1. while -&gt; isEnd ? 游标不断往前走直接所以 source 都解析完成</span>
    <span class=
"org-keyword">while</span> (!isEnd(context, mode, ancestors)) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">s</span> = context.source
      <span class="org-keyword">let</span> <span class=
"org-variable-name">node</span> = <span class=
"org-constant">undefined</span>
  
      <span class=
"org-keyword">if</span> (mode === TextModes.DATA || mode === TextModes.RCDATA) {
        <span class=
"org-keyword">if</span> (!context.inVPre &amp;& startsWith(s, context.options.delimiters[<span class="org-highlight-numbers-number">0</span>])) {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">'{{' 插值开始</span>
          node = parseInterpolation(context, mode)
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (mode === TextModes.DATA &amp;& s[<span class="org-highlight-numbers-number">0</span>] === <span class="org-string">'&lt;'</span>) {
          <span class="org-keyword">if</span> (s[<span class=
"org-highlight-numbers-number">1</span>] === <span class=
"org-string">'/'</span>) {
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">结束标签</span>
            <span class="org-keyword">if</span> (<span class=
"org-string">/[a-z]/</span>i.test(s[<span class=
"org-highlight-numbers-number">2</span>])) {
              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">异常结束，如：`&lt;div&gt;some text&lt;a`</span>
              emitError(context, <span class=
"org-string">'X_INVALID_END_TAG'</span>)
              parseTag(context, TagType.End, parent)
              <span class="org-keyword">continue</span>
            }
          } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (<span class=
"org-string">/[a-z]/</span>i.test(s[<span class=
"org-highlight-numbers-number">1</span>])) {
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">正常的开始标签</span>
            node = parseElement(context, ancestors)
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">2.x &lt;template&gt; 无指令兼容，这里就不实现了，重点关注 3.x 的代码</span>
          }
        }
      }
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">以上都不是，说明应该是纯文本节点</span>
      <span class="org-keyword">if</span> (!node) {
        node = parseText(context, mode)
      }
  
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">用 pushNode 在其中合并相邻的文本节点</span>
      <span class="org-keyword">if</span> (isArray(node)) {
        <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; node.length; i++) {
          pushNode(nodes, node[i])
        }
      } <span class="org-keyword">else</span> {
        pushNode(nodes, node)
      }
    }
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">2. 合并相邻文本节点，空格处理，会将多个空格合并成一个空格</span>
    <span class="org-keyword">let</span> <span class=
"org-variable-name">removedWhitespace</span> = <span class=
"org-constant">false</span>
    <span class=
"org-keyword">if</span> (mode !== TextModes.RAWTEXT &amp;& mode !== TextModes.RCDATA) {
      removedWhitespace = _removeWhitespace(nodes, context)
    }
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">3. 最后返回解析后的节点树</span>
    <span class=
"org-keyword">return</span> removedWhitespace ? nodes.filter(Boolean) : nodes
  }
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">_removeWhitespace</span>(<span class=
"org-variable-name">nodes</span>, <span class=
"org-variable-name">context</span>) {
    <span class="org-keyword">let</span> <span class=
"org-variable-name">removedWhitespace</span> = <span class=
"org-constant">false</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">可以通过选项来指定是不是保留空格，否则多余的会合并成一个</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">shouldCondense</span> = context.options.whitespace !== <span class="org-string">'preserve'</span>
    <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; nodes.length; i++) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">node</span> = nodes[i]
      <span class=
"org-keyword">if</span> (!context.inPre &amp;& node.type === NodeTypes.TEXT) {
        <span class="org-keyword">if</span> (!<span class=
"org-string">/[^\t\r\n\f]/</span>.test(node.content)) {
          <span class="org-keyword">const</span> <span class=
"org-variable-name">prev</span> = nodes[i - <span class=
"org-highlight-numbers-number">1</span>]
          <span class="org-keyword">const</span> <span class=
"org-variable-name">next</span> = nodes[i + <span class=
"org-highlight-numbers-number">1</span>]
  
          <span class="org-keyword">if</span> (
            !prev ||
              !next ||
              (shouldCondense &amp;& (
                prev.type === NodeTypes.COMMENT || next.type === NodeTypes.COMMENT || (
                  prev.type === NodeTypes.ELEMENT &amp;& next.type === NodeTypes.ELEMENT &amp;& <span class="org-string">/[\r\n]/</span>.test(node.content)
                )
              ))
          ) {
            removedWhitespace = <span class=
"org-constant">true</span>
            nodes[i] = <span class="org-constant">null</span>
          } <span class="org-keyword">else</span> {
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">合并成一个</span>
            node.content = <span class="org-string">' '</span>
          }
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (shouldCondense) {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">保留空格</span>
          node.content = node.content.replace(<span class=
"org-string">/[\t\r\n\f]+/</span>g, <span class=
"org-string">' '</span>)
        }
      } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (node.type === NodeTypes.COMMENT &amp;& !context.options.comments) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">可以通过配置删除注释节点</span>
        removedWhitespace = <span class="org-constant">true</span>
        nodes[i] = <span class="org-constant">null</span>
      }
    }
  
    <span class=
"org-keyword">if</span> (context.inPre &amp;& parent &amp;& context.options.isPreTag(parent.tag)) {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">删除 &lt;pre&gt; 中的第一行的空行</span>
      <span class="org-keyword">const</span> <span class=
"org-variable-name">first</span> = nodes[<span class=
"org-highlight-numbers-number">0</span>]
      <span class=
"org-keyword">if</span> (first &amp;& first.type === NodeTypes.TEXT) {
        first.content = first.content.replace(<span class=
"org-string">/^\r?\n/</span>, <span class="org-string">''</span>)
      }
    }
  
    <span class="org-keyword">return</span> removedWhitespace
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">parseElement</span>(<span class=
"org-variable-name">context</span>, <span class=
"org-variable-name">ancestors</span>) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">parent</span> = last(ancestors)
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">1. 解析出开始标签</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">element</span> = parseTag(context, TagType.Start, parent)
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">自闭合的标签： &lt;div/&gt;</span>
    <span class=
"org-keyword">if</span> (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
      <span class="org-keyword">return</span> element
    }
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">children</span>
    ancestors.push(element)
  
    <span class="org-keyword">const</span> <span class=
"org-variable-name">mode</span> = context.options.getTextMode(element, parent)
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">递归解析子节点</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">children</span> = parseChildren(context, mode, ancestors)
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">解析完出栈 [root, parent1, parent2, ...] 代表层级</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">&lt;root&gt;&lt;parent1&gt;&lt;parent2&gt;&lt;/parent&gt;&lt;parent1&gt;&lt;/root&gt; -&gt; 解析过程中通过</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">ancestors 来维护这个层级关系</span>
    ancestors.pop()
  
    element.children = children
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">2. 解析结束标签</span>
    <span class=
"org-keyword">if</span> (startsWithEndTagOpen(context.source, element.tag)) {
      parseTag(context, TagType.End, parent)
    }
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">更新解析后节点在源码中的位置信息</span>
    element.loc = getSelection(context, element.loc.start)
  
    <span class="org-keyword">return</span> element
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">parseTag</span>(<span class=
"org-variable-name">context</span>, <span class=
"org-variable-name">type</span>, <span class=
"org-variable-name">parent</span>) {
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">1. 开始标签</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">start</span> = getCursor(context)
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">合法标签的正则匹配</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">match</span> = <span class=
"org-string">/^&lt;\/?([a-z][^\t\r\n\f /&gt;]*)/</span>i.exec(context.source)
    <span class="org-keyword">const</span> <span class=
"org-variable-name">tag</span> = match[<span class=
"org-highlight-numbers-number">1</span>]
    <span class="org-keyword">const</span> <span class=
"org-variable-name">ns</span> = context.options.getNamespace(tag, parent)
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">游标前进标签名长度的位置，如： &lt;div id="foo"&gt; -&gt; ` id="foo"&gt;`</span>
    advanceBy(context, match[<span class=
"org-highlight-numbers-number">0</span>].length)
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">空格处理</span>
    advanceSpaces(context)
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">parse attributes</span>
    <span class="org-keyword">let</span> <span class=
"org-variable-name">props</span> = parseAttributes(context, type)
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment"><span class="org-bold"><span class=
"org-warning">TODO</span></span></span><span class=
"org-comment"> v-pre 检测</span>
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">2. 闭合标签</span>
    <span class="org-keyword">let</span> <span class=
"org-variable-name">isSelfClosing</span> = <span class=
"org-constant">false</span>
    <span class=
"org-keyword">if</span> (context.source.length === <span class=
"org-highlight-numbers-number">0</span>) {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">非法情况, ignore</span>
    } <span class="org-keyword">else</span> {
      isSelfClosing = startsWith(context.source, <span class=
"org-string">'/&gt;'</span>)
      advanceBy(context, isSelfClosing ? <span class=
"org-highlight-numbers-number">2</span> : <span class=
"org-highlight-numbers-number">1</span>)
    }
  
    <span class="org-keyword">if</span> (type === TagType.End) {
      <span class="org-keyword">return</span>
    }
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">3. 分析出标签的类型</span>
    <span class="org-keyword">let</span> <span class=
"org-variable-name">tagType</span> = ElementTypes.ELEMENT
    <span class="org-keyword">if</span> (!context.inVPre) {
      <span class="org-keyword">if</span> (tag === <span class=
"org-string">'slot'</span>) {
        tagType = ElementTypes.SLOT
      } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (tag === <span class=
"org-string">'template'</span>) {
        <span class=
"org-keyword">if</span> (props.some(p =&gt; p.type === NodeTypes.DIRECTIVE &amp;& isSpecialTemplateDirective(p.name))) {
          tagType = ElementTypes.TEMPLATE
        }
      } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (isComponent(tag, props, context)) {
        tagType = ElementTypes.COMPONENT
      }
    }
  
    <span class="org-keyword">return</span> {
      type: NodeTypes.ELEMENT,
      ns,
      tag,
      tagType,
      props,
      isSelfClosing,
      children: [],
      loc: getSelection(context, start),
      codegenNode: <span class=
"org-constant">undefined</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">在 transform 阶段生成的产物</span>
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">parseText</span>(<span class=
"org-variable-name">context</span>, <span class=
"org-variable-name">mode</span>) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">endTokens</span> = mode === TextModes.CDATA ? [<span class="org-string">']]&gt;'</span>] : [<span class="org-string">'&lt;'</span>, context.options.delimiters[<span class="org-highlight-numbers-number">0</span>]]
  
    <span class="org-keyword">let</span> <span class=
"org-variable-name">endIndex</span> = context.source.length
    <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; endTokens.length; i++) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">index</span> = context.source.indexOf(endTokens[i], <span class="org-highlight-numbers-number">1</span>)
      <span class="org-keyword">if</span> (index !== -<span class=
"org-highlight-numbers-number">1</span> &amp;& endIndex &gt; index) {
        endIndex = index
      }
    }
  
    <span class="org-keyword">const</span> <span class=
"org-variable-name">start</span> = getCursor(context)
    <span class="org-keyword">const</span> <span class=
"org-variable-name">content</span> = parseTextData(context, endIndex, mode)
  
    <span class="org-keyword">return</span> {
      type: NodeTypes.TEXT,
      content,
      loc: getSelection(context, start)
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">parseTextData</span>(<span class=
"org-variable-name">context</span>, <span class=
"org-variable-name">length</span>, <span class=
"org-variable-name">mode</span>) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">rawText</span> = context.source.slice(<span class="org-highlight-numbers-number">0</span>, length)
    advanceBy(context, length)
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">不含HTML entities</span>
    <span class=
"org-keyword">if</span> (mode === TextModes.RAWTEXT || mode === TextModes.CDATA || !rawText.includes(<span class="org-string">'&amp;'</span>)) {
      <span class="org-keyword">return</span> rawText
    } <span class="org-keyword">else</span> {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">将 &amp;gt; -&gt; `&gt;`, &amp;lt; -&gt; `&lt;`, &amp;amp; -&gt; `&amp;`, &amp;apos; -&gt; `'`, &amp;quot; -&gt; `"`</span>
      <span class=
"org-keyword">return</span> context.options.decodeEntities(rawText, mode === TextModes.ATTRIBUTE_VALUE)
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">parseInterpolation</span>(<span class=
"org-variable-name">context</span>, <span class=
"org-variable-name">mode</span>) {
    <span class="org-keyword">const</span> [<span class=
"org-variable-name">open</span>, <span class=
"org-variable-name">close</span>] = context.options.delimiters
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">如： source = "{{ a + b }}"</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">closeIndex = indexOf("}}", "{{".length) = 9</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">closeIndex</span> = context.source.indexOf(close, open.length)
    <span class=
"org-keyword">if</span> (closeIndex === -<span class=
"org-highlight-numbers-number">1</span>) {
      emitError(context, <span class=
"org-string">'X_MISSING_INTERPOLATION_END'</span>)
      <span class="org-keyword">return</span> <span class=
"org-constant">undefined</span>
    }
  
    <span class="org-keyword">const</span> <span class=
"org-variable-name">start</span> = getCursor(context)
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">&gt;&gt; 2 -&gt; " a + b }}"</span>
    advanceBy(context, open.length)
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">{ line, column, offset }</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">innerStart</span> = getCursor(context)
    <span class="org-keyword">const</span> <span class=
"org-variable-name">innerEnd</span> = getCursor(context)
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">9 - '{{'.length = 7</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">rawContentLength</span> = closeIndex - open.length
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">" a + b }}".slice(0, 7) =&gt; " a + b "</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">rawContent</span> = context.source.slice(<span class="org-highlight-numbers-number">0</span>, rawContentLength)
    <span class="org-keyword">const</span> <span class=
"org-variable-name">preTrimContent</span> = parseTextData(context, rawContentLength, mode)
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">" a + b " =&gt; "a + b"</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">content</span> = preTrimContent.trim()
    <span class="org-keyword">const</span> <span class=
"org-variable-name">startOffset</span> = preTrimContent.indexOf(content)
    <span class=
"org-keyword">if</span> (startOffset &gt; <span class=
"org-highlight-numbers-number">0</span>) {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">处理换行问题</span>
      advancePositionWithMutation(innerStart, rawContent, startOffset)
    }
    <span class="org-keyword">const</span> <span class=
"org-variable-name">endOffset</span> = rawContentLength - (preTrimContent.length - content.length - startOffset)
    advancePositionWithMutation(innerEnd, rawContent, endOffset)
    advanceBy(context, close.length)
  
    <span class="org-keyword">return</span> {
      type: NodeTypes.INTERPOLATION,
      content: {
        type: NodeTypes.SIMPLE_EXPRESSION,
        isStatic: <span class="org-constant">false</span>,
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">Set `isConstant` to false by default and will decide in transformExpression</span>
        constType: ConstantTypes.NOT_CONSTANT,
        content,
        loc: getSelection(context, innerStart, innerEnd)
      },
      loc: getSelection(context, start)
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">parseAttributes</span>(<span class=
"org-variable-name">context</span>, <span class=
"org-variable-name">type</span>) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">props</span> = []
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">用 set 避免重复属性</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">attributeNames</span> = <span class=
"org-keyword">new</span> <span class="org-type">Set</span>()
    <span class="org-keyword">while</span> (
      context.source.length &gt; <span class=
"org-highlight-numbers-number">0</span> &amp;&
        !startsWith(context.source, <span class=
"org-string">'&gt;'</span>) &amp;&
        !startsWith(context.source, <span class=
"org-string">'/&gt;'</span>)
    ) {
  
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">一些非法检测, ignore</span>
  
      <span class="org-keyword">const</span> <span class=
"org-variable-name">attr</span> = parseAttribute(context, attributeNames)
  
      logg(<span class="org-string">'ATTR'</span>, attr)
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">去掉 class 之间多余的空格，如： `foo   bar  ` -&gt; `foo bar`</span>
      <span class=
"org-keyword">if</span> (attr.type === NodeTypes.ATTRIBUTE &amp;&
         attr.value &amp;& attr.name === <span class=
"org-string">'class'</span>) {
        attr.value.content = attr.value.content.replace(<span class="org-string">/\s+/</span>g, <span class="org-string">' '</span>).trim()
      }
  
      <span class=
"org-keyword">if</span> (type === TagType.Start) {
        props.push(attr)
      }
  
      advanceSpaces(context)
    }
  
    <span class="org-keyword">return</span> props
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">parseAttribute</span>(<span class=
"org-variable-name">context</span>, <span class=
"org-variable-name">nameSet</span>) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">start</span> = getCursor(context)
    <span class="org-keyword">const</span> <span class=
"org-variable-name">match</span> = <span class=
"org-string">/^[^\t\r\n\f /&gt;][^\t\r\n\f /&gt;=]*/</span>.exec(context.source)
    <span class="org-keyword">const</span> <span class=
"org-variable-name">name</span> = match[<span class=
"org-highlight-numbers-number">0</span>]
  
    nameSet.add(name)
  
    advanceBy(context, name.length)
  
    <span class="org-keyword">let</span> <span class=
"org-variable-name">value</span> = <span class=
"org-constant">undefined</span>
  
    <span class="org-keyword">if</span> (<span class=
"org-string">/^[\t\r\n\f ]*=/</span>.test(context.source)) {
      advanceSpaces(context)
      advanceBy(context, <span class=
"org-highlight-numbers-number">1</span>)
      advanceSpaces(context)
      value = parseAttributeValue(context)
    }
  
    <span class="org-keyword">const</span> <span class=
"org-variable-name">loc</span> = getSelection(context, start)
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">v-on(@), v-bind(:), v-if, v-else, v-slot(#) 指令</span>
    <span class=
"org-keyword">if</span> (!context.inVPre &amp;& <span class=
"org-string">/^(v-[A-Za-z0-9-]|:|\.|@|#)/</span>.test(name)) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">match</span> = <span class=
"org-string">/(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/</span>i.exec(name)
  
      log(<span class=
"org-string">`parseAttribute| match=${match}`</span>)
      <span class="org-keyword">let</span> <span class=
"org-variable-name">isPropShorthand</span> = startsWith(name, <span class="org-string">'.'</span>)
      <span class="org-keyword">let</span> <span class=
"org-variable-name">dirName</span> =
          match[<span class=
"org-highlight-numbers-number">1</span>] ||
          (isPropShorthand || startsWith(name, <span class=
"org-string">':'</span>)
           ? <span class="org-string">'bind'</span>
           : startsWith(name, <span class="org-string">'@'</span>)
          ? <span class="org-string">'on'</span>
          : <span class="org-string">'slot'</span>)
      <span class="org-keyword">let</span> <span class=
"org-variable-name">arg</span>
  
      <span class="org-keyword">if</span> (match[<span class=
"org-highlight-numbers-number">2</span>]) {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">isSlot</span> = dirName === <span class=
"org-string">'slot'</span>
        <span class="org-keyword">const</span> <span class=
"org-variable-name">startOffset</span> = name.lastIndexOf(match[<span class="org-highlight-numbers-number">2</span>])
        <span class="org-keyword">const</span> <span class=
"org-variable-name">loc</span> = getSelection(
          context,
          getNewPosition(context, start, startOffset),
          getNewPosition(
            context,
            start,
            startOffset + match[<span class=
"org-highlight-numbers-number">2</span>].length + ((isSlot &amp;& match[<span class="org-highlight-numbers-number">3</span>]) || <span class="org-string">''</span>).length
          )
        )
  
        <span class="org-keyword">let</span> <span class=
"org-variable-name">content</span> = match[<span class=
"org-highlight-numbers-number">2</span>]
        <span class="org-keyword">let</span> <span class=
"org-variable-name">isStatic</span> = <span class=
"org-constant">true</span>
  
        <span class=
"org-keyword">if</span> (content.startsWith(<span class=
"org-string">'['</span>)) {
          isStatic = <span class="org-constant">false</span>
  
          content = content.slice(<span class=
"org-highlight-numbers-number">1</span>, content.length - <span class="org-highlight-numbers-number">1</span>)
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (isSlot){
          content += match[<span class=
"org-highlight-numbers-number">3</span>] || <span class=
"org-string">''</span>
        }
  
        arg = {
          type: NodeTypes.SIMPLE_EXPRESSION,
          content,
          isStatic,
          constType: isStatic
            ? ConstantTypes.CAN_STRINGIFY
            : ConstantTypes.NOT_CONSTANT,
          loc
        }
      }
  
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">quoted: `foo="bar"`, not quoted: `foo=bar`</span>
      <span class=
"org-keyword">if</span> (value &amp;& value.isQuoted) {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">valueLoc</span> = value.loc
        valueLoc.start.offset++
        valueLoc.start.column++
        valueLoc.end = advancePositionWithClone(valueLoc.start, value.content)
        valueLoc.source = valueLoc.source.slice(<span class=
"org-highlight-numbers-number">1</span>, -<span class=
"org-highlight-numbers-number">1</span>)
      }
  
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">修饰符 v-bind.number="foo" =&gt; '.number' =&gt; ['number']</span>
      <span class="org-keyword">const</span> <span class=
"org-variable-name">modifiers</span> = match[<span class=
"org-highlight-numbers-number">3</span>] ? match[<span class=
"org-highlight-numbers-number">3</span>].slice(<span class=
"org-highlight-numbers-number">1</span>).split(<span class=
"org-string">'.'</span>) : []
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">`&lt;div foo.prop="bar"&gt;` 如果不加 `.prop` 这个会被解析到 `$attrs` 中</span>
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">如果加了 `.prop` 则会被解析到 `$props` 中去</span>
      <span class="org-keyword">if</span> (isPropShorthand) {
        modifiers.push(<span class="org-string">'prop'</span>)
      }
  
      <span class="org-keyword">return</span> {
        type: NodeTypes.DIRECTIVE,
        name: dirName,
        exp: value &amp;& {
          type: NodeTypes.SIMPLE_EXPRESSION,
          content: value.content,
          isStatic: <span class="org-constant">false</span>,
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">Treat as non-constant by default. This can be potentially set to</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">other values by `transformExpression` to make it eligible for hoisting.</span>
          constType: ConstantTypes.NOT_CONSTANT,
          loc: value.loc
        },
        arg,
        modifiers,
        loc
      }
    }
  
    <span class="org-keyword">return</span> {
      type: NodeTypes.ATTRIBUTE,
      name,
      value: value &amp;& {
        type: NodeTypes.TEXT,
        content: value.content,
        loc: value.loc
      },
      loc
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">parseAttributeValue</span>(<span class=
"org-variable-name">context</span>) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">start</span> = getCursor(context)
    <span class="org-keyword">let</span> <span class=
"org-variable-name">content</span>
  
    <span class="org-keyword">const</span> <span class=
"org-variable-name">quote</span> = context.source[<span class=
"org-highlight-numbers-number">0</span>]
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">value 分两种情况，可以用引号包起来也可以不使用引号</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">`&lt;div foo="value"&gt;` 或 `&lt;div foo=value&gt;`</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">isQuoted</span> = quote === <span class=
"org-string">`"`</span> || quote === <span class=
"org-string">`'`</span>
    <span class="org-keyword">if</span> (isQuoted) {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">Quoted value.</span>
      advanceBy(context, <span class=
"org-highlight-numbers-number">1</span>)
  
      <span class="org-keyword">const</span> <span class=
"org-variable-name">endIndex</span> = context.source.indexOf(quote)
      <span class=
"org-keyword">if</span> (endIndex === -<span class=
"org-highlight-numbers-number">1</span>) {
        content = parseTextData(
          context,
          context.source.length,
          TextModes.ATTRIBUTE_VALUE
        )
      } <span class="org-keyword">else</span> {
        content = parseTextData(context, endIndex, TextModes.ATTRIBUTE_VALUE)
        advanceBy(context, <span class=
"org-highlight-numbers-number">1</span>)
      }
    } <span class="org-keyword">else</span> {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">Unquoted</span>
      <span class="org-keyword">const</span> <span class=
"org-variable-name">match</span> = <span class=
"org-string">/^[^\t\r\n\f &gt;]+/</span>.exec(context.source)
      <span class="org-keyword">if</span> (!match) {
        <span class="org-keyword">return</span> <span class=
"org-constant">undefined</span>
      }
      content = parseTextData(context, match[<span class=
"org-highlight-numbers-number">0</span>].length, TextModes.ATTRIBUTE_VALUE)
    }
  
    <span class=
"org-keyword">return</span> { content, isQuoted, loc: getSelection(context, start) }
  }
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">baseParse</span>(<span class=
"org-variable-name">content</span>, <span class=
"org-variable-name">options</span> = {}) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">context</span> = createParserContext(content, options)
    <span class="org-keyword">const</span> <span class=
"org-variable-name">start</span> = getCursor(context)
    <span class="org-keyword">return</span> createRoot(
      parseChildren(context, TextModes.DATA, []),
      getSelection(context, start)
    )
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">createTransformContext</span>(
    <span class="org-variable-name">root</span>,
    {
      filename = <span class="org-string">''</span>,
      prefixIdentifiers = <span class="org-constant">false</span>,
      hoistStatic = <span class="org-constant">false</span>,
      cacheHandlers = <span class="org-constant">false</span>,
      nodeTransforms = [],
      directiveTransforms = {},
      transformHoist = <span class="org-constant">null</span>,
      isBuiltInComponent = NOOP,
      isCustomElement = NOOP,
      expressionPlugins = [],
      scopeId = <span class="org-constant">null</span>,
      slotted = <span class="org-constant">true</span>,
      ssr = <span class="org-constant">false</span>,
      inSSR = <span class="org-constant">false</span>,
      ssrCssVars = <span class="org-string">``</span>,
      bindingMetadata = EMPTY_OBJ,
      inline = <span class="org-constant">false</span>,
      isTS = <span class="org-constant">false</span>,
      onError = defaultOnError,
      onWarn = defaultOnWarn,
      compatConfig
    }
  ) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">nameMatch</span> = filename.replace(<span class="org-string">/\?.*$/</span>, <span class="org-string">''</span>).match(<span class="org-string">/([^/\\]+)\.\w+$/</span>)
    <span class="org-keyword">const</span> <span class=
"org-variable-name">context</span> = {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">options</span>
      selfName: nameMatch &amp;& capitalize(camelize(nameMatch[<span class="org-highlight-numbers-number">1</span>])),
      prefixIdentifiers,
      hoistStatic,
      cacheHandlers,
      nodeTransforms,
      directiveTransforms,
      transformHoist,
      isBuiltInComponent,
      isCustomElement,
      expressionPlugins,
      scopeId,
      slotted,
      ssr,
      inSSR,
      ssrCssVars,
      bindingMetadata,
      inline,
      isTS,
      onError,
      onWarn,
      compatConfig,
  
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">state</span>
      root,
      helpers: <span class="org-keyword">new</span> <span class=
"org-type">Map</span>(),
      components: <span class="org-keyword">new</span> <span class=
"org-type">Set</span>(),
      directives: <span class="org-keyword">new</span> <span class=
"org-type">Set</span>(),
      hoists: [],
      imports: [],
      constantCache: <span class=
"org-keyword">new</span> <span class="org-type">Map</span>(),
      temps: <span class="org-highlight-numbers-number">0</span>,
      cached: <span class="org-highlight-numbers-number">0</span>,
      identifiers: Object.create(<span class=
"org-constant">null</span>),
      scopes: { <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">记录下面四个指令的嵌套层次</span>
        vFor: <span class="org-highlight-numbers-number">0</span>,
        vSlot: <span class="org-highlight-numbers-number">0</span>,
        vPre: <span class="org-highlight-numbers-number">0</span>,
        vOnce: <span class="org-highlight-numbers-number">0</span>
      },
      parent: <span class="org-constant">null</span>,
      currentNode: root,
      childIndex: <span class=
"org-highlight-numbers-number">0</span>,
      inVOnce: <span class="org-constant">false</span>,
  
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">methods</span>
      helper(name) {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">count</span> = context.helpers.get(name) || <span class="org-highlight-numbers-number">0</span>
        context.helpers.set(name, count + <span class=
"org-highlight-numbers-number">1</span>)
        <span class="org-keyword">return</span> name
      },
      removeHelper(name) {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">count</span> = context.helpers.get(name)
        <span class="org-keyword">if</span> (count) {
          <span class="org-keyword">const</span> <span class=
"org-variable-name">currentCount</span> = count - <span class=
"org-highlight-numbers-number">1</span>
          <span class="org-keyword">if</span> (!currentCount) {
            context.helpers.<span class=
"org-keyword">delete</span>(name)
          } <span class="org-keyword">else</span> {
            context.helpers.set(name, currentCount)
          }
        }
      },
      helperString(name) {
        <span class="org-keyword">return</span> <span class=
"org-string">`_${helperNameMap[context.helper(name)]}`</span>
      },
      replaceNode(node) {
        context.parent.children[context.childIndex] = context.currentNode = node
      },
      removeNode(node) {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">list</span> = context.parent.children
        <span class="org-keyword">const</span> <span class=
"org-variable-name">removalIndex</span> = node
          ? list.indexOf(node)
          : context.currentNode
          ? context.childIndex
          : -<span class="org-highlight-numbers-number">1</span>
  
        <span class=
"org-keyword">if</span> (!node || node === context.currentNode) {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">current node removed</span>
          context.currentNode = <span class=
"org-constant">null</span>
          context.onNodeRemoved()
        } <span class="org-keyword">else</span> {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">sibling node removed</span>
          <span class=
"org-keyword">if</span> (context.childIndex &gt; removalIndex) {
            context.childIndex--
            context.onNodeRemoved()
          }
        }
        context.parent.children.splice(removalIndex, <span class=
"org-highlight-numbers-number">1</span>)
      },
      onNodeRemoved: () =&gt; {},
      addIdentifiers(exp) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">identifier tracking only happens in non-browser builds.</span>
        <span class="org-keyword">if</span> (!__BROWSER__) {
          <span class="org-keyword">if</span> (isString(exp)) {
            addId(exp)
          } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (exp.identifiers) {
            exp.identifiers.forEach(addId)
          } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (exp.type === NodeTypes.SIMPLE_EXPRESSION) {
            addId(exp.content)
          }
        }
      },
      removeIdentifiers(exp) {
        <span class="org-keyword">if</span> (!__BROWSER__) {
          <span class="org-keyword">if</span> (isString(exp)) {
            removeId(exp)
          } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (exp.identifiers) {
            exp.identifiers.forEach(removeId)
          } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (exp.type === NodeTypes.SIMPLE_EXPRESSION) {
            removeId(exp.content)
          }
        }
      },
      hoist(exp) {
        <span class=
"org-keyword">if</span> (isString(exp)) exp = createSimpleExpression(exp)
        context.hoists.push(exp)
        <span class="org-keyword">const</span> <span class=
"org-variable-name">identifier</span> = createSimpleExpression(
          <span class=
"org-string">`_hoisted_${context.hoists.length}`</span>,
          <span class="org-constant">false</span>,
          exp.loc,
          ConstantTypes.CAN_HOIST
        )
        identifier.hoisted = exp
        <span class="org-keyword">return</span> identifier
      },
      cache(exp, isVNode = <span class=
"org-constant">false</span>) {
        <span class=
"org-keyword">return</span> createCacheExpression(context.cached++, exp, isVNode)
      }
    }
  
    <span class="org-keyword">function</span> <span class=
"org-function-name">addId</span>(<span class=
"org-variable-name">id</span>) {
      <span class=
"org-keyword">const</span> { identifiers } = context
      <span class=
"org-keyword">if</span> (identifiers[id] === <span class=
"org-constant">undefined</span>) {
        identifiers[id] = <span class=
"org-highlight-numbers-number">0</span>
      }
      identifiers[id]++
    }
  
    <span class="org-keyword">function</span> <span class=
"org-function-name">removeId</span>(<span class=
"org-variable-name">id</span>) {
      context.identifiers[id]--
    }
  
    <span class="org-keyword">return</span> context
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">traverseNode</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">记录当前正在处理的节点</span>
    context.currentNode = node
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">对节点转换时使用到的插件(外部可通过这个来修改某个指令)</span>
    <span class=
"org-keyword">const</span> { nodeTransforms } = context
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">递归遍历结束，回溯时调用的函数列表</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">也就是这个函数最后执行的函数，当一颗树遍历完成执行的函数</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">随后的 for 循环是用来收集这些函数的</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">exitFns</span> = []
  
    logg(<span class="org-string">'traverseNode'</span>, node)
    <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; nodeTransforms.length; i++) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">onExit</span> = nodeTransforms[i](node, context)
      <span class="org-keyword">if</span> (onExit) {
        <span class="org-keyword">if</span> (isArray(onExit)) {
          exitFns.push(...onExit)
        } <span class="org-keyword">else</span> {
          exitFns.push(onExit)
        }
      }
      <span class="org-keyword">if</span> (!context.currentNode) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">node was removed</span>
        <span class="org-keyword">return</span>
      } <span class="org-keyword">else</span> {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">node may have been replaced</span>
        node = context.currentNode
      }
    }
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">根据节点类型来分别处理，这里忽略注释</span>
    <span class="org-keyword">switch</span> (node.type) {
      <span class=
"org-keyword">case</span> NodeTypes.INTERPOLATION:
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">no need to traverse, but we need to inject toString helper</span>
        <span class="org-keyword">if</span> (!context.ssr) {
          context.helper(TO_DISPLAY_STRING)
        }
        <span class="org-keyword">break</span>
  
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">for container types, further traverse downwards</span>
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">处理 if...else if...else 分支</span>
      <span class="org-keyword">case</span> NodeTypes.IF:
        <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; node.branches.length; i++) {
          traverseNode(node.branches[i], context)
        }
        <span class="org-keyword">break</span>
      <span class=
"org-keyword">case</span> NodeTypes.IF_BRANCH: <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">else..if</span>
      <span class=
"org-keyword">case</span> NodeTypes.FOR: <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">for</span>
      <span class="org-keyword">case</span> NodeTypes.ELEMENT:
      <span class="org-keyword">case</span> NodeTypes.ROOT:
        traverseChildren(node, context)
        <span class="org-keyword">break</span>
    }
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">收集完成，执行这些收集到的函数，作用到当前节点上</span>
    context.currentNode = node
    <span class="org-keyword">let</span> <span class=
"org-variable-name">i</span> = exitFns.length
    <span class="org-keyword">while</span> (i--) {
      exitFns[i]()
    }
  }
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">traverseChildren</span>(<span class=
"org-variable-name">parent</span>, <span class=
"org-variable-name">context</span>) {
    <span class="org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">nodeRemoved</span> = () =&gt; {
      i--
    }
    <span class=
"org-keyword">for</span> (; i &lt; parent.children.length; i++) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">child</span> = parent.children[i]
      <span class=
"org-keyword">if</span> (isString(child)) <span class=
"org-keyword">continue</span>
      context.parent = parent
      context.childIndex = i
      context.onNodeRemoved = nodeRemoved
      traverseNode(child, context)
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">hoistStatic</span>(<span class=
"org-variable-name">root</span>, <span class=
"org-variable-name">context</span>) {
    _walk(
      root,
      context,
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">Root node is unfortunately non-hoistable due to potential parent</span>
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">fallthrough attributes.</span>
      isSingleElementRoot(root, root.children[<span class=
"org-highlight-numbers-number">0</span>])
    )
  }
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">isSingleElementRoot</span>(
    <span class="org-variable-name">root</span>,
    child
  ) {
    <span class="org-keyword">const</span> { children } = root
    <span class="org-keyword">return</span> (
      children.length === <span class=
"org-highlight-numbers-number">1</span> &amp;&
      child.type === NodeTypes.ELEMENT &amp;&
      !isSlotOutlet(child)
    )
  }
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">_walk</span>(
    <span class="org-variable-name">node</span>,
    <span class="org-variable-name">context</span>,
    doNotHoistNode = <span class="org-constant">false</span>
  ) {
    <span class="org-keyword">const</span> { children } = node
    <span class="org-keyword">const</span> <span class=
"org-variable-name">originalCount</span> = children.length
    <span class="org-keyword">let</span> <span class=
"org-variable-name">hoistedCount</span> = <span class=
"org-highlight-numbers-number">0</span>
  
    <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; children.length; i++) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">child</span> = children[i]
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">only plain elements & text calls are eligible for hoisting.</span>
      <span class="org-keyword">if</span> (
        child.type === NodeTypes.ELEMENT &amp;&
        child.tagType === ElementTypes.ELEMENT
      ) {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">constantType</span> = doNotHoistNode
          ? ConstantTypes.NOT_CONSTANT
          : getConstantType(child, context)
        <span class=
"org-keyword">if</span> (constantType &gt; ConstantTypes.NOT_CONSTANT) {
          <span class=
"org-keyword">if</span> (constantType &gt;= ConstantTypes.CAN_HOIST) {
            child.codegenNode.patchFlag =
              PatchFlags.HOISTED + (__DEV__ ? <span class=
"org-string">` /* HOISTED */`</span> : <span class=
"org-string">``</span>)
            child.codegenNode = context.hoist(child.codegenNode)
            hoistedCount++
            <span class="org-keyword">continue</span>
          }
        } <span class="org-keyword">else</span> {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">node may contain dynamic children, but its props may be eligible for</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">hoisting.</span>
          <span class="org-keyword">const</span> <span class=
"org-variable-name">codegenNode</span> = child.codegenNode
          <span class=
"org-keyword">if</span> (codegenNode.type === NodeTypes.VNODE_CALL) {
            <span class="org-keyword">const</span> <span class=
"org-variable-name">flag</span> = getPatchFlag(codegenNode)
            <span class="org-keyword">if</span> (
              (!flag ||
                flag === PatchFlags.NEED_PATCH ||
                flag === PatchFlags.TEXT) &amp;&
              getGeneratedPropsConstantType(child, context) &gt;=
                ConstantTypes.CAN_HOIST
            ) {
              <span class="org-keyword">const</span> <span class=
"org-variable-name">props</span> = getNodeProps(child)
              <span class="org-keyword">if</span> (props) {
                codegenNode.props = context.hoist(props)
              }
            }
            <span class=
"org-keyword">if</span> (codegenNode.dynamicProps) {
              codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps)
            }
          }
        }
      } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (
        child.type === NodeTypes.TEXT_CALL &amp;&
        getConstantType(child.content, context) &gt;= ConstantTypes.CAN_HOIST
      ) {
        child.codegenNode = context.hoist(child.codegenNode)
        hoistedCount++
      }
  
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">walk further</span>
      <span class=
"org-keyword">if</span> (child.type === NodeTypes.ELEMENT) {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">isComponent</span> = child.tagType === ElementTypes.COMPONENT
        <span class="org-keyword">if</span> (isComponent) {
          context.scopes.vSlot++
        }
        _walk(child, context)
        <span class="org-keyword">if</span> (isComponent) {
          context.scopes.vSlot--
        }
      } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (child.type === NodeTypes.FOR) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">Do not hoist v-for single child because it has to be a block</span>
        _walk(child, context, child.children.length === <span class="org-highlight-numbers-number">1</span>)
      } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (child.type === NodeTypes.IF) {
        <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; child.branches.length; i++) {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">Do not hoist v-if single child because it has to be a block</span>
          _walk(
            child.branches[i],
            context,
            child.branches[i].children.length === <span class=
"org-highlight-numbers-number">1</span>
          )
        }
      }
    }
  
    <span class=
"org-keyword">if</span> (hoistedCount &amp;& context.transformHoist) {
      logg(<span class=
"org-string">`hoist walk -&gt; transformHoist, hoistedCount = ${hoistedCount}`</span>)
      context.transformHoist(children, context, node)
    }
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">all children were hoisted - the entire children array is hoistable.</span>
    <span class="org-keyword">if</span> (
      hoistedCount &amp;&
      hoistedCount === originalCount &amp;&
      node.type === NodeTypes.ELEMENT &amp;&
      node.tagType === ElementTypes.ELEMENT &amp;&
      node.codegenNode &amp;&
      node.codegenNode.type === NodeTypes.VNODE_CALL &amp;&
      isArray(node.codegenNode.children)
    ) {
      node.codegenNode.children = context.hoist(
        createArrayExpression(node.codegenNode.children)
      )
    }
  }
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">getConstantType</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
    <span class=
"org-keyword">const</span> { constantCache } = context
    <span class="org-keyword">switch</span> (node.type) {
      <span class="org-keyword">case</span> NodeTypes.ELEMENT:
        <span class=
"org-keyword">if</span> (node.tagType !== ElementTypes.ELEMENT) {
          <span class=
"org-keyword">return</span> ConstantTypes.NOT_CONSTANT
        }
        <span class="org-keyword">const</span> <span class=
"org-variable-name">cached</span> = constantCache.get(node)
        <span class=
"org-keyword">if</span> (cached !== <span class="org-constant">undefined</span>) {
          <span class="org-keyword">return</span> cached
        }
        <span class="org-keyword">const</span> <span class=
"org-variable-name">codegenNode</span> = node.codegenNode
        <span class=
"org-keyword">if</span> (codegenNode.type !== NodeTypes.VNODE_CALL) {
          <span class=
"org-keyword">return</span> ConstantTypes.NOT_CONSTANT
        }
        <span class="org-keyword">if</span> (
          codegenNode.isBlock &amp;&
          node.tag !== <span class="org-string">'svg'</span> &amp;&
          node.tag !== <span class=
"org-string">'foreignObject'</span>
        ) {
          <span class=
"org-keyword">return</span> ConstantTypes.NOT_CONSTANT
        }
        <span class="org-keyword">const</span> <span class=
"org-variable-name">flag</span> = getPatchFlag(codegenNode)
        <span class="org-keyword">if</span> (!flag) {
          <span class="org-keyword">let</span> <span class=
"org-variable-name">returnType</span> = ConstantTypes.CAN_STRINGIFY
  
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">Element itself has no patch flag. However we still need to check:</span>
  
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">1. Even for a node with no patch flag, it is possible for it to contain</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">non-hoistable expressions that refers to scope variables, e.g. compiler</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">injected keys or cached event handlers. Therefore we need to always</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">check the codegenNode's props to be sure.</span>
          <span class="org-keyword">const</span> <span class=
"org-variable-name">generatedPropsType</span> = getGeneratedPropsConstantType(node, context)
          <span class=
"org-keyword">if</span> (generatedPropsType === ConstantTypes.NOT_CONSTANT) {
            constantCache.set(node, ConstantTypes.NOT_CONSTANT)
            <span class=
"org-keyword">return</span> ConstantTypes.NOT_CONSTANT
          }
          <span class=
"org-keyword">if</span> (generatedPropsType &lt; returnType) {
            returnType = generatedPropsType
          }
  
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">2. its children.</span>
          <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; node.children.length; i++) {
            <span class="org-keyword">const</span> <span class=
"org-variable-name">childType</span> = getConstantType(node.children[i], context)
            <span class=
"org-keyword">if</span> (childType === ConstantTypes.NOT_CONSTANT) {
              constantCache.set(node, ConstantTypes.NOT_CONSTANT)
              <span class=
"org-keyword">return</span> ConstantTypes.NOT_CONSTANT
            }
            <span class=
"org-keyword">if</span> (childType &lt; returnType) {
              returnType = childType
            }
          }
  
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">3. if the type is not already CAN_SKIP_PATCH which is the lowest non-0</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">type, check if any of the props can cause the type to be lowered</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">we can skip can_patch because it's guaranteed by the absence of a</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">patchFlag.</span>
          <span class=
"org-keyword">if</span> (returnType &gt; ConstantTypes.CAN_SKIP_PATCH) {
            <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; node.props.length; i++) {
              <span class="org-keyword">const</span> <span class=
"org-variable-name">p</span> = node.props[i]
              <span class=
"org-keyword">if</span> (p.type === NodeTypes.DIRECTIVE &amp;& p.name === <span class="org-string">'bind'</span> &amp;& p.exp) {
                <span class="org-keyword">const</span> <span class=
"org-variable-name">expType</span> = getConstantType(p.exp, context)
                <span class=
"org-keyword">if</span> (expType === ConstantTypes.NOT_CONSTANT) {
                  constantCache.set(node, ConstantTypes.NOT_CONSTANT)
                  <span class=
"org-keyword">return</span> ConstantTypes.NOT_CONSTANT
                }
                <span class=
"org-keyword">if</span> (expType &lt; returnType) {
                  returnType = expType
                }
              }
            }
          }
  
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">only svg/foreignObject could be block here, however if they are</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">static then they don't need to be blocks since there will be no</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">nested updates.</span>
          <span class=
"org-keyword">if</span> (codegenNode.isBlock) {
            context.removeHelper(OPEN_BLOCK)
            context.removeHelper(
              getVNodeBlockHelper(context.inSSR, codegenNode.isComponent)
            )
            codegenNode.isBlock = <span class=
"org-constant">false</span>
            context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent))
          }
  
          constantCache.set(node, returnType)
          <span class="org-keyword">return</span> returnType
        } <span class="org-keyword">else</span> {
          constantCache.set(node, ConstantTypes.NOT_CONSTANT)
          <span class=
"org-keyword">return</span> ConstantTypes.NOT_CONSTANT
        }
      <span class="org-keyword">case</span> NodeTypes.TEXT:
      <span class="org-keyword">case</span> NodeTypes.COMMENT:
        <span class=
"org-keyword">return</span> ConstantTypes.CAN_STRINGIFY
      <span class="org-keyword">case</span> NodeTypes.IF:
      <span class="org-keyword">case</span> NodeTypes.FOR:
      <span class="org-keyword">case</span> NodeTypes.IF_BRANCH:
        <span class=
"org-keyword">return</span> ConstantTypes.NOT_CONSTANT
      <span class=
"org-keyword">case</span> NodeTypes.INTERPOLATION:
      <span class="org-keyword">case</span> NodeTypes.TEXT_CALL:
        <span class=
"org-keyword">return</span> getConstantType(node.content, context)
      <span class=
"org-keyword">case</span> NodeTypes.SIMPLE_EXPRESSION:
        <span class="org-keyword">return</span> node.constType
      <span class=
"org-keyword">case</span> NodeTypes.COMPOUND_EXPRESSION:
        <span class="org-keyword">let</span> <span class=
"org-variable-name">returnType</span> = ConstantTypes.CAN_STRINGIFY
        <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; node.children.length; i++) {
          <span class="org-keyword">const</span> <span class=
"org-variable-name">child</span> = node.children[i]
          <span class=
"org-keyword">if</span> (isString(child) || isSymbol(child)) {
            <span class="org-keyword">continue</span>
          }
          <span class="org-keyword">const</span> <span class=
"org-variable-name">childType</span> = getConstantType(child, context)
          <span class=
"org-keyword">if</span> (childType === ConstantTypes.NOT_CONSTANT) {
            <span class=
"org-keyword">return</span> ConstantTypes.NOT_CONSTANT
          } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (childType &lt; returnType) {
            returnType = childType
          }
        }
        <span class="org-keyword">return</span> returnType
      <span class="org-keyword">default</span>:
        <span class=
"org-keyword">return</span> ConstantTypes.NOT_CONSTANT
    }
  }
  
  <span class="org-keyword">const</span> <span class=
"org-variable-name">allowHoistedHelperSet</span> = <span class=
"org-keyword">new</span> <span class="org-type">Set</span>([
    NORMALIZE_CLASS,
    NORMALIZE_STYLE,
    NORMALIZE_PROPS,
    GUARD_REACTIVE_PROPS
  ])
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">getConstantTypeOfHelperCall</span>(<span class=
"org-variable-name">value</span>, <span class=
"org-variable-name">context</span>){
    <span class="org-keyword">if</span> (
      value.type === NodeTypes.JS_CALL_EXPRESSION &amp;&
      !isString(value.callee) &amp;&
      allowHoistedHelperSet.has(value.callee)
    ) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">arg</span> = value.<span class=
"org-constant">arguments</span>[<span class=
"org-highlight-numbers-number">0</span>]
      <span class=
"org-keyword">if</span> (arg.type === NodeTypes.SIMPLE_EXPRESSION) {
        <span class=
"org-keyword">return</span> getConstantType(arg, context)
      } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (arg.type === NodeTypes.JS_CALL_EXPRESSION) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(exp))`</span>
        <span class=
"org-keyword">return</span> getConstantTypeOfHelperCall(arg, context)
      }
    }
    <span class=
"org-keyword">return</span> ConstantTypes.NOT_CONSTANT
  }
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">getGeneratedPropsConstantType</span>(<span class="org-variable-name">node</span>, <span class="org-variable-name">context</span>) {
    <span class="org-keyword">let</span> <span class=
"org-variable-name">returnType</span> = ConstantTypes.CAN_STRINGIFY
    <span class="org-keyword">const</span> <span class=
"org-variable-name">props</span> = getNodeProps(node)
    <span class=
"org-keyword">if</span> (props &amp;& props.type === NodeTypes.JS_OBJECT_EXPRESSION) {
      <span class="org-keyword">const</span> { properties } = props
      <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; properties.length; i++) {
        <span class=
"org-keyword">const</span> { key, value } = properties[i]
        <span class="org-keyword">const</span> <span class=
"org-variable-name">keyType</span> = getConstantType(key, context)
        <span class=
"org-keyword">if</span> (keyType === ConstantTypes.NOT_CONSTANT) {
          <span class="org-keyword">return</span> keyType
        }
        <span class=
"org-keyword">if</span> (keyType &lt; returnType) {
          returnType = keyType
        }
        <span class="org-keyword">let</span> <span class=
"org-variable-name">valueType</span>
        <span class=
"org-keyword">if</span> (value.type === NodeTypes.SIMPLE_EXPRESSION) {
          valueType = getConstantType(value, context)
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (value.type === NodeTypes.JS_CALL_EXPRESSION) {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">some helper calls can be hoisted,</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">such as the `normalizeProps` generated by the compiler for pre-normalize class,</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">in this case we need to respect the ConstantType of the helper's arguments</span>
          valueType = getConstantTypeOfHelperCall(value, context)
        } <span class="org-keyword">else</span> {
          valueType = ConstantTypes.NOT_CONSTANT
        }
        <span class=
"org-keyword">if</span> (valueType === ConstantTypes.NOT_CONSTANT) {
          <span class="org-keyword">return</span> valueType
        }
        <span class=
"org-keyword">if</span> (valueType &lt; returnType) {
          returnType = valueType
        }
      }
    }
    <span class="org-keyword">return</span> returnType
  }
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">getNodeProps</span>(<span class=
"org-variable-name">node</span>) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">codegenNode</span> = node.codegenNode
    <span class=
"org-keyword">if</span> (codegenNode.type === NodeTypes.VNODE_CALL) {
      <span class="org-keyword">return</span> codegenNode.props
    }
  }
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">getPatchFlag</span>(<span class=
"org-variable-name">node</span>) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">flag</span> = node.patchFlag
    <span class=
"org-keyword">return</span> flag ? parseInt(flag, <span class=
"org-highlight-numbers-number">10</span>) : <span class=
"org-constant">undefined</span>
  }
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">createRootCodegen</span>(<span class=
"org-variable-name">root</span>, <span class=
"org-variable-name">context</span>) {
    <span class="org-keyword">const</span> { helper } = context
    <span class="org-keyword">const</span> { children } = root
    logg(<span class=
"org-string">'createRootCodegen'</span>, <span class=
"org-string">`children=${children.length}, 只有一个用 block, 多个用Fragment`</span>)
    <span class=
"org-keyword">if</span> (children.length === <span class=
"org-highlight-numbers-number">1</span>) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">child</span> = children[<span class=
"org-highlight-numbers-number">0</span>]
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">if the single child is an element, turn it into a block.</span>
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">如果只有一个根元素，如： &lt;template&gt;&lt;div&gt;...&lt;/div&gt;&lt;/template&gt;</span>
      <span class=
"org-keyword">if</span> (isSingleElementRoot(root, child) &amp;& child.codegenNode) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">single element root is never hoisted so codegenNode will never be</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">SimpleExpressionNode</span>
        <span class="org-keyword">const</span> <span class=
"org-variable-name">codegenNode</span> = child.codegenNode
        <span class=
"org-keyword">if</span> (codegenNode.type === NodeTypes.VNODE_CALL) {
          makeBlock(codegenNode, context)
        }
        root.codegenNode = codegenNode
      } <span class="org-keyword">else</span> {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">- single &lt;slot/&gt;, IfNode, ForNode: already blocks.</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">- single text node: always patched.</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">root codegen falls through via genNode()</span>
        root.codegenNode = child
      }
    } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (children.length &gt; <span class=
"org-highlight-numbers-number">1</span>) {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">root 下有多个节点时，使用 fragment block，3.x 特性，2.x中是不支持多个元素的</span>
      <span class="org-keyword">let</span> <span class=
"org-variable-name">patchFlag</span> = PatchFlags.STABLE_FRAGMENT
      <span class="org-keyword">let</span> <span class=
"org-variable-name">patchFlagText</span> = PatchFlagNames[PatchFlags.STABLE_FRAGMENT]
  
      root.codegenNode = createVNodeCall(
        context,
        helper(FRAGMENT),
        <span class="org-constant">undefined</span>,
        root.children,
        patchFlag + (__DEV__ ? <span class=
"org-string">` /* ${patchFlagText} */`</span> : <span class=
"org-string">``</span>),
        <span class="org-constant">undefined</span>,
        <span class="org-constant">undefined</span>,
        <span class="org-constant">true</span>,
        <span class="org-constant">undefined</span>,
        <span class="org-constant">false</span> <span class=
"org-comment-delimiter">/* </span><span class=
"org-comment">isComponent</span><span class=
"org-comment-delimiter"> */</span>
      )
    } <span class="org-keyword">else</span> {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">no children = noop. codegen will return null.</span>
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">createStructuralDirectiveTransform</span>(<span class="org-variable-name">name</span>, <span class="org-variable-name">fn</span>) {
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">正则就用 test 方法，字符串直接比较</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">matches</span> = isString(name)
      ? (n) =&gt; n === name
      : (n) =&gt; name.test(n)
  
    logg(<span class=
"org-string">'createStructuralDirectiveTransform'</span>, <span class="org-string">`name=${name}, matches=${matches}`</span>)
    <span class="org-keyword">return</span> (node, context) =&gt; {
      <span class=
"org-keyword">if</span> (node.type === NodeTypes.ELEMENT) {
        <span class="org-keyword">const</span> { props } = node
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">v-slot 指令特殊处理，代码在 vSlot.ts 中，所以这里跳过它</span>
        <span class=
"org-keyword">if</span> (node.tagType === ElementTypes.TEMPLATE &amp;& props.some(isVSlot)) {
          <span class="org-keyword">return</span>
        }
        <span class="org-keyword">const</span> <span class=
"org-variable-name">exitFns</span> = []
        <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; props.length; i++) {
          <span class="org-keyword">const</span> <span class=
"org-variable-name">prop</span> = props[i]
          <span class=
"org-keyword">if</span> (prop.type === NodeTypes.DIRECTIVE &amp;& matches(prop.name)) {
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">structural directives are removed to avoid infinite recursion</span>
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">also we remove them *before* applying so that it can further</span>
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">traverse itself in case it moves the node around</span>
            props.splice(i, <span class=
"org-highlight-numbers-number">1</span>)
            i--
            <span class="org-keyword">const</span> <span class=
"org-variable-name">onExit</span> = fn(node, prop, context)
            <span class=
"org-keyword">if</span> (onExit) exitFns.push(onExit)
          }
        }
        <span class="org-keyword">return</span> exitFns
      }
    }
  }
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">getBaseTransformPreset</span>(<span class=
"org-variable-name">prefixIdentifiers</span>) {
    <span class="org-keyword">return</span> [
      [
        transformOnce,
        transformIf,
        transformMemo,
        transformFor,
        ...(!__BROWSER__ &amp;& prefixIdentifiers
          ? [
              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">order is important</span>
              trackVForSlotScopes,
              transformExpression
            ]
          : __BROWSER__ &amp;& __DEV__
          ? [transformExpression]
          : []),
        transformSlotOutlet,
        transformElement,
        trackSlotScopes,
        transformText
      ],
      {
        on: transformOn,
        bind: transformBind,
        model: transformModel
      }
    ]
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">makeBlock</span>(<span class=
"org-variable-name">node</span>, { <span class=
"org-variable-name">helper</span>, <span class=
"org-variable-name">removeHelper</span>, <span class=
"org-variable-name">inSSR</span> }) {
    <span class="org-keyword">if</span> (!node.isBlock) {
      node.isBlock = <span class="org-constant">true</span>
      removeHelper(getVNodeHelper(inSSR, node.isComponent))
      helper(OPEN_BLOCK)
      helper(getVNodeBlockHelper(inSSR, node.isComponent))
    }
  }
  <span class="org-keyword">const</span> <span class=
"org-variable-name">defaultFallback</span> = createSimpleExpression(<span class="org-string">`undefined`</span>, <span class="org-constant">false</span>)
  
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">A NodeTransform that:</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">1. Tracks scope identifiers for scoped slots so that they don't get prefixed</span>
  <span class="org-comment-delimiter">//    </span><span class=
"org-comment">by transformExpression. This is only applied in non-browser builds with</span>
  <span class="org-comment-delimiter">//    </span><span class=
"org-comment">{ prefixIdentifiers: true }.</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">2. Track v-slot depths so that we know a slot is inside another slot.</span>
  <span class="org-comment-delimiter">//    </span><span class=
"org-comment">Note the exit callback is executed before buildSlots() on the same node,</span>
  <span class="org-comment-delimiter">//    </span><span class=
"org-comment">so only nested slots see positive numbers.</span>
  <span class="org-keyword">const</span> <span class=
"org-variable-name">trackSlotScopes</span> = (node, context) =&gt; {
    <span class="org-keyword">if</span> (
      node.type === NodeTypes.ELEMENT &amp;&
      (node.tagType === ElementTypes.COMPONENT ||
        node.tagType === ElementTypes.TEMPLATE)
    ) {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">We are only checking non-empty v-slot here</span>
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">since we only care about slots that introduce scope variables.</span>
      <span class="org-keyword">const</span> <span class=
"org-variable-name">vSlot</span> = findDir(node, <span class=
"org-string">'slot'</span>)
      <span class="org-keyword">if</span> (vSlot) {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">slotProps</span> = vSlot.exp
        <span class=
"org-keyword">if</span> (!__BROWSER__ &amp;& context.prefixIdentifiers) {
          slotProps &amp;& context.addIdentifiers(slotProps)
        }
        context.scopes.vSlot++
        <span class="org-keyword">return</span> () =&gt; {
          <span class=
"org-keyword">if</span> (!__BROWSER__ &amp;& context.prefixIdentifiers) {
            slotProps &amp;& context.removeIdentifiers(slotProps)
          }
          context.scopes.vSlot--
        }
      }
    }
  }
  
  
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">A NodeTransform that tracks scope identifiers for scoped slots with v-for.</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">This transform is only applied in non-browser builds with { prefixIdentifiers: true }</span>
  <span class="org-keyword">const</span> <span class=
"org-variable-name">trackVForSlotScopes</span> = (node, context) =&gt; {
    <span class="org-keyword">let</span> <span class=
"org-variable-name">vFor</span>
    <span class="org-keyword">if</span> (
      isTemplateNode(node) &amp;&
      node.props.some(isVSlot) &amp;&
      (vFor = findDir(node, <span class="org-string">'for'</span>))
    ) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">result</span> = (vFor.parseResult = parseForExpression(
        vFor.exp,
        context
      ))
      <span class="org-keyword">if</span> (result) {
        <span class=
"org-keyword">const</span> { value, key, index } = result
        <span class=
"org-keyword">const</span> { addIdentifiers, removeIdentifiers } = context
        value &amp;& addIdentifiers(value)
        key &amp;& addIdentifiers(key)
        index &amp;& addIdentifiers(index)
  
        <span class="org-keyword">return</span> () =&gt; {
          value &amp;& removeIdentifiers(value)
          key &amp;& removeIdentifiers(key)
          index &amp;& removeIdentifiers(index)
        }
      }
    }
  }
  
  <span class="org-keyword">const</span> <span class=
"org-variable-name">buildClientSlotFn</span> = (props, children, loc) =&gt;
    createFunctionExpression(
      props,
      children,
      <span class="org-constant">false</span> <span class=
"org-comment-delimiter">/* </span><span class=
"org-comment">newline</span><span class=
"org-comment-delimiter"> */</span>,
      <span class="org-constant">true</span> <span class=
"org-comment-delimiter">/* </span><span class=
"org-comment">isSlot</span><span class=
"org-comment-delimiter"> */</span>,
      children.length ? children[<span class=
"org-highlight-numbers-number">0</span>].loc : loc
    )
  
  
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">Instead of being a DirectiveTransform, v-slot processing is called during</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">transformElement to build the slots object for a component.</span>
  <span class="org-keyword">function</span> <span class=
"org-function-name">buildSlots</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>, <span class=
"org-variable-name">buildSlotFn</span>= <span class=
"org-variable-name">buildClientSlotFn</span>) {
    context.helper(WITH_CTX)
  
    <span class="org-keyword">const</span> { children, loc } = node
    <span class="org-keyword">const</span> <span class=
"org-variable-name">slotsProperties</span> = []
    <span class="org-keyword">const</span> <span class=
"org-variable-name">dynamicSlots</span>= []
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">If the slot is inside a v-for or another v-slot, force it to be dynamic</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">since it likely uses a scope variable.</span>
    <span class="org-keyword">let</span> <span class=
"org-variable-name">hasDynamicSlots</span> = context.scopes.vSlot &gt; <span class="org-highlight-numbers-number">0</span> || context.scopes.vFor &gt; <span class="org-highlight-numbers-number">0</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">with `prefixIdentifiers: true`, this can be further optimized to make</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">it dynamic only when the slot actually uses the scope variables.</span>
    <span class=
"org-keyword">if</span> (!__BROWSER__ &amp;& !context.ssr &amp;& context.prefixIdentifiers) {
      hasDynamicSlots = hasScopeRef(node, context.identifiers)
    }
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">1. Check for slot with slotProps on component itself.</span>
    <span class="org-comment-delimiter">//    </span><span class=
"org-comment">&lt;Comp v-slot="{ prop }"/&gt;</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">onComponentSlot</span> = findDir(node, <span class="org-string">'slot'</span>, <span class="org-constant">true</span>)
    <span class="org-keyword">if</span> (onComponentSlot) {
      <span class=
"org-keyword">const</span> { arg, exp } = onComponentSlot
      <span class=
"org-keyword">if</span> (arg &amp;& !isStaticExp(arg)) {
        hasDynamicSlots = <span class="org-constant">true</span>
      }
      slotsProperties.push(
        createObjectProperty(
          arg || createSimpleExpression(<span class=
"org-string">'default'</span>, <span class=
"org-constant">true</span>),
          buildSlotFn(exp, children, loc)
        )
      )
    }
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">2. Iterate through children and check for template slots</span>
    <span class="org-comment-delimiter">//    </span><span class=
"org-comment">&lt;template v-slot:foo="{ prop }"&gt;</span>
    <span class="org-keyword">let</span> <span class=
"org-variable-name">hasTemplateSlots</span> = <span class=
"org-constant">false</span>
    <span class="org-keyword">let</span> <span class=
"org-variable-name">hasNamedDefaultSlot</span> = <span class=
"org-constant">false</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">implicitDefaultChildren</span> = []
    <span class="org-keyword">const</span> <span class=
"org-variable-name">seenSlotNames</span> = <span class=
"org-keyword">new</span> <span class="org-type">Set</span>()
  
    <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; children.length; i++) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">slotElement</span> = children[i]
      <span class="org-keyword">let</span> <span class=
"org-variable-name">slotDir</span>
  
      <span class="org-keyword">if</span> (
        !isTemplateNode(slotElement) ||
        !(slotDir = findDir(slotElement, <span class=
"org-string">'slot'</span>, <span class=
"org-constant">true</span>))
      ) { <span class=
"org-comment-delimiter">// </span><span class="org-comment">收集不在 template v-slot 中的元素/组件，这些都会合并到默认插槽中去</span>
        <span class=
"org-keyword">if</span> (slotElement.type !== NodeTypes.COMMENT) {
          implicitDefaultChildren.push(slotElement)
        }
        <span class="org-keyword">continue</span>
      }
  
      <span class="org-keyword">if</span> (onComponentSlot) {
        logg(<span class=
"org-string">`buildSlots already has on-component slot - this is incorrect usage`</span>)
        <span class="org-keyword">break</span>
      }
  
      hasTemplateSlots = <span class="org-constant">true</span>
      <span class=
"org-keyword">const</span> { children: <span class=
"org-variable-name">slotChildren</span>, loc: <span class=
"org-variable-name">slotLoc</span> } = slotElement
      <span class="org-keyword">const</span> {
        arg: slotName = createSimpleExpression(<span class=
"org-string">`default`</span>, <span class=
"org-constant">true</span>),
        exp: slotProps,
        loc: dirLoc
      } = slotDir
  
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">check if name is dynamic.</span>
      <span class="org-keyword">let</span> <span class=
"org-variable-name">staticSlotName</span>
      <span class="org-keyword">if</span> (isStaticExp(slotName)) {
        staticSlotName = slotName ? slotName.content : <span class=
"org-string">`default`</span>
      } <span class="org-keyword">else</span> {
        hasDynamicSlots = <span class="org-constant">true</span>
      }
  
      <span class="org-keyword">const</span> <span class=
"org-variable-name">slotFunction</span> = buildSlotFn(slotProps, slotChildren, slotLoc)
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">check if this slot is conditional (v-if/v-for)</span>
      <span class="org-keyword">let</span> <span class=
"org-variable-name">vIf</span>
      <span class="org-keyword">let</span> <span class=
"org-variable-name">vElse</span>
      <span class="org-keyword">let</span> <span class=
"org-variable-name">vFor</span>
      <span class=
"org-keyword">if</span> ((vIf = findDir(slotElement, <span class=
"org-string">'if'</span>))) {
        hasDynamicSlots = <span class="org-constant">true</span>
        dynamicSlots.push(
          createConditionalExpression(
            vIf.exp,
            buildDynamicSlot(slotName, slotFunction),
            defaultFallback
          )
        )
      } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (
        (vElse = findDir(slotElement, <span class=
"org-string">/^else(-if)?$/</span>, <span class=
"org-constant">true</span> <span class=
"org-comment-delimiter">/* </span><span class=
"org-comment">allowEmpty</span><span class=
"org-comment-delimiter"> */</span>))
      ) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">find adjacent v-if</span>
        <span class="org-keyword">let</span> <span class=
"org-variable-name">j</span> = i
        <span class="org-keyword">let</span> <span class=
"org-variable-name">prev</span>
        <span class="org-keyword">while</span> (j--) {
          prev = children[j]
          <span class=
"org-keyword">if</span> (prev.type !== NodeTypes.COMMENT) {
            <span class="org-keyword">break</span>
          }
        }
        <span class=
"org-keyword">if</span> (prev &amp;& isTemplateNode(prev) &amp;& findDir(prev, <span class="org-string">'if'</span>)) {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">remove node</span>
          children.splice(i, <span class=
"org-highlight-numbers-number">1</span>)
          i--
  
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">attach this slot to previous conditional</span>
          <span class="org-keyword">let</span> <span class=
"org-variable-name">conditional</span> = dynamicSlots[
            dynamicSlots.length - <span class=
"org-highlight-numbers-number">1</span>
          ]
          <span class="org-keyword">while</span> (
            conditional.alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION
          ) {
            conditional = conditional.alternate
          }
          conditional.alternate = vElse.exp
            ? createConditionalExpression(
                vElse.exp,
                buildDynamicSlot(slotName, slotFunction),
                defaultFallback
              )
            : buildDynamicSlot(slotName, slotFunction)
        }
      } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> ((vFor = findDir(slotElement, <span class=
"org-string">'for'</span>))) {
        hasDynamicSlots = <span class="org-constant">true</span>
        <span class="org-keyword">const</span> <span class=
"org-variable-name">parseResult</span> =
          vFor.parseResult ||
          parseForExpression(vFor.exp , context)
        <span class="org-keyword">if</span> (parseResult) {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">Render the dynamic slots as an array and add it to the createSlot()</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">args. The runtime knows how to handle it appropriately.</span>
          dynamicSlots.push(
            createCallExpression(context.helper(RENDER_LIST), [
              parseResult.source,
              createFunctionExpression(
                createForLoopParams(parseResult),
                buildDynamicSlot(slotName, slotFunction),
                <span class="org-constant">true</span> <span class=
"org-comment-delimiter">/* </span><span class=
"org-comment">force newline</span><span class=
"org-comment-delimiter"> */</span>
              )
            ])
          )
        }
      } <span class="org-keyword">else</span> {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">check duplicate static names</span>
        <span class="org-keyword">if</span> (staticSlotName) {
          <span class=
"org-keyword">if</span> (seenSlotNames.has(staticSlotName)) {
            logg(<span class=
"org-string">`buildSlots seenSlotNames has slot name`</span>)
            <span class="org-keyword">continue</span>
          }
          seenSlotNames.add(staticSlotName)
          <span class=
"org-keyword">if</span> (staticSlotName === <span class=
"org-string">'default'</span>) {
            hasNamedDefaultSlot = <span class=
"org-constant">true</span>
          }
        }
        slotsProperties.push(createObjectProperty(slotName, slotFunction))
      }
    }
  
    <span class="org-keyword">if</span> (!onComponentSlot) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">buildDefaultSlotProperty</span> = (props, children) =&gt; {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">fn</span> = buildSlotFn(props, children, loc)
  
        <span class=
"org-keyword">return</span> createObjectProperty(<span class=
"org-string">`default`</span>, fn)
      }
  
      <span class="org-keyword">if</span> (!hasTemplateSlots) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">implicit default slot (on component)</span>
        slotsProperties.push(buildDefaultSlotProperty(<span class=
"org-constant">undefined</span>, children))
      } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (
        implicitDefaultChildren.length &amp;&
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">#3766</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">with whitespace: 'preserve', whitespaces between slots will end up in</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">implicitDefaultChildren. Ignore if all implicit children are whitespaces.</span>
        implicitDefaultChildren.some(node =&gt; isNonWhitespaceContent(node))
      ) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">implicit default slot (mixed with named slots)</span>
        <span class="org-keyword">if</span> (hasNamedDefaultSlot) {
          logg(<span class=
"org-string">`buildSlots hasNamedDefaultSlot`</span>)
        } <span class="org-keyword">else</span> {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">合并到默认插槽</span>
          slotsProperties.push(
            buildDefaultSlotProperty(<span class=
"org-constant">undefined</span>, implicitDefaultChildren)
          )
        }
      }
    }
  
    <span class="org-keyword">const</span> <span class=
"org-variable-name">slotFlag</span> = hasDynamicSlots
      ? SlotFlags.DYNAMIC
      : hasForwardedSlots(node.children)
      ? SlotFlags.FORWARDED
      : SlotFlags.STABLE
  
    <span class="org-keyword">let</span> <span class=
"org-variable-name">slots</span> = createObjectExpression(
      slotsProperties.concat(
        createObjectProperty(
          <span class="org-string">`_`</span>,
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">2 = compiled but dynamic = can skip normalization, but must run diff</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">1 = compiled and static = can skip normalization AND diff as optimized</span>
          createSimpleExpression(
            slotFlag + (__DEV__ ? <span class=
"org-string">` /* ${slotFlagsText[slotFlag]} */`</span> : <span class="org-string">``</span>),
            <span class="org-constant">false</span>
          )
        )
      ),
      loc
    )
    <span class="org-keyword">if</span> (dynamicSlots.length) {
      slots = createCallExpression(context.helper(CREATE_SLOTS), [
        slots,
        createArrayExpression(dynamicSlots)
      ])
    }
  
    <span class="org-keyword">return</span> {
      slots,
      hasDynamicSlots
    }
  }
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">buildDynamicSlot</span>(<span class=
"org-variable-name">name</span>, <span class=
"org-variable-name">fn</span>) {
    <span class=
"org-keyword">return</span> createObjectExpression([
      createObjectProperty(<span class=
"org-string">`name`</span>, name),
      createObjectProperty(<span class=
"org-string">`fn`</span>, fn)
    ])
  }
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">hasForwardedSlots</span>(<span class=
"org-variable-name">children</span>) {
    <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; children.length; i++) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">child</span> = children[i]
      <span class="org-keyword">switch</span> (child.type) {
        <span class="org-keyword">case</span> NodeTypes.ELEMENT:
          <span class="org-keyword">if</span> (
            child.tagType === ElementTypes.SLOT ||
            hasForwardedSlots(child.children)
          ) {
            <span class="org-keyword">return</span> <span class=
"org-constant">true</span>
          }
          <span class="org-keyword">break</span>
        <span class="org-keyword">case</span> NodeTypes.IF:
          <span class=
"org-keyword">if</span> (hasForwardedSlots(child.branches)) <span class="org-keyword">return</span> <span class="org-constant">true</span>
          <span class="org-keyword">break</span>
        <span class="org-keyword">case</span> NodeTypes.IF_BRANCH:
        <span class="org-keyword">case</span> NodeTypes.FOR:
          <span class=
"org-keyword">if</span> (hasForwardedSlots(child.children)) <span class="org-keyword">return</span> <span class="org-constant">true</span>
          <span class="org-keyword">break</span>
        <span class="org-keyword">default</span>:
          <span class="org-keyword">break</span>
      }
    }
    <span class="org-keyword">return</span> <span class=
"org-constant">false</span>
  }
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">isNonWhitespaceContent</span>(<span class=
"org-variable-name">node</span>){
    <span class=
"org-keyword">if</span> (node.type !== NodeTypes.TEXT &amp;& node.type !== NodeTypes.TEXT_CALL)
      <span class="org-keyword">return</span> <span class=
"org-constant">true</span>
    <span class=
"org-keyword">return</span> node.type === NodeTypes.TEXT
      ? !!node.content.trim()
      : isNonWhitespaceContent(node.content)
  }
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">some directive transforms (e.g. v-model) may return a symbol for runtime</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">import, which should be used instead of a resolveDirective call.</span>
  <span class="org-keyword">const</span> <span class=
"org-variable-name">directiveImportMap</span> = <span class=
"org-keyword">new</span> <span class="org-type">WeakMap</span>()
  
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">generate a JavaScript AST for this element's codegen</span>
  <span class="org-keyword">const</span> <span class=
"org-variable-name">transformElement</span> = (node, context) =&gt; {
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">perform the work on exit, after all child expressions have been</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">processed and merged.</span>
    <span class="org-keyword">return</span> <span class=
"org-keyword">function</span> postTransformElement() {
      node = context.currentNode
  
      <span class="org-keyword">if</span> (
        !(
          node.type === NodeTypes.ELEMENT &amp;&
          (node.tagType === ElementTypes.ELEMENT ||
            node.tagType === ElementTypes.COMPONENT)
        )
      ) {
        <span class="org-keyword">return</span>
      }
  
      <span class="org-keyword">const</span> { tag, props } = node
      <span class="org-keyword">const</span> <span class=
"org-variable-name">isComponent</span> = node.tagType === ElementTypes.COMPONENT
  
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">The goal of the transform is to create a codegenNode implementing the</span>
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">VNodeCall interface.</span>
      <span class="org-keyword">let</span> <span class=
"org-variable-name">vnodeTag</span> = isComponent
        ? resolveComponentType(node, context)
        : <span class="org-string">`"${tag}"`</span>
  
      <span class="org-keyword">const</span> <span class=
"org-variable-name">isDynamicComponent</span> =
        isObject(vnodeTag) &amp;& vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT
  
      <span class="org-keyword">let</span> <span class=
"org-variable-name">vnodeProps</span>
      <span class="org-keyword">let</span> <span class=
"org-variable-name">vnodeChildren</span>
      <span class="org-keyword">let</span> <span class=
"org-variable-name">vnodePatchFlag</span>
      <span class="org-keyword">let</span> <span class=
"org-variable-name">patchFlag</span> = <span class=
"org-highlight-numbers-number">0</span>
      <span class="org-keyword">let</span> <span class=
"org-variable-name">vnodeDynamicProps</span>
      <span class="org-keyword">let</span> <span class=
"org-variable-name">dynamicPropNames</span>
      <span class="org-keyword">let</span> <span class=
"org-variable-name">vnodeDirectives</span>
  
      <span class="org-keyword">let</span> <span class=
"org-variable-name">shouldUseBlock</span> =
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">dynamic component may resolve to plain elements</span>
        isDynamicComponent ||
        vnodeTag === TELEPORT ||
        vnodeTag === SUSPENSE ||
        (!isComponent &amp;&
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">&lt;svg&gt; and &lt;foreignObject&gt; must be forced into blocks so that block</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">updates inside get proper isSVG flag at runtime. (#639, #643)</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">This is technically web-specific, but splitting the logic out of core</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">leads to too much unnecessary complexity.</span>
          (tag === <span class=
"org-string">'svg'</span> || tag === <span class=
"org-string">'foreignObject'</span>))
  
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">props</span>
      <span class=
"org-keyword">if</span> (props.length &gt; <span class=
"org-highlight-numbers-number">0</span>) {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">propsBuildResult</span> = buildProps(node, context)
        vnodeProps = propsBuildResult.props
        patchFlag = propsBuildResult.patchFlag
        dynamicPropNames = propsBuildResult.dynamicPropNames
        <span class="org-keyword">const</span> <span class=
"org-variable-name">directives</span> = propsBuildResult.directives
        vnodeDirectives =
          directives &amp;& directives.length
            ? (createArrayExpression(
                directives.map(dir =&gt; buildDirectiveArgs(dir, context))
              ))
            : <span class="org-constant">undefined</span>
  
        <span class=
"org-keyword">if</span> (propsBuildResult.shouldUseBlock) {
          shouldUseBlock = <span class="org-constant">true</span>
        }
      }
  
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">children</span>
      <span class=
"org-keyword">if</span> (node.children.length &gt; <span class=
"org-highlight-numbers-number">0</span>) {
        <span class=
"org-keyword">if</span> (vnodeTag === KEEP_ALIVE) {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">Although a built-in component, we compile KeepAlive with raw children</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">instead of slot functions so that it can be used inside Transition</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">or other Transition-wrapping HOCs.</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">To ensure correct updates with block optimizations, we need to:</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">1. Force keep-alive into a block. This avoids its children being</span>
          <span class=
"org-comment-delimiter">//    </span><span class=
"org-comment">collected by a parent block.</span>
          shouldUseBlock = <span class="org-constant">true</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">2. Force keep-alive to always be updated, since it uses raw children.</span>
          patchFlag |= PatchFlags.DYNAMIC_SLOTS
        }
  
        <span class="org-keyword">const</span> <span class=
"org-variable-name">shouldBuildAsSlots</span> =
          isComponent &amp;&
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">Teleport is not a real component and has dedicated runtime handling</span>
          vnodeTag !== TELEPORT &amp;&
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">explained above.</span>
          vnodeTag !== KEEP_ALIVE
  
        <span class="org-keyword">if</span> (shouldBuildAsSlots) {
          <span class=
"org-keyword">const</span> { slots, hasDynamicSlots } = buildSlots(node, context)
          vnodeChildren = slots
          <span class="org-keyword">if</span> (hasDynamicSlots) {
            patchFlag |= PatchFlags.DYNAMIC_SLOTS
          }
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (node.children.length === <span class=
"org-highlight-numbers-number">1</span> &amp;& vnodeTag !== TELEPORT) {
          <span class="org-keyword">const</span> <span class=
"org-variable-name">child</span> = node.children[<span class=
"org-highlight-numbers-number">0</span>]
          <span class="org-keyword">const</span> <span class=
"org-variable-name">type</span> = child.type
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">check for dynamic text children</span>
          <span class="org-keyword">const</span> <span class=
"org-variable-name">hasDynamicTextChild</span> =
            type === NodeTypes.INTERPOLATION ||
            type === NodeTypes.COMPOUND_EXPRESSION
          <span class="org-keyword">if</span> (
            hasDynamicTextChild &amp;&
            getConstantType(child, context) === ConstantTypes.NOT_CONSTANT
          ) {
            patchFlag |= PatchFlags.TEXT
          }
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">pass directly if the only child is a text node</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">(plain / interpolation / expression)</span>
          <span class=
"org-keyword">if</span> (hasDynamicTextChild || type === NodeTypes.TEXT) {
            vnodeChildren = child
          } <span class="org-keyword">else</span> {
            vnodeChildren = node.children
          }
        } <span class="org-keyword">else</span> {
          vnodeChildren = node.children
        }
      }
  
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">patchFlag & dynamicPropNames</span>
      <span class=
"org-keyword">if</span> (patchFlag !== <span class=
"org-highlight-numbers-number">0</span>) {
        vnodePatchFlag = String(patchFlag)
        <span class=
"org-keyword">if</span> (dynamicPropNames &amp;& dynamicPropNames.length) {
          vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames)
        }
      }
  
      node.codegenNode = createVNodeCall(
        context,
        vnodeTag,
        vnodeProps,
        vnodeChildren,
        vnodePatchFlag,
        vnodeDynamicProps,
        vnodeDirectives,
        !!shouldUseBlock,
        <span class="org-constant">false</span> <span class=
"org-comment-delimiter">/* </span><span class=
"org-comment">disableTracking</span><span class=
"org-comment-delimiter"> */</span>,
        isComponent,
        node.loc
      )
    }
  }
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">resolveComponentType</span>(
    <span class="org-variable-name">node</span>,
    <span class="org-variable-name">context</span>,
    ssr = <span class="org-constant">false</span>
  ) {
    <span class="org-keyword">let</span> { tag } = node
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">1. dynamic component</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">isExplicitDynamic</span> = isComponentTag(tag)
    <span class="org-keyword">const</span> <span class=
"org-variable-name">isProp</span> = findProp(node, <span class=
"org-string">'is'</span>)
    <span class="org-keyword">if</span> (isProp) {
      <span class="org-keyword">if</span> (isExplicitDynamic ) {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">exp</span> =
          isProp.type === NodeTypes.ATTRIBUTE
            ? isProp.value &amp;& createSimpleExpression(isProp.value.content, <span class="org-constant">true</span>)
            : isProp.exp
        <span class="org-keyword">if</span> (exp) {
          <span class=
"org-keyword">return</span> createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
            exp
          ])
        }
      } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (
        isProp.type === NodeTypes.ATTRIBUTE &amp;&
        isProp.value.content.startsWith(<span class=
"org-string">'vue:'</span>)
      ) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">&lt;button is="vue:xxx"&gt;</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">if not &lt;component&gt;, only is value that starts with "vue:" will be</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">treated as component by the parse phase and reach here, unless it's</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">compat mode where all is values are considered components</span>
        tag = isProp.value.content.slice(<span class=
"org-highlight-numbers-number">4</span>)
      }
    }
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">1.5 v-is (</span><span class=
"org-comment"><span class="org-bold"><span class=
"org-warning">TODO:</span></span></span><span class=
"org-comment"> Deprecate)</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">isDir</span> = !isExplicitDynamic &amp;& findDir(node, <span class="org-string">'is'</span>)
    <span class="org-keyword">if</span> (isDir &amp;& isDir.exp) {
      <span class=
"org-keyword">return</span> createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
        isDir.exp
      ])
    }
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">2. built-in components (Teleport, Transition, KeepAlive, Suspense...)</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">builtIn</span> = isCoreComponent(tag) || context.isBuiltInComponent(tag)
    <span class="org-keyword">if</span> (builtIn) {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">built-ins are simply fallthroughs / have special handling during ssr</span>
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">so we don't need to import their runtime equivalents</span>
      <span class=
"org-keyword">if</span> (!ssr) context.helper(builtIn)
      <span class="org-keyword">return</span> builtIn
    }
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">3. user component (from setup bindings)</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">this is skipped in browser build since browser builds do not perform</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">binding analysis.</span>
    <span class="org-keyword">if</span> (!__BROWSER__) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">fromSetup</span> = resolveSetupReference(tag, context)
      <span class="org-keyword">if</span> (fromSetup) {
        <span class="org-keyword">return</span> fromSetup
      }
      <span class="org-keyword">const</span> <span class=
"org-variable-name">dotIndex</span> = tag.indexOf(<span class=
"org-string">'.'</span>)
      <span class=
"org-keyword">if</span> (dotIndex &gt; <span class=
"org-highlight-numbers-number">0</span>) {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">ns</span> = resolveSetupReference(tag.slice(<span class="org-highlight-numbers-number">0</span>, dotIndex), context)
        <span class="org-keyword">if</span> (ns) {
          <span class=
"org-keyword">return</span> ns + tag.slice(dotIndex)
        }
      }
    }
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">4. Self referencing component (inferred from filename)</span>
    <span class="org-keyword">if</span> (
      !__BROWSER__ &amp;&
      context.selfName &amp;&
      capitalize(camelize(tag)) === context.selfName
    ) {
      context.helper(RESOLVE_COMPONENT)
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">codegen.ts has special check for __self postfix when generating</span>
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">component imports, which will pass additional `maybeSelfReference` flag</span>
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">to `resolveComponent`.</span>
      context.components.add(tag + <span class=
"org-string">`__self`</span>)
      <span class=
"org-keyword">return</span> toValidAssetId(tag, <span class=
"org-string">`component`</span>)
    }
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">5. user component (resolve)</span>
    context.helper(RESOLVE_COMPONENT)
    context.components.add(tag)
    <span class=
"org-keyword">return</span> toValidAssetId(tag, <span class=
"org-string">`component`</span>)
  }
  
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">resolveSetupReference</span>(<span class=
"org-variable-name">name</span>, <span class=
"org-variable-name">context</span>) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">bindings</span> = context.bindingMetadata
    <span class=
"org-keyword">if</span> (!bindings || bindings.__isScriptSetup === <span class="org-constant">false</span>) {
      <span class="org-keyword">return</span>
    }
  
    <span class="org-keyword">const</span> <span class=
"org-variable-name">camelName</span> = camelize(name)
    <span class="org-keyword">const</span> <span class=
"org-variable-name">PascalName</span> = capitalize(camelName)
    <span class="org-keyword">const</span> <span class=
"org-variable-name">checkType</span> = (type) =&gt; {
      <span class=
"org-keyword">if</span> (bindings[name] === type) {
        <span class="org-keyword">return</span> name
      }
      <span class=
"org-keyword">if</span> (bindings[camelName] === type) {
        <span class="org-keyword">return</span> camelName
      }
      <span class=
"org-keyword">if</span> (bindings[PascalName] === type) {
        <span class="org-keyword">return</span> PascalName
      }
    }
  
    <span class="org-keyword">const</span> <span class=
"org-variable-name">fromConst</span> = checkType(BindingTypes.SETUP_CONST)
    <span class="org-keyword">if</span> (fromConst) {
      <span class="org-keyword">return</span> context.inline
        ? <span class=
"org-comment-delimiter">// </span><span class="org-comment">in inline mode, const setup bindings (e.g. imports) can be used as-is</span>
          fromConst
        : <span class=
"org-string">`$setup[${JSON.stringify(fromConst)}]`</span>
    }
  
    <span class="org-keyword">const</span> <span class=
"org-variable-name">fromMaybeRef</span> =
      checkType(BindingTypes.SETUP_LET) ||
      checkType(BindingTypes.SETUP_REF) ||
      checkType(BindingTypes.SETUP_MAYBE_REF)
    <span class="org-keyword">if</span> (fromMaybeRef) {
      <span class="org-keyword">return</span> context.inline
        ? <span class=
"org-comment-delimiter">// </span><span class="org-comment">setup scope bindings that may be refs need to be unrefed</span>
          <span class=
"org-string">`${context.helperString(UNREF)}(${fromMaybeRef})`</span>
        : <span class=
"org-string">`$setup[${JSON.stringify(fromMaybeRef)}]`</span>
    }
  }
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">buildProps</span>(
    <span class="org-variable-name">node</span>,
    <span class="org-variable-name">context</span>,
    props = node.props,
    ssr = <span class="org-constant">false</span>
  ) {
    <span class=
"org-keyword">const</span> { tag, loc: elementLoc, children } = node
    <span class="org-keyword">const</span> <span class=
"org-variable-name">isComponent</span> = node.tagType === ElementTypes.COMPONENT
    <span class="org-keyword">let</span> <span class=
"org-variable-name">properties</span> = []
    <span class="org-keyword">const</span> <span class=
"org-variable-name">mergeArgs</span> = []
    <span class="org-keyword">const</span> <span class=
"org-variable-name">runtimeDirectives</span> = []
    <span class="org-keyword">const</span> <span class=
"org-variable-name">hasChildren</span> = children.length &gt; <span class="org-highlight-numbers-number">0</span>
    <span class="org-keyword">let</span> <span class=
"org-variable-name">shouldUseBlock</span> = <span class=
"org-constant">false</span>
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">patchFlag analysis</span>
    <span class="org-keyword">let</span> <span class=
"org-variable-name">patchFlag</span> = <span class=
"org-highlight-numbers-number">0</span>
    <span class="org-keyword">let</span> <span class=
"org-variable-name">hasRef</span> = <span class=
"org-constant">false</span>
    <span class="org-keyword">let</span> <span class=
"org-variable-name">hasClassBinding</span> = <span class=
"org-constant">false</span>
    <span class="org-keyword">let</span> <span class=
"org-variable-name">hasStyleBinding</span> = <span class=
"org-constant">false</span>
    <span class="org-keyword">let</span> <span class=
"org-variable-name">hasHydrationEventBinding</span> = <span class=
"org-constant">false</span>
    <span class="org-keyword">let</span> <span class=
"org-variable-name">hasDynamicKeys</span> = <span class=
"org-constant">false</span>
    <span class="org-keyword">let</span> <span class=
"org-variable-name">hasVnodeHook</span> = <span class=
"org-constant">false</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">dynamicPropNames</span> = []
  
    <span class="org-keyword">const</span> <span class=
"org-variable-name">analyzePatchFlag</span> = ({ key, value }) =&gt; {
      <span class="org-keyword">if</span> (isStaticExp(key)) {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">name</span> = key.content
        <span class="org-keyword">const</span> <span class=
"org-variable-name">isEventHandler</span> = isOn(name)
        <span class="org-keyword">if</span> (
          !isComponent &amp;&
          isEventHandler &amp;&
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">omit the flag for click handlers because hydration gives click</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">dedicated fast path.</span>
          name.toLowerCase() !== <span class=
"org-string">'onclick'</span> &amp;&
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">omit v-model handlers</span>
          name !== <span class=
"org-string">'onUpdate:modelValue'</span> &amp;&
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">omit onVnodeXXX hooks</span>
          !isReservedProp(name)
        ) {
          hasHydrationEventBinding = <span class=
"org-constant">true</span>
        }
  
        <span class=
"org-keyword">if</span> (isEventHandler &amp;& isReservedProp(name)) {
          hasVnodeHook = <span class="org-constant">true</span>
        }
  
        <span class="org-keyword">if</span> (
          value.type === NodeTypes.JS_CACHE_EXPRESSION ||
          ((value.type === NodeTypes.SIMPLE_EXPRESSION ||
            value.type === NodeTypes.COMPOUND_EXPRESSION) &amp;&
            getConstantType(value, context) &gt; <span class=
"org-highlight-numbers-number">0</span>)
        ) {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">skip if the prop is a cached handler or has constant value</span>
          <span class="org-keyword">return</span>
        }
  
        <span class="org-keyword">if</span> (name === <span class=
"org-string">'ref'</span>) {
          hasRef = <span class="org-constant">true</span>
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (name === <span class=
"org-string">'class'</span>) {
          hasClassBinding = <span class="org-constant">true</span>
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (name === <span class=
"org-string">'style'</span>) {
          hasStyleBinding = <span class="org-constant">true</span>
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (name !== <span class=
"org-string">'key'</span> &amp;& !dynamicPropNames.includes(name)) {
          dynamicPropNames.push(name)
        }
  
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">treat the dynamic class and style binding of the component as dynamic props</span>
        <span class="org-keyword">if</span> (
          isComponent &amp;&
          (name === <span class=
"org-string">'class'</span> || name === <span class=
"org-string">'style'</span>) &amp;&
          !dynamicPropNames.includes(name)
        ) {
          dynamicPropNames.push(name)
        }
      } <span class="org-keyword">else</span> {
        hasDynamicKeys = <span class="org-constant">true</span>
      }
    }
  
    <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; props.length; i++) {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">static attribute</span>
      <span class="org-keyword">const</span> <span class=
"org-variable-name">prop</span> = props[i]
      <span class=
"org-keyword">if</span> (prop.type === NodeTypes.ATTRIBUTE) {
        <span class=
"org-keyword">const</span> { loc, name, value } = prop
        <span class="org-keyword">let</span> <span class=
"org-variable-name">isStatic</span> = <span class=
"org-constant">true</span>
        <span class="org-keyword">if</span> (name === <span class=
"org-string">'ref'</span>) {
          hasRef = <span class="org-constant">true</span>
          <span class=
"org-keyword">if</span> (context.scopes.vFor &gt; <span class=
"org-highlight-numbers-number">0</span>) {
            properties.push(
              createObjectProperty(
                createSimpleExpression(<span class=
"org-string">'ref_for'</span>, <span class=
"org-constant">true</span>),
                createSimpleExpression(<span class=
"org-string">'true'</span>)
              )
            )
          }
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">in inline mode there is no setupState object, so we can't use string</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">keys to set the ref. Instead, we need to transform it to pass the</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">actual ref instead.</span>
          <span class="org-keyword">if</span> (
            !__BROWSER__ &amp;&
            value &amp;&
            context.inline &amp;&
            context.bindingMetadata[value.content]
          ) {
            isStatic = <span class="org-constant">false</span>
            properties.push(
              createObjectProperty(
                createSimpleExpression(<span class=
"org-string">'ref_key'</span>, <span class=
"org-constant">true</span>),
                createSimpleExpression(value.content, <span class=
"org-constant">true</span>, value.loc)
              )
            )
          }
        }
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">skip is on &lt;component&gt;, or is="vue:xxx"</span>
        <span class="org-keyword">if</span> (
          name === <span class="org-string">'is'</span> &amp;&
          (isComponentTag(tag) ||
            (value &amp;& value.content.startsWith(<span class=
"org-string">'vue:'</span>)))
        ) {
          <span class="org-keyword">continue</span>
        }
        properties.push(
          createObjectProperty(
            createSimpleExpression(
              name,
              <span class="org-constant">true</span>,
              getInnerRange(loc, <span class=
"org-highlight-numbers-number">0</span>, name.length)
            ),
            createSimpleExpression(
              value ? value.content : <span class=
"org-string">''</span>,
              isStatic,
              value ? value.loc : loc
            )
          )
        )
      } <span class="org-keyword">else</span> {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">directives</span>
        <span class=
"org-keyword">const</span> { name, arg, exp, loc } = prop
        <span class="org-keyword">const</span> <span class=
"org-variable-name">isVBind</span> = name === <span class=
"org-string">'bind'</span>
        <span class="org-keyword">const</span> <span class=
"org-variable-name">isVOn</span> = name === <span class=
"org-string">'on'</span>
  
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">skip v-slot - it is handled by its dedicated transform.</span>
        <span class="org-keyword">if</span> (name === <span class=
"org-string">'slot'</span>) {
          <span class="org-keyword">continue</span>
        }
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">skip v-once/v-memo - they are handled by dedicated transforms.</span>
        <span class="org-keyword">if</span> (name === <span class=
"org-string">'once'</span> || name === <span class=
"org-string">'memo'</span>) {
          <span class="org-keyword">continue</span>
        }
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">skip v-is and :is on &lt;component&gt;</span>
        <span class="org-keyword">if</span> (
          name === <span class="org-string">'is'</span> ||
          (isVBind &amp;&
            isStaticArgOf(arg, <span class=
"org-string">'is'</span>) &amp;&
            isComponentTag(tag))
        ) {
          <span class="org-keyword">continue</span>
        }
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">skip v-on in SSR compilation</span>
        <span class="org-keyword">if</span> (isVOn &amp;& ssr) {
          <span class="org-keyword">continue</span>
        }
  
        <span class="org-keyword">if</span> (
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">#938: elements with dynamic keys should be forced into blocks</span>
          (isVBind &amp;& isStaticArgOf(arg, <span class=
"org-string">'key'</span>)) ||
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">inline before-update hooks need to force block so that it is invoked</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">before children</span>
          (isVOn &amp;& hasChildren &amp;& isStaticArgOf(arg, <span class="org-string">'vue:before-update'</span>))
        ) {
          shouldUseBlock = <span class="org-constant">true</span>
        }
  
        <span class=
"org-keyword">if</span> (isVBind &amp;& isStaticArgOf(arg, <span class="org-string">'ref'</span>) &amp;& context.scopes.vFor &gt; <span class="org-highlight-numbers-number">0</span>) {
          properties.push(
            createObjectProperty(
              createSimpleExpression(<span class=
"org-string">'ref_for'</span>, <span class=
"org-constant">true</span>),
              createSimpleExpression(<span class=
"org-string">'true'</span>)
            )
          )
        }
  
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">special case for v-bind and v-on with no argument</span>
        <span class=
"org-keyword">if</span> (!arg &amp;& (isVBind || isVOn)) {
          hasDynamicKeys = <span class="org-constant">true</span>
          <span class="org-keyword">if</span> (exp) {
            <span class=
"org-keyword">if</span> (properties.length) {
              mergeArgs.push(
                createObjectExpression(dedupeProperties(properties), elementLoc)
              )
              properties = []
            }
            <span class="org-keyword">if</span> (isVBind) {
              mergeArgs.push(exp)
            } <span class="org-keyword">else</span> {
              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">v-on="obj" -&gt; toHandlers(obj)</span>
              mergeArgs.push({
                type: NodeTypes.JS_CALL_EXPRESSION,
                loc,
                callee: context.helper(TO_HANDLERS),
                <span class="org-constant">arguments</span>: [exp]
              })
            }
          }
          <span class="org-keyword">continue</span>
        }
  
        <span class="org-keyword">const</span> <span class=
"org-variable-name">directiveTransform</span> = context.directiveTransforms[name]
        <span class="org-keyword">if</span> (directiveTransform) {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">has built-in directive transform.</span>
          <span class=
"org-keyword">const</span> { props, needRuntime } = directiveTransform(prop, node, context)
          !ssr &amp;& props.forEach(analyzePatchFlag)
          properties.push(...props)
          <span class="org-keyword">if</span> (needRuntime) {
            runtimeDirectives.push(prop)
            <span class=
"org-keyword">if</span> (isSymbol(needRuntime)) {
              directiveImportMap.set(prop, needRuntime)
            }
          }
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (!isBuiltInDirective(name)) {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">no built-in transform, this is a user custom directive.</span>
          runtimeDirectives.push(prop)
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">custom dirs may use beforeUpdate so they need to force blocks</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">to ensure before-update gets called before children update</span>
          <span class="org-keyword">if</span> (hasChildren) {
            shouldUseBlock = <span class="org-constant">true</span>
          }
        }
      }
    }
  
    <span class="org-keyword">let</span> <span class=
"org-variable-name">propsExpression</span> = <span class=
"org-constant">undefined</span>
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">has v-bind="object" or v-on="object", wrap with mergeProps</span>
    <span class="org-keyword">if</span> (mergeArgs.length) {
      <span class="org-keyword">if</span> (properties.length) {
        mergeArgs.push(
          createObjectExpression(dedupeProperties(properties), elementLoc)
        )
      }
      <span class=
"org-keyword">if</span> (mergeArgs.length &gt; <span class=
"org-highlight-numbers-number">1</span>) {
        propsExpression = createCallExpression(
          context.helper(MERGE_PROPS),
          mergeArgs,
          elementLoc
        )
      } <span class="org-keyword">else</span> {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">single v-bind with nothing else - no need for a mergeProps call</span>
        propsExpression = mergeArgs[<span class=
"org-highlight-numbers-number">0</span>]
      }
    } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (properties.length) {
      propsExpression = createObjectExpression(
        dedupeProperties(properties),
        elementLoc
      )
    }
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">patchFlag analysis</span>
    <span class="org-keyword">if</span> (hasDynamicKeys) {
      patchFlag |= PatchFlags.FULL_PROPS
    } <span class="org-keyword">else</span> {
      <span class=
"org-keyword">if</span> (hasClassBinding &amp;& !isComponent) {
        patchFlag |= PatchFlags.CLASS
      }
      <span class=
"org-keyword">if</span> (hasStyleBinding &amp;& !isComponent) {
        patchFlag |= PatchFlags.STYLE
      }
      <span class=
"org-keyword">if</span> (dynamicPropNames.length) {
        patchFlag |= PatchFlags.PROPS
      }
      <span class=
"org-keyword">if</span> (hasHydrationEventBinding) {
        patchFlag |= PatchFlags.HYDRATE_EVENTS
      }
    }
    <span class="org-keyword">if</span> (
      !shouldUseBlock &amp;&
      (patchFlag === <span class=
"org-highlight-numbers-number">0</span> || patchFlag === PatchFlags.HYDRATE_EVENTS) &amp;&
      (hasRef || hasVnodeHook || runtimeDirectives.length &gt; <span class="org-highlight-numbers-number">0</span>)
    ) {
      patchFlag |= PatchFlags.NEED_PATCH
    }
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">pre-normalize props, SSR is skipped for now</span>
    <span class=
"org-keyword">if</span> (!context.inSSR &amp;& propsExpression) {
      <span class=
"org-keyword">switch</span> (propsExpression.type) {
        <span class=
"org-keyword">case</span> NodeTypes.JS_OBJECT_EXPRESSION:
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">means that there is no v-bind,</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">but still need to deal with dynamic key binding</span>
          <span class="org-keyword">let</span> <span class=
"org-variable-name">classKeyIndex</span> = -<span class=
"org-highlight-numbers-number">1</span>
          <span class="org-keyword">let</span> <span class=
"org-variable-name">styleKeyIndex</span> = -<span class=
"org-highlight-numbers-number">1</span>
          <span class="org-keyword">let</span> <span class=
"org-variable-name">hasDynamicKey</span> = <span class=
"org-constant">false</span>
  
          <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; propsExpression.properties.length; i++) {
            <span class="org-keyword">const</span> <span class=
"org-variable-name">key</span> = propsExpression.properties[i].key
            <span class=
"org-keyword">if</span> (isStaticExp(key)) {
              <span class=
"org-keyword">if</span> (key.content === <span class=
"org-string">'class'</span>) {
                classKeyIndex = i
              } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (key.content === <span class=
"org-string">'style'</span>) {
                styleKeyIndex = i
              }
            } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (!key.isHandlerKey) {
              hasDynamicKey = <span class=
"org-constant">true</span>
            }
          }
  
          <span class="org-keyword">const</span> <span class=
"org-variable-name">classProp</span> = propsExpression.properties[classKeyIndex]
          <span class="org-keyword">const</span> <span class=
"org-variable-name">styleProp</span> = propsExpression.properties[styleKeyIndex]
  
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">no dynamic key</span>
          <span class="org-keyword">if</span> (!hasDynamicKey) {
            <span class=
"org-keyword">if</span> (classProp &amp;& !isStaticExp(classProp.value)) {
              classProp.value = createCallExpression(
                context.helper(NORMALIZE_CLASS),
                [classProp.value]
              )
            }
            <span class="org-keyword">if</span> (
              styleProp &amp;&
              !isStaticExp(styleProp.value) &amp;&
              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">the static style is compiled into an object,</span>
              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">so use `hasStyleBinding` to ensure that it is a dynamic style binding</span>
              (hasStyleBinding ||
                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">v-bind:style and style both exist,</span>
                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">v-bind:style with static literal object</span>
                styleProp.value.type === NodeTypes.JS_ARRAY_EXPRESSION)
            ) {
              styleProp.value = createCallExpression(
                context.helper(NORMALIZE_STYLE),
                [styleProp.value]
              )
            }
          } <span class="org-keyword">else</span> {
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">dynamic key binding, wrap with `normalizeProps`</span>
            propsExpression = createCallExpression(
              context.helper(NORMALIZE_PROPS),
              [propsExpression]
            )
          }
          <span class="org-keyword">break</span>
        <span class=
"org-keyword">case</span> NodeTypes.JS_CALL_EXPRESSION:
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">mergeProps call, do nothing</span>
          <span class="org-keyword">break</span>
        <span class="org-keyword">default</span>:
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">single v-bind</span>
          propsExpression = createCallExpression(
            context.helper(NORMALIZE_PROPS),
            [
              createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
                propsExpression
              ])
            ]
          )
          <span class="org-keyword">break</span>
      }
    }
  
    <span class="org-keyword">return</span> {
      props: propsExpression,
      directives: runtimeDirectives,
      patchFlag,
      dynamicPropNames,
      shouldUseBlock
    }
  }
  
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">Dedupe props in an object literal.</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">Literal duplicated attributes would have been warned during the parse phase,</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">however, it's possible to encounter duplicated `onXXX` handlers with different</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">modifiers. We also need to merge static and dynamic class / style attributes.</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">- onXXX handlers / style: merge into array</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">- class: merge into single expression with concatenation</span>
  <span class="org-keyword">function</span> <span class=
"org-function-name">dedupeProperties</span>(<span class=
"org-variable-name">properties</span>) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">knownProps</span> = <span class=
"org-keyword">new</span> <span class="org-type">Map</span>()
    <span class="org-keyword">const</span> <span class=
"org-variable-name">deduped</span> = []
    <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; properties.length; i++) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">prop</span> = properties[i]
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">dynamic keys are always allowed</span>
      <span class=
"org-keyword">if</span> (prop.key.type === NodeTypes.COMPOUND_EXPRESSION || !prop.key.isStatic) {
        deduped.push(prop)
        <span class="org-keyword">continue</span>
      }
      <span class="org-keyword">const</span> <span class=
"org-variable-name">name</span> = prop.key.content
      <span class="org-keyword">const</span> <span class=
"org-variable-name">existing</span> = knownProps.get(name)
      <span class="org-keyword">if</span> (existing) {
        <span class="org-keyword">if</span> (name === <span class=
"org-string">'style'</span> || name === <span class=
"org-string">'class'</span> || isOn(name)) {
          mergeAsArray(existing, prop)
        }
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">unexpected duplicate, should have emitted error during parse</span>
      } <span class="org-keyword">else</span> {
        knownProps.set(name, prop)
        deduped.push(prop)
      }
    }
    <span class="org-keyword">return</span> deduped
  }
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">mergeAsArray</span>(<span class=
"org-variable-name">existing</span>, <span class=
"org-variable-name">incoming</span>) {
    <span class=
"org-keyword">if</span> (existing.value.type === NodeTypes.JS_ARRAY_EXPRESSION) {
      existing.value.elements.push(incoming.value)
    } <span class="org-keyword">else</span> {
      existing.value = createArrayExpression(
        [existing.value, incoming.value],
        existing.loc
      )
    }
  }
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">buildDirectiveArgs</span>(
    <span class="org-variable-name">dir</span>,
    context
  ) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">dirArgs</span> = []
    <span class="org-keyword">const</span> <span class=
"org-variable-name">runtime</span> = directiveImportMap.get(dir)
    <span class="org-keyword">if</span> (runtime) {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">built-in directive with runtime</span>
      dirArgs.push(context.helperString(runtime))
    } <span class="org-keyword">else</span> {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">user directive.</span>
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">see if we have directives exposed via &lt;script setup&gt;</span>
      <span class="org-keyword">const</span> <span class=
"org-variable-name">fromSetup</span> =
        !__BROWSER__ &amp;& resolveSetupReference(<span class=
"org-string">'v-'</span> + dir.name, context)
      <span class="org-keyword">if</span> (fromSetup) {
        dirArgs.push(fromSetup)
      } <span class="org-keyword">else</span> {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">inject statement for resolving directive</span>
        context.helper(RESOLVE_DIRECTIVE)
        context.directives.add(dir.name)
        dirArgs.push(toValidAssetId(dir.name, <span class=
"org-string">`directive`</span>))
      }
    }
    <span class="org-keyword">const</span> { loc } = dir
    <span class=
"org-keyword">if</span> (dir.exp) dirArgs.push(dir.exp)
    <span class="org-keyword">if</span> (dir.arg) {
      <span class="org-keyword">if</span> (!dir.exp) {
        dirArgs.push(<span class="org-string">`void 0`</span>)
      }
      dirArgs.push(dir.arg)
    }
    <span class=
"org-keyword">if</span> (Object.keys(dir.modifiers).length) {
      <span class="org-keyword">if</span> (!dir.arg) {
        <span class="org-keyword">if</span> (!dir.exp) {
          dirArgs.push(<span class="org-string">`void 0`</span>)
        }
        dirArgs.push(<span class="org-string">`void 0`</span>)
      }
      <span class="org-keyword">const</span> <span class=
"org-variable-name">trueExpression</span> = createSimpleExpression(<span class="org-string">`true`</span>, <span class="org-constant">false</span>, loc)
      dirArgs.push(
        createObjectExpression(
          dir.modifiers.map(modifier =&gt;
            createObjectProperty(modifier, trueExpression)
          ),
          loc
        )
      )
    }
    <span class=
"org-keyword">return</span> createArrayExpression(dirArgs, dir.loc)
  }
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">stringifyDynamicPropNames</span>(<span class=
"org-variable-name">props</span>) {
    <span class="org-keyword">let</span> <span class=
"org-variable-name">propsNamesString</span> = <span class=
"org-string">`[`</span>
    <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>, <span class=
"org-variable-name">l</span> = props.length; i &lt; l; i++) {
      propsNamesString += JSON.stringify(props[i])
      <span class="org-keyword">if</span> (i &lt; l - <span class=
"org-highlight-numbers-number">1</span>) propsNamesString += <span class="org-string">', '</span>
    }
    <span class=
"org-keyword">return</span> propsNamesString + <span class=
"org-string">`]`</span>
  }
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">isComponentTag</span>(<span class=
"org-variable-name">tag</span>) {
    <span class="org-keyword">return</span> tag === <span class=
"org-string">'component'</span> || tag === <span class=
"org-string">'Component'</span>
  }
  
  
  <span class="org-keyword">const</span> <span class=
"org-variable-name">isLiteralWhitelisted</span> = <span class=
"org-comment-delimiter">/*</span><span class=
"org-comment">#__PURE__</span><span class=
"org-comment-delimiter">*/</span> makeMap(<span class=
"org-string">'true,false,null,this'</span>)
  
  <span class="org-keyword">const</span> <span class=
"org-variable-name">transformExpression</span> = (node, context) =&gt; {
    logg(<span class=
"org-string">`transformExpression`</span>, node)
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">插值处理</span>
    <span class=
"org-keyword">if</span> (node.type === NodeTypes.INTERPOLATION) {
      node.content = processExpression(
        node.content ,
        context
      )
    } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (node.type === NodeTypes.ELEMENT) {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">处理元素上的指令</span>
      <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; node.props.length; i++) {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">dir</span> = node.props[i]
        logg(<span class=
"org-string">`transformExpression - prop[${i}] - directive`</span>, node.props[i])
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">do not process for v-on & v-for since they are special handled</span>
        <span class=
"org-keyword">if</span> (dir.type === NodeTypes.DIRECTIVE &amp;& dir.name !== <span class="org-string">'for'</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">v-for 在 vFor.ts 中处理</span>
          <span class="org-keyword">const</span> <span class=
"org-variable-name">exp</span> = dir.exp
          <span class="org-keyword">const</span> <span class=
"org-variable-name">arg</span> = dir.arg
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">do not process exp if this is v-on:arg - we need special handling</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">for wrapping inline statements.</span>
          <span class="org-keyword">if</span> (
            exp &amp;&
            exp.type === NodeTypes.SIMPLE_EXPRESSION &amp;&
            !(dir.name === <span class=
"org-string">'on'</span> &amp;& arg)
          ) {
            dir.exp = processExpression(
              exp,
              context,
              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">slot args must be processed as function params</span>
              dir.name === <span class="org-string">'slot'</span>
            )
          }
          <span class=
"org-keyword">if</span> (arg &amp;& arg.type === NodeTypes.SIMPLE_EXPRESSION &amp;& !arg.isStatic) {
            dir.arg = processExpression(arg, context)
          }
        }
      }
    }
  }
  
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">Important: since this function uses Node.js only dependencies, it should</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">always be used with a leading !__BROWSER__ check so that it can be</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">tree-shaken from the browser build.</span>
  <span class="org-keyword">function</span> <span class=
"org-function-name">processExpression</span>(
    <span class="org-variable-name">node</span>,
    <span class="org-variable-name">context</span>,
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">some expressions like v-slot props & v-for aliases should be parsed as</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">function params</span>
    asParams = <span class="org-constant">false</span>,
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">v-on handler values may contain multiple statements</span>
    asRawStatements = <span class="org-constant">false</span>,
    localVars = Object.create(context.identifiers)
  ) {
    <span class="org-keyword">if</span> (__BROWSER__) {
      <span class="org-keyword">return</span> node
    }
  
    <span class=
"org-keyword">if</span> (!context.prefixIdentifiers || !node.content.trim()) {
      <span class="org-keyword">return</span> node
    }
  
    <span class=
"org-keyword">const</span> { inline, bindingMetadata } = context
    <span class="org-keyword">const</span> <span class=
"org-variable-name">rewriteIdentifier</span> = (raw, parent, id) =&gt; {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">type</span> = hasOwn(bindingMetadata, raw) &amp;& bindingMetadata[raw]
      <span class="org-keyword">if</span> (inline) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">x = y</span>
        <span class="org-keyword">const</span> <span class=
"org-variable-name">isAssignmentLVal</span> =
          parent &amp;& parent.type === <span class=
"org-string">'AssignmentExpression'</span> &amp;& parent.left === id
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">x++</span>
        <span class="org-keyword">const</span> <span class=
"org-variable-name">isUpdateArg</span> =
          parent &amp;& parent.type === <span class=
"org-string">'UpdateExpression'</span> &amp;& parent.argument === id
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">({ x } = y)</span>
        <span class="org-keyword">const</span> <span class=
"org-variable-name">isDestructureAssignment</span> =
          parent &amp;& isInDestructureAssignment(parent, parentStack)
  
        <span class=
"org-keyword">if</span> (type === BindingTypes.SETUP_CONST || localVars[raw]) {
          <span class="org-keyword">return</span> raw
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (type === BindingTypes.SETUP_REF) {
          <span class="org-keyword">return</span> <span class=
"org-string">`${raw}.value`</span>
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (type === BindingTypes.SETUP_MAYBE_REF) {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">const binding that may or may not be ref</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">if it's not a ref, then assignments don't make sense -</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">so we ignore the non-ref assignment case and generate code</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">that assumes the value to be a ref for more efficiency</span>
          <span class=
"org-keyword">return</span> isAssignmentLVal || isUpdateArg || isDestructureAssignment
            ? <span class="org-string">`${raw}.value`</span>
            : <span class=
"org-string">`${context.helperString(UNREF)}(${raw})`</span>
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (type === BindingTypes.SETUP_LET) {
          <span class="org-keyword">if</span> (isAssignmentLVal) {
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">let binding.</span>
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">this is a bit more tricky as we need to cover the case where</span>
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">let is a local non-ref value, and we need to replicate the</span>
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">right hand side value.</span>
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">x = y --&gt; isRef(x) ? x.value = y : x = y</span>
            <span class=
"org-keyword">const</span> { right: rVal, operator } = parent
            <span class="org-keyword">const</span> <span class=
"org-variable-name">rExp</span> = rawExp.slice(rVal.start - <span class="org-highlight-numbers-number">1</span>, rVal.end - <span class="org-highlight-numbers-number">1</span>)
            <span class="org-keyword">const</span> <span class=
"org-variable-name">rExpString</span> = stringifyExpression(
              processExpression(
                createSimpleExpression(rExp, <span class=
"org-constant">false</span>),
                context,
                <span class="org-constant">false</span>,
                <span class="org-constant">false</span>,
                knownIds
              )
            )
            <span class="org-keyword">return</span> <span class=
"org-string">`${context.helperString(IS_REF)}(${raw})${``} ? ${raw}.value ${operator} ${rExpString} : ${raw}`</span>
          } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (isUpdateArg) {
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">make id replace parent in the code range so the raw update operator</span>
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">is removed</span>
            id.start = parent.start
            id.end = parent.end
            <span class=
"org-keyword">const</span> { prefix: isPrefix, operator } = parent
            <span class="org-keyword">const</span> <span class=
"org-variable-name">prefix</span> = isPrefix ? operator : <span class="org-string">``</span>
            <span class="org-keyword">const</span> <span class=
"org-variable-name">postfix</span> = isPrefix ? <span class=
"org-string">``</span> : operator
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">let binding.</span>
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">x++ --&gt; isRef(a) ? a.value++ : a++</span>
            <span class="org-keyword">return</span> <span class=
"org-string">`${context.helperString(IS_REF)}(${raw})${``} ? ${prefix}${raw}.value${postfix} : ${prefix}${raw}${postfix}`</span>
          } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (isDestructureAssignment) {
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment"><span class="org-bold"><span class=
"org-warning">TODO</span></span></span>
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">let binding in a destructure assignment - it's very tricky to</span>
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">handle both possible cases here without altering the original</span>
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">structure of the code, so we just assume it's not a ref here</span>
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">for now</span>
            <span class="org-keyword">return</span> raw
          } <span class="org-keyword">else</span> {
            <span class="org-keyword">return</span> <span class=
"org-string">`${context.helperString(UNREF)}(${raw})`</span>
          }
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (type === BindingTypes.PROPS) {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">use __props which is generated by compileScript so in ts mode</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">it gets correct type</span>
          <span class="org-keyword">return</span> <span class=
"org-string">`__props.${raw}`</span>
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (type === BindingTypes.PROPS_ALIASED) {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">prop with a different local alias (from defineProps() destructure)</span>
          <span class="org-keyword">return</span> <span class=
"org-string">`__props.${bindingMetadata.__propsAliases[raw]}`</span>
        }
      } <span class="org-keyword">else</span> {
        <span class=
"org-keyword">if</span> (type &amp;& type.startsWith(<span class=
"org-string">'setup'</span>)) {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">setup bindings in non-inline mode</span>
          <span class="org-keyword">return</span> <span class=
"org-string">`$setup.${raw}`</span>
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (type === BindingTypes.PROPS_ALIASED) {
          <span class="org-keyword">return</span> <span class=
"org-string">`$props.${bindingMetadata.__propsAliases[raw]}`</span>
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (type) {
          <span class="org-keyword">return</span> <span class=
"org-string">`$${type}.${raw}`</span>
        }
      }
  
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">fallback to ctx</span>
      <span class="org-keyword">return</span> <span class=
"org-string">`_ctx.${raw}`</span>
    }
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">fast path if expression is a simple identifier.</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">rawExp</span> = node.content
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">bail constant on parens (function invocation) and dot (member access)</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">bailConstant</span> = rawExp.indexOf(<span class="org-string">`(`</span>) &gt; -<span class="org-highlight-numbers-number">1</span> || rawExp.indexOf(<span class="org-string">'.'</span>) &gt; <span class="org-highlight-numbers-number">0</span>
  
    logg(<span class=
"org-string">`processExpression - node.content: ${rawExp}`</span>)
    <span class=
"org-keyword">if</span> (isSimpleIdentifier(rawExp)) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">isScopeVarReference</span> = context.identifiers[rawExp]
      <span class="org-keyword">const</span> <span class=
"org-variable-name">isAllowedGlobal</span> = isGloballyWhitelisted(rawExp)
      <span class="org-keyword">const</span> <span class=
"org-variable-name">isLiteral</span> = isLiteralWhitelisted(rawExp)
      <span class=
"org-keyword">if</span> (!asParams &amp;& !isScopeVarReference &amp;& !isAllowedGlobal &amp;& !isLiteral) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">const bindings exposed from setup can be skipped for patching but</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">cannot be hoisted to module scope</span>
        <span class=
"org-keyword">if</span> (bindingMetadata[node.content] === BindingTypes.SETUP_CONST) {
          node.constType = ConstantTypes.CAN_SKIP_PATCH
        }
        node.content = rewriteIdentifier(rawExp)
      } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (!isScopeVarReference) {
        <span class="org-keyword">if</span> (isLiteral) {
          node.constType = ConstantTypes.CAN_STRINGIFY
        } <span class="org-keyword">else</span> {
          node.constType = ConstantTypes.CAN_HOIST
        }
      }
      <span class="org-keyword">return</span> node
    }
  
    <span class="org-keyword">let</span> <span class=
"org-variable-name">ast</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">exp needs to be parsed differently:</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">1. Multiple inline statements (v-on, with presence of `;`): parse as raw</span>
    <span class="org-comment-delimiter">//    </span><span class=
"org-comment">exp, but make sure to pad with spaces for consistent ranges</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">2. Expressions: wrap with parens (for e.g. object expressions)</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">3. Function arguments (v-for, v-slot): place in a function argument position</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">source</span> = asRawStatements
      ? <span class="org-string">` ${rawExp} `</span>
      : <span class=
"org-string">`(${rawExp})${asParams ? `</span>=&gt;{}<span class=
"org-string">` : ``}`</span>
    <span class="org-keyword">try</span> {
      ast = babelParser.parse(source, {
        plugins: context.expressionPlugins
      }).program
    } <span class="org-keyword">catch</span> (e) {
      <span class="org-keyword">return</span> node
    }
  
    logg(<span class=
"org-string">`processExpression - babel parse`</span>, ast)
    <span class="org-keyword">const</span> <span class=
"org-variable-name">ids</span> = []
    <span class="org-keyword">const</span> <span class=
"org-variable-name">parentStack</span> = []
    <span class="org-keyword">const</span> <span class=
"org-variable-name">knownIds</span> = Object.create(context.identifiers)
  
    walkIdentifiers(
      ast,
      (node, parent, _, isReferenced, isLocal) =&gt; {
        <span class=
"org-keyword">if</span> (isStaticPropertyKey(node, parent)) {
          <span class="org-keyword">return</span>
        }
  
        <span class="org-keyword">const</span> <span class=
"org-variable-name">needPrefix</span> = isReferenced &amp;& canPrefix(node)
        <span class=
"org-keyword">if</span> (needPrefix &amp;& !isLocal) {
          <span class=
"org-keyword">if</span> (isStaticProperty(parent) &amp;& parent.shorthand) {
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">property shorthand like { foo }, we need to add the key since</span>
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">we rewrite the value</span>
            node.prefix = <span class=
"org-string">`${node.name}: `</span>
          }
          node.name = rewriteIdentifier(node.name, parent, node)
          ids.push(node)
        } <span class="org-keyword">else</span> {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">The identifier is considered constant unless it's pointing to a</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">local scope variable (a v-for alias, or a v-slot prop)</span>
          <span class=
"org-keyword">if</span> (!(needPrefix &amp;& isLocal) &amp;& !bailConstant) {
            node.isConstant = <span class=
"org-constant">true</span>
          }
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">also generate sub-expressions for other identifiers for better</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">source map support. (except for property keys which are static)</span>
          ids.push(node)
        }
      },
      <span class="org-constant">true</span>, <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">invoke on ALL identifiers</span>
      parentStack,
      knownIds
    )
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">We break up the compound expression into an array of strings and sub</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">expressions (for identifiers that have been prefixed). In codegen, if</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">an ExpressionNode has the `.children` property, it will be used instead of</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">`.content`.</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">children</span> = []
    ids.sort((a, b) =&gt; a.start - b.start)
    ids.forEach((id, i) =&gt; {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">range is offset by -1 due to the wrapping parens when parsed</span>
      <span class="org-keyword">const</span> <span class=
"org-variable-name">start</span> = id.start - <span class=
"org-highlight-numbers-number">1</span>
      <span class="org-keyword">const</span> <span class=
"org-variable-name">end</span> = id.end - <span class=
"org-highlight-numbers-number">1</span>
      <span class="org-keyword">const</span> <span class=
"org-variable-name">last</span> = ids[i - <span class=
"org-highlight-numbers-number">1</span>]
      <span class="org-keyword">const</span> <span class=
"org-variable-name">leadingText</span> = rawExp.slice(last ? last.end - <span class="org-highlight-numbers-number">1</span> : <span class="org-highlight-numbers-number">0</span>, start)
      <span class=
"org-keyword">if</span> (leadingText.length || id.prefix) {
        children.push(leadingText + (id.prefix || <span class=
"org-string">``</span>))
      }
      <span class="org-keyword">const</span> <span class=
"org-variable-name">source</span> = rawExp.slice(start, end)
      children.push(
        createSimpleExpression(
          id.name,
          <span class="org-constant">false</span>,
          {
            source,
            start: advancePositionWithClone(node.loc.start, source, start),
            end: advancePositionWithClone(node.loc.start, source, end)
          },
          id.isConstant ? ConstantTypes.CAN_STRINGIFY : ConstantTypes.NOT_CONSTANT
        )
      )
      <span class=
"org-keyword">if</span> (i === ids.length - <span class=
"org-highlight-numbers-number">1</span> &amp;& end &lt; rawExp.length) {
        children.push(rawExp.slice(end))
      }
    })
  
    <span class="org-keyword">let</span> <span class=
"org-variable-name">ret</span>
    <span class="org-keyword">if</span> (children.length) {
      ret = createCompoundExpression(children, node.loc)
    } <span class="org-keyword">else</span> {
      ret = node
      ret.constType = bailConstant
        ? ConstantTypes.NOT_CONSTANT
        : ConstantTypes.CAN_STRINGIFY
    }
    ret.identifiers = Object.keys(knownIds)
    <span class="org-keyword">return</span> ret
  }
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">canPrefix</span>(<span class=
"org-variable-name">id</span>) {
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">skip whitelisted globals</span>
    <span class=
"org-keyword">if</span> (isGloballyWhitelisted(id.name)) {
      <span class="org-keyword">return</span> <span class=
"org-constant">false</span>
    }
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">special case for webpack compilation</span>
    <span class="org-keyword">if</span> (id.name === <span class=
"org-string">'require'</span>) {
      <span class="org-keyword">return</span> <span class=
"org-constant">false</span>
    }
    <span class="org-keyword">return</span> <span class=
"org-constant">true</span>
  }
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">stringifyExpression</span>(<span class=
"org-variable-name">exp</span>) {
    <span class="org-keyword">if</span> (isString(exp)) {
      <span class="org-keyword">return</span> exp
    } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (exp.type === NodeTypes.SIMPLE_EXPRESSION) {
      <span class="org-keyword">return</span> exp.content
    } <span class="org-keyword">else</span> {
      <span class="org-keyword">return</span> (exp.children)
        .map(stringifyExpression)
        .join(<span class="org-string">''</span>)
    }
  }
  
  <span class="org-keyword">const</span> <span class=
"org-variable-name">transformSlotOutlet</span> = (node, context) =&gt; {
    <span class=
"org-keyword">if</span> (isSlotOutlet(node)) { <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">&lt;slot/&gt;</span>
      <span class=
"org-keyword">const</span> { children, loc } = node
      <span class=
"org-keyword">const</span> { slotName, slotProps } = processSlotOutlet(node, context)
  
      <span class="org-keyword">const</span> <span class=
"org-variable-name">slotArgs</span> = [
        context.prefixIdentifiers ? <span class=
"org-string">`_ctx.$slots`</span> : <span class=
"org-string">`$slots`</span>,
        slotName,
        <span class="org-string">'{}'</span>, <span class=
"org-comment-delimiter">//  </span><span class=
"org-comment">props</span>
        <span class="org-string">'undefined'</span>, <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">children</span>
        <span class="org-string">'true'</span>
      ]
      <span class="org-keyword">let</span> <span class=
"org-variable-name">expectedLen</span> = <span class=
"org-highlight-numbers-number">2</span>
  
      <span class="org-keyword">if</span> (slotProps) {
        slotArgs[<span class=
"org-highlight-numbers-number">2</span>] = slotProps
        expectedLen = <span class=
"org-highlight-numbers-number">3</span>
      }
  
      <span class="org-keyword">if</span> (children.length) {
        slotArgs[<span class=
"org-highlight-numbers-number">3</span>] = createFunctionExpression([], children, <span class="org-constant">false</span>, <span class="org-constant">false</span>, loc)
        expectedLen = <span class=
"org-highlight-numbers-number">4</span>
      }
  
      <span class=
"org-keyword">if</span> (context.scopeId &amp;& !context.slotted) {
        expectedLen = <span class=
"org-highlight-numbers-number">5</span>
      }
      slotArgs.splice(expectedLen) <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">remove unused arguments</span>
  
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">-&gt; renderSlot($slots, slotName, props, children, true)</span>
      node.codegenNode = createCallExpression(
        context.helper(RENDER_SLOT), <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">renderSlot</span>
        slotArgs,
        loc
      )
    }
  }
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">processSlotOutlet</span>(
    <span class="org-variable-name">node</span>,
    context
  ) {
    <span class="org-keyword">let</span> <span class=
"org-variable-name">slotName</span> = <span class=
"org-string">`"default"`</span>
    <span class="org-keyword">let</span> <span class=
"org-variable-name">slotProps</span> = <span class=
"org-constant">undefined</span>
  
    <span class="org-keyword">const</span> <span class=
"org-variable-name">nonNameProps</span> = [] <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">无名插槽</span>
    logg(<span class=
"org-string">`processSlotOutlet| props.length = ${node.props.length}`</span>)
    <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; node.props.length; i++) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">p</span> = node.props[i]
      logg(<span class=
"org-string">`processSlotOutlet| props[${i}]`</span>, p)
      <span class=
"org-keyword">if</span> (p.type === NodeTypes.ATTRIBUTE) { <span class="org-comment-delimiter">// </span><span class="org-comment">静态 &lt;slot name="xxx"/&gt;</span>
        <span class="org-keyword">if</span> (p.value) {
          <span class=
"org-keyword">if</span> (p.name === <span class=
"org-string">'name'</span>) {
            slotName = JSON.stringify(p.value.content)
          } <span class="org-keyword">else</span> {
            p.name = camelize(p.name)
            nonNameProps.push(p)
          }
        }
      } <span class="org-keyword">else</span> { <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">动态 &lt;slot :name="xxx"/&gt;</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">动态插槽 &lt;slot v-bind:name="slotName"/&gt;</span>
        <span class=
"org-keyword">if</span> (p.name === <span class="org-string">'bind'</span> &amp;& isStaticArgOf(p.arg, <span class="org-string">'name'</span>)) {
          <span class=
"org-keyword">if</span> (p.exp) slotName = p.exp
        } <span class="org-keyword">else</span> {
          <span class=
"org-keyword">if</span> (p.name === <span class=
"org-string">'bind'</span> &amp;& p.arg &amp;& isStaticExp(p.arg)) {
            p.arg.content = camelize(p.arg.content)
          }
          nonNameProps.push(p)
        }
      }
    }
  
    logg(<span class=
"org-string">`processSlotOutlet| nonNameProps.length=${nonNameProps.length}`</span>)
    <span class=
"org-keyword">if</span> (nonNameProps.length &gt; <span class=
"org-highlight-numbers-number">0</span>) {
      <span class=
"org-keyword">const</span> { props, directives } = buildProps(node, context, nonNameProps)
      slotProps = props
  
      <span class="org-keyword">if</span> (directives.length) {
        logg(<span class=
"org-string">'[ERROR] X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET'</span>)
      }
    }
  
    <span class="org-keyword">return</span> {
      slotName,
      slotProps
    }
  }
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">Merge adjacent text nodes and expressions into a single expression</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">e.g. &lt;div&gt;abc {{ d }} {{ e }}&lt;/div&gt; should have a single expression node as child.</span>
  <span class="org-keyword">const</span> <span class=
"org-variable-name">transformText</span> = (node, context) =&gt; {
    <span class="org-keyword">if</span> (
      node.type === NodeTypes.ROOT ||
      node.type === NodeTypes.ELEMENT ||
      node.type === NodeTypes.FOR ||
      node.type === NodeTypes.IF_BRANCH
    ) {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">perform the transform on node exit so that all expressions have already</span>
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">been processed.</span>
      <span class="org-keyword">return</span> () =&gt; {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">children</span> = node.children
        <span class="org-keyword">let</span> <span class=
"org-variable-name">currentContainer</span> = <span class=
"org-constant">undefined</span>
        <span class="org-keyword">let</span> <span class=
"org-variable-name">hasText</span> = <span class=
"org-constant">false</span>
  
        <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; children.length; i++) {
          <span class="org-keyword">const</span> <span class=
"org-variable-name">child</span> = children[i]
          <span class="org-keyword">if</span> (isText(child)) {
            hasText = <span class="org-constant">true</span>
            <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">j</span> = i + <span class=
"org-highlight-numbers-number">1</span>; j &lt; children.length; j++) {
              <span class="org-keyword">const</span> <span class=
"org-variable-name">next</span> = children[j]
              <span class="org-keyword">if</span> (isText(next)) {
                <span class=
"org-keyword">if</span> (!currentContainer) {
                  currentContainer = children[i] = {
                    type: NodeTypes.COMPOUND_EXPRESSION,
                    loc: child.loc,
                    children: [child]
                  }
                }
                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">merge adjacent text node into current</span>
                currentContainer.children.push(<span class=
"org-string">` + `</span>, next)
                children.splice(j, <span class=
"org-highlight-numbers-number">1</span>)
                j--
              } <span class="org-keyword">else</span> {
                currentContainer = <span class=
"org-constant">undefined</span>
                <span class="org-keyword">break</span>
              }
            }
          }
        }
  
        <span class="org-keyword">if</span> (
          !hasText ||
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">if this is a plain element with a single text child, leave it</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">as-is since the runtime has dedicated fast path for this by directly</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">setting textContent of the element.</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">for component root it's always normalized anyway.</span>
          (children.length === <span class=
"org-highlight-numbers-number">1</span> &amp;&
            (node.type === NodeTypes.ROOT ||
              (node.type === NodeTypes.ELEMENT &amp;&
                node.tagType === ElementTypes.ELEMENT &amp;&
                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">#3756</span>
                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">custom directives can potentially add DOM elements arbitrarily,</span>
                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">we need to avoid setting textContent of the element at runtime</span>
                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">to avoid accidentally overwriting the DOM elements added</span>
                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">by the user through custom directives.</span>
                !node.props.find(
                  p =&gt;
                    p.type === NodeTypes.DIRECTIVE &amp;&
                    !context.directiveTransforms[p.name]
                ))))
        ) {
          <span class="org-keyword">return</span>
        }
  
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">pre-convert text nodes into createTextVNode(text) calls to avoid</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">runtime normalization.</span>
        <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; children.length; i++) {
          <span class="org-keyword">const</span> <span class=
"org-variable-name">child</span> = children[i]
          <span class=
"org-keyword">if</span> (isText(child) || child.type === NodeTypes.COMPOUND_EXPRESSION) {
            <span class="org-keyword">const</span> <span class=
"org-variable-name">callArgs</span> = []
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">createTextVNode defaults to single whitespace, so if it is a</span>
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">single space the code could be an empty call to save bytes.</span>
            <span class=
"org-keyword">if</span> (child.type !== NodeTypes.TEXT || child.content !== <span class="org-string">' '</span>) {
              callArgs.push(child)
            }
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">mark dynamic text with flag so it gets patched inside a block</span>
            <span class="org-keyword">if</span> (
              !context.ssr &amp;&
              getConstantType(child, context) === ConstantTypes.NOT_CONSTANT
            ) {
              callArgs.push(
                PatchFlags.TEXT +
                  (__DEV__ ? <span class=
"org-string">` /* ${PatchFlagNames[PatchFlags.TEXT]} */`</span> : <span class="org-string">``</span>)
              )
            }
            children[i] = {
              type: NodeTypes.TEXT_CALL,
              content: child,
              loc: child.loc,
              codegenNode: createCallExpression(
                context.helper(CREATE_TEXT),
                callArgs
              )
            }
          }
        }
      }
    }
  }
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">v-bind without arg is handled directly in ./transformElements.ts due to it affecting</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">codegen for the entire props object. This transform here is only for v-bind</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">*with* args.</span>
  <span class="org-keyword">const</span> <span class=
"org-variable-name">transformBind</span> = (dir, _node, context) =&gt; {
    <span class=
"org-keyword">const</span> { exp, modifiers, loc } = dir
    <span class="org-keyword">const</span> <span class=
"org-variable-name">arg</span> = dir.arg
  
    <span class=
"org-keyword">if</span> (arg.type !== NodeTypes.SIMPLE_EXPRESSION) {
      arg.children.unshift(<span class="org-string">`(`</span>)
      arg.children.push(<span class="org-string">`) || ""`</span>)
    } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (!arg.isStatic) {
      arg.content = <span class=
"org-string">`${arg.content} || ""`</span>
    }
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">.sync is replaced by v-model:arg</span>
    <span class=
"org-keyword">if</span> (modifiers.includes(<span class=
"org-string">'camel'</span>)) {
      <span class=
"org-keyword">if</span> (arg.type === NodeTypes.SIMPLE_EXPRESSION) {
        <span class="org-keyword">if</span> (arg.isStatic) {
          arg.content = camelize(arg.content)
        } <span class="org-keyword">else</span> {
          arg.content = <span class=
"org-string">`${context.helperString(CAMELIZE)}(${arg.content})`</span>
        }
      } <span class="org-keyword">else</span> {
        arg.children.unshift(<span class=
"org-string">`${context.helperString(CAMELIZE)}(`</span>)
        arg.children.push(<span class="org-string">`)`</span>)
      }
    }
  
    <span class="org-keyword">if</span> (!context.inSSR) {
      <span class=
"org-keyword">if</span> (modifiers.includes(<span class=
"org-string">'prop'</span>)) {
        injectPrefix(arg, <span class="org-string">'.'</span>)
      }
      <span class=
"org-keyword">if</span> (modifiers.includes(<span class=
"org-string">'attr'</span>)) {
        injectPrefix(arg, <span class="org-string">'^'</span>)
      }
    }
  
    <span class="org-keyword">if</span> (
      !exp ||
      (exp.type === NodeTypes.SIMPLE_EXPRESSION &amp;& !exp.content.trim())
    ) {
      logg(<span class=
"org-string">`transformBind v-bind no expression`</span>)
      <span class="org-keyword">return</span> {
        props: [createObjectProperty(arg, createSimpleExpression(<span class="org-string">''</span>, <span class="org-constant">true</span>, loc))]
      }
    }
  
    <span class="org-keyword">return</span> {
      props: [createObjectProperty(arg, exp)]
    }
  }
  
  <span class="org-keyword">const</span> <span class=
"org-variable-name">injectPrefix</span> = (arg, prefix) =&gt; {
    <span class=
"org-keyword">if</span> (arg.type === NodeTypes.SIMPLE_EXPRESSION) {
      <span class="org-keyword">if</span> (arg.isStatic) {
        arg.content = prefix + arg.content
      } <span class="org-keyword">else</span> {
        arg.content = <span class=
"org-string">`\`${prefix}\${${arg.content}}\``</span>
      }
    } <span class="org-keyword">else</span> {
      arg.children.unshift(<span class=
"org-string">`'${prefix}' + (`</span>)
      arg.children.push(<span class="org-string">`)`</span>)
    }
  }
  
  <span class="org-keyword">const</span> <span class=
"org-variable-name">transformFor</span> = createStructuralDirectiveTransform(
    <span class="org-string">'for'</span>,
    (node, dir, context) =&gt; {
      <span class=
"org-keyword">const</span> { helper, removeHelper } = context
      <span class=
"org-keyword">return</span> processFor(node, dir, context, forNode =&gt; {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">create the loop render function expression now, and add the</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">iterator on exit after all children have been traversed</span>
        <span class="org-keyword">const</span> <span class=
"org-variable-name">renderExp</span> = createCallExpression(helper(RENDER_LIST), [
          forNode.source
        ])
        <span class="org-keyword">const</span> <span class=
"org-variable-name">isTemplate</span> = isTemplateNode(node)
        <span class="org-keyword">const</span> <span class=
"org-variable-name">memo</span> = findDir(node, <span class=
"org-string">'memo'</span>)
        <span class="org-keyword">const</span> <span class=
"org-variable-name">keyProp</span> = findProp(node, <span class=
"org-string">`key`</span>)
        <span class="org-keyword">const</span> <span class=
"org-variable-name">keyExp</span> =
          keyProp &amp;&
          (keyProp.type === NodeTypes.ATTRIBUTE
            ? createSimpleExpression(keyProp.value.content, <span class="org-constant">true</span>)
            : keyProp.exp)
        <span class="org-keyword">const</span> <span class=
"org-variable-name">keyProperty</span> = keyProp ? createObjectProperty(<span class="org-string">`key`</span>, keyExp) : <span class="org-constant">null</span>
  
        <span class=
"org-keyword">if</span> (!__BROWSER__ &amp;& isTemplate) {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">#2085 / #5288 process :key and v-memo expressions need to be</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">processed on `&lt;template v-for&gt;`. In this case the node is discarded</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">and never traversed so its binding expressions won't be processed</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">by the normal transforms.</span>
          <span class="org-keyword">if</span> (memo) {
            memo.exp = processExpression(
              memo.exp ,
              context
            )
          }
          <span class=
"org-keyword">if</span> (keyProperty &amp;& keyProp.type !== NodeTypes.ATTRIBUTE) {
            keyProperty.value = processExpression(
              keyProperty.value ,
              context
            )
          }
        }
  
        <span class="org-keyword">const</span> <span class=
"org-variable-name">isStableFragment</span> =
          forNode.source.type === NodeTypes.SIMPLE_EXPRESSION &amp;&
          forNode.source.constType &gt; ConstantTypes.NOT_CONSTANT
        <span class="org-keyword">const</span> <span class=
"org-variable-name">fragmentFlag</span> = isStableFragment
          ? PatchFlags.STABLE_FRAGMENT
          : keyProp
          ? PatchFlags.KEYED_FRAGMENT
          : PatchFlags.UNKEYED_FRAGMENT
  
        forNode.codegenNode = createVNodeCall(
          context,
          helper(FRAGMENT),
          <span class="org-constant">undefined</span>,
          renderExp,
          fragmentFlag +
            (__DEV__ ? <span class=
"org-string">` /* ${PatchFlagNames[fragmentFlag]} */`</span> : <span class="org-string">``</span>),
          <span class="org-constant">undefined</span>,
          <span class="org-constant">undefined</span>,
          <span class="org-constant">true</span> <span class=
"org-comment-delimiter">/* </span><span class=
"org-comment">isBlock</span><span class=
"org-comment-delimiter"> */</span>,
          !isStableFragment <span class=
"org-comment-delimiter">/* </span><span class=
"org-comment">disableTracking</span><span class=
"org-comment-delimiter"> */</span>,
          <span class="org-constant">false</span> <span class=
"org-comment-delimiter">/* </span><span class=
"org-comment">isComponent</span><span class=
"org-comment-delimiter"> */</span>,
          node.loc
        )
  
        <span class="org-keyword">return</span> () =&gt; {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">finish the codegen now that all children have been traversed</span>
          <span class="org-keyword">let</span> <span class=
"org-variable-name">childBlock</span>
          <span class=
"org-keyword">const</span> { children } = forNode
  
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">check &lt;template v-for&gt; key placement</span>
          <span class=
"org-keyword">if</span> ((__DEV__ || !__BROWSER__) &amp;& isTemplate) {
            node.children.some(c =&gt; {
              <span class=
"org-keyword">if</span> (c.type === NodeTypes.ELEMENT) {
                <span class="org-keyword">const</span> <span class=
"org-variable-name">key</span> = findProp(c, <span class=
"org-string">'key'</span>)
                <span class="org-keyword">if</span> (key) {
                  logg(<span class=
"org-string">`transformFor - key on template`</span>)
                  <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
                }
              }
            })
          }
  
          <span class="org-keyword">const</span> <span class=
"org-variable-name">needFragmentWrapper</span> =
            children.length !== <span class=
"org-highlight-numbers-number">1</span> || children[<span class=
"org-highlight-numbers-number">0</span>].type !== NodeTypes.ELEMENT
          <span class="org-keyword">const</span> <span class=
"org-variable-name">slotOutlet</span> = isSlotOutlet(node)
            ? node
            : isTemplate &amp;&
              node.children.length === <span class=
"org-highlight-numbers-number">1</span> &amp;&
              isSlotOutlet(node.children[<span class=
"org-highlight-numbers-number">0</span>])
            ? node.children[<span class=
"org-highlight-numbers-number">0</span>] <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">api-extractor somehow fails to infer this</span>
            : <span class="org-constant">null</span>
  
          <span class="org-keyword">if</span> (slotOutlet) {
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">&lt;slot v-for="..."&gt; or &lt;template v-for="..."&gt;&lt;slot/&gt;&lt;/template&gt;</span>
            childBlock = slotOutlet.codegenNode
            <span class=
"org-keyword">if</span> (isTemplate &amp;& keyProperty) {
              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">&lt;template v-for="..." :key="..."&gt;&lt;slot/&gt;&lt;/template&gt;</span>
              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">we need to inject the key to the renderSlot() call.</span>
              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">the props for renderSlot is passed as the 3rd argument.</span>
              injectProp(childBlock, keyProperty, context)
            }
          } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (needFragmentWrapper) {
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">&lt;template v-for="..."&gt; with text or multi-elements</span>
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">should generate a fragment block for each loop</span>
            childBlock = createVNodeCall(
              context,
              helper(FRAGMENT),
              keyProperty ? createObjectExpression([keyProperty]) : <span class="org-constant">undefined</span>,
              node.children,
              PatchFlags.STABLE_FRAGMENT +
                (__DEV__
                  ? <span class=
"org-string">` /* ${PatchFlagNames[PatchFlags.STABLE_FRAGMENT]} */`</span>
                  : <span class="org-string">``</span>),
              <span class="org-constant">undefined</span>,
              <span class="org-constant">undefined</span>,
              <span class="org-constant">true</span>,
              <span class="org-constant">undefined</span>,
              <span class="org-constant">false</span> <span class=
"org-comment-delimiter">/* </span><span class=
"org-comment">isComponent</span><span class=
"org-comment-delimiter"> */</span>
            )
          } <span class="org-keyword">else</span> {
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">Normal element v-for. Directly use the child's codegenNode</span>
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">but mark it as a block.</span>
            childBlock = children[<span class=
"org-highlight-numbers-number">0</span>].codegenNode
            <span class=
"org-keyword">if</span> (isTemplate &amp;& keyProperty) {
              injectProp(childBlock, keyProperty, context)
            }
            <span class=
"org-keyword">if</span> (childBlock.isBlock !== !isStableFragment) {
              <span class=
"org-keyword">if</span> (childBlock.isBlock) {
                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">switch from block to vnode</span>
                removeHelper(OPEN_BLOCK)
                removeHelper(
                  getVNodeBlockHelper(context.inSSR, childBlock.isComponent)
                )
              } <span class="org-keyword">else</span> {
                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">switch from vnode to block</span>
                removeHelper(
                  getVNodeHelper(context.inSSR, childBlock.isComponent)
                )
              }
            }
            childBlock.isBlock = !isStableFragment
            <span class=
"org-keyword">if</span> (childBlock.isBlock) {
              helper(OPEN_BLOCK)
              helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent))
            } <span class="org-keyword">else</span> {
              helper(getVNodeHelper(context.inSSR, childBlock.isComponent))
            }
          }
  
          <span class="org-keyword">if</span> (memo) {
            <span class="org-keyword">const</span> <span class=
"org-variable-name">loop</span> = createFunctionExpression(
              createForLoopParams(forNode.parseResult, [
                createSimpleExpression(<span class=
"org-string">`_cached`</span>)
              ])
            )
            loop.body = createBlockStatement([
              createCompoundExpression([<span class=
"org-string">`const _memo = (`</span>, memo.exp, <span class=
"org-string">`)`</span>]),
              createCompoundExpression([
                <span class="org-string">`if (_cached`</span>,
                ...(keyExp ? [<span class=
"org-string">` &amp;& _cached.key === `</span>, keyExp] : []),
                <span class=
"org-string">` &amp;& ${context.helperString(</span>
<span class="org-string">                  IS_MEMO_SAME</span>
<span class=
"org-string">                )}(_cached, _memo)) return _cached`</span>
              ]),
              createCompoundExpression([<span class=
"org-string">`const _item = `</span>, childBlock]),
              createSimpleExpression(<span class=
"org-string">`_item.memo = _memo`</span>),
              createSimpleExpression(<span class=
"org-string">`return _item`</span>)
            ])
            renderExp.<span class=
"org-constant">arguments</span>.push(
              loop,
              createSimpleExpression(<span class=
"org-string">`_cache`</span>),
              createSimpleExpression(String(context.cached++))
            )
          } <span class="org-keyword">else</span> {
            renderExp.<span class=
"org-constant">arguments</span>.push(
              createFunctionExpression(
                createForLoopParams(forNode.parseResult),
                childBlock,
                <span class="org-constant">true</span> <span class=
"org-comment-delimiter">/* </span><span class=
"org-comment">force newline</span><span class=
"org-comment-delimiter"> */</span>
              )
            )
          }
        }
      })
    }
  )
  
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">target-agnostic transform used for both Client and SSR</span>
  <span class="org-keyword">function</span> <span class=
"org-function-name">processFor</span>(
    <span class="org-variable-name">node</span>,
    <span class="org-variable-name">dir</span>,
    <span class="org-variable-name">context</span>,
    processCodegen
  ) {
    <span class="org-keyword">if</span> (!dir.exp) {
      logg(<span class=
"org-string">`processFor - dir.exp is null`</span>)
      <span class="org-keyword">return</span>
    }
  
    <span class="org-keyword">const</span> <span class=
"org-variable-name">parseResult</span> = parseForExpression(
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">can only be simple expression because vFor transform is applied</span>
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">before expression transform.</span>
      dir.exp,
      context
    )
  
    <span class="org-keyword">if</span> (!parseResult) {
      logg(<span class=
"org-string">`processFor - parseResult is null`</span>)
      <span class="org-keyword">return</span>
    }
  
    <span class=
"org-keyword">const</span> { addIdentifiers, removeIdentifiers, scopes } = context
    <span class=
"org-keyword">const</span> { source, value, key, index } = parseResult
  
    <span class="org-keyword">const</span> <span class=
"org-variable-name">forNode</span> = {
      type: NodeTypes.FOR,
      loc: dir.loc,
      source,
      valueAlias: value,
      keyAlias: key,
      objectIndexAlias: index,
      parseResult,
      children: isTemplateNode(node) ? node.children : [node]
    }
  
    context.replaceNode(forNode)
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">bookkeeping</span>
    scopes.vFor++
    <span class=
"org-keyword">if</span> (!__BROWSER__ &amp;& context.prefixIdentifiers) {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">scope management</span>
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">inject identifiers to context</span>
      value &amp;& addIdentifiers(value)
      key &amp;& addIdentifiers(key)
      index &amp;& addIdentifiers(index)
    }
  
    <span class="org-keyword">const</span> <span class=
"org-variable-name">onExit</span> = processCodegen &amp;& processCodegen(forNode)
  
    <span class="org-keyword">return</span> () =&gt; {
      scopes.vFor--
      <span class=
"org-keyword">if</span> (!__BROWSER__ &amp;& context.prefixIdentifiers) {
        value &amp;& removeIdentifiers(value)
        key &amp;& removeIdentifiers(key)
        index &amp;& removeIdentifiers(index)
      }
      <span class="org-keyword">if</span> (onExit) onExit()
    }
  }
  
  <span class="org-keyword">const</span> <span class=
"org-variable-name">forAliasRE</span> = <span class=
"org-string">/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">This regex doesn't cover the case if key or index aliases have destructuring,</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">but those do not make sense in the first place, so this works in practice.</span>
  <span class="org-keyword">const</span> <span class=
"org-variable-name">forIteratorRE</span> = <span class=
"org-string">/,([^,\}\]]*)(?:,([^,\}\]]*))?$/</span>
  <span class="org-keyword">const</span> <span class=
"org-variable-name">stripParensRE</span> = <span class=
"org-string">/^\(|\)$/</span>g
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">parseForExpression</span>(
    <span class="org-variable-name">input</span>,
    context
  ) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">loc</span> = input.loc
    <span class="org-keyword">const</span> <span class=
"org-variable-name">exp</span> = input.content
    <span class="org-keyword">const</span> <span class=
"org-variable-name">inMatch</span> = exp.match(forAliasRE)
    <span class="org-keyword">if</span> (!inMatch) <span class=
"org-keyword">return</span>
  
    <span class="org-keyword">const</span> [, <span class=
"org-variable-name">LHS</span>, <span class=
"org-variable-name">RHS</span>] = inMatch
  
    <span class="org-keyword">const</span> <span class=
"org-variable-name">result</span> = {
      source: createAliasExpression(
        loc,
        RHS.trim(),
        exp.indexOf(RHS, LHS.length)
      ),
      value: <span class="org-constant">undefined</span>,
      key: <span class="org-constant">undefined</span>,
      index: <span class="org-constant">undefined</span>
    }
    <span class=
"org-keyword">if</span> (!__BROWSER__ &amp;& context.prefixIdentifiers) {
      result.source = processExpression(
        result.source,
        context
      )
    }
  
    <span class="org-keyword">let</span> <span class=
"org-variable-name">valueContent</span> = LHS.trim().replace(stripParensRE, <span class="org-string">''</span>).trim()
    <span class="org-keyword">const</span> <span class=
"org-variable-name">trimmedOffset</span> = LHS.indexOf(valueContent)
  
    <span class="org-keyword">const</span> <span class=
"org-variable-name">iteratorMatch</span> = valueContent.match(forIteratorRE)
    <span class="org-keyword">if</span> (iteratorMatch) {
      valueContent = valueContent.replace(forIteratorRE, <span class="org-string">''</span>).trim()
  
      <span class="org-keyword">const</span> <span class=
"org-variable-name">keyContent</span> = iteratorMatch[<span class=
"org-highlight-numbers-number">1</span>].trim()
      <span class="org-keyword">let</span> <span class=
"org-variable-name">keyOffset</span>
      <span class="org-keyword">if</span> (keyContent) {
        keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length)
        result.key = createAliasExpression(loc, keyContent, keyOffset)
        <span class=
"org-keyword">if</span> (!__BROWSER__ &amp;& context.prefixIdentifiers) {
          result.key = processExpression(result.key, context, <span class="org-constant">true</span>)
        }
      }
  
      <span class=
"org-keyword">if</span> (iteratorMatch[<span class=
"org-highlight-numbers-number">2</span>]) {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">indexContent</span> = iteratorMatch[<span class="org-highlight-numbers-number">2</span>].trim()
  
        <span class="org-keyword">if</span> (indexContent) {
          result.index = createAliasExpression(
            loc,
            indexContent,
            exp.indexOf(
              indexContent,
              result.key
                ? keyOffset + keyContent.length
                : trimmedOffset + valueContent.length
            )
          )
          <span class=
"org-keyword">if</span> (!__BROWSER__ &amp;& context.prefixIdentifiers) {
            result.index = processExpression(result.index, context, <span class="org-constant">true</span>)
          }
        }
      }
    }
  
    <span class="org-keyword">if</span> (valueContent) {
      result.value = createAliasExpression(loc, valueContent, trimmedOffset)
      <span class=
"org-keyword">if</span> (!__BROWSER__ &amp;& context.prefixIdentifiers) {
        result.value = processExpression(result.value, context, <span class="org-constant">true</span>)
      }
    }
  
    <span class="org-keyword">return</span> result
  }
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">createAliasExpression</span>(
    <span class="org-variable-name">range</span>,
    <span class="org-variable-name">content</span>,
    offset
  ) {
    <span class="org-keyword">return</span> createSimpleExpression(
      content,
      <span class="org-constant">false</span>,
      getInnerRange(range, offset, content.length)
    )
  }
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">createForLoopParams</span>(
    { value, key, index },
    memoArgs = []
  ) {
    <span class=
"org-keyword">return</span> createParamsList([value, key, index, ...memoArgs])
  }
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">createParamsList</span>(<span class=
"org-variable-name">args</span>) {
    <span class="org-keyword">let</span> <span class=
"org-variable-name">i</span> = args.length
    <span class="org-keyword">while</span> (i--) {
      <span class="org-keyword">if</span> (args[i]) <span class=
"org-keyword">break</span>
    }
    <span class="org-keyword">return</span> args
      .slice(<span class=
"org-highlight-numbers-number">0</span>, i + <span class=
"org-highlight-numbers-number">1</span>)
      .map((arg, i) =&gt; arg || createSimpleExpression(<span class="org-string">`_`</span>.repeat(i + <span class="org-highlight-numbers-number">1</span>), <span class="org-constant">false</span>))
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">processIf</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">dir</span>, <span class=
"org-variable-name">context</span>, <span class=
"org-variable-name">processCodegen</span>) {
    logg(<span class=
"org-string">'processIf - node - dir'</span>, node, dir)
    <span class="org-keyword">if</span> (
      dir.name !== <span class="org-string">'else'</span> &amp;&
      (!dir.exp || !dir.exp.content.trim())
    ) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">loc</span> = dir.exp ? dir.exp.loc : node.loc
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">&lt;div v-if&gt;&lt;/div&gt; 没有指令值的情况，默认值为 true</span>
      dir.exp = createSimpleExpression(<span class=
"org-string">`true`</span>, <span class=
"org-constant">false</span>, loc)
    }
  
    <span class=
"org-keyword">if</span> (!__BROWSER__ &amp;& context.prefixIdentifiers &amp;& dir.exp) {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">dir.exp can only be simple expression because vIf transform is applied</span>
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">before expression transform.</span>
      dir.exp = processExpression(dir.exp, context)
    }
  
    <span class="org-keyword">if</span> (dir.name === <span class=
"org-string">'if'</span>) { <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">v-if</span>
      <span class="org-keyword">const</span> <span class=
"org-variable-name">branch</span> = createIfBranch(node, dir)
      <span class="org-keyword">const</span> <span class=
"org-variable-name">ifNode</span> = {
        type: NodeTypes.IF,
        loc: node.loc,
        branches: [branch]
      }
      context.replaceNode(ifNode)
      <span class="org-keyword">if</span> (processCodegen) {
        <span class=
"org-keyword">return</span> processCodegen(ifNode, branch, <span class="org-constant">true</span>)
      }
    } <span class="org-keyword">else</span> {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">locate the adjacent v-if</span>
      <span class="org-keyword">const</span> <span class=
"org-variable-name">siblings</span> = context.parent.children
      <span class="org-keyword">const</span> <span class=
"org-variable-name">comments</span> = []
      <span class="org-keyword">let</span> <span class=
"org-variable-name">i</span> = siblings.indexOf(node)
      <span class=
"org-keyword">while</span> (i-- &gt;= -<span class=
"org-highlight-numbers-number">1</span>) {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">sibling</span> = siblings[i]
  
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">空行，空文本</span>
        <span class="org-keyword">if</span> (
          sibling &amp;&
          sibling.type === NodeTypes.TEXT &amp;&
          !sibling.content.trim().length
        ) {
          context.removeNode(sibling)
          <span class="org-keyword">continue</span>
        }
  
        <span class=
"org-keyword">if</span> (sibling &amp;& sibling.type === NodeTypes.IF) {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">这里会将原本的结点删除，而是用新组装的 if 结构(包含else-if, else 分支的结构，node.branches[...])</span>
          context.removeNode()
          <span class="org-keyword">const</span> <span class=
"org-variable-name">branch</span> = createIfBranch(node, dir)
          sibling.branches.push(branch)
  
          <span class="org-keyword">const</span> <span class=
"org-variable-name">onExit</span> = processCodegen &amp;& processCodegen(sibling, branch, <span class="org-constant">false</span>)
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">这里需要手动触发一次遍历，因为上面将原本的分支节点从原来的节点树中删除了</span>
          traverseNode(branch, context)
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">回溯结束后执行收集到的 transformXxx 函数</span>
          <span class="org-keyword">if</span> (onExit) onExit()
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">make sure to reset currentNode after traversal to indicate this</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">node has been removed.</span>
          context.currentNode = <span class=
"org-constant">null</span>
        }
        <span class="org-keyword">break</span>
      }
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">createIfBranch</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">dir</span>) {
    <span class="org-keyword">return</span> {
      type: NodeTypes.IF_BRANCH,
      loc: node.loc,
      condition: dir.name === <span class=
"org-string">'else'</span> ? <span class=
"org-constant">undefined</span> : dir.exp,
      children:
        node.tagType === ElementTypes.TEMPLATE &amp;& !findDir(node, <span class="org-string">'for'</span>)
          ? node.children
          : [node],
      userKey: findProp(node, <span class=
"org-string">`key`</span>)
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">createCodegenNodeForBranch</span>(<span class=
"org-variable-name">branch</span>, <span class=
"org-variable-name">keyIndex</span>, <span class=
"org-variable-name">context</span>) {
    <span class="org-keyword">if</span> (branch.condition) {
      <span class=
"org-keyword">return</span> createConditionalExpression(
        branch.condition,
        createChildrenCodegenNode(branch, keyIndex, context),
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">这里是考虑到只有 v-if 的情况，因为 v-if 指令最后都会被解析成三目运算符形式</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">如： &lt;div v-if="foo"/&gt;&lt;div v-else/&gt; =&gt; foo ? ... : ...</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">如： &lt;div v-if="foo"/&gt;&lt;div v-else-if="bar"/&gt;&lt;div v-else/&gt; =&gt; foo ? ... : bar ? ... : ...</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">所以必需得要有一个 v-else，如果没有的话就相当于是 `foo ? ...` 这样的语句是不合法的</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">因此这里在判断没有 v-else 分支的情况时默认给它创建了个注释节点</span>
        createCallExpression(context.helper(CREATE_COMMENT), [
          __DEV__ ? <span class=
"org-string">'"v-if"'</span> : <span class=
"org-string">'""'</span>,
          <span class="org-string">'true'</span>
        ])
      )
    } <span class="org-keyword">else</span> {
      <span class=
"org-keyword">return</span> createChildrenCodegenNode(branch, keyIndex, context)
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">createChildrenCodegenNode</span>(<span class=
"org-variable-name">branch</span>, <span class=
"org-variable-name">keyIndex</span>, <span class=
"org-variable-name">context</span>) {
    <span class="org-keyword">const</span> { helper } = context
    <span class="org-keyword">const</span> <span class=
"org-variable-name">keyProperty</span> = createObjectProperty(
      <span class="org-string">`key`</span>,
      createSimpleExpression(
        <span class="org-string">`${keyIndex}`</span>,
        <span class="org-constant">false</span>,
        locStub,
        ConstantTypes.CAN_HOIST
      )
    )
    <span class="org-keyword">const</span> { children } = branch
    <span class="org-keyword">const</span> <span class=
"org-variable-name">firstChild</span> = children[<span class=
"org-highlight-numbers-number">0</span>]
    <span class="org-keyword">const</span> <span class=
"org-variable-name">needFragmentWrapper</span> =
      children.length !== <span class=
"org-highlight-numbers-number">1</span> || firstChild.type !== NodeTypes.ELEMENT
    <span class="org-keyword">if</span> (needFragmentWrapper) {
      <span class=
"org-keyword">if</span> (children.length === <span class=
"org-highlight-numbers-number">1</span> &amp;& firstChild.type === NodeTypes.FOR) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">optimize away nested fragments when child is a ForNode</span>
        <span class="org-keyword">const</span> <span class=
"org-variable-name">vnodeCall</span> = firstChild.codegenNode
        injectProp(vnodeCall, keyProperty, context)
        <span class="org-keyword">return</span> vnodeCall
      } <span class="org-keyword">else</span> {
        <span class="org-keyword">let</span> <span class=
"org-variable-name">patchFlag</span> = PatchFlags.STABLE_FRAGMENT
        <span class="org-keyword">let</span> <span class=
"org-variable-name">patchFlagText</span> = PatchFlagNames[PatchFlags.STABLE_FRAGMENT]
  
        <span class="org-keyword">return</span> createVNodeCall(
          context,
          helper(FRAGMENT),
          createObjectExpression([keyProperty]),
          children,
          patchFlag + (__DEV__ ? <span class=
"org-string">` /* ${patchFlagText} */`</span> : <span class=
"org-string">``</span>),
          <span class="org-constant">undefined</span>,
          <span class="org-constant">undefined</span>,
          <span class="org-constant">true</span>,
          <span class="org-constant">false</span>,
          <span class="org-constant">false</span> <span class=
"org-comment-delimiter">/* </span><span class=
"org-comment">isComponent</span><span class=
"org-comment-delimiter"> */</span>,
          branch.loc
        )
      }
    } <span class="org-keyword">else</span> {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">ret</span> = firstChild.codegenNode
      <span class="org-keyword">const</span> <span class=
"org-variable-name">vnodeCall</span> = getMemoedVNodeCall(ret)
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">Change createVNode to createBlock.</span>
      <span class=
"org-keyword">if</span> (vnodeCall.type === NodeTypes.VNODE_CALL) {
        makeBlock(vnodeCall, context)
      }
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">inject branch key</span>
      injectProp(vnodeCall, keyProperty, context)
      <span class="org-keyword">return</span> ret
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">isSameKey</span>(<span class=
"org-variable-name">a</span>, <span class=
"org-variable-name">b</span>) {
    <span class="org-keyword">if</span> (!a || a.type !== b.type) {
      <span class="org-keyword">return</span> <span class=
"org-constant">false</span>
    }
    <span class=
"org-keyword">if</span> (a.type === NodeTypes.ATTRIBUTE) {
      <span class=
"org-keyword">if</span> (a.value.content !== b.value.content) {
        <span class="org-keyword">return</span> <span class=
"org-constant">false</span>
      }
    } <span class="org-keyword">else</span> {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">directive</span>
      <span class="org-keyword">const</span> <span class=
"org-variable-name">exp</span> = a.exp
      <span class="org-keyword">const</span> <span class=
"org-variable-name">branchExp</span> = b.exp
      <span class=
"org-keyword">if</span> (exp.type !== branchExp.type) {
        <span class="org-keyword">return</span> <span class=
"org-constant">false</span>
      }
      <span class="org-keyword">if</span> (
        exp.type !== NodeTypes.SIMPLE_EXPRESSION ||
        exp.isStatic !== branchExp.isStatic ||
        exp.content !== branchExp.content
      ) {
        <span class="org-keyword">return</span> <span class=
"org-constant">false</span>
      }
    }
    <span class="org-keyword">return</span> <span class=
"org-constant">true</span>
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">getParentCondition</span>(<span class=
"org-variable-name">node</span>) {
    <span class="org-keyword">while</span> (<span class=
"org-constant">true</span>) {
      <span class=
"org-keyword">if</span> (node.type === NodeTypes.JS_CONDITIONAL_EXPRESSION) {
        <span class=
"org-keyword">if</span> (node.alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION) {
          node = node.alternate
        } <span class="org-keyword">else</span> {
          <span class="org-keyword">return</span> node
        }
      } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (node.type === NodeTypes.JS_CACHE_EXPRESSION) {
        node = node.value
      }
    }
  }
  
  
  <span class="org-keyword">const</span> <span class=
"org-variable-name">transformIf</span> = createStructuralDirectiveTransform(
    <span class="org-string">/^(if|else|else-if)$/</span>,
    (node, dir, context) =&gt; {
      <span class=
"org-keyword">return</span> processIf(node, dir, context, (ifNode, branch, isRoot) =&gt; {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">siblings</span> = context.parent.children
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">if...else if...else 都处于同级渲染</span>
        <span class="org-keyword">let</span> <span class=
"org-variable-name">i</span> = siblings.indexOf(ifNode)
        <span class="org-keyword">let</span> <span class=
"org-variable-name">key</span> = <span class=
"org-highlight-numbers-number">0</span>
        <span class=
"org-keyword">while</span> (i-- &gt;= <span class=
"org-highlight-numbers-number">0</span>) {
          <span class="org-keyword">const</span> <span class=
"org-variable-name">sibling</span> = siblings[i]
          <span class=
"org-keyword">if</span> (sibling &amp;& sibling.type === NodeTypes.IF) {
            key += sibling.branches.length
          }
        }
  
        logg(<span class=
"org-string">'transformIf'</span>, ifNode, { isRoot, branch })
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">退出时的回调，当所有 children 被遍历转换完成时被调用生成 codegenNode</span>
        <span class="org-keyword">return</span> () =&gt; {
          <span class=
"org-keyword">if</span> (isRoot) { <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">v-if</span>
            ifNode.codegenNode = createCodegenNodeForBranch(
              branch, key, context
            )
            logg(<span class=
"org-string">'transformIf - isRoot - v-if'</span>, ifNode)
          } <span class="org-keyword">else</span> { <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">v-else, v-else-if</span>
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">将 v-else-* 分枝挂到 v-if 节点下面</span>
            <span class="org-keyword">const</span> <span class=
"org-variable-name">parentCondition</span> = getParentCondition(ifNode.codegenNode)
            parentCondition.alternate = createCodegenNodeForBranch(
              branch, key + ifNode.branches.length - <span class=
"org-highlight-numbers-number">1</span>,
              context
            )
            logg(<span class=
"org-string">'transformIf - v-else-*'</span>, ifNode)
          }
        }
  
      })
    }
  )
  <span class="org-keyword">const</span> <span class=
"org-variable-name">memoSeen</span> = <span class=
"org-keyword">new</span> <span class="org-type">WeakSet</span>()
  
  <span class="org-keyword">const</span> <span class=
"org-variable-name">transformMemo</span> = (node, context) =&gt; {
    <span class=
"org-keyword">if</span> (node.type === NodeTypes.ELEMENT) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">dir</span> = findDir(node, <span class=
"org-string">'memo'</span>)
      <span class=
"org-keyword">if</span> (!dir || memoSeen.has(node)) {
        <span class="org-keyword">return</span>
      }
      memoSeen.add(node)
      <span class="org-keyword">return</span> () =&gt; {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">codegenNode</span> = node.codegenNode || context.currentNode.codegenNode
        <span class=
"org-keyword">if</span> (codegenNode &amp;& codegenNode.type === NodeTypes.VNODE_CALL) {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">non-component sub tree should be turned into a block</span>
          <span class=
"org-keyword">if</span> (node.tagType !== ElementTypes.COMPONENT) {
            makeBlock(codegenNode, context)
          }
          node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
            dir.exp,
            createFunctionExpression(<span class=
"org-constant">undefined</span>, codegenNode),
            <span class="org-string">`_cache`</span>,
            String(context.cached++)
          ])
        }
      }
    }
  }
  <span class="org-keyword">const</span> <span class=
"org-variable-name">transformModel</span> = (dir, node, context) =&gt; {
    <span class="org-keyword">const</span> { exp, arg } = dir
    <span class="org-keyword">if</span> (!exp) {
      logg(<span class="org-string">`transformModel no exp`</span>)
      <span class=
"org-keyword">return</span> createTransformProps()
    }
  
    <span class="org-keyword">const</span> <span class=
"org-variable-name">rawExp</span> = exp.loc.source
    <span class="org-keyword">const</span> <span class=
"org-variable-name">expString</span> =
      exp.type === NodeTypes.SIMPLE_EXPRESSION ? exp.content : rawExp
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">im SFC &lt;script setup&gt; inline mode, the exp may have been transformed into</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">_unref(exp)</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">bindingType</span> = context.bindingMetadata[rawExp]
    <span class="org-keyword">const</span> <span class=
"org-variable-name">maybeRef</span> =
      !__BROWSER__ &amp;&
      context.inline &amp;&
      bindingType &amp;&
      bindingType !== BindingTypes.SETUP_CONST
  
    <span class="org-keyword">if</span> (
      !expString.trim() ||
      (!isMemberExpression(expString, context) &amp;& !maybeRef)
    ) {
      <span class=
"org-keyword">return</span> createTransformProps()
    }
  
    <span class="org-keyword">if</span> (
      !__BROWSER__ &amp;&
      context.prefixIdentifiers &amp;&
      isSimpleIdentifier(expString) &amp;&
      context.identifiers[expString]
    ) {
      <span class=
"org-keyword">return</span> createTransformProps()
    }
  
    <span class="org-keyword">const</span> <span class=
"org-variable-name">propName</span> = arg ? arg : createSimpleExpression(<span class="org-string">'modelValue'</span>, <span class="org-constant">true</span>)
    <span class="org-keyword">const</span> <span class=
"org-variable-name">eventName</span> = arg
      ? isStaticExp(arg)
        ? <span class="org-string">`onUpdate:${arg.content}`</span>
        : createCompoundExpression([<span class=
"org-string">'"onUpdate:" + '</span>, arg])
      : <span class="org-string">`onUpdate:modelValue`</span>
  
    <span class="org-keyword">let</span> <span class=
"org-variable-name">assignmentExp</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">eventArg</span> = context.isTS ? <span class=
"org-string">`($event: any)`</span> : <span class=
"org-string">`$event`</span>
    <span class="org-keyword">if</span> (maybeRef) {
      <span class=
"org-keyword">if</span> (bindingType === BindingTypes.SETUP_REF) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">v-model used on known ref.</span>
        assignmentExp = createCompoundExpression([
          <span class="org-string">`${eventArg} =&gt; ((`</span>,
          createSimpleExpression(rawExp, <span class=
"org-constant">false</span>, exp.loc),
          <span class="org-string">`).value = $event)`</span>
        ])
      } <span class="org-keyword">else</span> {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">v-model used on a potentially ref binding in &lt;script setup&gt; inline mode.</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">the assignment needs to check whether the binding is actually a ref.</span>
        <span class="org-keyword">const</span> <span class=
"org-variable-name">altAssignment</span> =
          bindingType === BindingTypes.SETUP_LET ? <span class=
"org-string">`${rawExp} = $event`</span> : <span class=
"org-string">`null`</span>
        assignmentExp = createCompoundExpression([
          <span class=
"org-string">`${eventArg} =&gt; (${context.helperString(IS_REF)}(${rawExp}) ? (`</span>,
          createSimpleExpression(rawExp, <span class=
"org-constant">false</span>, exp.loc),
          <span class=
"org-string">`).value = $event : ${altAssignment})`</span>
        ])
      }
    } <span class="org-keyword">else</span> {
      assignmentExp = createCompoundExpression([
        <span class="org-string">`${eventArg} =&gt; ((`</span>,
        exp,
        <span class="org-string">`) = $event)`</span>
      ])
    }
  
    <span class="org-keyword">const</span> <span class=
"org-variable-name">props</span> = [
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">modelValue: foo</span>
      createObjectProperty(propName, dir.exp),
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">"onUpdate:modelValue": $event =&gt; (foo = $event)</span>
      createObjectProperty(eventName, assignmentExp)
    ]
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">cache v-model handler if applicable (when it doesn't refer any scope vars)</span>
    <span class="org-keyword">if</span> (
      !__BROWSER__ &amp;&
      context.prefixIdentifiers &amp;&
      !context.inVOnce &amp;&
      context.cacheHandlers &amp;&
      !hasScopeRef(exp, context.identifiers)
    ) {
      props[<span class=
"org-highlight-numbers-number">1</span>].value = context.cache(props[<span class="org-highlight-numbers-number">1</span>].value)
    }
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">modelModifiers: { foo: true, "bar-baz": true }</span>
    <span class=
"org-keyword">if</span> (dir.modifiers.length &amp;& node.tagType === ElementTypes.COMPONENT) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">modifiers</span> = dir.modifiers
        .map(m =&gt; (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + <span class="org-string">`: true`</span>)
        .join(<span class="org-string">`, `</span>)
      <span class="org-keyword">const</span> <span class=
"org-variable-name">modifiersKey</span> = arg
        ? isStaticExp(arg)
          ? <span class=
"org-string">`${arg.content}Modifiers`</span>
          : createCompoundExpression([arg, <span class=
"org-string">' + "Modifiers"'</span>])
        : <span class="org-string">`modelModifiers`</span>
      props.push(
        createObjectProperty(
          modifiersKey,
          createSimpleExpression(
            <span class="org-string">`{ ${modifiers} }`</span>,
            <span class="org-constant">false</span>,
            dir.loc,
            ConstantTypes.CAN_HOIST
          )
        )
      )
    }
  
    <span class=
"org-keyword">return</span> createTransformProps(props)
  }
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">createTransformProps</span>(<span class=
"org-variable-name">props</span> = []) {
    <span class="org-keyword">return</span> { props }
  }
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">函数表达式正则, @click="fnExp"</span>
  <span class="org-keyword">const</span> <span class=
"org-variable-name">fnExpRE</span> =
    <span class=
"org-string">/^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*=&gt;|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/</span>
  
  <span class="org-keyword">const</span> <span class=
"org-variable-name">transformOn</span> = (
    dir,
    node,
    context,
    augmentor
  ) =&gt; {
    <span class=
"org-keyword">const</span> { loc, modifiers, arg } = dir
  
    <span class="org-keyword">let</span> <span class=
"org-variable-name">eventName</span>
    <span class=
"org-keyword">if</span> (arg.type === NodeTypes.SIMPLE_EXPRESSION) {
      <span class="org-keyword">if</span> (arg.isStatic) {
        <span class="org-keyword">let</span> <span class=
"org-variable-name">rawName</span> = arg.content
  
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">将事件名转成驼峰式</span>
        eventName = createSimpleExpression(
          toHandlerKey(camelize(rawName)),
          <span class="org-constant">true</span>,
          arg.loc
        )
      } <span class="org-keyword">else</span> {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">#2388 toHandlerKey 将事件名转成 onXxx, 如：eventName -&gt; onEventName</span>
        eventName = createCompoundExpression([
          <span class=
"org-string">`${context.helperString(TO_HANDLER_KEY)}(`</span>,
          arg,
          <span class="org-string">`)`</span>
        ])
      }
    } <span class="org-keyword">else</span> {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">already a compound expression.</span>
  
      eventName = arg
      eventName.children.unshift(<span class=
"org-string">`${context.helperString(TO_HANDLER_KEY)}(`</span>)
      eventName.children.push(<span class="org-string">`)`</span>)
    }
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">handler processing, 事件表达式内容</span>
    <span class="org-keyword">let</span> <span class=
"org-variable-name">exp</span> = dir.exp
    <span class=
"org-keyword">if</span> (exp &amp;& !exp.content.trim()) {
      exp = <span class="org-constant">undefined</span>
    }
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">事件处理函数缓存</span>
    <span class="org-keyword">let</span> <span class=
"org-variable-name">shouldCache</span> = context.cacheHandlers &amp;& !exp &amp;& !context.inVOnce
    <span class="org-keyword">if</span> (exp) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">isMemberExp</span> = isMemberExpression(exp.content, context)
      <span class="org-keyword">const</span> <span class=
"org-variable-name">isInlineStatement</span> = !(isMemberExp || fnExpRE.test(exp.content))
      <span class="org-keyword">const</span> <span class=
"org-variable-name">hasMultipleStatements</span> = exp.content.includes(<span class="org-string">`;`</span>)
  
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">process the expression since it's been skipped</span>
      <span class=
"org-keyword">if</span> (!__BROWSER__ &amp;& context.prefixIdentifiers) {
        isInlineStatement &amp;& context.addIdentifiers(<span class="org-string">`$event`</span>)
        exp = dir.exp = processExpression(
          exp,
          context,
          <span class="org-constant">false</span>,
          hasMultipleStatements
        )
        isInlineStatement &amp;& context.removeIdentifiers(<span class="org-string">`$event`</span>)
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">with scope analysis, the function is hoistable if it has no reference</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">to scope variables.</span>
        shouldCache =
          context.cacheHandlers &amp;&
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">unnecessary to cache inside v-once</span>
          !context.inVOnce &amp;&
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">runtime constants don't need to be cached</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">(this is analyzed by compileScript in SFC &lt;script setup&gt;)</span>
          !(exp.type === NodeTypes.SIMPLE_EXPRESSION &amp;& exp.constType &gt; <span class="org-highlight-numbers-number">0</span>) &amp;&
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">#1541 bail if this is a member exp handler passed to a component -</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">we need to use the original function to preserve arity,</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">e.g. &lt;transition&gt; relies on checking cb.length to determine</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">transition end handling. Inline function is ok since its arity</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">is preserved even when cached.</span>
          !(isMemberExp &amp;& node.tagType === ElementTypes.COMPONENT) &amp;&
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">bail if the function references closure variables (v-for, v-slot)</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">it must be passed fresh to avoid stale values.</span>
          !hasScopeRef(exp, context.identifiers)
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">If the expression is optimizable and is a member expression pointing</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">to a function, turn it into invocation (and wrap in an arrow function</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">below) so that it always accesses the latest value when called - thus</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">avoiding the need to be patched.</span>
        <span class=
"org-keyword">if</span> (shouldCache &amp;& isMemberExp) {
          <span class=
"org-keyword">if</span> (exp.type === NodeTypes.SIMPLE_EXPRESSION) {
            exp.content = <span class=
"org-string">`${exp.content} &amp;& ${exp.content}(...args)`</span>
          } <span class="org-keyword">else</span> {
            exp.children = [...exp.children, <span class=
"org-string">` &amp;& `</span>, ...exp.children, <span class=
"org-string">`(...args)`</span>]
          }
        }
      }
  
      <span class=
"org-keyword">if</span> (isInlineStatement || (shouldCache &amp;& isMemberExp)) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">wrap inline statement in a function expression</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">($event) =&gt; statement</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">(...args) =&gt; { statement1;statement2 }</span>
        exp = createCompoundExpression([
          <span class="org-string">`${</span>
<span class="org-string">            isInlineStatement</span>
<span class="org-string">              ? `</span>$event<span class=
"org-string">`</span>
<span class=
"org-string">              : `</span>(...args)<span class=
"org-string">`</span>
<span class=
"org-string">          } =&gt; ${hasMultipleStatements ? `</span>{<span class="org-string">` : `</span>(<span class="org-string">`}`</span>,
          exp,
          hasMultipleStatements ? <span class=
"org-string">`}`</span> : <span class="org-string">`)`</span>
        ])
      }
    }
  
    <span class="org-keyword">let</span> <span class=
"org-variable-name">ret</span> = {
      props: [
        createObjectProperty(
          eventName,
          exp || createSimpleExpression(<span class=
"org-string">`() =&gt; {}`</span>, <span class=
"org-constant">false</span>, loc)
        )
      ]
    }
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">apply extended compiler augmentor</span>
    <span class="org-keyword">if</span> (augmentor) {
      ret = augmentor(ret)
    }
  
    <span class="org-keyword">if</span> (shouldCache) {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">cache handlers so that it's always the same handler being passed down.</span>
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">this avoids unnecessary re-renders when users use inline handlers on</span>
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">components.</span>
      ret.props[<span class=
"org-highlight-numbers-number">0</span>].value = context.cache(ret.props[<span class="org-highlight-numbers-number">0</span>].value)
    }
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">mark the key as handler for props normalization check</span>
    ret.props.forEach(p =&gt; (p.key.isHandlerKey = <span class=
"org-constant">true</span>))
    <span class="org-keyword">return</span> ret
  }
  <span class="org-keyword">const</span> <span class=
"org-variable-name">seen</span> = <span class=
"org-keyword">new</span> <span class="org-type">WeakSet</span>()
  
  <span class="org-keyword">const</span> <span class=
"org-variable-name">transformOnce</span> = (node, context) =&gt; {
    <span class=
"org-keyword">if</span> (node.type === NodeTypes.ELEMENT &amp;& findDir(node, <span class="org-string">'once'</span>, <span class="org-constant">true</span>)) {
      <span class=
"org-keyword">if</span> (seen.has(node) || context.inVOnce) {
        logg(<span class=
"org-string">`transformOnce node has seen`</span>)
        <span class="org-keyword">return</span>
      }
      seen.add(node)
      context.inVOnce = <span class="org-constant">true</span>
      context.helper(SET_BLOCK_TRACKING)
      <span class="org-keyword">return</span> () =&gt; {
        context.inVOnce = <span class="org-constant">false</span>
        <span class="org-keyword">const</span> <span class=
"org-variable-name">cur</span> = context.currentNode
        <span class="org-keyword">if</span> (cur.codegenNode) {
          cur.codegenNode = context.cache(cur.codegenNode, <span class="org-constant">true</span> <span class="org-comment-delimiter">/* </span><span class="org-comment">isVNode</span><span class="org-comment-delimiter"> */</span>)
        }
      }
    }
  }
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">Important: since this function uses Node.js only dependencies, it should</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">always be used with a leading !__BROWSER__ check so that it can be</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">tree-shaken from the browser build.</span>
  <span class="org-keyword">function</span> <span class=
"org-function-name">processExpression</span>(
    <span class="org-variable-name">node</span>,
    <span class="org-variable-name">context</span>,
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">some expressions like v-slot props & v-for aliases should be parsed as</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">function params</span>
    asParams = <span class="org-constant">false</span>,
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">v-on handler values may contain multiple statements</span>
    asRawStatements = <span class="org-constant">false</span>,
    localVars = Object.create(context.identifiers)
  ) {
    <span class="org-keyword">if</span> (__BROWSER__) {
      <span class="org-keyword">return</span> node
    }
  
    <span class=
"org-keyword">if</span> (!context.prefixIdentifiers || !node.content.trim()) {
      <span class="org-keyword">return</span> node
    }
  
    <span class=
"org-keyword">const</span> { inline, bindingMetadata } = context
    <span class="org-keyword">const</span> <span class=
"org-variable-name">rewriteIdentifier</span> = (raw, parent, id) =&gt; {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">type</span> = hasOwn(bindingMetadata, raw) &amp;& bindingMetadata[raw]
      <span class="org-keyword">if</span> (inline) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">x = y</span>
        <span class="org-keyword">const</span> <span class=
"org-variable-name">isAssignmentLVal</span> =
          parent &amp;& parent.type === <span class=
"org-string">'AssignmentExpression'</span> &amp;& parent.left === id
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">x++</span>
        <span class="org-keyword">const</span> <span class=
"org-variable-name">isUpdateArg</span> =
          parent &amp;& parent.type === <span class=
"org-string">'UpdateExpression'</span> &amp;& parent.argument === id
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">({ x } = y)</span>
        <span class="org-keyword">const</span> <span class=
"org-variable-name">isDestructureAssignment</span> =
          parent &amp;& isInDestructureAssignment(parent, parentStack)
  
        <span class=
"org-keyword">if</span> (type === BindingTypes.SETUP_CONST || localVars[raw]) {
          <span class="org-keyword">return</span> raw
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (type === BindingTypes.SETUP_REF) {
          <span class="org-keyword">return</span> <span class=
"org-string">`${raw}.value`</span>
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (type === BindingTypes.SETUP_MAYBE_REF) {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">const binding that may or may not be ref</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">if it's not a ref, then assignments don't make sense -</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">so we ignore the non-ref assignment case and generate code</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">that assumes the value to be a ref for more efficiency</span>
          <span class=
"org-keyword">return</span> isAssignmentLVal || isUpdateArg || isDestructureAssignment
            ? <span class="org-string">`${raw}.value`</span>
            : <span class=
"org-string">`${context.helperString(UNREF)}(${raw})`</span>
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (type === BindingTypes.SETUP_LET) {
          <span class="org-keyword">if</span> (isAssignmentLVal) {
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">let binding.</span>
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">this is a bit more tricky as we need to cover the case where</span>
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">let is a local non-ref value, and we need to replicate the</span>
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">right hand side value.</span>
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">x = y --&gt; isRef(x) ? x.value = y : x = y</span>
            <span class=
"org-keyword">const</span> { right: rVal, operator } = parent
            <span class="org-keyword">const</span> <span class=
"org-variable-name">rExp</span> = rawExp.slice(rVal.start - <span class="org-highlight-numbers-number">1</span>, rVal.end - <span class="org-highlight-numbers-number">1</span>)
            <span class="org-keyword">const</span> <span class=
"org-variable-name">rExpString</span> = stringifyExpression(
              processExpression(
                createSimpleExpression(rExp, <span class=
"org-constant">false</span>),
                context,
                <span class="org-constant">false</span>,
                <span class="org-constant">false</span>,
                knownIds
              )
            )
            <span class="org-keyword">return</span> <span class=
"org-string">`${context.helperString(IS_REF)}(${raw})${``} ? ${raw}.value ${operator} ${rExpString} : ${raw}`</span>
          } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (isUpdateArg) {
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">make id replace parent in the code range so the raw update operator</span>
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">is removed</span>
            id.start = parent.start
            id.end = parent.end
            <span class=
"org-keyword">const</span> { prefix: isPrefix, operator } = parent
            <span class="org-keyword">const</span> <span class=
"org-variable-name">prefix</span> = isPrefix ? operator : <span class="org-string">``</span>
            <span class="org-keyword">const</span> <span class=
"org-variable-name">postfix</span> = isPrefix ? <span class=
"org-string">``</span> : operator
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">let binding.</span>
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">x++ --&gt; isRef(a) ? a.value++ : a++</span>
            <span class="org-keyword">return</span> <span class=
"org-string">`${context.helperString(IS_REF)}(${raw})${``} ? ${prefix}${raw}.value${postfix} : ${prefix}${raw}${postfix}`</span>
          } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (isDestructureAssignment) {
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment"><span class="org-bold"><span class=
"org-warning">TODO</span></span></span>
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">let binding in a destructure assignment - it's very tricky to</span>
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">handle both possible cases here without altering the original</span>
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">structure of the code, so we just assume it's not a ref here</span>
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">for now</span>
            <span class="org-keyword">return</span> raw
          } <span class="org-keyword">else</span> {
            <span class="org-keyword">return</span> <span class=
"org-string">`${context.helperString(UNREF)}(${raw})`</span>
          }
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (type === BindingTypes.PROPS) {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">use __props which is generated by compileScript so in ts mode</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">it gets correct type</span>
          <span class="org-keyword">return</span> <span class=
"org-string">`__props.${raw}`</span>
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (type === BindingTypes.PROPS_ALIASED) {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">prop with a different local alias (from defineProps() destructure)</span>
          <span class="org-keyword">return</span> <span class=
"org-string">`__props.${bindingMetadata.__propsAliases[raw]}`</span>
        }
      } <span class="org-keyword">else</span> {
        <span class=
"org-keyword">if</span> (type &amp;& type.startsWith(<span class=
"org-string">'setup'</span>)) {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">setup bindings in non-inline mode</span>
          <span class="org-keyword">return</span> <span class=
"org-string">`$setup.${raw}`</span>
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (type === BindingTypes.PROPS_ALIASED) {
          <span class="org-keyword">return</span> <span class=
"org-string">`$props.${bindingMetadata.__propsAliases[raw]}`</span>
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (type) {
          <span class="org-keyword">return</span> <span class=
"org-string">`$${type}.${raw}`</span>
        }
      }
  
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">fallback to ctx</span>
      <span class="org-keyword">return</span> <span class=
"org-string">`_ctx.${raw}`</span>
    }
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">fast path if expression is a simple identifier.</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">rawExp</span> = node.content
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">bail constant on parens (function invocation) and dot (member access)</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">bailConstant</span> = rawExp.indexOf(<span class="org-string">`(`</span>) &gt; -<span class="org-highlight-numbers-number">1</span> || rawExp.indexOf(<span class="org-string">'.'</span>) &gt; <span class="org-highlight-numbers-number">0</span>
  
    <span class=
"org-keyword">if</span> (isSimpleIdentifier(rawExp)) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">isScopeVarReference</span> = context.identifiers[rawExp]
      <span class="org-keyword">const</span> <span class=
"org-variable-name">isAllowedGlobal</span> = isGloballyWhitelisted(rawExp)
      <span class="org-keyword">const</span> <span class=
"org-variable-name">isLiteral</span> = isLiteralWhitelisted(rawExp)
      <span class=
"org-keyword">if</span> (!asParams &amp;& !isScopeVarReference &amp;& !isAllowedGlobal &amp;& !isLiteral) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">const bindings exposed from setup can be skipped for patching but</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">cannot be hoisted to module scope</span>
        <span class=
"org-keyword">if</span> (bindingMetadata[node.content] === BindingTypes.SETUP_CONST) {
          node.constType = ConstantTypes.CAN_SKIP_PATCH
        }
        node.content = rewriteIdentifier(rawExp)
      } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (!isScopeVarReference) {
        <span class="org-keyword">if</span> (isLiteral) {
          node.constType = ConstantTypes.CAN_STRINGIFY
        } <span class="org-keyword">else</span> {
          node.constType = ConstantTypes.CAN_HOIST
        }
      }
      <span class="org-keyword">return</span> node
    }
  
    <span class="org-keyword">let</span> <span class=
"org-variable-name">ast</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">exp needs to be parsed differently:</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">1. Multiple inline statements (v-on, with presence of `;`): parse as raw</span>
    <span class="org-comment-delimiter">//    </span><span class=
"org-comment">exp, but make sure to pad with spaces for consistent ranges</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">2. Expressions: wrap with parens (for e.g. object expressions)</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">3. Function arguments (v-for, v-slot): place in a function argument position</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">source</span> = asRawStatements
      ? <span class="org-string">` ${rawExp} `</span>
      : <span class=
"org-string">`(${rawExp})${asParams ? `</span>=&gt;{}<span class=
"org-string">` : ``}`</span>
    <span class="org-keyword">try</span> {
      ast = babelParser.parse(source, {
        plugins: context.expressionPlugins
      }).program
    } <span class="org-keyword">catch</span> (e) {
      <span class="org-keyword">return</span> node
    }
  
    <span class="org-keyword">const</span> <span class=
"org-variable-name">ids</span>= []
    <span class="org-keyword">const</span> <span class=
"org-variable-name">parentStack</span> = []
    <span class="org-keyword">const</span> <span class=
"org-variable-name">knownIds</span> = Object.create(context.identifiers)
  
    walkIdentifiers(
      ast,
      (node, parent, _, isReferenced, isLocal) =&gt; {
        <span class=
"org-keyword">if</span> (isStaticPropertyKey(node, parent)) {
          <span class="org-keyword">return</span>
        }
  
        <span class="org-keyword">const</span> <span class=
"org-variable-name">needPrefix</span> = isReferenced &amp;& canPrefix(node)
        <span class=
"org-keyword">if</span> (needPrefix &amp;& !isLocal) {
          <span class=
"org-keyword">if</span> (isStaticProperty(parent) &amp;& parent.shorthand) {
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">property shorthand like { foo }, we need to add the key since</span>
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">we rewrite the value</span>
            node.prefix = <span class=
"org-string">`${node.name}: `</span>
          }
          node.name = rewriteIdentifier(node.name, parent, node)
          ids.push(node)
        } <span class="org-keyword">else</span> {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">The identifier is considered constant unless it's pointing to a</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">local scope variable (a v-for alias, or a v-slot prop)</span>
          <span class=
"org-keyword">if</span> (!(needPrefix &amp;& isLocal) &amp;& !bailConstant) {
            node.isConstant = <span class=
"org-constant">true</span>
          }
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">also generate sub-expressions for other identifiers for better</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">source map support. (except for property keys which are static)</span>
          ids.push(node)
        }
      },
      <span class="org-constant">true</span>, <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">invoke on ALL identifiers</span>
      parentStack,
      knownIds
    )
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">We break up the compound expression into an array of strings and sub</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">expressions (for identifiers that have been prefixed). In codegen, if</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">an ExpressionNode has the `.children` property, it will be used instead of</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">`.content`.</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">children</span> = []
    ids.sort((a, b) =&gt; a.start - b.start)
    ids.forEach((id, i) =&gt; {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">range is offset by -1 due to the wrapping parens when parsed</span>
      <span class="org-keyword">const</span> <span class=
"org-variable-name">start</span> = id.start - <span class=
"org-highlight-numbers-number">1</span>
      <span class="org-keyword">const</span> <span class=
"org-variable-name">end</span> = id.end - <span class=
"org-highlight-numbers-number">1</span>
      <span class="org-keyword">const</span> <span class=
"org-variable-name">last</span> = ids[i - <span class=
"org-highlight-numbers-number">1</span>]
      <span class="org-keyword">const</span> <span class=
"org-variable-name">leadingText</span> = rawExp.slice(last ? last.end - <span class="org-highlight-numbers-number">1</span> : <span class="org-highlight-numbers-number">0</span>, start)
      <span class=
"org-keyword">if</span> (leadingText.length || id.prefix) {
        children.push(leadingText + (id.prefix || <span class=
"org-string">``</span>))
      }
      <span class="org-keyword">const</span> <span class=
"org-variable-name">source</span> = rawExp.slice(start, end)
      children.push(
        createSimpleExpression(
          id.name,
          <span class="org-constant">false</span>,
          {
            source,
            start: advancePositionWithClone(node.loc.start, source, start),
            end: advancePositionWithClone(node.loc.start, source, end)
          },
          id.isConstant ? ConstantTypes.CAN_STRINGIFY : ConstantTypes.NOT_CONSTANT
        )
      )
      <span class=
"org-keyword">if</span> (i === ids.length - <span class=
"org-highlight-numbers-number">1</span> &amp;& end &lt; rawExp.length) {
        children.push(rawExp.slice(end))
      }
    })
  
    <span class="org-keyword">let</span> <span class=
"org-variable-name">ret</span>
    <span class="org-keyword">if</span> (children.length) {
      ret = createCompoundExpression(children, node.loc)
    } <span class="org-keyword">else</span> {
      ret = node
      ret.constType = bailConstant
        ? ConstantTypes.NOT_CONSTANT
        : ConstantTypes.CAN_STRINGIFY
    }
    ret.identifiers = Object.keys(knownIds)
    <span class="org-keyword">return</span> ret
  }
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">canPrefix</span>(<span class=
"org-variable-name">id</span>) {
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">skip whitelisted globals</span>
    <span class=
"org-keyword">if</span> (isGloballyWhitelisted(id.name)) {
      <span class="org-keyword">return</span> <span class=
"org-constant">false</span>
    }
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">special case for webpack compilation</span>
    <span class="org-keyword">if</span> (id.name === <span class=
"org-string">'require'</span>) {
      <span class="org-keyword">return</span> <span class=
"org-constant">false</span>
    }
    <span class="org-keyword">return</span> <span class=
"org-constant">true</span>
  }
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">stringifyExpression</span>(<span class=
"org-variable-name">exp</span>){
    <span class="org-keyword">if</span> (isString(exp)) {
      <span class="org-keyword">return</span> exp
    } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (exp.type === NodeTypes.SIMPLE_EXPRESSION) {
      <span class="org-keyword">return</span> exp.content
    } <span class="org-keyword">else</span> {
      <span class=
"org-keyword">return</span> exp.children.map(stringifyExpression).join(<span class="org-string">''</span>)
    }
  }
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">createRoot</span>(<span class=
"org-variable-name">children</span>, <span class=
"org-variable-name">loc</span> = <span class=
"org-variable-name">locStub</span>) {
    <span class="org-keyword">return</span> {
      type: NodeTypes.ROOT,
      children,
      helpers: [],
      components: [],
      directives: [],
      hoists: [],
      imports: [],
      cached: <span class="org-highlight-numbers-number">0</span>,
      temps: <span class="org-highlight-numbers-number">0</span>,
      codegenNode: <span class="org-constant">undefined</span>,
      loc
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">createVNodeCall</span>(
    <span class="org-variable-name">context</span>,
    <span class="org-variable-name">tag</span>,
    <span class="org-variable-name">props</span>,
    <span class="org-variable-name">children</span>,
    <span class="org-variable-name">patchFlag</span>,
    <span class="org-variable-name">dynamicProps</span>,
    <span class="org-variable-name">directives</span>,
    isBlock = <span class="org-constant">false</span>,
    disableTracking = <span class="org-constant">false</span>,
    isComponent = <span class="org-constant">false</span>,
    loc = locStub
  ) {
    <span class="org-keyword">if</span> (context) {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">单个子节点用 block</span>
      <span class="org-keyword">if</span> (isBlock) {
        context.helper(OPEN_BLOCK)
        context.helper(getVNodeBlockHelper(context.inSSR, isComponent))
      } <span class="org-keyword">else</span> {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">多个节节点用 fragment</span>
        context.helper(getVNodeHelper(context.inSSR, isComponent))
      }
      <span class="org-keyword">if</span> (directives) {
        context.helper(WITH_DIRECTIVES)
      }
    }
  
    <span class="org-keyword">return</span> {
      type: NodeTypes.VNODE_CALL,
      tag,
      props,
      children,
      patchFlag,
      dynamicProps,
      directives,
      isBlock,
      disableTracking,
      isComponent,
      loc
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">createArrayExpression</span>(<span class=
"org-variable-name">elements</span>, <span class=
"org-variable-name">loc</span> = <span class=
"org-variable-name">locStub</span>) {
    <span class="org-keyword">return</span> {
      type: NodeTypes.JS_ARRAY_EXPRESSION,
      loc,
      elements
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">createObjectExpression</span>(<span class=
"org-variable-name">properties</span>, <span class=
"org-variable-name">loc</span> = <span class=
"org-variable-name">locStub</span>) {
    <span class="org-keyword">return</span> {
      type: NodeTypes.JS_OBJECT_EXPRESSION,
      loc,
      properties
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">createObjectProperty</span>(<span class=
"org-variable-name">key</span>, <span class=
"org-variable-name">value</span>) {
    <span class="org-keyword">return</span> {
      type: NodeTypes.JS_PROPERTY,
      loc: locStub,
      key: isString(key) ? createSimpleExpression(key, <span class=
"org-constant">true</span>) : key,
      value
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">createSimpleExpression</span>(
    <span class="org-variable-name">content</span>,
    isStatic = <span class="org-constant">false</span>,
    loc  = locStub,
    constType = ConstantTypes.NOT_CONSTANT
  ) {
    <span class="org-keyword">return</span> {
      type: NodeTypes.SIMPLE_EXPRESSION,
      loc,
      content,
      isStatic,
      constType: isStatic ? ConstantTypes.CAN_STRINGIFY : constType
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">createInterpolation</span>(<span class=
"org-variable-name">content</span>, <span class=
"org-variable-name">loc</span>) {
    <span class="org-keyword">return</span> {
      type: NodeTypes.INTERPOLATION,
      loc,
      content: isString(content)
        ? createSimpleExpression(content, <span class=
"org-constant">false</span>, loc)
        : content
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">createCompoundExpression</span>(<span class=
"org-variable-name">children</span>, <span class=
"org-variable-name">loc</span> = <span class=
"org-variable-name">locStub</span>) {
    <span class="org-keyword">return</span> {
      type: NodeTypes.COMPOUND_EXPRESSION,
      loc,
      children
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">createCallExpression</span>(<span class=
"org-variable-name">callee</span>, <span class=
"org-variable-name">args</span> = [], <span class=
"org-variable-name">loc</span> = <span class=
"org-variable-name">locStub</span>) {
    <span class="org-keyword">return</span> {
      type: NodeTypes.JS_CALL_EXPRESSION,
      loc,
      callee,
      <span class="org-constant">arguments</span>: args
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">createFunctionExpression</span>(
    <span class="org-variable-name">params</span>,
    returns = <span class="org-constant">undefined</span>,
    newline = <span class="org-constant">false</span>,
    isSlot = <span class="org-constant">false</span>,
    loc = locStub
  ) {
    <span class="org-keyword">return</span> {
      type: NodeTypes.JS_FUNCTION_EXPRESSION,
      params,
      returns,
      newline,
      isSlot,
      loc
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">createConditionalExpression</span>(
    <span class="org-variable-name">test</span>,
    <span class="org-variable-name">consequent</span>,
    <span class="org-variable-name">alternate</span>,
    newline = <span class="org-constant">true</span>
  ) {
    <span class="org-keyword">return</span> {
      type: NodeTypes.JS_CONDITIONAL_EXPRESSION,
      test,
      consequent,
      alternate,
      newline,
      loc: locStub
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">createCacheExpression</span>(
    <span class="org-variable-name">index</span>,
    <span class="org-variable-name">value</span>,
    isVNode = <span class="org-constant">false</span>
  ) {
    <span class="org-keyword">return</span> {
      type: NodeTypes.JS_CACHE_EXPRESSION,
      index,
      value,
      isVNode,
      loc: locStub
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">createBlockStatement</span>(<span class=
"org-variable-name">body</span>) {
    <span class="org-keyword">return</span> {
      type: NodeTypes.JS_BLOCK_STATEMENT,
      body,
      loc: locStub
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">createTemplateLiteral</span>(<span class=
"org-variable-name">elements</span>) {
    <span class="org-keyword">return</span> {
      type: NodeTypes.JS_TEMPLATE_LITERAL,
      elements,
      loc: locStub
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">createIfStatement</span>(<span class=
"org-variable-name">test</span>, <span class=
"org-variable-name">consequent</span>, <span class=
"org-variable-name">alternate</span>) {
    <span class="org-keyword">return</span> {
      type: NodeTypes.JS_IF_STATEMENT,
      test,
      consequent,
      alternate,
      loc: locStub
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">createAssignmentExpression</span>(<span class=
"org-variable-name">left</span>, <span class=
"org-variable-name">right</span>) {
    <span class="org-keyword">return</span> {
      type: NodeTypes.JS_ASSIGNMENT_EXPRESSION,
      left,
      right,
      loc: locStub
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">createSequenceExpression</span>(<span class=
"org-variable-name">expressions</span>) {
    <span class="org-keyword">return</span> {
      type: NodeTypes.JS_SEQUENCE_EXPRESSION,
      expressions,
      loc: locStub
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">createReturnStatement</span>(<span class=
"org-variable-name">returns</span>) {
    <span class="org-keyword">return</span> {
      type: NodeTypes.JS_RETURN_STATEMENT,
      returns,
      loc: locStub
    }
  }
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">transform</span>(<span class=
"org-variable-name">root</span>, <span class=
"org-variable-name">options</span>) {
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">transform 上下文</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">context</span> = createTransformContext(root, options)
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">递归遍历整个 ast root 树，最终为每颗子树生成 codegenNode</span>
    traverseNode(root, context)
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">静态提升处理</span>
    <span class="org-keyword">if</span> (options.hoistStatic) {
      hoistStatic(root, context)
    }
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">创建 root codegenNode 代码</span>
    <span class="org-keyword">if</span> (!options.ssr) {
      createRootCodegen(root, context)
    }
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">finalize meta information</span>
    root.helpers = [...context.helpers.keys()]
    root.components = [...context.components]
    root.directives = [...context.directives]
    root.imports = context.imports
    root.hoists = context.hoists
    root.temps = context.temps
    root.cached = context.cached
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">getBaseTransformPreset</span>(<span class=
"org-variable-name">prefixIdentifiers</span>) {
    <span class="org-keyword">return</span> [
      [
        transformOnce,
        transformIf,
        transformMemo,
        transformFor,
        ...(!__BROWSER__ &amp;& prefixIdentifiers
          ? [
              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">order is important</span>
              trackVForSlotScopes,
              transformExpression
            ]
          : __BROWSER__ &amp;& __DEV__
          ? [transformExpression]
          : []),
        transformSlotOutlet,
        transformElement,
        trackSlotScopes,
        transformText
      ],
      {
        on: transformOn,
        bind: transformBind,
        model: transformModel
      }
    ]
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">createCodegenContext</span>(
    <span class="org-variable-name">ast</span>,
    {
      mode = <span class="org-string">'function'</span>,
      prefixIdentifiers = mode === <span class=
"org-string">'module'</span>,
      sourceMap = <span class="org-constant">false</span>,
      filename = <span class=
"org-string">`template.vue.html`</span>,
      scopeId = <span class="org-constant">null</span>,
      optimizeImports = <span class="org-constant">false</span>,
      runtimeGlobalName = <span class="org-string">`Vue`</span>,
      runtimeModuleName = <span class="org-string">`vue`</span>,
      ssrRuntimeModuleName = <span class=
"org-string">'vue/server-renderer'</span>,
      ssr = <span class="org-constant">false</span>,
      isTS = <span class="org-constant">false</span>,
      inSSR = <span class="org-constant">false</span>
    }
  ) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">context</span> = {
      mode,
      prefixIdentifiers,
      sourceMap,
      filename,
      scopeId,
      optimizeImports,
      runtimeGlobalName,
      runtimeModuleName,
      ssrRuntimeModuleName,
      ssr,
      isTS,
      inSSR,
      source: ast.loc.source,
      code: <span class="org-string">``</span>,
      column: <span class="org-highlight-numbers-number">1</span>,
      line: <span class="org-highlight-numbers-number">1</span>,
      offset: <span class="org-highlight-numbers-number">0</span>,
      indentLevel: <span class=
"org-highlight-numbers-number">0</span>,
      pure: <span class="org-constant">false</span>,
      map: <span class="org-constant">undefined</span>,
      helper(key) {
        <span class="org-keyword">return</span> <span class=
"org-string">`_${helperNameMap[key]}`</span>
      },
      push(code, node) {
        context.code += code
        <span class=
"org-keyword">if</span> (!__BROWSER__ &amp;& context.map) {
          <span class="org-keyword">if</span> (node) {
            <span class="org-keyword">let</span> <span class=
"org-variable-name">name</span>
            <span class=
"org-keyword">if</span> (node.type === NodeTypes.SIMPLE_EXPRESSION &amp;& !node.isStatic) {
              <span class="org-keyword">const</span> <span class=
"org-variable-name">content</span> = node.content.replace(<span class="org-string">/^_ctx\./</span>, <span class="org-string">''</span>)
              <span class=
"org-keyword">if</span> (content !== node.content &amp;& isSimpleIdentifier(content)) {
                name = content
              }
            }
            addMapping(node.loc.start, name)
          }
          advancePositionWithMutation(context, code)
          <span class=
"org-keyword">if</span> (node &amp;& node.loc !== locStub) {
            addMapping(node.loc.end)
          }
        }
      },
      indent() {
        newline(++context.indentLevel)
      },
      deindent(withoutNewLine = <span class=
"org-constant">false</span>) {
        <span class="org-keyword">if</span> (withoutNewLine) {
          --context.indentLevel
        } <span class="org-keyword">else</span> {
          newline(--context.indentLevel)
        }
      },
      newline() {
        newline(context.indentLevel)
      }
    }
  
    <span class="org-keyword">function</span> <span class=
"org-function-name">newline</span>(<span class=
"org-variable-name">n</span>) {
      context.push(<span class=
"org-string">'\n'</span> + <span class=
"org-string">`  `</span>.repeat(n))
    }
  
    <span class="org-keyword">function</span> <span class=
"org-function-name">addMapping</span>(<span class=
"org-variable-name">loc</span>, <span class=
"org-variable-name">name</span>) {
      context.map.addMapping({
        name,
        source: context.filename,
        original: {
          line: loc.line,
          column: loc.column - <span class=
"org-highlight-numbers-number">1</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">source-map column is 0 based</span>
        },
        generated: {
          line: context.line,
          column: context.column - <span class=
"org-highlight-numbers-number">1</span>
        }
      })
    }
  
    <span class="org-keyword">return</span> context
  }
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">genModulePreamble</span>(<span class=
"org-variable-name">ast</span>, <span class=
"org-variable-name">context</span>, <span class=
"org-variable-name">genScopeId</span>, <span class=
"org-variable-name">inline</span>) {
    <span class="org-keyword">const</span> {
      push,
      newline,
      optimizeImports,
      runtimeModuleName,
      ssrRuntimeModuleName
    } = context
  
    <span class=
"org-keyword">if</span> (genScopeId &amp;& ast.hoists.length) {
      ast.helpers.push(PUSH_SCOPE_ID, POP_SCOPE_ID)
    }
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">generate import statements for helpers</span>
    <span class="org-keyword">if</span> (ast.helpers.length) {
      <span class="org-keyword">if</span> (optimizeImports) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">when bundled with webpack with code-split, calling an import binding</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">as a function leads to it being wrapped with `Object(a.b)` or `(0,a.b)`,</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">incurring both payload size increase and potential perf overhead.</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">therefore we assign the imports to variables (which is a constant ~50b</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">cost per-component instead of scaling with template size)</span>
        push(
          <span class="org-string">`import { ${ast.helpers</span>
<span class=
"org-string">            .map(s =&gt; helperNameMap[s])</span>
<span class=
"org-string">            .join(', ')} } from ${JSON.stringify(runtimeModuleName)}\n`</span>
        )
        push(
          <span class=
"org-string">`\n// Binding optimization for webpack code-split\nconst ${ast.helpers</span>
<span class=
"org-string">            .map(s =&gt; `</span>_${helperNameMap[s]} = ${helperNameMap[s]}<span class="org-string">`)</span>
<span class="org-string">            .join(', ')}\n`</span>
        )
      } <span class="org-keyword">else</span> {
        push(
          <span class="org-string">`import { ${ast.helpers</span>
<span class=
"org-string">            .map(s =&gt; `</span>${helperNameMap[s]} as _${helperNameMap[s]}<span class="org-string">`)</span>
<span class=
"org-string">            .join(', ')} } from ${JSON.stringify(runtimeModuleName)}\n`</span>
        )
      }
    }
  
    <span class=
"org-keyword">if</span> (ast.ssrHelpers &amp;& ast.ssrHelpers.length) {
      push(
        <span class="org-string">`import { ${ast.ssrHelpers</span>
<span class=
"org-string">          .map(s =&gt; `</span>${helperNameMap[s]} as _${helperNameMap[s]}<span class="org-string">`)</span>
<span class=
"org-string">          .join(', ')} } from "${ssrRuntimeModuleName}"\n`</span>
      )
    }
  
    <span class="org-keyword">if</span> (ast.imports.length) {
      genImports(ast.imports, context)
      newline()
    }
  
    genHoists(ast.hoists, context)
    newline()
  
    <span class="org-keyword">if</span> (!inline) {
      push(<span class="org-string">`export `</span>)
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">genImports</span>(<span class=
"org-variable-name">importsOptions</span>, <span class=
"org-variable-name">context</span>) {
    <span class="org-keyword">if</span> (!importsOptions.length) {
      <span class="org-keyword">return</span>
    }
    importsOptions.forEach(imports =&gt; {
      context.push(<span class="org-string">`import `</span>)
      genNode(imports.exp, context)
      context.push(<span class=
"org-string">` from '${imports.path}'`</span>)
      context.newline()
    })
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">genFunctionPreamble</span>(<span class=
"org-variable-name">ast</span>, <span class=
"org-variable-name">context</span>) {
    <span class="org-keyword">const</span> {
      ssr,
      prefixIdentifiers,
      push,
      newline,
      runtimeModuleName,
      runtimeGlobalName,
      ssrRuntimeModuleName
    } = context
    <span class="org-keyword">const</span> <span class=
"org-variable-name">VueBinding</span> =
      !__BROWSER__ &amp;& ssr
        ? <span class=
"org-string">`require(${JSON.stringify(runtimeModuleName)})`</span>
        : runtimeGlobalName
    <span class="org-keyword">const</span> <span class=
"org-variable-name">aliasHelper</span> = (s) =&gt; <span class=
"org-string">`${helperNameMap[s]}: _${helperNameMap[s]}`</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">Generate const declaration for helpers</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">In prefix mode, we place the const declaration at top so it's done</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">only once; But if we not prefixing, we place the declaration inside the</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">with block so it doesn't incur the `in` check cost for every helper access.</span>
    <span class=
"org-keyword">if</span> (ast.helpers.length &gt; <span class=
"org-highlight-numbers-number">0</span>) {
      <span class=
"org-keyword">if</span> (!__BROWSER__ &amp;& prefixIdentifiers) {
        push(
          <span class=
"org-string">`const { ${ast.helpers.map(aliasHelper).join(', ')} } = ${VueBinding}\n`</span>
        )
      } <span class="org-keyword">else</span> {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">"with" mode.</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">save Vue in a separate variable to avoid collision</span>
        push(<span class=
"org-string">`const _Vue = ${VueBinding}\n`</span>)
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">in "with" mode, helpers are declared inside the with block to avoid</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">has check cost, but hoists are lifted out of the function - we need</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">to provide the helper here.</span>
        <span class="org-keyword">if</span> (ast.hoists.length) {
          <span class="org-keyword">const</span> <span class=
"org-variable-name">staticHelpers</span> = [
            CREATE_VNODE,
            CREATE_ELEMENT_VNODE,
            CREATE_COMMENT,
            CREATE_TEXT,
            CREATE_STATIC
          ]
            .filter(helper =&gt; ast.helpers.includes(helper))
            .map(aliasHelper)
            .join(<span class="org-string">', '</span>)
          push(<span class=
"org-string">`const { ${staticHelpers} } = _Vue\n`</span>)
        }
      }
    }
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">generate variables for ssr helpers</span>
    <span class=
"org-keyword">if</span> (!__BROWSER__ &amp;& ast.ssrHelpers &amp;& ast.ssrHelpers.length) {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">ssr guarantees prefixIdentifier: true</span>
      push(
        <span class="org-string">`const { ${ast.ssrHelpers</span>
<span class="org-string">          .map(aliasHelper)</span>
<span class=
"org-string">          .join(', ')} } = require("${ssrRuntimeModuleName}")\n`</span>
      )
    }
    genHoists(ast.hoists, context)
    newline()
    push(<span class="org-string">`return `</span>)
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">genHoists</span>(<span class=
"org-variable-name">hoists</span>, <span class=
"org-variable-name">context</span>) {
    <span class="org-keyword">if</span> (!hoists.length) {
      <span class="org-keyword">return</span>
    }
    context.pure = <span class="org-constant">true</span>
    <span class=
"org-keyword">const</span> { push, newline, helper, scopeId, mode } = context
    <span class="org-keyword">const</span> <span class=
"org-variable-name">genScopeId</span> = !__BROWSER__ &amp;& scopeId != <span class="org-constant">null</span> &amp;& mode !== <span class="org-string">'function'</span>
    newline()
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">generate inlined withScopeId helper</span>
    <span class="org-keyword">if</span> (genScopeId) {
      push(
        <span class=
"org-string">`const _withScopeId = n =&gt; (${helper(</span>
<span class="org-string">          PUSH_SCOPE_ID</span>
<span class=
"org-string">        )}("${scopeId}"),n=n(),${helper(POP_SCOPE_ID)}(),n)`</span>
      )
      newline()
    }
  
    <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; hoists.length; i++) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">exp</span> = hoists[i]
      <span class="org-keyword">if</span> (exp) {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">needScopeIdWrapper</span> = genScopeId &amp;& exp.type === NodeTypes.VNODE_CALL
        push(
          <span class=
"org-string">`const _hoisted_${i + 1} = ${</span>
<span class=
"org-string">            needScopeIdWrapper ? `</span>${PURE_ANNOTATION} _withScopeId(() =&gt; <span class="org-string">` : ``</span>
<span class="org-string">          }`</span>
        )
        genNode(exp, context)
        <span class="org-keyword">if</span> (needScopeIdWrapper) {
          push(<span class="org-string">`)`</span>)
        }
        newline()
      }
    }
  
    context.pure = <span class="org-constant">false</span>
  }
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">type = 'component' | 'directive' | 'filter'</span>
  <span class="org-keyword">function</span> <span class=
"org-function-name">genAssets</span>(<span class=
"org-variable-name">assets</span>, <span class=
"org-variable-name">type</span>, { <span class=
"org-variable-name">helper</span>, <span class=
"org-variable-name">push</span>, <span class=
"org-variable-name">newline</span>, <span class=
"org-variable-name">isTS</span> }) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">resolver</span> = helper(
      type === <span class="org-string">'component'</span>
        ? RESOLVE_COMPONENT
        : RESOLVE_DIRECTIVE
    )
    <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; assets.length; i++) {
      <span class="org-keyword">let</span> <span class=
"org-variable-name">id</span> = assets[i]
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">potential component implicit self-reference inferred from SFC filename</span>
      <span class="org-keyword">const</span> <span class=
"org-variable-name">maybeSelfReference</span> = id.endsWith(<span class="org-string">'__self'</span>)
      <span class="org-keyword">if</span> (maybeSelfReference) {
        id = id.slice(<span class=
"org-highlight-numbers-number">0</span>, -<span class=
"org-highlight-numbers-number">6</span>)
      }
      push(
        <span class=
"org-string">`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${</span>
<span class=
"org-string">          maybeSelfReference ? `</span>, <span class=
"org-constant">true</span><span class="org-string">` : ``</span>
<span class="org-string">        })${isTS ? `</span>!<span class=
"org-string">` : ``}`</span>
      )
      <span class=
"org-keyword">if</span> (i &lt; assets.length - <span class=
"org-highlight-numbers-number">1</span>) {
        newline()
      }
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">genText</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
    context.push(JSON.stringify(node.content), node)
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">genExpression</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
    <span class=
"org-keyword">const</span> { content, isStatic } = node
    context.push(isStatic ? JSON.stringify(content) : content, node)
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">genInterpolation</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
    <span class=
"org-keyword">const</span> { push, helper, pure } = context
    <span class=
"org-keyword">if</span> (pure) push(PURE_ANNOTATION)
    push(<span class=
"org-string">`${helper(TO_DISPLAY_STRING)}(`</span>)
    genNode(node.content, context)
    push(<span class="org-string">`)`</span>)
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">genCompoundExpression</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
    <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; node.children.length; i++) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">child</span> = node.children[i]
      <span class="org-keyword">if</span> (isString(child)) {
        context.push(child)
      } <span class="org-keyword">else</span> {
        genNode(child, context)
      }
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">genComment</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
    <span class=
"org-keyword">const</span> { push, helper, pure } = context
    <span class="org-keyword">if</span> (pure) {
      push(PURE_ANNOTATION)
    }
    push(<span class=
"org-string">`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`</span>, node)
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">genVNodeCall</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
    <span class=
"org-keyword">const</span> { push, helper, pure } = context
    <span class="org-keyword">const</span> {
      tag,
      props,
      children,
      patchFlag,
      dynamicProps,
      directives,
      isBlock,
      disableTracking,
      isComponent
    } = node
    <span class="org-keyword">if</span> (directives) {
      push(helper(WITH_DIRECTIVES) + <span class=
"org-string">`(`</span>)
    }
    <span class="org-keyword">if</span> (isBlock) {
      push(<span class=
"org-string">`(${helper(OPEN_BLOCK)}(${disableTracking ? `</span><span class="org-constant">true</span><span class="org-string">` : ``}), `</span>)
    }
    <span class="org-keyword">if</span> (pure) {
      push(PURE_ANNOTATION)
    }
    <span class="org-keyword">const</span> <span class=
"org-variable-name">callHelper</span> = isBlock
      ? getVNodeBlockHelper(context.inSSR, isComponent)
      : getVNodeHelper(context.inSSR, isComponent)
    push(helper(callHelper) + <span class=
"org-string">`(`</span>, node)
    genNodeList(
      genNullableArgs([tag, props, children, patchFlag, dynamicProps]),
      context
    )
    push(<span class="org-string">`)`</span>)
    <span class="org-keyword">if</span> (isBlock) {
      push(<span class="org-string">`)`</span>)
    }
    <span class="org-keyword">if</span> (directives) {
      push(<span class="org-string">`, `</span>)
      genNode(directives, context)
      push(<span class="org-string">`)`</span>)
    }
  }
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">JavaScript</span>
  <span class="org-keyword">function</span> <span class=
"org-function-name">genCallExpression</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
    <span class=
"org-keyword">const</span> { push, helper, pure } = context
    <span class="org-keyword">const</span> <span class=
"org-variable-name">callee</span> = isString(node.callee) ? node.callee : helper(node.callee)
    <span class="org-keyword">if</span> (pure) {
      push(PURE_ANNOTATION)
    }
    push(callee + <span class="org-string">`(`</span>, node)
    genNodeList(node.<span class=
"org-constant">arguments</span>, context)
    push(<span class="org-string">`)`</span>)
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">genObjectExpression</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
    <span class=
"org-keyword">const</span> { push, indent, deindent, newline } = context
    <span class="org-keyword">const</span> { properties } = node
    <span class="org-keyword">if</span> (!properties.length) {
      push(<span class="org-string">`{}`</span>, node)
      <span class="org-keyword">return</span>
    }
    <span class="org-keyword">const</span> <span class=
"org-variable-name">multilines</span> =
      properties.length &gt; <span class=
"org-highlight-numbers-number">1</span> ||
      ((!__BROWSER__ || __DEV__) &amp;&
        properties.some(p =&gt; p.value.type !== NodeTypes.SIMPLE_EXPRESSION))
    push(multilines ? <span class=
"org-string">`{`</span> : <span class="org-string">`{ `</span>)
    multilines &amp;& indent()
    <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; properties.length; i++) {
      <span class=
"org-keyword">const</span> { key, value } = properties[i]
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">key</span>
      genExpressionAsPropertyKey(key, context)
      push(<span class="org-string">`: `</span>)
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">value</span>
      genNode(value, context)
      <span class=
"org-keyword">if</span> (i &lt; properties.length - <span class=
"org-highlight-numbers-number">1</span>) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">will only reach this if it's multilines</span>
        push(<span class="org-string">`,`</span>)
        newline()
      }
    }
    multilines &amp;& deindent()
    push(multilines ? <span class=
"org-string">`}`</span> : <span class="org-string">` }`</span>)
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">genArrayExpression</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
    genNodeListAsArray(node.elements, context)
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">genFunctionExpression</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
    <span class=
"org-keyword">const</span> { push, indent, deindent } = context
    <span class=
"org-keyword">const</span> { params, returns, body, newline, isSlot } = node
    <span class="org-keyword">if</span> (isSlot) {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">wrap slot functions with owner context</span>
      push(<span class=
"org-string">`_${helperNameMap[WITH_CTX]}(`</span>)
    }
    push(<span class="org-string">`(`</span>, node)
    <span class="org-keyword">if</span> (isArray(params)) {
      genNodeList(params, context)
    } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (params) {
      genNode(params, context)
    }
    push(<span class="org-string">`) =&gt; `</span>)
    <span class="org-keyword">if</span> (newline || body) {
      push(<span class="org-string">`{`</span>)
      indent()
    }
    <span class="org-keyword">if</span> (returns) {
      <span class="org-keyword">if</span> (newline) {
        push(<span class="org-string">`return `</span>)
      }
      <span class="org-keyword">if</span> (isArray(returns)) {
        genNodeListAsArray(returns, context)
      } <span class="org-keyword">else</span> {
        genNode(returns, context)
      }
    } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (body) {
      genNode(body, context)
    }
    <span class="org-keyword">if</span> (newline || body) {
      deindent()
      push(<span class="org-string">`}`</span>)
    }
    <span class="org-keyword">if</span> (isSlot) {
      push(<span class="org-string">`)`</span>)
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">genConditionalExpression</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
    <span class=
"org-keyword">const</span> { test, consequent, alternate, newline: needNewline } = node
    <span class=
"org-keyword">const</span> { push, indent, deindent, newline } = context
    <span class=
"org-keyword">if</span> (test.type === NodeTypes.SIMPLE_EXPRESSION) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">needsParens</span> = !isSimpleIdentifier(test.content)
      needsParens &amp;& push(<span class="org-string">`(`</span>)
      genExpression(test, context)
      needsParens &amp;& push(<span class="org-string">`)`</span>)
    } <span class="org-keyword">else</span> {
      push(<span class="org-string">`(`</span>)
      genNode(test, context)
      push(<span class="org-string">`)`</span>)
    }
    needNewline &amp;& indent()
    context.indentLevel++
    needNewline || push(<span class="org-string">` `</span>)
    push(<span class="org-string">`? `</span>)
    genNode(consequent, context)
    context.indentLevel--
    needNewline &amp;& newline()
    needNewline || push(<span class="org-string">` `</span>)
    push(<span class="org-string">`: `</span>)
    <span class="org-keyword">const</span> <span class=
"org-variable-name">isNested</span> = alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION
    <span class="org-keyword">if</span> (!isNested) {
      context.indentLevel++
    }
    genNode(alternate, context)
    <span class="org-keyword">if</span> (!isNested) {
      context.indentLevel--
    }
    needNewline &amp;& deindent(<span class=
"org-constant">true</span> <span class=
"org-comment-delimiter">/* </span><span class=
"org-comment">without newline</span><span class=
"org-comment-delimiter"> */</span>)
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">genCacheExpression</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
    <span class=
"org-keyword">const</span> { push, helper, indent, deindent, newline } = context
    push(<span class=
"org-string">`_cache[${node.index}] || (`</span>)
    <span class="org-keyword">if</span> (node.isVNode) {
      indent()
      push(<span class=
"org-string">`${helper(SET_BLOCK_TRACKING)}(-1),`</span>)
      newline()
    }
    push(<span class=
"org-string">`_cache[${node.index}] = `</span>)
    genNode(node.value, context)
    <span class="org-keyword">if</span> (node.isVNode) {
      push(<span class="org-string">`,`</span>)
      newline()
      push(<span class=
"org-string">`${helper(SET_BLOCK_TRACKING)}(1),`</span>)
      newline()
      push(<span class="org-string">`_cache[${node.index}]`</span>)
      deindent()
    }
    push(<span class="org-string">`)`</span>)
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">genNodeList</span>(<span class=
"org-variable-name">nodes</span>, <span class=
"org-variable-name">context</span>, <span class=
"org-variable-name">multilines</span> = <span class=
"org-constant">false</span>, <span class=
"org-variable-name">comma</span> = <span class=
"org-constant">true</span>) {
    <span class=
"org-keyword">const</span> { push, newline } = context
    <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; nodes.length; i++) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">node</span> = nodes[i]
      <span class="org-keyword">if</span> (isString(node)) {
        push(node)
      } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (isArray(node)) {
        genNodeListAsArray(node, context)
      } <span class="org-keyword">else</span> {
        genNode(node, context)
      }
      <span class=
"org-keyword">if</span> (i &lt; nodes.length - <span class=
"org-highlight-numbers-number">1</span>) {
        <span class="org-keyword">if</span> (multilines) {
          comma &amp;& push(<span class="org-string">','</span>)
          newline()
        } <span class="org-keyword">else</span> {
          comma &amp;& push(<span class="org-string">', '</span>)
        }
      }
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">genTemplateLiteral</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
    <span class=
"org-keyword">const</span> { push, indent, deindent } = context
    push(<span class="org-string">'`'</span>)
    <span class="org-keyword">const</span> <span class=
"org-variable-name">l</span> = node.elements.length
    <span class="org-keyword">const</span> <span class=
"org-variable-name">multilines</span> = l &gt; <span class=
"org-highlight-numbers-number">3</span>
    <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; l; i++) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">e</span> = node.elements[i]
      <span class="org-keyword">if</span> (isString(e)) {
        push(e.replace(<span class=
"org-string">/(`|\$|\\)/</span>g, <span class=
"org-string">'\\$1'</span>))
      } <span class="org-keyword">else</span> {
        push(<span class="org-string">'${'</span>)
        <span class="org-keyword">if</span> (multilines) indent()
        genNode(e, context)
        <span class="org-keyword">if</span> (multilines) deindent()
        push(<span class="org-string">'}'</span>)
      }
    }
    push(<span class="org-string">'`'</span>)
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">genIfStatement</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
    <span class=
"org-keyword">const</span> { push, indent, deindent } = context
    <span class=
"org-keyword">const</span> { test, consequent, alternate } = node
    push(<span class="org-string">`if (`</span>)
    genNode(test, context)
    push(<span class="org-string">`) {`</span>)
    indent()
    genNode(consequent, context)
    deindent()
    push(<span class="org-string">`}`</span>)
    <span class="org-keyword">if</span> (alternate) {
      push(<span class="org-string">` else `</span>)
      <span class=
"org-keyword">if</span> (alternate.type === NodeTypes.JS_IF_STATEMENT) {
        genIfStatement(alternate, context)
      } <span class="org-keyword">else</span> {
        push(<span class="org-string">`{`</span>)
        indent()
        genNode(alternate, context)
        deindent()
        push(<span class="org-string">`}`</span>)
      }
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">genAssignmentExpression</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
    genNode(node.left, context)
    context.push(<span class="org-string">` = `</span>)
    genNode(node.right, context)
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">genSequenceExpression</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
    context.push(<span class="org-string">`(`</span>)
    genNodeList(node.expressions, context)
    context.push(<span class="org-string">`)`</span>)
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">genReturnStatement</span>({ returns }, context) {
    context.push(<span class="org-string">`return `</span>)
    <span class="org-keyword">if</span> (isArray(returns)) {
      genNodeListAsArray(returns, context)
    } <span class="org-keyword">else</span> {
      genNode(returns, context)
    }
  }
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">genNode</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
    <span class="org-keyword">if</span> (isString(node)) {
      context.push(node)
      <span class="org-keyword">return</span>
    }
    <span class="org-keyword">if</span> (isSymbol(node)) {
      context.push(context.helper(node))
      <span class="org-keyword">return</span>
    }
    <span class="org-keyword">switch</span> (node.type) {
      <span class="org-keyword">case</span> NodeTypes.ELEMENT:
      <span class="org-keyword">case</span> NodeTypes.IF:
      <span class="org-keyword">case</span> NodeTypes.FOR:
        genNode(node.codegenNode, context)
        <span class="org-keyword">break</span>
      <span class="org-keyword">case</span> NodeTypes.TEXT:
        genText(node, context)
        <span class="org-keyword">break</span>
      <span class=
"org-keyword">case</span> NodeTypes.SIMPLE_EXPRESSION:
        genExpression(node, context)
        <span class="org-keyword">break</span>
      <span class=
"org-keyword">case</span> NodeTypes.INTERPOLATION:
        genInterpolation(node, context)
        <span class="org-keyword">break</span>
      <span class="org-keyword">case</span> NodeTypes.TEXT_CALL:
        genNode(node.codegenNode, context)
        <span class="org-keyword">break</span>
      <span class=
"org-keyword">case</span> NodeTypes.COMPOUND_EXPRESSION:
        genCompoundExpression(node, context)
        <span class="org-keyword">break</span>
      <span class="org-keyword">case</span> NodeTypes.COMMENT:
        genComment(node, context)
        <span class="org-keyword">break</span>
      <span class="org-keyword">case</span> NodeTypes.VNODE_CALL:
        genVNodeCall(node, context)
        <span class="org-keyword">break</span>
  
      <span class=
"org-keyword">case</span> NodeTypes.JS_CALL_EXPRESSION:
        genCallExpression(node, context)
        <span class="org-keyword">break</span>
      <span class=
"org-keyword">case</span> NodeTypes.JS_OBJECT_EXPRESSION:
        genObjectExpression(node, context)
        <span class="org-keyword">break</span>
      <span class=
"org-keyword">case</span> NodeTypes.JS_ARRAY_EXPRESSION:
        genArrayExpression(node, context)
        <span class="org-keyword">break</span>
      <span class=
"org-keyword">case</span> NodeTypes.JS_FUNCTION_EXPRESSION:
        genFunctionExpression(node, context)
        <span class="org-keyword">break</span>
      <span class=
"org-keyword">case</span> NodeTypes.JS_CONDITIONAL_EXPRESSION:
        genConditionalExpression(node, context)
        <span class="org-keyword">break</span>
      <span class=
"org-keyword">case</span> NodeTypes.JS_CACHE_EXPRESSION:
        genCacheExpression(node, context)
        <span class="org-keyword">break</span>
      <span class=
"org-keyword">case</span> NodeTypes.JS_BLOCK_STATEMENT:
        genNodeList(node.body, context, <span class=
"org-constant">true</span>, <span class=
"org-constant">false</span>)
        <span class="org-keyword">break</span>
  
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">SSR only types</span>
      <span class=
"org-keyword">case</span> NodeTypes.JS_TEMPLATE_LITERAL:
        !__BROWSER__ &amp;& genTemplateLiteral(node, context)
        <span class="org-keyword">break</span>
      <span class=
"org-keyword">case</span> NodeTypes.JS_IF_STATEMENT:
        !__BROWSER__ &amp;& genIfStatement(node, context)
        <span class="org-keyword">break</span>
      <span class=
"org-keyword">case</span> NodeTypes.JS_ASSIGNMENT_EXPRESSION:
        !__BROWSER__ &amp;& genAssignmentExpression(node, context)
        <span class="org-keyword">break</span>
      <span class=
"org-keyword">case</span> NodeTypes.JS_SEQUENCE_EXPRESSION:
        !__BROWSER__ &amp;& genSequenceExpression(node, context)
        <span class="org-keyword">break</span>
      <span class=
"org-keyword">case</span> NodeTypes.JS_RETURN_STATEMENT:
        !__BROWSER__ &amp;& genReturnStatement(node, context)
        <span class="org-keyword">break</span>
  
      <span class="org-comment-delimiter">/* </span><span class=
"org-comment">istanbul ignore next</span><span class=
"org-comment-delimiter"> */</span>
      <span class="org-keyword">case</span> NodeTypes.IF_BRANCH:
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">noop</span>
        <span class="org-keyword">break</span>
      <span class="org-keyword">default</span>:
        logg(<span class=
"org-string">`unhandled codegen node type: ${node.type}`</span>)
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">genNodeListAsArray</span>(<span class=
"org-variable-name">nodes</span>, <span class=
"org-variable-name">context</span>) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">multilines</span> =
      nodes.length &gt; <span class=
"org-highlight-numbers-number">3</span> ||
      ((!__BROWSER__ || __DEV__) &amp;& nodes.some(n =&gt; isArray(n) || !isText(n)))
    context.push(<span class="org-string">`[`</span>)
    multilines &amp;& context.indent()
    genNodeList(nodes, context, multilines)
    multilines &amp;& context.deindent()
    context.push(<span class="org-string">`]`</span>)
  }
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">generate</span>(<span class=
"org-variable-name">ast</span>, <span class=
"org-variable-name">options</span> = {}) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">context</span> = createCodegenContext(ast, options)
    <span class=
"org-keyword">if</span> (options.onContextCreated) options.onContextCreated(context)
    <span class="org-keyword">const</span> {
      mode,
      push,
      prefixIdentifiers,
      indent,
      deindent,
      newline,
      scopeId,
      ssr
    } = context
  
    <span class="org-keyword">const</span> <span class=
"org-variable-name">hasHelpers</span> = ast.helpers.length &gt; <span class="org-highlight-numbers-number">0</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">useWithBlock</span> = !prefixIdentifiers &amp;& mode !== <span class="org-string">'module'</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">genScopeId</span> = !__BROWSER__ &amp;& scopeId != <span class="org-constant">null</span> &amp;& mode === <span class="org-string">'module'</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">isSetupInlined</span> = !__BROWSER__ &amp;& !!options.inline
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">preambles</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">in setup() inline mode, the preamble is generated in a sub context</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">and returned separately.</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">preambleContext</span> = isSetupInlined
      ? createCodegenContext(ast, options)
      : context
    <span class=
"org-keyword">if</span> (!__BROWSER__ &amp;& mode === <span class=
"org-string">'module'</span>) {
      genModulePreamble(ast, preambleContext, genScopeId, isSetupInlined)
    } <span class="org-keyword">else</span> {
      genFunctionPreamble(ast, preambleContext)
    }
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">enter render function</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">functionName</span> = ssr ? <span class=
"org-string">`ssrRender`</span> : <span class=
"org-string">`render`</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">args</span> = ssr ? [<span class=
"org-string">'_ctx'</span>, <span class=
"org-string">'_push'</span>, <span class=
"org-string">'_parent'</span>, <span class=
"org-string">'_attrs'</span>] : [<span class=
"org-string">'_ctx'</span>, <span class=
"org-string">'_cache'</span>]
    <span class=
"org-keyword">if</span> (!__BROWSER__ &amp;& options.bindingMetadata &amp;& !options.inline) {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">binding optimization args</span>
      args.push(<span class=
"org-string">'$props'</span>, <span class=
"org-string">'$setup'</span>, <span class=
"org-string">'$data'</span>, <span class=
"org-string">'$options'</span>)
    }
    <span class="org-keyword">const</span> <span class=
"org-variable-name">signature</span> =
      !__BROWSER__ &amp;& options.isTS
        ? args.map(arg =&gt; <span class=
"org-string">`${arg}: any`</span>).join(<span class=
"org-string">','</span>)
        : args.join(<span class="org-string">', '</span>)
  
    <span class="org-keyword">if</span> (isSetupInlined) {
      push(<span class=
"org-string">`(${signature}) =&gt; {`</span>)
    } <span class="org-keyword">else</span> {
      push(<span class=
"org-string">`function ${functionName}(${signature}) {`</span>)
    }
    indent()
  
    <span class="org-keyword">if</span> (useWithBlock) {
      push(<span class="org-string">`with (_ctx) {`</span>)
      indent()
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">function mode const declarations should be inside with block</span>
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">also they should be renamed to avoid collision with user properties</span>
      <span class="org-keyword">if</span> (hasHelpers) {
        push(
          <span class="org-string">`const { ${ast.helpers</span>
<span class=
"org-string">            .map(s =&gt; `</span>${helperNameMap[s]}: _${helperNameMap[s]}<span class="org-string">`)</span>
<span class="org-string">            .join(', ')} } = _Vue`</span>
        )
        push(<span class="org-string">`\n`</span>)
        newline()
      }
    }
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">generate asset resolution statements</span>
    <span class="org-keyword">if</span> (ast.components.length) {
      genAssets(ast.components, <span class=
"org-string">'component'</span>, context)
      <span class=
"org-keyword">if</span> (ast.directives.length || ast.temps &gt; <span class="org-highlight-numbers-number">0</span>) {
        newline()
      }
    }
    <span class="org-keyword">if</span> (ast.directives.length) {
      genAssets(ast.directives, <span class=
"org-string">'directive'</span>, context)
      <span class=
"org-keyword">if</span> (ast.temps &gt; <span class=
"org-highlight-numbers-number">0</span>) {
        newline()
      }
    }
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">临时变量</span>
    <span class=
"org-keyword">if</span> (ast.temps &gt; <span class="org-highlight-numbers-number">0</span>) {
      push(<span class="org-string">`let `</span>)
      <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; ast.temps; i++) {
        push(<span class=
"org-string">`${i &gt; 0 ? `</span>, <span class=
"org-string">` : ``}_temp${i}`</span>)
      }
    }
    <span class=
"org-keyword">if</span> (ast.components.length || ast.directives.length || ast.temps) {
      push(<span class="org-string">`\n`</span>)
      newline()
    }
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">generate the VNode tree expression</span>
    <span class="org-keyword">if</span> (!ssr) {
      push(<span class="org-string">`return `</span>)
    }
    <span class="org-keyword">if</span> (ast.codegenNode) {
      genNode(ast.codegenNode, context)
    } <span class="org-keyword">else</span> {
      push(<span class="org-string">`null`</span>)
    }
  
    <span class="org-keyword">if</span> (useWithBlock) {
      deindent()
      push(<span class="org-string">`}`</span>)
    }
  
    deindent()
    push(<span class="org-string">`}`</span>)
  
    <span class="org-keyword">return</span> {
      ast,
      code: context.code,
      preamble: isSetupInlined ? preambleContext.code : <span class="org-string">``</span>,
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">SourceMapGenerator does have toJSON() method but it's not in the types</span>
      map: context.map ? context.map.toJSON() : <span class=
"org-constant">undefined</span>
    }
  }

  <span class="org-keyword">function</span> <span class=
"org-function-name">baseCompile</span>(<span class=
"org-variable-name">template</span>, <span class=
"org-variable-name">options</span> = {}) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">isModuleMode</span> = options.mode === <span class="org-string">'module'</span>

    <span class="org-keyword">const</span> <span class=
"org-variable-name">prefixIdentifiers</span> =
        !__BROWSER__ &amp;& (options.prefixIdentifiers === <span class="org-constant">true</span> || isModuleMode)

    <span class="org-keyword">const</span> <span class=
"org-variable-name">ast</span> = isString(template) ? baseParse(template, options) : template
    <span class="org-keyword">const</span> [<span class=
"org-variable-name">nodeTransforms</span>, <span class=
"org-variable-name">directiveTransforms</span>] = getBaseTransformPreset(prefixIdentifiers)

    <span class="org-comment-delimiter">// </span><span class=
"org-comment">转换出每个节点的 codegenNode</span>
    transform(
        ast,
        extend({}, options, {
        prefixIdentifiers,
        nodeTransforms: [
            ...nodeTransforms,
            ...(options.nodeTransforms || []) <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">user transforms</span>
        ],
        directiveTransforms: extend(
            {},
            directiveTransforms,
            options.directiveTransforms || {} <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">user transforms</span>
        )
        })
    )

    <span class="org-comment-delimiter">// </span><span class=
"org-comment">生成 codegen</span>
    <span class=
"org-keyword">return</span> generate(ast, extend({}, options, { prefixIdentifiers }))
  }
<span class="org-keyword">const</span> <span class=
"org-variable-name">namedCharacterReferences</span> = {
  <span class="org-string">"GT"</span>: <span class=
"org-string">"&gt;"</span>,
  <span class="org-string">"gt"</span>: <span class=
"org-string">"&gt;"</span>,
  <span class="org-string">"LT"</span>: <span class=
"org-string">"&lt;"</span>,
  <span class="org-string">"lt"</span>: <span class=
"org-string">"&lt;"</span>,
  <span class="org-string">"ac;"</span>: <span class=
"org-string">"∾"</span>,
  <span class="org-string">"af;"</span>: <span class=
"org-string">"⁡"</span>,
  <span class="org-string">"AMP"</span>: <span class=
"org-string">"&amp;"</span>,
  <span class="org-string">"amp"</span>: <span class=
"org-string">"&amp;"</span>,
  <span class="org-string">"ap;"</span>: <span class=
"org-string">"≈"</span>,
  <span class="org-string">"DD;"</span>: <span class=
"org-string">"ⅅ"</span>,
  <span class="org-string">"dd;"</span>: <span class=
"org-string">"ⅆ"</span>,
  <span class="org-string">"deg"</span>: <span class=
"org-string">"°"</span>,
  <span class="org-string">"ee;"</span>: <span class=
"org-string">"ⅇ"</span>,
  <span class="org-string">"eg;"</span>: <span class=
"org-string">"⪚"</span>,
  <span class="org-string">"el;"</span>: <span class=
"org-string">"⪙"</span>,
  <span class="org-string">"ETH"</span>: <span class=
"org-string">"Ð"</span>,
  <span class="org-string">"eth"</span>: <span class=
"org-string">"ð"</span>,
  <span class="org-string">"gE;"</span>: <span class=
"org-string">"≧"</span>,
  <span class="org-string">"ge;"</span>: <span class=
"org-string">"≥"</span>,
  <span class="org-string">"Gg;"</span>: <span class=
"org-string">"⋙"</span>,
  <span class="org-string">"gg;"</span>: <span class=
"org-string">"≫"</span>,
  <span class="org-string">"gl;"</span>: <span class=
"org-string">"≷"</span>,
  <span class="org-string">"GT;"</span>: <span class=
"org-string">"&gt;"</span>,
  <span class="org-string">"Gt;"</span>: <span class=
"org-string">"≫"</span>,
  <span class="org-string">"gt;"</span>: <span class=
"org-string">"&gt;"</span>,
  <span class="org-string">"ic;"</span>: <span class=
"org-string">"⁣"</span>,
  <span class="org-string">"ii;"</span>: <span class=
"org-string">"ⅈ"</span>,
  <span class="org-string">"Im;"</span>: <span class=
"org-string">"ℑ"</span>,
  <span class="org-string">"in;"</span>: <span class=
"org-string">"∈"</span>,
  <span class="org-string">"it;"</span>: <span class=
"org-string">"⁢"</span>,
  <span class="org-string">"lE;"</span>: <span class=
"org-string">"≦"</span>,
  <span class="org-string">"le;"</span>: <span class=
"org-string">"≤"</span>,
  <span class="org-string">"lg;"</span>: <span class=
"org-string">"≶"</span>,
  <span class="org-string">"Ll;"</span>: <span class=
"org-string">"⋘"</span>,
  <span class="org-string">"ll;"</span>: <span class=
"org-string">"≪"</span>,
  <span class="org-string">"LT;"</span>: <span class=
"org-string">"&lt;"</span>,
  <span class="org-string">"Lt;"</span>: <span class=
"org-string">"≪"</span>,
  <span class="org-string">"lt;"</span>: <span class=
"org-string">"&lt;"</span>,
  <span class="org-string">"mp;"</span>: <span class=
"org-string">"∓"</span>,
  <span class="org-string">"Mu;"</span>: <span class=
"org-string">"Μ"</span>,
  <span class="org-string">"mu;"</span>: <span class=
"org-string">"μ"</span>,
  <span class="org-string">"ne;"</span>: <span class=
"org-string">"≠"</span>,
  <span class="org-string">"ni;"</span>: <span class=
"org-string">"∋"</span>,
  <span class="org-string">"not"</span>: <span class=
"org-string">"¬"</span>,
  <span class="org-string">"Nu;"</span>: <span class=
"org-string">"Ν"</span>,
  <span class="org-string">"nu;"</span>: <span class=
"org-string">"ν"</span>,
  <span class="org-string">"Or;"</span>: <span class=
"org-string">"⩔"</span>,
  <span class="org-string">"or;"</span>: <span class=
"org-string">"∨"</span>,
  <span class="org-string">"oS;"</span>: <span class=
"org-string">"Ⓢ"</span>,
  <span class="org-string">"Pi;"</span>: <span class=
"org-string">"Π"</span>,
  <span class="org-string">"pi;"</span>: <span class=
"org-string">"π"</span>,
  <span class="org-string">"pm;"</span>: <span class=
"org-string">"±"</span>,
  <span class="org-string">"Pr;"</span>: <span class=
"org-string">"⪻"</span>,
  <span class="org-string">"pr;"</span>: <span class=
"org-string">"≺"</span>,
  <span class="org-string">"Re;"</span>: <span class=
"org-string">"ℜ"</span>,
  <span class="org-string">"REG"</span>: <span class=
"org-string">"®"</span>,
  <span class="org-string">"reg"</span>: <span class=
"org-string">"®"</span>,
  <span class="org-string">"rx;"</span>: <span class=
"org-string">"℞"</span>,
  <span class="org-string">"Sc;"</span>: <span class=
"org-string">"⪼"</span>,
  <span class="org-string">"sc;"</span>: <span class=
"org-string">"≻"</span>,
  <span class="org-string">"shy"</span>: <span class=
"org-string">"­"</span>,
  <span class="org-string">"uml"</span>: <span class=
"org-string">"¨"</span>,
  <span class="org-string">"wp;"</span>: <span class=
"org-string">"℘"</span>,
  <span class="org-string">"wr;"</span>: <span class=
"org-string">"≀"</span>,
  <span class="org-string">"Xi;"</span>: <span class=
"org-string">"Ξ"</span>,
  <span class="org-string">"xi;"</span>: <span class=
"org-string">"ξ"</span>,
  <span class="org-string">"yen"</span>: <span class=
"org-string">"¥"</span>,
  <span class="org-string">"acd;"</span>: <span class=
"org-string">"∿"</span>,
  <span class="org-string">"acE;"</span>: <span class=
"org-string">"∾̳"</span>,
  <span class="org-string">"Acy;"</span>: <span class=
"org-string">"А"</span>,
  <span class="org-string">"acy;"</span>: <span class=
"org-string">"а"</span>,
  <span class="org-string">"Afr;"</span>: <span class=
"org-string">"𝔄"</span>,
  <span class="org-string">"afr;"</span>: <span class=
"org-string">"𝔞"</span>,
  <span class="org-string">"AMP;"</span>: <span class=
"org-string">"&amp;"</span>,
  <span class="org-string">"amp;"</span>: <span class=
"org-string">"&amp;"</span>,
  <span class="org-string">"And;"</span>: <span class=
"org-string">"⩓"</span>,
  <span class="org-string">"and;"</span>: <span class=
"org-string">"∧"</span>,
  <span class="org-string">"ang;"</span>: <span class=
"org-string">"∠"</span>,
  <span class="org-string">"apE;"</span>: <span class=
"org-string">"⩰"</span>,
  <span class="org-string">"ape;"</span>: <span class=
"org-string">"≊"</span>,
  <span class="org-string">"ast;"</span>: <span class=
"org-string">"*"</span>,
  <span class="org-string">"Auml"</span>: <span class=
"org-string">"Ä"</span>,
  <span class="org-string">"auml"</span>: <span class=
"org-string">"ä"</span>,
  <span class="org-string">"Bcy;"</span>: <span class=
"org-string">"Б"</span>,
  <span class="org-string">"bcy;"</span>: <span class=
"org-string">"б"</span>,
  <span class="org-string">"Bfr;"</span>: <span class=
"org-string">"𝔅"</span>,
  <span class="org-string">"bfr;"</span>: <span class=
"org-string">"𝔟"</span>,
  <span class="org-string">"bne;"</span>: <span class=
"org-string">"=⃥"</span>,
  <span class="org-string">"bot;"</span>: <span class=
"org-string">"⊥"</span>,
  <span class="org-string">"Cap;"</span>: <span class=
"org-string">"⋒"</span>,
  <span class="org-string">"cap;"</span>: <span class=
"org-string">"∩"</span>,
  <span class="org-string">"cent"</span>: <span class=
"org-string">"¢"</span>,
  <span class="org-string">"Cfr;"</span>: <span class=
"org-string">"ℭ"</span>,
  <span class="org-string">"cfr;"</span>: <span class=
"org-string">"𝔠"</span>,
  <span class="org-string">"Chi;"</span>: <span class=
"org-string">"Χ"</span>,
  <span class="org-string">"chi;"</span>: <span class=
"org-string">"χ"</span>,
  <span class="org-string">"cir;"</span>: <span class=
"org-string">"○"</span>,
  <span class="org-string">"COPY"</span>: <span class=
"org-string">"©"</span>,
  <span class="org-string">"copy"</span>: <span class=
"org-string">"©"</span>,
  <span class="org-string">"Cup;"</span>: <span class=
"org-string">"⋓"</span>,
  <span class="org-string">"cup;"</span>: <span class=
"org-string">"∪"</span>,
  <span class="org-string">"Dcy;"</span>: <span class=
"org-string">"Д"</span>,
  <span class="org-string">"dcy;"</span>: <span class=
"org-string">"д"</span>,
  <span class="org-string">"deg;"</span>: <span class=
"org-string">"°"</span>,
  <span class="org-string">"Del;"</span>: <span class=
"org-string">"∇"</span>,
  <span class="org-string">"Dfr;"</span>: <span class=
"org-string">"𝔇"</span>,
  <span class="org-string">"dfr;"</span>: <span class=
"org-string">"𝔡"</span>,
  <span class="org-string">"die;"</span>: <span class=
"org-string">"¨"</span>,
  <span class="org-string">"div;"</span>: <span class=
"org-string">"÷"</span>,
  <span class="org-string">"Dot;"</span>: <span class=
"org-string">"¨"</span>,
  <span class="org-string">"dot;"</span>: <span class=
"org-string">"˙"</span>,
  <span class="org-string">"Ecy;"</span>: <span class=
"org-string">"Э"</span>,
  <span class="org-string">"ecy;"</span>: <span class=
"org-string">"э"</span>,
  <span class="org-string">"Efr;"</span>: <span class=
"org-string">"𝔈"</span>,
  <span class="org-string">"efr;"</span>: <span class=
"org-string">"𝔢"</span>,
  <span class="org-string">"egs;"</span>: <span class=
"org-string">"⪖"</span>,
  <span class="org-string">"ell;"</span>: <span class=
"org-string">"ℓ"</span>,
  <span class="org-string">"els;"</span>: <span class=
"org-string">"⪕"</span>,
  <span class="org-string">"ENG;"</span>: <span class=
"org-string">"Ŋ"</span>,
  <span class="org-string">"eng;"</span>: <span class=
"org-string">"ŋ"</span>,
  <span class="org-string">"Eta;"</span>: <span class=
"org-string">"Η"</span>,
  <span class="org-string">"eta;"</span>: <span class=
"org-string">"η"</span>,
  <span class="org-string">"ETH;"</span>: <span class=
"org-string">"Ð"</span>,
  <span class="org-string">"eth;"</span>: <span class=
"org-string">"ð"</span>,
  <span class="org-string">"Euml"</span>: <span class=
"org-string">"Ë"</span>,
  <span class="org-string">"euml"</span>: <span class=
"org-string">"ë"</span>,
  <span class="org-string">"Fcy;"</span>: <span class=
"org-string">"Ф"</span>,
  <span class="org-string">"fcy;"</span>: <span class=
"org-string">"ф"</span>,
  <span class="org-string">"Ffr;"</span>: <span class=
"org-string">"𝔉"</span>,
  <span class="org-string">"ffr;"</span>: <span class=
"org-string">"𝔣"</span>,
  <span class="org-string">"gap;"</span>: <span class=
"org-string">"⪆"</span>,
  <span class="org-string">"Gcy;"</span>: <span class=
"org-string">"Г"</span>,
  <span class="org-string">"gcy;"</span>: <span class=
"org-string">"г"</span>,
  <span class="org-string">"gEl;"</span>: <span class=
"org-string">"⪌"</span>,
  <span class="org-string">"gel;"</span>: <span class=
"org-string">"⋛"</span>,
  <span class="org-string">"geq;"</span>: <span class=
"org-string">"≥"</span>,
  <span class="org-string">"ges;"</span>: <span class=
"org-string">"⩾"</span>,
  <span class="org-string">"Gfr;"</span>: <span class=
"org-string">"𝔊"</span>,
  <span class="org-string">"gfr;"</span>: <span class=
"org-string">"𝔤"</span>,
  <span class="org-string">"ggg;"</span>: <span class=
"org-string">"⋙"</span>,
  <span class="org-string">"gla;"</span>: <span class=
"org-string">"⪥"</span>,
  <span class="org-string">"glE;"</span>: <span class=
"org-string">"⪒"</span>,
  <span class="org-string">"glj;"</span>: <span class=
"org-string">"⪤"</span>,
  <span class="org-string">"gnE;"</span>: <span class=
"org-string">"≩"</span>,
  <span class="org-string">"gne;"</span>: <span class=
"org-string">"⪈"</span>,
  <span class="org-string">"Hat;"</span>: <span class=
"org-string">"^"</span>,
  <span class="org-string">"Hfr;"</span>: <span class=
"org-string">"ℌ"</span>,
  <span class="org-string">"hfr;"</span>: <span class=
"org-string">"𝔥"</span>,
  <span class="org-string">"Icy;"</span>: <span class=
"org-string">"И"</span>,
  <span class="org-string">"icy;"</span>: <span class=
"org-string">"и"</span>,
  <span class="org-string">"iff;"</span>: <span class=
"org-string">"⇔"</span>,
  <span class="org-string">"Ifr;"</span>: <span class=
"org-string">"ℑ"</span>,
  <span class="org-string">"ifr;"</span>: <span class=
"org-string">"𝔦"</span>,
  <span class="org-string">"Int;"</span>: <span class=
"org-string">"∬"</span>,
  <span class="org-string">"int;"</span>: <span class=
"org-string">"∫"</span>,
  <span class="org-string">"Iuml"</span>: <span class=
"org-string">"Ï"</span>,
  <span class="org-string">"iuml"</span>: <span class=
"org-string">"ï"</span>,
  <span class="org-string">"Jcy;"</span>: <span class=
"org-string">"Й"</span>,
  <span class="org-string">"jcy;"</span>: <span class=
"org-string">"й"</span>,
  <span class="org-string">"Jfr;"</span>: <span class=
"org-string">"𝔍"</span>,
  <span class="org-string">"jfr;"</span>: <span class=
"org-string">"𝔧"</span>,
  <span class="org-string">"Kcy;"</span>: <span class=
"org-string">"К"</span>,
  <span class="org-string">"kcy;"</span>: <span class=
"org-string">"к"</span>,
  <span class="org-string">"Kfr;"</span>: <span class=
"org-string">"𝔎"</span>,
  <span class="org-string">"kfr;"</span>: <span class=
"org-string">"𝔨"</span>,
  <span class="org-string">"lap;"</span>: <span class=
"org-string">"⪅"</span>,
  <span class="org-string">"lat;"</span>: <span class=
"org-string">"⪫"</span>,
  <span class="org-string">"Lcy;"</span>: <span class=
"org-string">"Л"</span>,
  <span class="org-string">"lcy;"</span>: <span class=
"org-string">"л"</span>,
  <span class="org-string">"lEg;"</span>: <span class=
"org-string">"⪋"</span>,
  <span class="org-string">"leg;"</span>: <span class=
"org-string">"⋚"</span>,
  <span class="org-string">"leq;"</span>: <span class=
"org-string">"≤"</span>,
  <span class="org-string">"les;"</span>: <span class=
"org-string">"⩽"</span>,
  <span class="org-string">"Lfr;"</span>: <span class=
"org-string">"𝔏"</span>,
  <span class="org-string">"lfr;"</span>: <span class=
"org-string">"𝔩"</span>,
  <span class="org-string">"lgE;"</span>: <span class=
"org-string">"⪑"</span>,
  <span class="org-string">"lnE;"</span>: <span class=
"org-string">"≨"</span>,
  <span class="org-string">"lne;"</span>: <span class=
"org-string">"⪇"</span>,
  <span class="org-string">"loz;"</span>: <span class=
"org-string">"◊"</span>,
  <span class="org-string">"lrm;"</span>: <span class=
"org-string">"‎"</span>,
  <span class="org-string">"Lsh;"</span>: <span class=
"org-string">"↰"</span>,
  <span class="org-string">"lsh;"</span>: <span class=
"org-string">"↰"</span>,
  <span class="org-string">"macr"</span>: <span class=
"org-string">"¯"</span>,
  <span class="org-string">"Map;"</span>: <span class=
"org-string">"⤅"</span>,
  <span class="org-string">"map;"</span>: <span class=
"org-string">"↦"</span>,
  <span class="org-string">"Mcy;"</span>: <span class=
"org-string">"М"</span>,
  <span class="org-string">"mcy;"</span>: <span class=
"org-string">"м"</span>,
  <span class="org-string">"Mfr;"</span>: <span class=
"org-string">"𝔐"</span>,
  <span class="org-string">"mfr;"</span>: <span class=
"org-string">"𝔪"</span>,
  <span class="org-string">"mho;"</span>: <span class=
"org-string">"℧"</span>,
  <span class="org-string">"mid;"</span>: <span class=
"org-string">"∣"</span>,
  <span class="org-string">"nap;"</span>: <span class=
"org-string">"≉"</span>,
  <span class="org-string">"nbsp"</span>: <span class=
"org-string">" "</span>,
  <span class="org-string">"Ncy;"</span>: <span class=
"org-string">"Н"</span>,
  <span class="org-string">"ncy;"</span>: <span class=
"org-string">"н"</span>,
  <span class="org-string">"Nfr;"</span>: <span class=
"org-string">"𝔑"</span>,
  <span class="org-string">"nfr;"</span>: <span class=
"org-string">"𝔫"</span>,
  <span class="org-string">"ngE;"</span>: <span class=
"org-string">"≧̸"</span>,
  <span class="org-string">"nge;"</span>: <span class=
"org-string">"≱"</span>,
  <span class="org-string">"nGg;"</span>: <span class=
"org-string">"⋙̸"</span>,
  <span class="org-string">"nGt;"</span>: <span class=
"org-string">"≫⃒"</span>,
  <span class="org-string">"ngt;"</span>: <span class=
"org-string">"≯"</span>,
  <span class="org-string">"nis;"</span>: <span class=
"org-string">"⋼"</span>,
  <span class="org-string">"niv;"</span>: <span class=
"org-string">"∋"</span>,
  <span class="org-string">"nlE;"</span>: <span class=
"org-string">"≦̸"</span>,
  <span class="org-string">"nle;"</span>: <span class=
"org-string">"≰"</span>,
  <span class="org-string">"nLl;"</span>: <span class=
"org-string">"⋘̸"</span>,
  <span class="org-string">"nLt;"</span>: <span class=
"org-string">"≪⃒"</span>,
  <span class="org-string">"nlt;"</span>: <span class=
"org-string">"≮"</span>,
  <span class="org-string">"Not;"</span>: <span class=
"org-string">"⫬"</span>,
  <span class="org-string">"not;"</span>: <span class=
"org-string">"¬"</span>,
  <span class="org-string">"npr;"</span>: <span class=
"org-string">"⊀"</span>,
  <span class="org-string">"nsc;"</span>: <span class=
"org-string">"⊁"</span>,
  <span class="org-string">"num;"</span>: <span class=
"org-string">"#"</span>,
  <span class="org-string">"Ocy;"</span>: <span class=
"org-string">"О"</span>,
  <span class="org-string">"ocy;"</span>: <span class=
"org-string">"о"</span>,
  <span class="org-string">"Ofr;"</span>: <span class=
"org-string">"𝔒"</span>,
  <span class="org-string">"ofr;"</span>: <span class=
"org-string">"𝔬"</span>,
  <span class="org-string">"ogt;"</span>: <span class=
"org-string">"⧁"</span>,
  <span class="org-string">"ohm;"</span>: <span class=
"org-string">"Ω"</span>,
  <span class="org-string">"olt;"</span>: <span class=
"org-string">"⧀"</span>,
  <span class="org-string">"ord;"</span>: <span class=
"org-string">"⩝"</span>,
  <span class="org-string">"ordf"</span>: <span class=
"org-string">"ª"</span>,
  <span class="org-string">"ordm"</span>: <span class=
"org-string">"º"</span>,
  <span class="org-string">"orv;"</span>: <span class=
"org-string">"⩛"</span>,
  <span class="org-string">"Ouml"</span>: <span class=
"org-string">"Ö"</span>,
  <span class="org-string">"ouml"</span>: <span class=
"org-string">"ö"</span>,
  <span class="org-string">"par;"</span>: <span class=
"org-string">"∥"</span>,
  <span class="org-string">"para"</span>: <span class=
"org-string">"¶"</span>,
  <span class="org-string">"Pcy;"</span>: <span class=
"org-string">"П"</span>,
  <span class="org-string">"pcy;"</span>: <span class=
"org-string">"п"</span>,
  <span class="org-string">"Pfr;"</span>: <span class=
"org-string">"𝔓"</span>,
  <span class="org-string">"pfr;"</span>: <span class=
"org-string">"𝔭"</span>,
  <span class="org-string">"Phi;"</span>: <span class=
"org-string">"Φ"</span>,
  <span class="org-string">"phi;"</span>: <span class=
"org-string">"φ"</span>,
  <span class="org-string">"piv;"</span>: <span class=
"org-string">"ϖ"</span>,
  <span class="org-string">"prE;"</span>: <span class=
"org-string">"⪳"</span>,
  <span class="org-string">"pre;"</span>: <span class=
"org-string">"⪯"</span>,
  <span class="org-string">"Psi;"</span>: <span class=
"org-string">"Ψ"</span>,
  <span class="org-string">"psi;"</span>: <span class=
"org-string">"ψ"</span>,
  <span class="org-string">"Qfr;"</span>: <span class=
"org-string">"𝔔"</span>,
  <span class="org-string">"qfr;"</span>: <span class=
"org-string">"𝔮"</span>,
  <span class="org-string">"QUOT"</span>: <span class=
"org-string">"\""</span>,
  <span class="org-string">"quot"</span>: <span class=
"org-string">"\""</span>,
  <span class="org-string">"Rcy;"</span>: <span class=
"org-string">"Р"</span>,
  <span class="org-string">"rcy;"</span>: <span class=
"org-string">"р"</span>,
  <span class="org-string">"REG;"</span>: <span class=
"org-string">"®"</span>,
  <span class="org-string">"reg;"</span>: <span class=
"org-string">"®"</span>,
  <span class="org-string">"Rfr;"</span>: <span class=
"org-string">"ℜ"</span>,
  <span class="org-string">"rfr;"</span>: <span class=
"org-string">"𝔯"</span>,
  <span class="org-string">"Rho;"</span>: <span class=
"org-string">"Ρ"</span>,
  <span class="org-string">"rho;"</span>: <span class=
"org-string">"ρ"</span>,
  <span class="org-string">"rlm;"</span>: <span class=
"org-string">"‏"</span>,
  <span class="org-string">"Rsh;"</span>: <span class=
"org-string">"↱"</span>,
  <span class="org-string">"rsh;"</span>: <span class=
"org-string">"↱"</span>,
  <span class="org-string">"scE;"</span>: <span class=
"org-string">"⪴"</span>,
  <span class="org-string">"sce;"</span>: <span class=
"org-string">"⪰"</span>,
  <span class="org-string">"Scy;"</span>: <span class=
"org-string">"С"</span>,
  <span class="org-string">"scy;"</span>: <span class=
"org-string">"с"</span>,
  <span class="org-string">"sect"</span>: <span class=
"org-string">"§"</span>,
  <span class="org-string">"Sfr;"</span>: <span class=
"org-string">"𝔖"</span>,
  <span class="org-string">"sfr;"</span>: <span class=
"org-string">"𝔰"</span>,
  <span class="org-string">"shy;"</span>: <span class=
"org-string">"­"</span>,
  <span class="org-string">"sim;"</span>: <span class=
"org-string">"∼"</span>,
  <span class="org-string">"smt;"</span>: <span class=
"org-string">"⪪"</span>,
  <span class="org-string">"sol;"</span>: <span class=
"org-string">"/"</span>,
  <span class="org-string">"squ;"</span>: <span class=
"org-string">"□"</span>,
  <span class="org-string">"Sub;"</span>: <span class=
"org-string">"⋐"</span>,
  <span class="org-string">"sub;"</span>: <span class=
"org-string">"⊂"</span>,
  <span class="org-string">"Sum;"</span>: <span class=
"org-string">"∑"</span>,
  <span class="org-string">"sum;"</span>: <span class=
"org-string">"∑"</span>,
  <span class="org-string">"Sup;"</span>: <span class=
"org-string">"⋑"</span>,
  <span class="org-string">"sup;"</span>: <span class=
"org-string">"⊃"</span>,
  <span class="org-string">"sup1"</span>: <span class=
"org-string">"¹"</span>,
  <span class="org-string">"sup2"</span>: <span class=
"org-string">"²"</span>,
  <span class="org-string">"sup3"</span>: <span class=
"org-string">"³"</span>,
  <span class="org-string">"Tab;"</span>: <span class=
"org-string">"\t"</span>,
  <span class="org-string">"Tau;"</span>: <span class=
"org-string">"Τ"</span>,
  <span class="org-string">"tau;"</span>: <span class=
"org-string">"τ"</span>,
  <span class="org-string">"Tcy;"</span>: <span class=
"org-string">"Т"</span>,
  <span class="org-string">"tcy;"</span>: <span class=
"org-string">"т"</span>,
  <span class="org-string">"Tfr;"</span>: <span class=
"org-string">"𝔗"</span>,
  <span class="org-string">"tfr;"</span>: <span class=
"org-string">"𝔱"</span>,
  <span class="org-string">"top;"</span>: <span class=
"org-string">"⊤"</span>,
  <span class="org-string">"Ucy;"</span>: <span class=
"org-string">"У"</span>,
  <span class="org-string">"ucy;"</span>: <span class=
"org-string">"у"</span>,
  <span class="org-string">"Ufr;"</span>: <span class=
"org-string">"𝔘"</span>,
  <span class="org-string">"ufr;"</span>: <span class=
"org-string">"𝔲"</span>,
  <span class="org-string">"uml;"</span>: <span class=
"org-string">"¨"</span>,
  <span class="org-string">"Uuml"</span>: <span class=
"org-string">"Ü"</span>,
  <span class="org-string">"uuml"</span>: <span class=
"org-string">"ü"</span>,
  <span class="org-string">"Vcy;"</span>: <span class=
"org-string">"В"</span>,
  <span class="org-string">"vcy;"</span>: <span class=
"org-string">"в"</span>,
  <span class="org-string">"Vee;"</span>: <span class=
"org-string">"⋁"</span>,
  <span class="org-string">"vee;"</span>: <span class=
"org-string">"∨"</span>,
  <span class="org-string">"Vfr;"</span>: <span class=
"org-string">"𝔙"</span>,
  <span class="org-string">"vfr;"</span>: <span class=
"org-string">"𝔳"</span>,
  <span class="org-string">"Wfr;"</span>: <span class=
"org-string">"𝔚"</span>,
  <span class="org-string">"wfr;"</span>: <span class=
"org-string">"𝔴"</span>,
  <span class="org-string">"Xfr;"</span>: <span class=
"org-string">"𝔛"</span>,
  <span class="org-string">"xfr;"</span>: <span class=
"org-string">"𝔵"</span>,
  <span class="org-string">"Ycy;"</span>: <span class=
"org-string">"Ы"</span>,
  <span class="org-string">"ycy;"</span>: <span class=
"org-string">"ы"</span>,
  <span class="org-string">"yen;"</span>: <span class=
"org-string">"¥"</span>,
  <span class="org-string">"Yfr;"</span>: <span class=
"org-string">"𝔜"</span>,
  <span class="org-string">"yfr;"</span>: <span class=
"org-string">"𝔶"</span>,
  <span class="org-string">"yuml"</span>: <span class=
"org-string">"ÿ"</span>,
  <span class="org-string">"Zcy;"</span>: <span class=
"org-string">"З"</span>,
  <span class="org-string">"zcy;"</span>: <span class=
"org-string">"з"</span>,
  <span class="org-string">"Zfr;"</span>: <span class=
"org-string">"ℨ"</span>,
  <span class="org-string">"zfr;"</span>: <span class=
"org-string">"𝔷"</span>,
  <span class="org-string">"zwj;"</span>: <span class=
"org-string">"‍"</span>,
  <span class="org-string">"Acirc"</span>: <span class=
"org-string">"Â"</span>,
  <span class="org-string">"acirc"</span>: <span class=
"org-string">"â"</span>,
  <span class="org-string">"acute"</span>: <span class=
"org-string">"´"</span>,
  <span class="org-string">"AElig"</span>: <span class=
"org-string">"Æ"</span>,
  <span class="org-string">"aelig"</span>: <span class=
"org-string">"æ"</span>,
  <span class="org-string">"andd;"</span>: <span class=
"org-string">"⩜"</span>,
  <span class="org-string">"andv;"</span>: <span class=
"org-string">"⩚"</span>,
  <span class="org-string">"ange;"</span>: <span class=
"org-string">"⦤"</span>,
  <span class="org-string">"Aopf;"</span>: <span class=
"org-string">"𝔸"</span>,
  <span class="org-string">"aopf;"</span>: <span class=
"org-string">"𝕒"</span>,
  <span class="org-string">"apid;"</span>: <span class=
"org-string">"≋"</span>,
  <span class="org-string">"apos;"</span>: <span class=
"org-string">"'"</span>,
  <span class="org-string">"Aring"</span>: <span class=
"org-string">"Å"</span>,
  <span class="org-string">"aring"</span>: <span class=
"org-string">"å"</span>,
  <span class="org-string">"Ascr;"</span>: <span class=
"org-string">"𝒜"</span>,
  <span class="org-string">"ascr;"</span>: <span class=
"org-string">"𝒶"</span>,
  <span class="org-string">"Auml;"</span>: <span class=
"org-string">"Ä"</span>,
  <span class="org-string">"auml;"</span>: <span class=
"org-string">"ä"</span>,
  <span class="org-string">"Barv;"</span>: <span class=
"org-string">"⫧"</span>,
  <span class="org-string">"bbrk;"</span>: <span class=
"org-string">"⎵"</span>,
  <span class="org-string">"Beta;"</span>: <span class=
"org-string">"Β"</span>,
  <span class="org-string">"beta;"</span>: <span class=
"org-string">"β"</span>,
  <span class="org-string">"beth;"</span>: <span class=
"org-string">"ℶ"</span>,
  <span class="org-string">"bNot;"</span>: <span class=
"org-string">"⫭"</span>,
  <span class="org-string">"bnot;"</span>: <span class=
"org-string">"⌐"</span>,
  <span class="org-string">"Bopf;"</span>: <span class=
"org-string">"𝔹"</span>,
  <span class="org-string">"bopf;"</span>: <span class=
"org-string">"𝕓"</span>,
  <span class="org-string">"boxH;"</span>: <span class=
"org-string">"═"</span>,
  <span class="org-string">"boxh;"</span>: <span class=
"org-string">"─"</span>,
  <span class="org-string">"boxV;"</span>: <span class=
"org-string">"║"</span>,
  <span class="org-string">"boxv;"</span>: <span class=
"org-string">"│"</span>,
  <span class="org-string">"Bscr;"</span>: <span class=
"org-string">"ℬ"</span>,
  <span class="org-string">"bscr;"</span>: <span class=
"org-string">"𝒷"</span>,
  <span class="org-string">"bsim;"</span>: <span class=
"org-string">"∽"</span>,
  <span class="org-string">"bsol;"</span>: <span class=
"org-string">"\\"</span>,
  <span class="org-string">"bull;"</span>: <span class=
"org-string">"•"</span>,
  <span class="org-string">"bump;"</span>: <span class=
"org-string">"≎"</span>,
  <span class="org-string">"caps;"</span>: <span class=
"org-string">"∩︀"</span>,
  <span class="org-string">"Cdot;"</span>: <span class=
"org-string">"Ċ"</span>,
  <span class="org-string">"cdot;"</span>: <span class=
"org-string">"ċ"</span>,
  <span class="org-string">"cedil"</span>: <span class=
"org-string">"¸"</span>,
  <span class="org-string">"cent;"</span>: <span class=
"org-string">"¢"</span>,
  <span class="org-string">"CHcy;"</span>: <span class=
"org-string">"Ч"</span>,
  <span class="org-string">"chcy;"</span>: <span class=
"org-string">"ч"</span>,
  <span class="org-string">"circ;"</span>: <span class=
"org-string">"ˆ"</span>,
  <span class="org-string">"cirE;"</span>: <span class=
"org-string">"⧃"</span>,
  <span class="org-string">"cire;"</span>: <span class=
"org-string">"≗"</span>,
  <span class="org-string">"comp;"</span>: <span class=
"org-string">"∁"</span>,
  <span class="org-string">"cong;"</span>: <span class=
"org-string">"≅"</span>,
  <span class="org-string">"Copf;"</span>: <span class=
"org-string">"ℂ"</span>,
  <span class="org-string">"copf;"</span>: <span class=
"org-string">"𝕔"</span>,
  <span class="org-string">"COPY;"</span>: <span class=
"org-string">"©"</span>,
  <span class="org-string">"copy;"</span>: <span class=
"org-string">"©"</span>,
  <span class="org-string">"Cscr;"</span>: <span class=
"org-string">"𝒞"</span>,
  <span class="org-string">"cscr;"</span>: <span class=
"org-string">"𝒸"</span>,
  <span class="org-string">"csub;"</span>: <span class=
"org-string">"⫏"</span>,
  <span class="org-string">"csup;"</span>: <span class=
"org-string">"⫐"</span>,
  <span class="org-string">"cups;"</span>: <span class=
"org-string">"∪︀"</span>,
  <span class="org-string">"Darr;"</span>: <span class=
"org-string">"↡"</span>,
  <span class="org-string">"dArr;"</span>: <span class=
"org-string">"⇓"</span>,
  <span class="org-string">"darr;"</span>: <span class=
"org-string">"↓"</span>,
  <span class="org-string">"dash;"</span>: <span class=
"org-string">"‐"</span>,
  <span class="org-string">"dHar;"</span>: <span class=
"org-string">"⥥"</span>,
  <span class="org-string">"diam;"</span>: <span class=
"org-string">"⋄"</span>,
  <span class="org-string">"DJcy;"</span>: <span class=
"org-string">"Ђ"</span>,
  <span class="org-string">"djcy;"</span>: <span class=
"org-string">"ђ"</span>,
  <span class="org-string">"Dopf;"</span>: <span class=
"org-string">"𝔻"</span>,
  <span class="org-string">"dopf;"</span>: <span class=
"org-string">"𝕕"</span>,
  <span class="org-string">"Dscr;"</span>: <span class=
"org-string">"𝒟"</span>,
  <span class="org-string">"dscr;"</span>: <span class=
"org-string">"𝒹"</span>,
  <span class="org-string">"DScy;"</span>: <span class=
"org-string">"Ѕ"</span>,
  <span class="org-string">"dscy;"</span>: <span class=
"org-string">"ѕ"</span>,
  <span class="org-string">"dsol;"</span>: <span class=
"org-string">"⧶"</span>,
  <span class="org-string">"dtri;"</span>: <span class=
"org-string">"▿"</span>,
  <span class="org-string">"DZcy;"</span>: <span class=
"org-string">"Џ"</span>,
  <span class="org-string">"dzcy;"</span>: <span class=
"org-string">"џ"</span>,
  <span class="org-string">"ecir;"</span>: <span class=
"org-string">"≖"</span>,
  <span class="org-string">"Ecirc"</span>: <span class=
"org-string">"Ê"</span>,
  <span class="org-string">"ecirc"</span>: <span class=
"org-string">"ê"</span>,
  <span class="org-string">"Edot;"</span>: <span class=
"org-string">"Ė"</span>,
  <span class="org-string">"eDot;"</span>: <span class=
"org-string">"≑"</span>,
  <span class="org-string">"edot;"</span>: <span class=
"org-string">"ė"</span>,
  <span class="org-string">"emsp;"</span>: <span class=
"org-string">" "</span>,
  <span class="org-string">"ensp;"</span>: <span class=
"org-string">" "</span>,
  <span class="org-string">"Eopf;"</span>: <span class=
"org-string">"𝔼"</span>,
  <span class="org-string">"eopf;"</span>: <span class=
"org-string">"𝕖"</span>,
  <span class="org-string">"epar;"</span>: <span class=
"org-string">"⋕"</span>,
  <span class="org-string">"epsi;"</span>: <span class=
"org-string">"ε"</span>,
  <span class="org-string">"Escr;"</span>: <span class=
"org-string">"ℰ"</span>,
  <span class="org-string">"escr;"</span>: <span class=
"org-string">"ℯ"</span>,
  <span class="org-string">"Esim;"</span>: <span class=
"org-string">"⩳"</span>,
  <span class="org-string">"esim;"</span>: <span class=
"org-string">"≂"</span>,
  <span class="org-string">"Euml;"</span>: <span class=
"org-string">"Ë"</span>,
  <span class="org-string">"euml;"</span>: <span class=
"org-string">"ë"</span>,
  <span class="org-string">"euro;"</span>: <span class=
"org-string">"€"</span>,
  <span class="org-string">"excl;"</span>: <span class=
"org-string">"!"</span>,
  <span class="org-string">"flat;"</span>: <span class=
"org-string">"♭"</span>,
  <span class="org-string">"fnof;"</span>: <span class=
"org-string">"ƒ"</span>,
  <span class="org-string">"Fopf;"</span>: <span class=
"org-string">"𝔽"</span>,
  <span class="org-string">"fopf;"</span>: <span class=
"org-string">"𝕗"</span>,
  <span class="org-string">"fork;"</span>: <span class=
"org-string">"⋔"</span>,
  <span class="org-string">"Fscr;"</span>: <span class=
"org-string">"ℱ"</span>,
  <span class="org-string">"fscr;"</span>: <span class=
"org-string">"𝒻"</span>,
  <span class="org-string">"Gdot;"</span>: <span class=
"org-string">"Ġ"</span>,
  <span class="org-string">"gdot;"</span>: <span class=
"org-string">"ġ"</span>,
  <span class="org-string">"geqq;"</span>: <span class=
"org-string">"≧"</span>,
  <span class="org-string">"gesl;"</span>: <span class=
"org-string">"⋛︀"</span>,
  <span class="org-string">"GJcy;"</span>: <span class=
"org-string">"Ѓ"</span>,
  <span class="org-string">"gjcy;"</span>: <span class=
"org-string">"ѓ"</span>,
  <span class="org-string">"gnap;"</span>: <span class=
"org-string">"⪊"</span>,
  <span class="org-string">"gneq;"</span>: <span class=
"org-string">"⪈"</span>,
  <span class="org-string">"Gopf;"</span>: <span class=
"org-string">"𝔾"</span>,
  <span class="org-string">"gopf;"</span>: <span class=
"org-string">"𝕘"</span>,
  <span class="org-string">"Gscr;"</span>: <span class=
"org-string">"𝒢"</span>,
  <span class="org-string">"gscr;"</span>: <span class=
"org-string">"ℊ"</span>,
  <span class="org-string">"gsim;"</span>: <span class=
"org-string">"≳"</span>,
  <span class="org-string">"gtcc;"</span>: <span class=
"org-string">"⪧"</span>,
  <span class="org-string">"gvnE;"</span>: <span class=
"org-string">"≩︀"</span>,
  <span class="org-string">"half;"</span>: <span class=
"org-string">"½"</span>,
  <span class="org-string">"hArr;"</span>: <span class=
"org-string">"⇔"</span>,
  <span class="org-string">"harr;"</span>: <span class=
"org-string">"↔"</span>,
  <span class="org-string">"hbar;"</span>: <span class=
"org-string">"ℏ"</span>,
  <span class="org-string">"Hopf;"</span>: <span class=
"org-string">"ℍ"</span>,
  <span class="org-string">"hopf;"</span>: <span class=
"org-string">"𝕙"</span>,
  <span class="org-string">"Hscr;"</span>: <span class=
"org-string">"ℋ"</span>,
  <span class="org-string">"hscr;"</span>: <span class=
"org-string">"𝒽"</span>,
  <span class="org-string">"Icirc"</span>: <span class=
"org-string">"Î"</span>,
  <span class="org-string">"icirc"</span>: <span class=
"org-string">"î"</span>,
  <span class="org-string">"Idot;"</span>: <span class=
"org-string">"İ"</span>,
  <span class="org-string">"IEcy;"</span>: <span class=
"org-string">"Е"</span>,
  <span class="org-string">"iecy;"</span>: <span class=
"org-string">"е"</span>,
  <span class="org-string">"iexcl"</span>: <span class=
"org-string">"¡"</span>,
  <span class="org-string">"imof;"</span>: <span class=
"org-string">"⊷"</span>,
  <span class="org-string">"IOcy;"</span>: <span class=
"org-string">"Ё"</span>,
  <span class="org-string">"iocy;"</span>: <span class=
"org-string">"ё"</span>,
  <span class="org-string">"Iopf;"</span>: <span class=
"org-string">"𝕀"</span>,
  <span class="org-string">"iopf;"</span>: <span class=
"org-string">"𝕚"</span>,
  <span class="org-string">"Iota;"</span>: <span class=
"org-string">"Ι"</span>,
  <span class="org-string">"iota;"</span>: <span class=
"org-string">"ι"</span>,
  <span class="org-string">"Iscr;"</span>: <span class=
"org-string">"ℐ"</span>,
  <span class="org-string">"iscr;"</span>: <span class=
"org-string">"𝒾"</span>,
  <span class="org-string">"isin;"</span>: <span class=
"org-string">"∈"</span>,
  <span class="org-string">"Iuml;"</span>: <span class=
"org-string">"Ï"</span>,
  <span class="org-string">"iuml;"</span>: <span class=
"org-string">"ï"</span>,
  <span class="org-string">"Jopf;"</span>: <span class=
"org-string">"𝕁"</span>,
  <span class="org-string">"jopf;"</span>: <span class=
"org-string">"𝕛"</span>,
  <span class="org-string">"Jscr;"</span>: <span class=
"org-string">"𝒥"</span>,
  <span class="org-string">"jscr;"</span>: <span class=
"org-string">"𝒿"</span>,
  <span class="org-string">"KHcy;"</span>: <span class=
"org-string">"Х"</span>,
  <span class="org-string">"khcy;"</span>: <span class=
"org-string">"х"</span>,
  <span class="org-string">"KJcy;"</span>: <span class=
"org-string">"Ќ"</span>,
  <span class="org-string">"kjcy;"</span>: <span class=
"org-string">"ќ"</span>,
  <span class="org-string">"Kopf;"</span>: <span class=
"org-string">"𝕂"</span>,
  <span class="org-string">"kopf;"</span>: <span class=
"org-string">"𝕜"</span>,
  <span class="org-string">"Kscr;"</span>: <span class=
"org-string">"𝒦"</span>,
  <span class="org-string">"kscr;"</span>: <span class=
"org-string">"𝓀"</span>,
  <span class="org-string">"Lang;"</span>: <span class=
"org-string">"⟪"</span>,
  <span class="org-string">"lang;"</span>: <span class=
"org-string">"⟨"</span>,
  <span class="org-string">"laquo"</span>: <span class=
"org-string">"«"</span>,
  <span class="org-string">"Larr;"</span>: <span class=
"org-string">"↞"</span>,
  <span class="org-string">"lArr;"</span>: <span class=
"org-string">"⇐"</span>,
  <span class="org-string">"larr;"</span>: <span class=
"org-string">"←"</span>,
  <span class="org-string">"late;"</span>: <span class=
"org-string">"⪭"</span>,
  <span class="org-string">"lcub;"</span>: <span class=
"org-string">"{"</span>,
  <span class="org-string">"ldca;"</span>: <span class=
"org-string">"⤶"</span>,
  <span class="org-string">"ldsh;"</span>: <span class=
"org-string">"↲"</span>,
  <span class="org-string">"leqq;"</span>: <span class=
"org-string">"≦"</span>,
  <span class="org-string">"lesg;"</span>: <span class=
"org-string">"⋚︀"</span>,
  <span class="org-string">"lHar;"</span>: <span class=
"org-string">"⥢"</span>,
  <span class="org-string">"LJcy;"</span>: <span class=
"org-string">"Љ"</span>,
  <span class="org-string">"ljcy;"</span>: <span class=
"org-string">"љ"</span>,
  <span class="org-string">"lnap;"</span>: <span class=
"org-string">"⪉"</span>,
  <span class="org-string">"lneq;"</span>: <span class=
"org-string">"⪇"</span>,
  <span class="org-string">"Lopf;"</span>: <span class=
"org-string">"𝕃"</span>,
  <span class="org-string">"lopf;"</span>: <span class=
"org-string">"𝕝"</span>,
  <span class="org-string">"lozf;"</span>: <span class=
"org-string">"⧫"</span>,
  <span class="org-string">"lpar;"</span>: <span class=
"org-string">"("</span>,
  <span class="org-string">"Lscr;"</span>: <span class=
"org-string">"ℒ"</span>,
  <span class="org-string">"lscr;"</span>: <span class=
"org-string">"𝓁"</span>,
  <span class="org-string">"lsim;"</span>: <span class=
"org-string">"≲"</span>,
  <span class="org-string">"lsqb;"</span>: <span class=
"org-string">"["</span>,
  <span class="org-string">"ltcc;"</span>: <span class=
"org-string">"⪦"</span>,
  <span class="org-string">"ltri;"</span>: <span class=
"org-string">"◃"</span>,
  <span class="org-string">"lvnE;"</span>: <span class=
"org-string">"≨︀"</span>,
  <span class="org-string">"macr;"</span>: <span class=
"org-string">"¯"</span>,
  <span class="org-string">"male;"</span>: <span class=
"org-string">"♂"</span>,
  <span class="org-string">"malt;"</span>: <span class=
"org-string">"✠"</span>,
  <span class="org-string">"micro"</span>: <span class=
"org-string">"µ"</span>,
  <span class="org-string">"mlcp;"</span>: <span class=
"org-string">"⫛"</span>,
  <span class="org-string">"mldr;"</span>: <span class=
"org-string">"…"</span>,
  <span class="org-string">"Mopf;"</span>: <span class=
"org-string">"𝕄"</span>,
  <span class="org-string">"mopf;"</span>: <span class=
"org-string">"𝕞"</span>,
  <span class="org-string">"Mscr;"</span>: <span class=
"org-string">"ℳ"</span>,
  <span class="org-string">"mscr;"</span>: <span class=
"org-string">"𝓂"</span>,
  <span class="org-string">"nang;"</span>: <span class=
"org-string">"∠⃒"</span>,
  <span class="org-string">"napE;"</span>: <span class=
"org-string">"⩰̸"</span>,
  <span class="org-string">"nbsp;"</span>: <span class=
"org-string">" "</span>,
  <span class="org-string">"ncap;"</span>: <span class=
"org-string">"⩃"</span>,
  <span class="org-string">"ncup;"</span>: <span class=
"org-string">"⩂"</span>,
  <span class="org-string">"ngeq;"</span>: <span class=
"org-string">"≱"</span>,
  <span class="org-string">"nges;"</span>: <span class=
"org-string">"⩾̸"</span>,
  <span class="org-string">"ngtr;"</span>: <span class=
"org-string">"≯"</span>,
  <span class="org-string">"nGtv;"</span>: <span class=
"org-string">"≫̸"</span>,
  <span class="org-string">"nisd;"</span>: <span class=
"org-string">"⋺"</span>,
  <span class="org-string">"NJcy;"</span>: <span class=
"org-string">"Њ"</span>,
  <span class="org-string">"njcy;"</span>: <span class=
"org-string">"њ"</span>,
  <span class="org-string">"nldr;"</span>: <span class=
"org-string">"‥"</span>,
  <span class="org-string">"nleq;"</span>: <span class=
"org-string">"≰"</span>,
  <span class="org-string">"nles;"</span>: <span class=
"org-string">"⩽̸"</span>,
  <span class="org-string">"nLtv;"</span>: <span class=
"org-string">"≪̸"</span>,
  <span class="org-string">"nmid;"</span>: <span class=
"org-string">"∤"</span>,
  <span class="org-string">"Nopf;"</span>: <span class=
"org-string">"ℕ"</span>,
  <span class="org-string">"nopf;"</span>: <span class=
"org-string">"𝕟"</span>,
  <span class="org-string">"npar;"</span>: <span class=
"org-string">"∦"</span>,
  <span class="org-string">"npre;"</span>: <span class=
"org-string">"⪯̸"</span>,
  <span class="org-string">"nsce;"</span>: <span class=
"org-string">"⪰̸"</span>,
  <span class="org-string">"Nscr;"</span>: <span class=
"org-string">"𝒩"</span>,
  <span class="org-string">"nscr;"</span>: <span class=
"org-string">"𝓃"</span>,
  <span class="org-string">"nsim;"</span>: <span class=
"org-string">"≁"</span>,
  <span class="org-string">"nsub;"</span>: <span class=
"org-string">"⊄"</span>,
  <span class="org-string">"nsup;"</span>: <span class=
"org-string">"⊅"</span>,
  <span class="org-string">"ntgl;"</span>: <span class=
"org-string">"≹"</span>,
  <span class="org-string">"ntlg;"</span>: <span class=
"org-string">"≸"</span>,
  <span class="org-string">"nvap;"</span>: <span class=
"org-string">"≍⃒"</span>,
  <span class="org-string">"nvge;"</span>: <span class=
"org-string">"≥⃒"</span>,
  <span class="org-string">"nvgt;"</span>: <span class=
"org-string">"&gt;⃒"</span>,
  <span class="org-string">"nvle;"</span>: <span class=
"org-string">"≤⃒"</span>,
  <span class="org-string">"nvlt;"</span>: <span class=
"org-string">"&lt;⃒"</span>,
  <span class="org-string">"oast;"</span>: <span class=
"org-string">"⊛"</span>,
  <span class="org-string">"ocir;"</span>: <span class=
"org-string">"⊚"</span>,
  <span class="org-string">"Ocirc"</span>: <span class=
"org-string">"Ô"</span>,
  <span class="org-string">"ocirc"</span>: <span class=
"org-string">"ô"</span>,
  <span class="org-string">"odiv;"</span>: <span class=
"org-string">"⨸"</span>,
  <span class="org-string">"odot;"</span>: <span class=
"org-string">"⊙"</span>,
  <span class="org-string">"ogon;"</span>: <span class=
"org-string">"˛"</span>,
  <span class="org-string">"oint;"</span>: <span class=
"org-string">"∮"</span>,
  <span class="org-string">"omid;"</span>: <span class=
"org-string">"⦶"</span>,
  <span class="org-string">"Oopf;"</span>: <span class=
"org-string">"𝕆"</span>,
  <span class="org-string">"oopf;"</span>: <span class=
"org-string">"𝕠"</span>,
  <span class="org-string">"opar;"</span>: <span class=
"org-string">"⦷"</span>,
  <span class="org-string">"ordf;"</span>: <span class=
"org-string">"ª"</span>,
  <span class="org-string">"ordm;"</span>: <span class=
"org-string">"º"</span>,
  <span class="org-string">"oror;"</span>: <span class=
"org-string">"⩖"</span>,
  <span class="org-string">"Oscr;"</span>: <span class=
"org-string">"𝒪"</span>,
  <span class="org-string">"oscr;"</span>: <span class=
"org-string">"ℴ"</span>,
  <span class="org-string">"osol;"</span>: <span class=
"org-string">"⊘"</span>,
  <span class="org-string">"Ouml;"</span>: <span class=
"org-string">"Ö"</span>,
  <span class="org-string">"ouml;"</span>: <span class=
"org-string">"ö"</span>,
  <span class="org-string">"para;"</span>: <span class=
"org-string">"¶"</span>,
  <span class="org-string">"part;"</span>: <span class=
"org-string">"∂"</span>,
  <span class="org-string">"perp;"</span>: <span class=
"org-string">"⊥"</span>,
  <span class="org-string">"phiv;"</span>: <span class=
"org-string">"ϕ"</span>,
  <span class="org-string">"plus;"</span>: <span class=
"org-string">"+"</span>,
  <span class="org-string">"Popf;"</span>: <span class=
"org-string">"ℙ"</span>,
  <span class="org-string">"popf;"</span>: <span class=
"org-string">"𝕡"</span>,
  <span class="org-string">"pound"</span>: <span class=
"org-string">"£"</span>,
  <span class="org-string">"prap;"</span>: <span class=
"org-string">"⪷"</span>,
  <span class="org-string">"prec;"</span>: <span class=
"org-string">"≺"</span>,
  <span class="org-string">"prnE;"</span>: <span class=
"org-string">"⪵"</span>,
  <span class="org-string">"prod;"</span>: <span class=
"org-string">"∏"</span>,
  <span class="org-string">"prop;"</span>: <span class=
"org-string">"∝"</span>,
  <span class="org-string">"Pscr;"</span>: <span class=
"org-string">"𝒫"</span>,
  <span class="org-string">"pscr;"</span>: <span class=
"org-string">"𝓅"</span>,
  <span class="org-string">"qint;"</span>: <span class=
"org-string">"⨌"</span>,
  <span class="org-string">"Qopf;"</span>: <span class=
"org-string">"ℚ"</span>,
  <span class="org-string">"qopf;"</span>: <span class=
"org-string">"𝕢"</span>,
  <span class="org-string">"Qscr;"</span>: <span class=
"org-string">"𝒬"</span>,
  <span class="org-string">"qscr;"</span>: <span class=
"org-string">"𝓆"</span>,
  <span class="org-string">"QUOT;"</span>: <span class=
"org-string">"\""</span>,
  <span class="org-string">"quot;"</span>: <span class=
"org-string">"\""</span>,
  <span class="org-string">"race;"</span>: <span class=
"org-string">"∽̱"</span>,
  <span class="org-string">"Rang;"</span>: <span class=
"org-string">"⟫"</span>,
  <span class="org-string">"rang;"</span>: <span class=
"org-string">"⟩"</span>,
  <span class="org-string">"raquo"</span>: <span class=
"org-string">"»"</span>,
  <span class="org-string">"Rarr;"</span>: <span class=
"org-string">"↠"</span>,
  <span class="org-string">"rArr;"</span>: <span class=
"org-string">"⇒"</span>,
  <span class="org-string">"rarr;"</span>: <span class=
"org-string">"→"</span>,
  <span class="org-string">"rcub;"</span>: <span class=
"org-string">"}"</span>,
  <span class="org-string">"rdca;"</span>: <span class=
"org-string">"⤷"</span>,
  <span class="org-string">"rdsh;"</span>: <span class=
"org-string">"↳"</span>,
  <span class="org-string">"real;"</span>: <span class=
"org-string">"ℜ"</span>,
  <span class="org-string">"rect;"</span>: <span class=
"org-string">"▭"</span>,
  <span class="org-string">"rHar;"</span>: <span class=
"org-string">"⥤"</span>,
  <span class="org-string">"rhov;"</span>: <span class=
"org-string">"ϱ"</span>,
  <span class="org-string">"ring;"</span>: <span class=
"org-string">"˚"</span>,
  <span class="org-string">"Ropf;"</span>: <span class=
"org-string">"ℝ"</span>,
  <span class="org-string">"ropf;"</span>: <span class=
"org-string">"𝕣"</span>,
  <span class="org-string">"rpar;"</span>: <span class=
"org-string">")"</span>,
  <span class="org-string">"Rscr;"</span>: <span class=
"org-string">"ℛ"</span>,
  <span class="org-string">"rscr;"</span>: <span class=
"org-string">"𝓇"</span>,
  <span class="org-string">"rsqb;"</span>: <span class=
"org-string">"]"</span>,
  <span class="org-string">"rtri;"</span>: <span class=
"org-string">"▹"</span>,
  <span class="org-string">"scap;"</span>: <span class=
"org-string">"⪸"</span>,
  <span class="org-string">"scnE;"</span>: <span class=
"org-string">"⪶"</span>,
  <span class="org-string">"sdot;"</span>: <span class=
"org-string">"⋅"</span>,
  <span class="org-string">"sect;"</span>: <span class=
"org-string">"§"</span>,
  <span class="org-string">"semi;"</span>: <span class=
"org-string">";"</span>,
  <span class="org-string">"sext;"</span>: <span class=
"org-string">"✶"</span>,
  <span class="org-string">"SHcy;"</span>: <span class=
"org-string">"Ш"</span>,
  <span class="org-string">"shcy;"</span>: <span class=
"org-string">"ш"</span>,
  <span class="org-string">"sime;"</span>: <span class=
"org-string">"≃"</span>,
  <span class="org-string">"simg;"</span>: <span class=
"org-string">"⪞"</span>,
  <span class="org-string">"siml;"</span>: <span class=
"org-string">"⪝"</span>,
  <span class="org-string">"smid;"</span>: <span class=
"org-string">"∣"</span>,
  <span class="org-string">"smte;"</span>: <span class=
"org-string">"⪬"</span>,
  <span class="org-string">"solb;"</span>: <span class=
"org-string">"⧄"</span>,
  <span class="org-string">"Sopf;"</span>: <span class=
"org-string">"𝕊"</span>,
  <span class="org-string">"sopf;"</span>: <span class=
"org-string">"𝕤"</span>,
  <span class="org-string">"spar;"</span>: <span class=
"org-string">"∥"</span>,
  <span class="org-string">"Sqrt;"</span>: <span class=
"org-string">"√"</span>,
  <span class="org-string">"squf;"</span>: <span class=
"org-string">"▪"</span>,
  <span class="org-string">"Sscr;"</span>: <span class=
"org-string">"𝒮"</span>,
  <span class="org-string">"sscr;"</span>: <span class=
"org-string">"𝓈"</span>,
  <span class="org-string">"Star;"</span>: <span class=
"org-string">"⋆"</span>,
  <span class="org-string">"star;"</span>: <span class=
"org-string">"☆"</span>,
  <span class="org-string">"subE;"</span>: <span class=
"org-string">"⫅"</span>,
  <span class="org-string">"sube;"</span>: <span class=
"org-string">"⊆"</span>,
  <span class="org-string">"succ;"</span>: <span class=
"org-string">"≻"</span>,
  <span class="org-string">"sung;"</span>: <span class=
"org-string">"♪"</span>,
  <span class="org-string">"sup1;"</span>: <span class=
"org-string">"¹"</span>,
  <span class="org-string">"sup2;"</span>: <span class=
"org-string">"²"</span>,
  <span class="org-string">"sup3;"</span>: <span class=
"org-string">"³"</span>,
  <span class="org-string">"supE;"</span>: <span class=
"org-string">"⫆"</span>,
  <span class="org-string">"supe;"</span>: <span class=
"org-string">"⊇"</span>,
  <span class="org-string">"szlig"</span>: <span class=
"org-string">"ß"</span>,
  <span class="org-string">"tbrk;"</span>: <span class=
"org-string">"⎴"</span>,
  <span class="org-string">"tdot;"</span>: <span class=
"org-string">"⃛"</span>,
  <span class="org-string">"THORN"</span>: <span class=
"org-string">"Þ"</span>,
  <span class="org-string">"thorn"</span>: <span class=
"org-string">"þ"</span>,
  <span class="org-string">"times"</span>: <span class=
"org-string">"×"</span>,
  <span class="org-string">"tint;"</span>: <span class=
"org-string">"∭"</span>,
  <span class="org-string">"toea;"</span>: <span class=
"org-string">"⤨"</span>,
  <span class="org-string">"Topf;"</span>: <span class=
"org-string">"𝕋"</span>,
  <span class="org-string">"topf;"</span>: <span class=
"org-string">"𝕥"</span>,
  <span class="org-string">"tosa;"</span>: <span class=
"org-string">"⤩"</span>,
  <span class="org-string">"trie;"</span>: <span class=
"org-string">"≜"</span>,
  <span class="org-string">"Tscr;"</span>: <span class=
"org-string">"𝒯"</span>,
  <span class="org-string">"tscr;"</span>: <span class=
"org-string">"𝓉"</span>,
  <span class="org-string">"TScy;"</span>: <span class=
"org-string">"Ц"</span>,
  <span class="org-string">"tscy;"</span>: <span class=
"org-string">"ц"</span>,
  <span class="org-string">"Uarr;"</span>: <span class=
"org-string">"↟"</span>,
  <span class="org-string">"uArr;"</span>: <span class=
"org-string">"⇑"</span>,
  <span class="org-string">"uarr;"</span>: <span class=
"org-string">"↑"</span>,
  <span class="org-string">"Ucirc"</span>: <span class=
"org-string">"Û"</span>,
  <span class="org-string">"ucirc"</span>: <span class=
"org-string">"û"</span>,
  <span class="org-string">"uHar;"</span>: <span class=
"org-string">"⥣"</span>,
  <span class="org-string">"Uopf;"</span>: <span class=
"org-string">"𝕌"</span>,
  <span class="org-string">"uopf;"</span>: <span class=
"org-string">"𝕦"</span>,
  <span class="org-string">"Upsi;"</span>: <span class=
"org-string">"ϒ"</span>,
  <span class="org-string">"upsi;"</span>: <span class=
"org-string">"υ"</span>,
  <span class="org-string">"Uscr;"</span>: <span class=
"org-string">"𝒰"</span>,
  <span class="org-string">"uscr;"</span>: <span class=
"org-string">"𝓊"</span>,
  <span class="org-string">"utri;"</span>: <span class=
"org-string">"▵"</span>,
  <span class="org-string">"Uuml;"</span>: <span class=
"org-string">"Ü"</span>,
  <span class="org-string">"uuml;"</span>: <span class=
"org-string">"ü"</span>,
  <span class="org-string">"vArr;"</span>: <span class=
"org-string">"⇕"</span>,
  <span class="org-string">"varr;"</span>: <span class=
"org-string">"↕"</span>,
  <span class="org-string">"Vbar;"</span>: <span class=
"org-string">"⫫"</span>,
  <span class="org-string">"vBar;"</span>: <span class=
"org-string">"⫨"</span>,
  <span class="org-string">"Vert;"</span>: <span class=
"org-string">"‖"</span>,
  <span class="org-string">"vert;"</span>: <span class=
"org-string">"|"</span>,
  <span class="org-string">"Vopf;"</span>: <span class=
"org-string">"𝕍"</span>,
  <span class="org-string">"vopf;"</span>: <span class=
"org-string">"𝕧"</span>,
  <span class="org-string">"Vscr;"</span>: <span class=
"org-string">"𝒱"</span>,
  <span class="org-string">"vscr;"</span>: <span class=
"org-string">"𝓋"</span>,
  <span class="org-string">"Wopf;"</span>: <span class=
"org-string">"𝕎"</span>,
  <span class="org-string">"wopf;"</span>: <span class=
"org-string">"𝕨"</span>,
  <span class="org-string">"Wscr;"</span>: <span class=
"org-string">"𝒲"</span>,
  <span class="org-string">"wscr;"</span>: <span class=
"org-string">"𝓌"</span>,
  <span class="org-string">"xcap;"</span>: <span class=
"org-string">"⋂"</span>,
  <span class="org-string">"xcup;"</span>: <span class=
"org-string">"⋃"</span>,
  <span class="org-string">"xmap;"</span>: <span class=
"org-string">"⟼"</span>,
  <span class="org-string">"xnis;"</span>: <span class=
"org-string">"⋻"</span>,
  <span class="org-string">"Xopf;"</span>: <span class=
"org-string">"𝕏"</span>,
  <span class="org-string">"xopf;"</span>: <span class=
"org-string">"𝕩"</span>,
  <span class="org-string">"Xscr;"</span>: <span class=
"org-string">"𝒳"</span>,
  <span class="org-string">"xscr;"</span>: <span class=
"org-string">"𝓍"</span>,
  <span class="org-string">"xvee;"</span>: <span class=
"org-string">"⋁"</span>,
  <span class="org-string">"YAcy;"</span>: <span class=
"org-string">"Я"</span>,
  <span class="org-string">"yacy;"</span>: <span class=
"org-string">"я"</span>,
  <span class="org-string">"YIcy;"</span>: <span class=
"org-string">"Ї"</span>,
  <span class="org-string">"yicy;"</span>: <span class=
"org-string">"ї"</span>,
  <span class="org-string">"Yopf;"</span>: <span class=
"org-string">"𝕐"</span>,
  <span class="org-string">"yopf;"</span>: <span class=
"org-string">"𝕪"</span>,
  <span class="org-string">"Yscr;"</span>: <span class=
"org-string">"𝒴"</span>,
  <span class="org-string">"yscr;"</span>: <span class=
"org-string">"𝓎"</span>,
  <span class="org-string">"YUcy;"</span>: <span class=
"org-string">"Ю"</span>,
  <span class="org-string">"yucy;"</span>: <span class=
"org-string">"ю"</span>,
  <span class="org-string">"Yuml;"</span>: <span class=
"org-string">"Ÿ"</span>,
  <span class="org-string">"yuml;"</span>: <span class=
"org-string">"ÿ"</span>,
  <span class="org-string">"Zdot;"</span>: <span class=
"org-string">"Ż"</span>,
  <span class="org-string">"zdot;"</span>: <span class=
"org-string">"ż"</span>,
  <span class="org-string">"Zeta;"</span>: <span class=
"org-string">"Ζ"</span>,
  <span class="org-string">"zeta;"</span>: <span class=
"org-string">"ζ"</span>,
  <span class="org-string">"ZHcy;"</span>: <span class=
"org-string">"Ж"</span>,
  <span class="org-string">"zhcy;"</span>: <span class=
"org-string">"ж"</span>,
  <span class="org-string">"Zopf;"</span>: <span class=
"org-string">"ℤ"</span>,
  <span class="org-string">"zopf;"</span>: <span class=
"org-string">"𝕫"</span>,
  <span class="org-string">"Zscr;"</span>: <span class=
"org-string">"𝒵"</span>,
  <span class="org-string">"zscr;"</span>: <span class=
"org-string">"𝓏"</span>,
  <span class="org-string">"zwnj;"</span>: <span class=
"org-string">"‌"</span>,
  <span class="org-string">"Aacute"</span>: <span class=
"org-string">"Á"</span>,
  <span class="org-string">"aacute"</span>: <span class=
"org-string">"á"</span>,
  <span class="org-string">"Acirc;"</span>: <span class=
"org-string">"Â"</span>,
  <span class="org-string">"acirc;"</span>: <span class=
"org-string">"â"</span>,
  <span class="org-string">"acute;"</span>: <span class=
"org-string">"´"</span>,
  <span class="org-string">"AElig;"</span>: <span class=
"org-string">"Æ"</span>,
  <span class="org-string">"aelig;"</span>: <span class=
"org-string">"æ"</span>,
  <span class="org-string">"Agrave"</span>: <span class=
"org-string">"À"</span>,
  <span class="org-string">"agrave"</span>: <span class=
"org-string">"à"</span>,
  <span class="org-string">"aleph;"</span>: <span class=
"org-string">"ℵ"</span>,
  <span class="org-string">"Alpha;"</span>: <span class=
"org-string">"Α"</span>,
  <span class="org-string">"alpha;"</span>: <span class=
"org-string">"α"</span>,
  <span class="org-string">"Amacr;"</span>: <span class=
"org-string">"Ā"</span>,
  <span class="org-string">"amacr;"</span>: <span class=
"org-string">"ā"</span>,
  <span class="org-string">"amalg;"</span>: <span class=
"org-string">"⨿"</span>,
  <span class="org-string">"angle;"</span>: <span class=
"org-string">"∠"</span>,
  <span class="org-string">"angrt;"</span>: <span class=
"org-string">"∟"</span>,
  <span class="org-string">"angst;"</span>: <span class=
"org-string">"Å"</span>,
  <span class="org-string">"Aogon;"</span>: <span class=
"org-string">"Ą"</span>,
  <span class="org-string">"aogon;"</span>: <span class=
"org-string">"ą"</span>,
  <span class="org-string">"Aring;"</span>: <span class=
"org-string">"Å"</span>,
  <span class="org-string">"aring;"</span>: <span class=
"org-string">"å"</span>,
  <span class="org-string">"asymp;"</span>: <span class=
"org-string">"≈"</span>,
  <span class="org-string">"Atilde"</span>: <span class=
"org-string">"Ã"</span>,
  <span class="org-string">"atilde"</span>: <span class=
"org-string">"ã"</span>,
  <span class="org-string">"awint;"</span>: <span class=
"org-string">"⨑"</span>,
  <span class="org-string">"bcong;"</span>: <span class=
"org-string">"≌"</span>,
  <span class="org-string">"bdquo;"</span>: <span class=
"org-string">"„"</span>,
  <span class="org-string">"bepsi;"</span>: <span class=
"org-string">"϶"</span>,
  <span class="org-string">"blank;"</span>: <span class=
"org-string">"␣"</span>,
  <span class="org-string">"blk12;"</span>: <span class=
"org-string">"▒"</span>,
  <span class="org-string">"blk14;"</span>: <span class=
"org-string">"░"</span>,
  <span class="org-string">"blk34;"</span>: <span class=
"org-string">"▓"</span>,
  <span class="org-string">"block;"</span>: <span class=
"org-string">"█"</span>,
  <span class="org-string">"boxDL;"</span>: <span class=
"org-string">"╗"</span>,
  <span class="org-string">"boxDl;"</span>: <span class=
"org-string">"╖"</span>,
  <span class="org-string">"boxdL;"</span>: <span class=
"org-string">"╕"</span>,
  <span class="org-string">"boxdl;"</span>: <span class=
"org-string">"┐"</span>,
  <span class="org-string">"boxDR;"</span>: <span class=
"org-string">"╔"</span>,
  <span class="org-string">"boxDr;"</span>: <span class=
"org-string">"╓"</span>,
  <span class="org-string">"boxdR;"</span>: <span class=
"org-string">"╒"</span>,
  <span class="org-string">"boxdr;"</span>: <span class=
"org-string">"┌"</span>,
  <span class="org-string">"boxHD;"</span>: <span class=
"org-string">"╦"</span>,
  <span class="org-string">"boxHd;"</span>: <span class=
"org-string">"╤"</span>,
  <span class="org-string">"boxhD;"</span>: <span class=
"org-string">"╥"</span>,
  <span class="org-string">"boxhd;"</span>: <span class=
"org-string">"┬"</span>,
  <span class="org-string">"boxHU;"</span>: <span class=
"org-string">"╩"</span>,
  <span class="org-string">"boxHu;"</span>: <span class=
"org-string">"╧"</span>,
  <span class="org-string">"boxhU;"</span>: <span class=
"org-string">"╨"</span>,
  <span class="org-string">"boxhu;"</span>: <span class=
"org-string">"┴"</span>,
  <span class="org-string">"boxUL;"</span>: <span class=
"org-string">"╝"</span>,
  <span class="org-string">"boxUl;"</span>: <span class=
"org-string">"╜"</span>,
  <span class="org-string">"boxuL;"</span>: <span class=
"org-string">"╛"</span>,
  <span class="org-string">"boxul;"</span>: <span class=
"org-string">"┘"</span>,
  <span class="org-string">"boxUR;"</span>: <span class=
"org-string">"╚"</span>,
  <span class="org-string">"boxUr;"</span>: <span class=
"org-string">"╙"</span>,
  <span class="org-string">"boxuR;"</span>: <span class=
"org-string">"╘"</span>,
  <span class="org-string">"boxur;"</span>: <span class=
"org-string">"└"</span>,
  <span class="org-string">"boxVH;"</span>: <span class=
"org-string">"╬"</span>,
  <span class="org-string">"boxVh;"</span>: <span class=
"org-string">"╫"</span>,
  <span class="org-string">"boxvH;"</span>: <span class=
"org-string">"╪"</span>,
  <span class="org-string">"boxvh;"</span>: <span class=
"org-string">"┼"</span>,
  <span class="org-string">"boxVL;"</span>: <span class=
"org-string">"╣"</span>,
  <span class="org-string">"boxVl;"</span>: <span class=
"org-string">"╢"</span>,
  <span class="org-string">"boxvL;"</span>: <span class=
"org-string">"╡"</span>,
  <span class="org-string">"boxvl;"</span>: <span class=
"org-string">"┤"</span>,
  <span class="org-string">"boxVR;"</span>: <span class=
"org-string">"╠"</span>,
  <span class="org-string">"boxVr;"</span>: <span class=
"org-string">"╟"</span>,
  <span class="org-string">"boxvR;"</span>: <span class=
"org-string">"╞"</span>,
  <span class="org-string">"boxvr;"</span>: <span class=
"org-string">"├"</span>,
  <span class="org-string">"Breve;"</span>: <span class=
"org-string">"˘"</span>,
  <span class="org-string">"breve;"</span>: <span class=
"org-string">"˘"</span>,
  <span class="org-string">"brvbar"</span>: <span class=
"org-string">"¦"</span>,
  <span class="org-string">"bsemi;"</span>: <span class=
"org-string">"⁏"</span>,
  <span class="org-string">"bsime;"</span>: <span class=
"org-string">"⋍"</span>,
  <span class="org-string">"bsolb;"</span>: <span class=
"org-string">"⧅"</span>,
  <span class="org-string">"bumpE;"</span>: <span class=
"org-string">"⪮"</span>,
  <span class="org-string">"bumpe;"</span>: <span class=
"org-string">"≏"</span>,
  <span class="org-string">"caret;"</span>: <span class=
"org-string">"⁁"</span>,
  <span class="org-string">"caron;"</span>: <span class=
"org-string">"ˇ"</span>,
  <span class="org-string">"ccaps;"</span>: <span class=
"org-string">"⩍"</span>,
  <span class="org-string">"Ccedil"</span>: <span class=
"org-string">"Ç"</span>,
  <span class="org-string">"ccedil"</span>: <span class=
"org-string">"ç"</span>,
  <span class="org-string">"Ccirc;"</span>: <span class=
"org-string">"Ĉ"</span>,
  <span class="org-string">"ccirc;"</span>: <span class=
"org-string">"ĉ"</span>,
  <span class="org-string">"ccups;"</span>: <span class=
"org-string">"⩌"</span>,
  <span class="org-string">"cedil;"</span>: <span class=
"org-string">"¸"</span>,
  <span class="org-string">"check;"</span>: <span class=
"org-string">"✓"</span>,
  <span class="org-string">"clubs;"</span>: <span class=
"org-string">"♣"</span>,
  <span class="org-string">"Colon;"</span>: <span class=
"org-string">"∷"</span>,
  <span class="org-string">"colon;"</span>: <span class=
"org-string">":"</span>,
  <span class="org-string">"comma;"</span>: <span class=
"org-string">","</span>,
  <span class="org-string">"crarr;"</span>: <span class=
"org-string">"↵"</span>,
  <span class="org-string">"Cross;"</span>: <span class=
"org-string">"⨯"</span>,
  <span class="org-string">"cross;"</span>: <span class=
"org-string">"✗"</span>,
  <span class="org-string">"csube;"</span>: <span class=
"org-string">"⫑"</span>,
  <span class="org-string">"csupe;"</span>: <span class=
"org-string">"⫒"</span>,
  <span class="org-string">"ctdot;"</span>: <span class=
"org-string">"⋯"</span>,
  <span class="org-string">"cuepr;"</span>: <span class=
"org-string">"⋞"</span>,
  <span class="org-string">"cuesc;"</span>: <span class=
"org-string">"⋟"</span>,
  <span class="org-string">"cupor;"</span>: <span class=
"org-string">"⩅"</span>,
  <span class="org-string">"curren"</span>: <span class=
"org-string">"¤"</span>,
  <span class="org-string">"cuvee;"</span>: <span class=
"org-string">"⋎"</span>,
  <span class="org-string">"cuwed;"</span>: <span class=
"org-string">"⋏"</span>,
  <span class="org-string">"cwint;"</span>: <span class=
"org-string">"∱"</span>,
  <span class="org-string">"Dashv;"</span>: <span class=
"org-string">"⫤"</span>,
  <span class="org-string">"dashv;"</span>: <span class=
"org-string">"⊣"</span>,
  <span class="org-string">"dblac;"</span>: <span class=
"org-string">"˝"</span>,
  <span class="org-string">"ddarr;"</span>: <span class=
"org-string">"⇊"</span>,
  <span class="org-string">"Delta;"</span>: <span class=
"org-string">"Δ"</span>,
  <span class="org-string">"delta;"</span>: <span class=
"org-string">"δ"</span>,
  <span class="org-string">"dharl;"</span>: <span class=
"org-string">"⇃"</span>,
  <span class="org-string">"dharr;"</span>: <span class=
"org-string">"⇂"</span>,
  <span class="org-string">"diams;"</span>: <span class=
"org-string">"♦"</span>,
  <span class="org-string">"disin;"</span>: <span class=
"org-string">"⋲"</span>,
  <span class="org-string">"divide"</span>: <span class=
"org-string">"÷"</span>,
  <span class="org-string">"doteq;"</span>: <span class=
"org-string">"≐"</span>,
  <span class="org-string">"dtdot;"</span>: <span class=
"org-string">"⋱"</span>,
  <span class="org-string">"dtrif;"</span>: <span class=
"org-string">"▾"</span>,
  <span class="org-string">"duarr;"</span>: <span class=
"org-string">"⇵"</span>,
  <span class="org-string">"duhar;"</span>: <span class=
"org-string">"⥯"</span>,
  <span class="org-string">"Eacute"</span>: <span class=
"org-string">"É"</span>,
  <span class="org-string">"eacute"</span>: <span class=
"org-string">"é"</span>,
  <span class="org-string">"Ecirc;"</span>: <span class=
"org-string">"Ê"</span>,
  <span class="org-string">"ecirc;"</span>: <span class=
"org-string">"ê"</span>,
  <span class="org-string">"eDDot;"</span>: <span class=
"org-string">"⩷"</span>,
  <span class="org-string">"efDot;"</span>: <span class=
"org-string">"≒"</span>,
  <span class="org-string">"Egrave"</span>: <span class=
"org-string">"È"</span>,
  <span class="org-string">"egrave"</span>: <span class=
"org-string">"è"</span>,
  <span class="org-string">"Emacr;"</span>: <span class=
"org-string">"Ē"</span>,
  <span class="org-string">"emacr;"</span>: <span class=
"org-string">"ē"</span>,
  <span class="org-string">"empty;"</span>: <span class=
"org-string">"∅"</span>,
  <span class="org-string">"Eogon;"</span>: <span class=
"org-string">"Ę"</span>,
  <span class="org-string">"eogon;"</span>: <span class=
"org-string">"ę"</span>,
  <span class="org-string">"eplus;"</span>: <span class=
"org-string">"⩱"</span>,
  <span class="org-string">"epsiv;"</span>: <span class=
"org-string">"ϵ"</span>,
  <span class="org-string">"eqsim;"</span>: <span class=
"org-string">"≂"</span>,
  <span class="org-string">"Equal;"</span>: <span class=
"org-string">"⩵"</span>,
  <span class="org-string">"equiv;"</span>: <span class=
"org-string">"≡"</span>,
  <span class="org-string">"erarr;"</span>: <span class=
"org-string">"⥱"</span>,
  <span class="org-string">"erDot;"</span>: <span class=
"org-string">"≓"</span>,
  <span class="org-string">"esdot;"</span>: <span class=
"org-string">"≐"</span>,
  <span class="org-string">"exist;"</span>: <span class=
"org-string">"∃"</span>,
  <span class="org-string">"fflig;"</span>: <span class=
"org-string">"ﬀ"</span>,
  <span class="org-string">"filig;"</span>: <span class=
"org-string">"ﬁ"</span>,
  <span class="org-string">"fjlig;"</span>: <span class=
"org-string">"fj"</span>,
  <span class="org-string">"fllig;"</span>: <span class=
"org-string">"ﬂ"</span>,
  <span class="org-string">"fltns;"</span>: <span class=
"org-string">"▱"</span>,
  <span class="org-string">"forkv;"</span>: <span class=
"org-string">"⫙"</span>,
  <span class="org-string">"frac12"</span>: <span class=
"org-string">"½"</span>,
  <span class="org-string">"frac14"</span>: <span class=
"org-string">"¼"</span>,
  <span class="org-string">"frac34"</span>: <span class=
"org-string">"¾"</span>,
  <span class="org-string">"frasl;"</span>: <span class=
"org-string">"⁄"</span>,
  <span class="org-string">"frown;"</span>: <span class=
"org-string">"⌢"</span>,
  <span class="org-string">"Gamma;"</span>: <span class=
"org-string">"Γ"</span>,
  <span class="org-string">"gamma;"</span>: <span class=
"org-string">"γ"</span>,
  <span class="org-string">"Gcirc;"</span>: <span class=
"org-string">"Ĝ"</span>,
  <span class="org-string">"gcirc;"</span>: <span class=
"org-string">"ĝ"</span>,
  <span class="org-string">"gescc;"</span>: <span class=
"org-string">"⪩"</span>,
  <span class="org-string">"gimel;"</span>: <span class=
"org-string">"ℷ"</span>,
  <span class="org-string">"gneqq;"</span>: <span class=
"org-string">"≩"</span>,
  <span class="org-string">"gnsim;"</span>: <span class=
"org-string">"⋧"</span>,
  <span class="org-string">"grave;"</span>: <span class=
"org-string">"`"</span>,
  <span class="org-string">"gsime;"</span>: <span class=
"org-string">"⪎"</span>,
  <span class="org-string">"gsiml;"</span>: <span class=
"org-string">"⪐"</span>,
  <span class="org-string">"gtcir;"</span>: <span class=
"org-string">"⩺"</span>,
  <span class="org-string">"gtdot;"</span>: <span class=
"org-string">"⋗"</span>,
  <span class="org-string">"Hacek;"</span>: <span class=
"org-string">"ˇ"</span>,
  <span class="org-string">"harrw;"</span>: <span class=
"org-string">"↭"</span>,
  <span class="org-string">"Hcirc;"</span>: <span class=
"org-string">"Ĥ"</span>,
  <span class="org-string">"hcirc;"</span>: <span class=
"org-string">"ĥ"</span>,
  <span class="org-string">"hoarr;"</span>: <span class=
"org-string">"⇿"</span>,
  <span class="org-string">"Iacute"</span>: <span class=
"org-string">"Í"</span>,
  <span class="org-string">"iacute"</span>: <span class=
"org-string">"í"</span>,
  <span class="org-string">"Icirc;"</span>: <span class=
"org-string">"Î"</span>,
  <span class="org-string">"icirc;"</span>: <span class=
"org-string">"î"</span>,
  <span class="org-string">"iexcl;"</span>: <span class=
"org-string">"¡"</span>,
  <span class="org-string">"Igrave"</span>: <span class=
"org-string">"Ì"</span>,
  <span class="org-string">"igrave"</span>: <span class=
"org-string">"ì"</span>,
  <span class="org-string">"iiint;"</span>: <span class=
"org-string">"∭"</span>,
  <span class="org-string">"iiota;"</span>: <span class=
"org-string">"℩"</span>,
  <span class="org-string">"IJlig;"</span>: <span class=
"org-string">"Ĳ"</span>,
  <span class="org-string">"ijlig;"</span>: <span class=
"org-string">"ĳ"</span>,
  <span class="org-string">"Imacr;"</span>: <span class=
"org-string">"Ī"</span>,
  <span class="org-string">"imacr;"</span>: <span class=
"org-string">"ī"</span>,
  <span class="org-string">"image;"</span>: <span class=
"org-string">"ℑ"</span>,
  <span class="org-string">"imath;"</span>: <span class=
"org-string">"ı"</span>,
  <span class="org-string">"imped;"</span>: <span class=
"org-string">"Ƶ"</span>,
  <span class="org-string">"infin;"</span>: <span class=
"org-string">"∞"</span>,
  <span class="org-string">"Iogon;"</span>: <span class=
"org-string">"Į"</span>,
  <span class="org-string">"iogon;"</span>: <span class=
"org-string">"į"</span>,
  <span class="org-string">"iprod;"</span>: <span class=
"org-string">"⨼"</span>,
  <span class="org-string">"iquest"</span>: <span class=
"org-string">"¿"</span>,
  <span class="org-string">"isinE;"</span>: <span class=
"org-string">"⋹"</span>,
  <span class="org-string">"isins;"</span>: <span class=
"org-string">"⋴"</span>,
  <span class="org-string">"isinv;"</span>: <span class=
"org-string">"∈"</span>,
  <span class="org-string">"Iukcy;"</span>: <span class=
"org-string">"І"</span>,
  <span class="org-string">"iukcy;"</span>: <span class=
"org-string">"і"</span>,
  <span class="org-string">"Jcirc;"</span>: <span class=
"org-string">"Ĵ"</span>,
  <span class="org-string">"jcirc;"</span>: <span class=
"org-string">"ĵ"</span>,
  <span class="org-string">"jmath;"</span>: <span class=
"org-string">"ȷ"</span>,
  <span class="org-string">"Jukcy;"</span>: <span class=
"org-string">"Є"</span>,
  <span class="org-string">"jukcy;"</span>: <span class=
"org-string">"є"</span>,
  <span class="org-string">"Kappa;"</span>: <span class=
"org-string">"Κ"</span>,
  <span class="org-string">"kappa;"</span>: <span class=
"org-string">"κ"</span>,
  <span class="org-string">"lAarr;"</span>: <span class=
"org-string">"⇚"</span>,
  <span class="org-string">"langd;"</span>: <span class=
"org-string">"⦑"</span>,
  <span class="org-string">"laquo;"</span>: <span class=
"org-string">"«"</span>,
  <span class="org-string">"larrb;"</span>: <span class=
"org-string">"⇤"</span>,
  <span class="org-string">"lates;"</span>: <span class=
"org-string">"⪭︀"</span>,
  <span class="org-string">"lBarr;"</span>: <span class=
"org-string">"⤎"</span>,
  <span class="org-string">"lbarr;"</span>: <span class=
"org-string">"⤌"</span>,
  <span class="org-string">"lbbrk;"</span>: <span class=
"org-string">"❲"</span>,
  <span class="org-string">"lbrke;"</span>: <span class=
"org-string">"⦋"</span>,
  <span class="org-string">"lceil;"</span>: <span class=
"org-string">"⌈"</span>,
  <span class="org-string">"ldquo;"</span>: <span class=
"org-string">"“"</span>,
  <span class="org-string">"lescc;"</span>: <span class=
"org-string">"⪨"</span>,
  <span class="org-string">"lhard;"</span>: <span class=
"org-string">"↽"</span>,
  <span class="org-string">"lharu;"</span>: <span class=
"org-string">"↼"</span>,
  <span class="org-string">"lhblk;"</span>: <span class=
"org-string">"▄"</span>,
  <span class="org-string">"llarr;"</span>: <span class=
"org-string">"⇇"</span>,
  <span class="org-string">"lltri;"</span>: <span class=
"org-string">"◺"</span>,
  <span class="org-string">"lneqq;"</span>: <span class=
"org-string">"≨"</span>,
  <span class="org-string">"lnsim;"</span>: <span class=
"org-string">"⋦"</span>,
  <span class="org-string">"loang;"</span>: <span class=
"org-string">"⟬"</span>,
  <span class="org-string">"loarr;"</span>: <span class=
"org-string">"⇽"</span>,
  <span class="org-string">"lobrk;"</span>: <span class=
"org-string">"⟦"</span>,
  <span class="org-string">"lopar;"</span>: <span class=
"org-string">"⦅"</span>,
  <span class="org-string">"lrarr;"</span>: <span class=
"org-string">"⇆"</span>,
  <span class="org-string">"lrhar;"</span>: <span class=
"org-string">"⇋"</span>,
  <span class="org-string">"lrtri;"</span>: <span class=
"org-string">"⊿"</span>,
  <span class="org-string">"lsime;"</span>: <span class=
"org-string">"⪍"</span>,
  <span class="org-string">"lsimg;"</span>: <span class=
"org-string">"⪏"</span>,
  <span class="org-string">"lsquo;"</span>: <span class=
"org-string">"‘"</span>,
  <span class="org-string">"ltcir;"</span>: <span class=
"org-string">"⩹"</span>,
  <span class="org-string">"ltdot;"</span>: <span class=
"org-string">"⋖"</span>,
  <span class="org-string">"ltrie;"</span>: <span class=
"org-string">"⊴"</span>,
  <span class="org-string">"ltrif;"</span>: <span class=
"org-string">"◂"</span>,
  <span class="org-string">"mdash;"</span>: <span class=
"org-string">"—"</span>,
  <span class="org-string">"mDDot;"</span>: <span class=
"org-string">"∺"</span>,
  <span class="org-string">"micro;"</span>: <span class=
"org-string">"µ"</span>,
  <span class="org-string">"middot"</span>: <span class=
"org-string">"·"</span>,
  <span class="org-string">"minus;"</span>: <span class=
"org-string">"−"</span>,
  <span class="org-string">"mumap;"</span>: <span class=
"org-string">"⊸"</span>,
  <span class="org-string">"nabla;"</span>: <span class=
"org-string">"∇"</span>,
  <span class="org-string">"napid;"</span>: <span class=
"org-string">"≋̸"</span>,
  <span class="org-string">"napos;"</span>: <span class=
"org-string">"ŉ"</span>,
  <span class="org-string">"natur;"</span>: <span class=
"org-string">"♮"</span>,
  <span class="org-string">"nbump;"</span>: <span class=
"org-string">"≎̸"</span>,
  <span class="org-string">"ncong;"</span>: <span class=
"org-string">"≇"</span>,
  <span class="org-string">"ndash;"</span>: <span class=
"org-string">"–"</span>,
  <span class="org-string">"neArr;"</span>: <span class=
"org-string">"⇗"</span>,
  <span class="org-string">"nearr;"</span>: <span class=
"org-string">"↗"</span>,
  <span class="org-string">"nedot;"</span>: <span class=
"org-string">"≐̸"</span>,
  <span class="org-string">"nesim;"</span>: <span class=
"org-string">"≂̸"</span>,
  <span class="org-string">"ngeqq;"</span>: <span class=
"org-string">"≧̸"</span>,
  <span class="org-string">"ngsim;"</span>: <span class=
"org-string">"≵"</span>,
  <span class="org-string">"nhArr;"</span>: <span class=
"org-string">"⇎"</span>,
  <span class="org-string">"nharr;"</span>: <span class=
"org-string">"↮"</span>,
  <span class="org-string">"nhpar;"</span>: <span class=
"org-string">"⫲"</span>,
  <span class="org-string">"nlArr;"</span>: <span class=
"org-string">"⇍"</span>,
  <span class="org-string">"nlarr;"</span>: <span class=
"org-string">"↚"</span>,
  <span class="org-string">"nleqq;"</span>: <span class=
"org-string">"≦̸"</span>,
  <span class="org-string">"nless;"</span>: <span class=
"org-string">"≮"</span>,
  <span class="org-string">"nlsim;"</span>: <span class=
"org-string">"≴"</span>,
  <span class="org-string">"nltri;"</span>: <span class=
"org-string">"⋪"</span>,
  <span class="org-string">"notin;"</span>: <span class=
"org-string">"∉"</span>,
  <span class="org-string">"notni;"</span>: <span class=
"org-string">"∌"</span>,
  <span class="org-string">"npart;"</span>: <span class=
"org-string">"∂̸"</span>,
  <span class="org-string">"nprec;"</span>: <span class=
"org-string">"⊀"</span>,
  <span class="org-string">"nrArr;"</span>: <span class=
"org-string">"⇏"</span>,
  <span class="org-string">"nrarr;"</span>: <span class=
"org-string">"↛"</span>,
  <span class="org-string">"nrtri;"</span>: <span class=
"org-string">"⋫"</span>,
  <span class="org-string">"nsime;"</span>: <span class=
"org-string">"≄"</span>,
  <span class="org-string">"nsmid;"</span>: <span class=
"org-string">"∤"</span>,
  <span class="org-string">"nspar;"</span>: <span class=
"org-string">"∦"</span>,
  <span class="org-string">"nsubE;"</span>: <span class=
"org-string">"⫅̸"</span>,
  <span class="org-string">"nsube;"</span>: <span class=
"org-string">"⊈"</span>,
  <span class="org-string">"nsucc;"</span>: <span class=
"org-string">"⊁"</span>,
  <span class="org-string">"nsupE;"</span>: <span class=
"org-string">"⫆̸"</span>,
  <span class="org-string">"nsupe;"</span>: <span class=
"org-string">"⊉"</span>,
  <span class="org-string">"Ntilde"</span>: <span class=
"org-string">"Ñ"</span>,
  <span class="org-string">"ntilde"</span>: <span class=
"org-string">"ñ"</span>,
  <span class="org-string">"numsp;"</span>: <span class=
"org-string">" "</span>,
  <span class="org-string">"nvsim;"</span>: <span class=
"org-string">"∼⃒"</span>,
  <span class="org-string">"nwArr;"</span>: <span class=
"org-string">"⇖"</span>,
  <span class="org-string">"nwarr;"</span>: <span class=
"org-string">"↖"</span>,
  <span class="org-string">"Oacute"</span>: <span class=
"org-string">"Ó"</span>,
  <span class="org-string">"oacute"</span>: <span class=
"org-string">"ó"</span>,
  <span class="org-string">"Ocirc;"</span>: <span class=
"org-string">"Ô"</span>,
  <span class="org-string">"ocirc;"</span>: <span class=
"org-string">"ô"</span>,
  <span class="org-string">"odash;"</span>: <span class=
"org-string">"⊝"</span>,
  <span class="org-string">"OElig;"</span>: <span class=
"org-string">"Œ"</span>,
  <span class="org-string">"oelig;"</span>: <span class=
"org-string">"œ"</span>,
  <span class="org-string">"ofcir;"</span>: <span class=
"org-string">"⦿"</span>,
  <span class="org-string">"Ograve"</span>: <span class=
"org-string">"Ò"</span>,
  <span class="org-string">"ograve"</span>: <span class=
"org-string">"ò"</span>,
  <span class="org-string">"ohbar;"</span>: <span class=
"org-string">"⦵"</span>,
  <span class="org-string">"olarr;"</span>: <span class=
"org-string">"↺"</span>,
  <span class="org-string">"olcir;"</span>: <span class=
"org-string">"⦾"</span>,
  <span class="org-string">"oline;"</span>: <span class=
"org-string">"‾"</span>,
  <span class="org-string">"Omacr;"</span>: <span class=
"org-string">"Ō"</span>,
  <span class="org-string">"omacr;"</span>: <span class=
"org-string">"ō"</span>,
  <span class="org-string">"Omega;"</span>: <span class=
"org-string">"Ω"</span>,
  <span class="org-string">"omega;"</span>: <span class=
"org-string">"ω"</span>,
  <span class="org-string">"operp;"</span>: <span class=
"org-string">"⦹"</span>,
  <span class="org-string">"oplus;"</span>: <span class=
"org-string">"⊕"</span>,
  <span class="org-string">"orarr;"</span>: <span class=
"org-string">"↻"</span>,
  <span class="org-string">"order;"</span>: <span class=
"org-string">"ℴ"</span>,
  <span class="org-string">"Oslash"</span>: <span class=
"org-string">"Ø"</span>,
  <span class="org-string">"oslash"</span>: <span class=
"org-string">"ø"</span>,
  <span class="org-string">"Otilde"</span>: <span class=
"org-string">"Õ"</span>,
  <span class="org-string">"otilde"</span>: <span class=
"org-string">"õ"</span>,
  <span class="org-string">"ovbar;"</span>: <span class=
"org-string">"⌽"</span>,
  <span class="org-string">"parsl;"</span>: <span class=
"org-string">"⫽"</span>,
  <span class="org-string">"phone;"</span>: <span class=
"org-string">"☎"</span>,
  <span class="org-string">"plusb;"</span>: <span class=
"org-string">"⊞"</span>,
  <span class="org-string">"pluse;"</span>: <span class=
"org-string">"⩲"</span>,
  <span class="org-string">"plusmn"</span>: <span class=
"org-string">"±"</span>,
  <span class="org-string">"pound;"</span>: <span class=
"org-string">"£"</span>,
  <span class="org-string">"prcue;"</span>: <span class=
"org-string">"≼"</span>,
  <span class="org-string">"Prime;"</span>: <span class=
"org-string">"″"</span>,
  <span class="org-string">"prime;"</span>: <span class=
"org-string">"′"</span>,
  <span class="org-string">"prnap;"</span>: <span class=
"org-string">"⪹"</span>,
  <span class="org-string">"prsim;"</span>: <span class=
"org-string">"≾"</span>,
  <span class="org-string">"quest;"</span>: <span class=
"org-string">"?"</span>,
  <span class="org-string">"rAarr;"</span>: <span class=
"org-string">"⇛"</span>,
  <span class="org-string">"radic;"</span>: <span class=
"org-string">"√"</span>,
  <span class="org-string">"rangd;"</span>: <span class=
"org-string">"⦒"</span>,
  <span class="org-string">"range;"</span>: <span class=
"org-string">"⦥"</span>,
  <span class="org-string">"raquo;"</span>: <span class=
"org-string">"»"</span>,
  <span class="org-string">"rarrb;"</span>: <span class=
"org-string">"⇥"</span>,
  <span class="org-string">"rarrc;"</span>: <span class=
"org-string">"⤳"</span>,
  <span class="org-string">"rarrw;"</span>: <span class=
"org-string">"↝"</span>,
  <span class="org-string">"ratio;"</span>: <span class=
"org-string">"∶"</span>,
  <span class="org-string">"RBarr;"</span>: <span class=
"org-string">"⤐"</span>,
  <span class="org-string">"rBarr;"</span>: <span class=
"org-string">"⤏"</span>,
  <span class="org-string">"rbarr;"</span>: <span class=
"org-string">"⤍"</span>,
  <span class="org-string">"rbbrk;"</span>: <span class=
"org-string">"❳"</span>,
  <span class="org-string">"rbrke;"</span>: <span class=
"org-string">"⦌"</span>,
  <span class="org-string">"rceil;"</span>: <span class=
"org-string">"⌉"</span>,
  <span class="org-string">"rdquo;"</span>: <span class=
"org-string">"”"</span>,
  <span class="org-string">"reals;"</span>: <span class=
"org-string">"ℝ"</span>,
  <span class="org-string">"rhard;"</span>: <span class=
"org-string">"⇁"</span>,
  <span class="org-string">"rharu;"</span>: <span class=
"org-string">"⇀"</span>,
  <span class="org-string">"rlarr;"</span>: <span class=
"org-string">"⇄"</span>,
  <span class="org-string">"rlhar;"</span>: <span class=
"org-string">"⇌"</span>,
  <span class="org-string">"rnmid;"</span>: <span class=
"org-string">"⫮"</span>,
  <span class="org-string">"roang;"</span>: <span class=
"org-string">"⟭"</span>,
  <span class="org-string">"roarr;"</span>: <span class=
"org-string">"⇾"</span>,
  <span class="org-string">"robrk;"</span>: <span class=
"org-string">"⟧"</span>,
  <span class="org-string">"ropar;"</span>: <span class=
"org-string">"⦆"</span>,
  <span class="org-string">"rrarr;"</span>: <span class=
"org-string">"⇉"</span>,
  <span class="org-string">"rsquo;"</span>: <span class=
"org-string">"’"</span>,
  <span class="org-string">"rtrie;"</span>: <span class=
"org-string">"⊵"</span>,
  <span class="org-string">"rtrif;"</span>: <span class=
"org-string">"▸"</span>,
  <span class="org-string">"sbquo;"</span>: <span class=
"org-string">"‚"</span>,
  <span class="org-string">"sccue;"</span>: <span class=
"org-string">"≽"</span>,
  <span class="org-string">"Scirc;"</span>: <span class=
"org-string">"Ŝ"</span>,
  <span class="org-string">"scirc;"</span>: <span class=
"org-string">"ŝ"</span>,
  <span class="org-string">"scnap;"</span>: <span class=
"org-string">"⪺"</span>,
  <span class="org-string">"scsim;"</span>: <span class=
"org-string">"≿"</span>,
  <span class="org-string">"sdotb;"</span>: <span class=
"org-string">"⊡"</span>,
  <span class="org-string">"sdote;"</span>: <span class=
"org-string">"⩦"</span>,
  <span class="org-string">"seArr;"</span>: <span class=
"org-string">"⇘"</span>,
  <span class="org-string">"searr;"</span>: <span class=
"org-string">"↘"</span>,
  <span class="org-string">"setmn;"</span>: <span class=
"org-string">"∖"</span>,
  <span class="org-string">"sharp;"</span>: <span class=
"org-string">"♯"</span>,
  <span class="org-string">"Sigma;"</span>: <span class=
"org-string">"Σ"</span>,
  <span class="org-string">"sigma;"</span>: <span class=
"org-string">"σ"</span>,
  <span class="org-string">"simeq;"</span>: <span class=
"org-string">"≃"</span>,
  <span class="org-string">"simgE;"</span>: <span class=
"org-string">"⪠"</span>,
  <span class="org-string">"simlE;"</span>: <span class=
"org-string">"⪟"</span>,
  <span class="org-string">"simne;"</span>: <span class=
"org-string">"≆"</span>,
  <span class="org-string">"slarr;"</span>: <span class=
"org-string">"←"</span>,
  <span class="org-string">"smile;"</span>: <span class=
"org-string">"⌣"</span>,
  <span class="org-string">"smtes;"</span>: <span class=
"org-string">"⪬︀"</span>,
  <span class="org-string">"sqcap;"</span>: <span class=
"org-string">"⊓"</span>,
  <span class="org-string">"sqcup;"</span>: <span class=
"org-string">"⊔"</span>,
  <span class="org-string">"sqsub;"</span>: <span class=
"org-string">"⊏"</span>,
  <span class="org-string">"sqsup;"</span>: <span class=
"org-string">"⊐"</span>,
  <span class="org-string">"srarr;"</span>: <span class=
"org-string">"→"</span>,
  <span class="org-string">"starf;"</span>: <span class=
"org-string">"★"</span>,
  <span class="org-string">"strns;"</span>: <span class=
"org-string">"¯"</span>,
  <span class="org-string">"subnE;"</span>: <span class=
"org-string">"⫋"</span>,
  <span class="org-string">"subne;"</span>: <span class=
"org-string">"⊊"</span>,
  <span class="org-string">"supnE;"</span>: <span class=
"org-string">"⫌"</span>,
  <span class="org-string">"supne;"</span>: <span class=
"org-string">"⊋"</span>,
  <span class="org-string">"swArr;"</span>: <span class=
"org-string">"⇙"</span>,
  <span class="org-string">"swarr;"</span>: <span class=
"org-string">"↙"</span>,
  <span class="org-string">"szlig;"</span>: <span class=
"org-string">"ß"</span>,
  <span class="org-string">"Theta;"</span>: <span class=
"org-string">"Θ"</span>,
  <span class="org-string">"theta;"</span>: <span class=
"org-string">"θ"</span>,
  <span class="org-string">"thkap;"</span>: <span class=
"org-string">"≈"</span>,
  <span class="org-string">"THORN;"</span>: <span class=
"org-string">"Þ"</span>,
  <span class="org-string">"thorn;"</span>: <span class=
"org-string">"þ"</span>,
  <span class="org-string">"Tilde;"</span>: <span class=
"org-string">"∼"</span>,
  <span class="org-string">"tilde;"</span>: <span class=
"org-string">"˜"</span>,
  <span class="org-string">"times;"</span>: <span class=
"org-string">"×"</span>,
  <span class="org-string">"TRADE;"</span>: <span class=
"org-string">"™"</span>,
  <span class="org-string">"trade;"</span>: <span class=
"org-string">"™"</span>,
  <span class="org-string">"trisb;"</span>: <span class=
"org-string">"⧍"</span>,
  <span class="org-string">"TSHcy;"</span>: <span class=
"org-string">"Ћ"</span>,
  <span class="org-string">"tshcy;"</span>: <span class=
"org-string">"ћ"</span>,
  <span class="org-string">"twixt;"</span>: <span class=
"org-string">"≬"</span>,
  <span class="org-string">"Uacute"</span>: <span class=
"org-string">"Ú"</span>,
  <span class="org-string">"uacute"</span>: <span class=
"org-string">"ú"</span>,
  <span class="org-string">"Ubrcy;"</span>: <span class=
"org-string">"Ў"</span>,
  <span class="org-string">"ubrcy;"</span>: <span class=
"org-string">"ў"</span>,
  <span class="org-string">"Ucirc;"</span>: <span class=
"org-string">"Û"</span>,
  <span class="org-string">"ucirc;"</span>: <span class=
"org-string">"û"</span>,
  <span class="org-string">"udarr;"</span>: <span class=
"org-string">"⇅"</span>,
  <span class="org-string">"udhar;"</span>: <span class=
"org-string">"⥮"</span>,
  <span class="org-string">"Ugrave"</span>: <span class=
"org-string">"Ù"</span>,
  <span class="org-string">"ugrave"</span>: <span class=
"org-string">"ù"</span>,
  <span class="org-string">"uharl;"</span>: <span class=
"org-string">"↿"</span>,
  <span class="org-string">"uharr;"</span>: <span class=
"org-string">"↾"</span>,
  <span class="org-string">"uhblk;"</span>: <span class=
"org-string">"▀"</span>,
  <span class="org-string">"ultri;"</span>: <span class=
"org-string">"◸"</span>,
  <span class="org-string">"Umacr;"</span>: <span class=
"org-string">"Ū"</span>,
  <span class="org-string">"umacr;"</span>: <span class=
"org-string">"ū"</span>,
  <span class="org-string">"Union;"</span>: <span class=
"org-string">"⋃"</span>,
  <span class="org-string">"Uogon;"</span>: <span class=
"org-string">"Ų"</span>,
  <span class="org-string">"uogon;"</span>: <span class=
"org-string">"ų"</span>,
  <span class="org-string">"uplus;"</span>: <span class=
"org-string">"⊎"</span>,
  <span class="org-string">"upsih;"</span>: <span class=
"org-string">"ϒ"</span>,
  <span class="org-string">"UpTee;"</span>: <span class=
"org-string">"⊥"</span>,
  <span class="org-string">"Uring;"</span>: <span class=
"org-string">"Ů"</span>,
  <span class="org-string">"uring;"</span>: <span class=
"org-string">"ů"</span>,
  <span class="org-string">"urtri;"</span>: <span class=
"org-string">"◹"</span>,
  <span class="org-string">"utdot;"</span>: <span class=
"org-string">"⋰"</span>,
  <span class="org-string">"utrif;"</span>: <span class=
"org-string">"▴"</span>,
  <span class="org-string">"uuarr;"</span>: <span class=
"org-string">"⇈"</span>,
  <span class="org-string">"varpi;"</span>: <span class=
"org-string">"ϖ"</span>,
  <span class="org-string">"vBarv;"</span>: <span class=
"org-string">"⫩"</span>,
  <span class="org-string">"VDash;"</span>: <span class=
"org-string">"⊫"</span>,
  <span class="org-string">"Vdash;"</span>: <span class=
"org-string">"⊩"</span>,
  <span class="org-string">"vDash;"</span>: <span class=
"org-string">"⊨"</span>,
  <span class="org-string">"vdash;"</span>: <span class=
"org-string">"⊢"</span>,
  <span class="org-string">"veeeq;"</span>: <span class=
"org-string">"≚"</span>,
  <span class="org-string">"vltri;"</span>: <span class=
"org-string">"⊲"</span>,
  <span class="org-string">"vnsub;"</span>: <span class=
"org-string">"⊂⃒"</span>,
  <span class="org-string">"vnsup;"</span>: <span class=
"org-string">"⊃⃒"</span>,
  <span class="org-string">"vprop;"</span>: <span class=
"org-string">"∝"</span>,
  <span class="org-string">"vrtri;"</span>: <span class=
"org-string">"⊳"</span>,
  <span class="org-string">"Wcirc;"</span>: <span class=
"org-string">"Ŵ"</span>,
  <span class="org-string">"wcirc;"</span>: <span class=
"org-string">"ŵ"</span>,
  <span class="org-string">"Wedge;"</span>: <span class=
"org-string">"⋀"</span>,
  <span class="org-string">"wedge;"</span>: <span class=
"org-string">"∧"</span>,
  <span class="org-string">"xcirc;"</span>: <span class=
"org-string">"◯"</span>,
  <span class="org-string">"xdtri;"</span>: <span class=
"org-string">"▽"</span>,
  <span class="org-string">"xhArr;"</span>: <span class=
"org-string">"⟺"</span>,
  <span class="org-string">"xharr;"</span>: <span class=
"org-string">"⟷"</span>,
  <span class="org-string">"xlArr;"</span>: <span class=
"org-string">"⟸"</span>,
  <span class="org-string">"xlarr;"</span>: <span class=
"org-string">"⟵"</span>,
  <span class="org-string">"xodot;"</span>: <span class=
"org-string">"⨀"</span>,
  <span class="org-string">"xrArr;"</span>: <span class=
"org-string">"⟹"</span>,
  <span class="org-string">"xrarr;"</span>: <span class=
"org-string">"⟶"</span>,
  <span class="org-string">"xutri;"</span>: <span class=
"org-string">"△"</span>,
  <span class="org-string">"Yacute"</span>: <span class=
"org-string">"Ý"</span>,
  <span class="org-string">"yacute"</span>: <span class=
"org-string">"ý"</span>,
  <span class="org-string">"Ycirc;"</span>: <span class=
"org-string">"Ŷ"</span>,
  <span class="org-string">"ycirc;"</span>: <span class=
"org-string">"ŷ"</span>,
  <span class="org-string">"Aacute;"</span>: <span class=
"org-string">"Á"</span>,
  <span class="org-string">"aacute;"</span>: <span class=
"org-string">"á"</span>,
  <span class="org-string">"Abreve;"</span>: <span class=
"org-string">"Ă"</span>,
  <span class="org-string">"abreve;"</span>: <span class=
"org-string">"ă"</span>,
  <span class="org-string">"Agrave;"</span>: <span class=
"org-string">"À"</span>,
  <span class="org-string">"agrave;"</span>: <span class=
"org-string">"à"</span>,
  <span class="org-string">"andand;"</span>: <span class=
"org-string">"⩕"</span>,
  <span class="org-string">"angmsd;"</span>: <span class=
"org-string">"∡"</span>,
  <span class="org-string">"angsph;"</span>: <span class=
"org-string">"∢"</span>,
  <span class="org-string">"apacir;"</span>: <span class=
"org-string">"⩯"</span>,
  <span class="org-string">"approx;"</span>: <span class=
"org-string">"≈"</span>,
  <span class="org-string">"Assign;"</span>: <span class=
"org-string">"≔"</span>,
  <span class="org-string">"Atilde;"</span>: <span class=
"org-string">"Ã"</span>,
  <span class="org-string">"atilde;"</span>: <span class=
"org-string">"ã"</span>,
  <span class="org-string">"barvee;"</span>: <span class=
"org-string">"⊽"</span>,
  <span class="org-string">"Barwed;"</span>: <span class=
"org-string">"⌆"</span>,
  <span class="org-string">"barwed;"</span>: <span class=
"org-string">"⌅"</span>,
  <span class="org-string">"becaus;"</span>: <span class=
"org-string">"∵"</span>,
  <span class="org-string">"bernou;"</span>: <span class=
"org-string">"ℬ"</span>,
  <span class="org-string">"bigcap;"</span>: <span class=
"org-string">"⋂"</span>,
  <span class="org-string">"bigcup;"</span>: <span class=
"org-string">"⋃"</span>,
  <span class="org-string">"bigvee;"</span>: <span class=
"org-string">"⋁"</span>,
  <span class="org-string">"bkarow;"</span>: <span class=
"org-string">"⤍"</span>,
  <span class="org-string">"bottom;"</span>: <span class=
"org-string">"⊥"</span>,
  <span class="org-string">"bowtie;"</span>: <span class=
"org-string">"⋈"</span>,
  <span class="org-string">"boxbox;"</span>: <span class=
"org-string">"⧉"</span>,
  <span class="org-string">"bprime;"</span>: <span class=
"org-string">"‵"</span>,
  <span class="org-string">"brvbar;"</span>: <span class=
"org-string">"¦"</span>,
  <span class="org-string">"bullet;"</span>: <span class=
"org-string">"•"</span>,
  <span class="org-string">"Bumpeq;"</span>: <span class=
"org-string">"≎"</span>,
  <span class="org-string">"bumpeq;"</span>: <span class=
"org-string">"≏"</span>,
  <span class="org-string">"Cacute;"</span>: <span class=
"org-string">"Ć"</span>,
  <span class="org-string">"cacute;"</span>: <span class=
"org-string">"ć"</span>,
  <span class="org-string">"capand;"</span>: <span class=
"org-string">"⩄"</span>,
  <span class="org-string">"capcap;"</span>: <span class=
"org-string">"⩋"</span>,
  <span class="org-string">"capcup;"</span>: <span class=
"org-string">"⩇"</span>,
  <span class="org-string">"capdot;"</span>: <span class=
"org-string">"⩀"</span>,
  <span class="org-string">"Ccaron;"</span>: <span class=
"org-string">"Č"</span>,
  <span class="org-string">"ccaron;"</span>: <span class=
"org-string">"č"</span>,
  <span class="org-string">"Ccedil;"</span>: <span class=
"org-string">"Ç"</span>,
  <span class="org-string">"ccedil;"</span>: <span class=
"org-string">"ç"</span>,
  <span class="org-string">"circeq;"</span>: <span class=
"org-string">"≗"</span>,
  <span class="org-string">"cirmid;"</span>: <span class=
"org-string">"⫯"</span>,
  <span class="org-string">"Colone;"</span>: <span class=
"org-string">"⩴"</span>,
  <span class="org-string">"colone;"</span>: <span class=
"org-string">"≔"</span>,
  <span class="org-string">"commat;"</span>: <span class=
"org-string">"@"</span>,
  <span class="org-string">"compfn;"</span>: <span class=
"org-string">"∘"</span>,
  <span class="org-string">"Conint;"</span>: <span class=
"org-string">"∯"</span>,
  <span class="org-string">"conint;"</span>: <span class=
"org-string">"∮"</span>,
  <span class="org-string">"coprod;"</span>: <span class=
"org-string">"∐"</span>,
  <span class="org-string">"copysr;"</span>: <span class=
"org-string">"℗"</span>,
  <span class="org-string">"cularr;"</span>: <span class=
"org-string">"↶"</span>,
  <span class="org-string">"CupCap;"</span>: <span class=
"org-string">"≍"</span>,
  <span class="org-string">"cupcap;"</span>: <span class=
"org-string">"⩆"</span>,
  <span class="org-string">"cupcup;"</span>: <span class=
"org-string">"⩊"</span>,
  <span class="org-string">"cupdot;"</span>: <span class=
"org-string">"⊍"</span>,
  <span class="org-string">"curarr;"</span>: <span class=
"org-string">"↷"</span>,
  <span class="org-string">"curren;"</span>: <span class=
"org-string">"¤"</span>,
  <span class="org-string">"cylcty;"</span>: <span class=
"org-string">"⌭"</span>,
  <span class="org-string">"Dagger;"</span>: <span class=
"org-string">"‡"</span>,
  <span class="org-string">"dagger;"</span>: <span class=
"org-string">"†"</span>,
  <span class="org-string">"daleth;"</span>: <span class=
"org-string">"ℸ"</span>,
  <span class="org-string">"Dcaron;"</span>: <span class=
"org-string">"Ď"</span>,
  <span class="org-string">"dcaron;"</span>: <span class=
"org-string">"ď"</span>,
  <span class="org-string">"dfisht;"</span>: <span class=
"org-string">"⥿"</span>,
  <span class="org-string">"divide;"</span>: <span class=
"org-string">"÷"</span>,
  <span class="org-string">"divonx;"</span>: <span class=
"org-string">"⋇"</span>,
  <span class="org-string">"dlcorn;"</span>: <span class=
"org-string">"⌞"</span>,
  <span class="org-string">"dlcrop;"</span>: <span class=
"org-string">"⌍"</span>,
  <span class="org-string">"dollar;"</span>: <span class=
"org-string">"$"</span>,
  <span class="org-string">"DotDot;"</span>: <span class=
"org-string">"⃜"</span>,
  <span class="org-string">"drcorn;"</span>: <span class=
"org-string">"⌟"</span>,
  <span class="org-string">"drcrop;"</span>: <span class=
"org-string">"⌌"</span>,
  <span class="org-string">"Dstrok;"</span>: <span class=
"org-string">"Đ"</span>,
  <span class="org-string">"dstrok;"</span>: <span class=
"org-string">"đ"</span>,
  <span class="org-string">"Eacute;"</span>: <span class=
"org-string">"É"</span>,
  <span class="org-string">"eacute;"</span>: <span class=
"org-string">"é"</span>,
  <span class="org-string">"easter;"</span>: <span class=
"org-string">"⩮"</span>,
  <span class="org-string">"Ecaron;"</span>: <span class=
"org-string">"Ě"</span>,
  <span class="org-string">"ecaron;"</span>: <span class=
"org-string">"ě"</span>,
  <span class="org-string">"ecolon;"</span>: <span class=
"org-string">"≕"</span>,
  <span class="org-string">"Egrave;"</span>: <span class=
"org-string">"È"</span>,
  <span class="org-string">"egrave;"</span>: <span class=
"org-string">"è"</span>,
  <span class="org-string">"egsdot;"</span>: <span class=
"org-string">"⪘"</span>,
  <span class="org-string">"elsdot;"</span>: <span class=
"org-string">"⪗"</span>,
  <span class="org-string">"emptyv;"</span>: <span class=
"org-string">"∅"</span>,
  <span class="org-string">"emsp13;"</span>: <span class=
"org-string">" "</span>,
  <span class="org-string">"emsp14;"</span>: <span class=
"org-string">" "</span>,
  <span class="org-string">"eparsl;"</span>: <span class=
"org-string">"⧣"</span>,
  <span class="org-string">"eqcirc;"</span>: <span class=
"org-string">"≖"</span>,
  <span class="org-string">"equals;"</span>: <span class=
"org-string">"="</span>,
  <span class="org-string">"equest;"</span>: <span class=
"org-string">"≟"</span>,
  <span class="org-string">"Exists;"</span>: <span class=
"org-string">"∃"</span>,
  <span class="org-string">"female;"</span>: <span class=
"org-string">"♀"</span>,
  <span class="org-string">"ffilig;"</span>: <span class=
"org-string">"ﬃ"</span>,
  <span class="org-string">"ffllig;"</span>: <span class=
"org-string">"ﬄ"</span>,
  <span class="org-string">"ForAll;"</span>: <span class=
"org-string">"∀"</span>,
  <span class="org-string">"forall;"</span>: <span class=
"org-string">"∀"</span>,
  <span class="org-string">"frac12;"</span>: <span class=
"org-string">"½"</span>,
  <span class="org-string">"frac13;"</span>: <span class=
"org-string">"⅓"</span>,
  <span class="org-string">"frac14;"</span>: <span class=
"org-string">"¼"</span>,
  <span class="org-string">"frac15;"</span>: <span class=
"org-string">"⅕"</span>,
  <span class="org-string">"frac16;"</span>: <span class=
"org-string">"⅙"</span>,
  <span class="org-string">"frac18;"</span>: <span class=
"org-string">"⅛"</span>,
  <span class="org-string">"frac23;"</span>: <span class=
"org-string">"⅔"</span>,
  <span class="org-string">"frac25;"</span>: <span class=
"org-string">"⅖"</span>,
  <span class="org-string">"frac34;"</span>: <span class=
"org-string">"¾"</span>,
  <span class="org-string">"frac35;"</span>: <span class=
"org-string">"⅗"</span>,
  <span class="org-string">"frac38;"</span>: <span class=
"org-string">"⅜"</span>,
  <span class="org-string">"frac45;"</span>: <span class=
"org-string">"⅘"</span>,
  <span class="org-string">"frac56;"</span>: <span class=
"org-string">"⅚"</span>,
  <span class="org-string">"frac58;"</span>: <span class=
"org-string">"⅝"</span>,
  <span class="org-string">"frac78;"</span>: <span class=
"org-string">"⅞"</span>,
  <span class="org-string">"gacute;"</span>: <span class=
"org-string">"ǵ"</span>,
  <span class="org-string">"Gammad;"</span>: <span class=
"org-string">"Ϝ"</span>,
  <span class="org-string">"gammad;"</span>: <span class=
"org-string">"ϝ"</span>,
  <span class="org-string">"Gbreve;"</span>: <span class=
"org-string">"Ğ"</span>,
  <span class="org-string">"gbreve;"</span>: <span class=
"org-string">"ğ"</span>,
  <span class="org-string">"Gcedil;"</span>: <span class=
"org-string">"Ģ"</span>,
  <span class="org-string">"gesdot;"</span>: <span class=
"org-string">"⪀"</span>,
  <span class="org-string">"gesles;"</span>: <span class=
"org-string">"⪔"</span>,
  <span class="org-string">"gtlPar;"</span>: <span class=
"org-string">"⦕"</span>,
  <span class="org-string">"gtrarr;"</span>: <span class=
"org-string">"⥸"</span>,
  <span class="org-string">"gtrdot;"</span>: <span class=
"org-string">"⋗"</span>,
  <span class="org-string">"gtrsim;"</span>: <span class=
"org-string">"≳"</span>,
  <span class="org-string">"hairsp;"</span>: <span class=
"org-string">" "</span>,
  <span class="org-string">"hamilt;"</span>: <span class=
"org-string">"ℋ"</span>,
  <span class="org-string">"HARDcy;"</span>: <span class=
"org-string">"Ъ"</span>,
  <span class="org-string">"hardcy;"</span>: <span class=
"org-string">"ъ"</span>,
  <span class="org-string">"hearts;"</span>: <span class=
"org-string">"♥"</span>,
  <span class="org-string">"hellip;"</span>: <span class=
"org-string">"…"</span>,
  <span class="org-string">"hercon;"</span>: <span class=
"org-string">"⊹"</span>,
  <span class="org-string">"homtht;"</span>: <span class=
"org-string">"∻"</span>,
  <span class="org-string">"horbar;"</span>: <span class=
"org-string">"―"</span>,
  <span class="org-string">"hslash;"</span>: <span class=
"org-string">"ℏ"</span>,
  <span class="org-string">"Hstrok;"</span>: <span class=
"org-string">"Ħ"</span>,
  <span class="org-string">"hstrok;"</span>: <span class=
"org-string">"ħ"</span>,
  <span class="org-string">"hybull;"</span>: <span class=
"org-string">"⁃"</span>,
  <span class="org-string">"hyphen;"</span>: <span class=
"org-string">"‐"</span>,
  <span class="org-string">"Iacute;"</span>: <span class=
"org-string">"Í"</span>,
  <span class="org-string">"iacute;"</span>: <span class=
"org-string">"í"</span>,
  <span class="org-string">"Igrave;"</span>: <span class=
"org-string">"Ì"</span>,
  <span class="org-string">"igrave;"</span>: <span class=
"org-string">"ì"</span>,
  <span class="org-string">"iiiint;"</span>: <span class=
"org-string">"⨌"</span>,
  <span class="org-string">"iinfin;"</span>: <span class=
"org-string">"⧜"</span>,
  <span class="org-string">"incare;"</span>: <span class=
"org-string">"℅"</span>,
  <span class="org-string">"inodot;"</span>: <span class=
"org-string">"ı"</span>,
  <span class="org-string">"intcal;"</span>: <span class=
"org-string">"⊺"</span>,
  <span class="org-string">"iquest;"</span>: <span class=
"org-string">"¿"</span>,
  <span class="org-string">"isinsv;"</span>: <span class=
"org-string">"⋳"</span>,
  <span class="org-string">"Itilde;"</span>: <span class=
"org-string">"Ĩ"</span>,
  <span class="org-string">"itilde;"</span>: <span class=
"org-string">"ĩ"</span>,
  <span class="org-string">"Jsercy;"</span>: <span class=
"org-string">"Ј"</span>,
  <span class="org-string">"jsercy;"</span>: <span class=
"org-string">"ј"</span>,
  <span class="org-string">"kappav;"</span>: <span class=
"org-string">"ϰ"</span>,
  <span class="org-string">"Kcedil;"</span>: <span class=
"org-string">"Ķ"</span>,
  <span class="org-string">"kcedil;"</span>: <span class=
"org-string">"ķ"</span>,
  <span class="org-string">"kgreen;"</span>: <span class=
"org-string">"ĸ"</span>,
  <span class="org-string">"Lacute;"</span>: <span class=
"org-string">"Ĺ"</span>,
  <span class="org-string">"lacute;"</span>: <span class=
"org-string">"ĺ"</span>,
  <span class="org-string">"lagran;"</span>: <span class=
"org-string">"ℒ"</span>,
  <span class="org-string">"Lambda;"</span>: <span class=
"org-string">"Λ"</span>,
  <span class="org-string">"lambda;"</span>: <span class=
"org-string">"λ"</span>,
  <span class="org-string">"langle;"</span>: <span class=
"org-string">"⟨"</span>,
  <span class="org-string">"larrfs;"</span>: <span class=
"org-string">"⤝"</span>,
  <span class="org-string">"larrhk;"</span>: <span class=
"org-string">"↩"</span>,
  <span class="org-string">"larrlp;"</span>: <span class=
"org-string">"↫"</span>,
  <span class="org-string">"larrpl;"</span>: <span class=
"org-string">"⤹"</span>,
  <span class="org-string">"larrtl;"</span>: <span class=
"org-string">"↢"</span>,
  <span class="org-string">"lAtail;"</span>: <span class=
"org-string">"⤛"</span>,
  <span class="org-string">"latail;"</span>: <span class=
"org-string">"⤙"</span>,
  <span class="org-string">"lbrace;"</span>: <span class=
"org-string">"{"</span>,
  <span class="org-string">"lbrack;"</span>: <span class=
"org-string">"["</span>,
  <span class="org-string">"Lcaron;"</span>: <span class=
"org-string">"Ľ"</span>,
  <span class="org-string">"lcaron;"</span>: <span class=
"org-string">"ľ"</span>,
  <span class="org-string">"Lcedil;"</span>: <span class=
"org-string">"Ļ"</span>,
  <span class="org-string">"lcedil;"</span>: <span class=
"org-string">"ļ"</span>,
  <span class="org-string">"ldquor;"</span>: <span class=
"org-string">"„"</span>,
  <span class="org-string">"lesdot;"</span>: <span class=
"org-string">"⩿"</span>,
  <span class="org-string">"lesges;"</span>: <span class=
"org-string">"⪓"</span>,
  <span class="org-string">"lfisht;"</span>: <span class=
"org-string">"⥼"</span>,
  <span class="org-string">"lfloor;"</span>: <span class=
"org-string">"⌊"</span>,
  <span class="org-string">"lharul;"</span>: <span class=
"org-string">"⥪"</span>,
  <span class="org-string">"llhard;"</span>: <span class=
"org-string">"⥫"</span>,
  <span class="org-string">"Lmidot;"</span>: <span class=
"org-string">"Ŀ"</span>,
  <span class="org-string">"lmidot;"</span>: <span class=
"org-string">"ŀ"</span>,
  <span class="org-string">"lmoust;"</span>: <span class=
"org-string">"⎰"</span>,
  <span class="org-string">"loplus;"</span>: <span class=
"org-string">"⨭"</span>,
  <span class="org-string">"lowast;"</span>: <span class=
"org-string">"∗"</span>,
  <span class="org-string">"lowbar;"</span>: <span class=
"org-string">"_"</span>,
  <span class="org-string">"lparlt;"</span>: <span class=
"org-string">"⦓"</span>,
  <span class="org-string">"lrhard;"</span>: <span class=
"org-string">"⥭"</span>,
  <span class="org-string">"lsaquo;"</span>: <span class=
"org-string">"‹"</span>,
  <span class="org-string">"lsquor;"</span>: <span class=
"org-string">"‚"</span>,
  <span class="org-string">"Lstrok;"</span>: <span class=
"org-string">"Ł"</span>,
  <span class="org-string">"lstrok;"</span>: <span class=
"org-string">"ł"</span>,
  <span class="org-string">"lthree;"</span>: <span class=
"org-string">"⋋"</span>,
  <span class="org-string">"ltimes;"</span>: <span class=
"org-string">"⋉"</span>,
  <span class="org-string">"ltlarr;"</span>: <span class=
"org-string">"⥶"</span>,
  <span class="org-string">"ltrPar;"</span>: <span class=
"org-string">"⦖"</span>,
  <span class="org-string">"mapsto;"</span>: <span class=
"org-string">"↦"</span>,
  <span class="org-string">"marker;"</span>: <span class=
"org-string">"▮"</span>,
  <span class="org-string">"mcomma;"</span>: <span class=
"org-string">"⨩"</span>,
  <span class="org-string">"midast;"</span>: <span class=
"org-string">"*"</span>,
  <span class="org-string">"midcir;"</span>: <span class=
"org-string">"⫰"</span>,
  <span class="org-string">"middot;"</span>: <span class=
"org-string">"·"</span>,
  <span class="org-string">"minusb;"</span>: <span class=
"org-string">"⊟"</span>,
  <span class="org-string">"minusd;"</span>: <span class=
"org-string">"∸"</span>,
  <span class="org-string">"mnplus;"</span>: <span class=
"org-string">"∓"</span>,
  <span class="org-string">"models;"</span>: <span class=
"org-string">"⊧"</span>,
  <span class="org-string">"mstpos;"</span>: <span class=
"org-string">"∾"</span>,
  <span class="org-string">"Nacute;"</span>: <span class=
"org-string">"Ń"</span>,
  <span class="org-string">"nacute;"</span>: <span class=
"org-string">"ń"</span>,
  <span class="org-string">"nbumpe;"</span>: <span class=
"org-string">"≏̸"</span>,
  <span class="org-string">"Ncaron;"</span>: <span class=
"org-string">"Ň"</span>,
  <span class="org-string">"ncaron;"</span>: <span class=
"org-string">"ň"</span>,
  <span class="org-string">"Ncedil;"</span>: <span class=
"org-string">"Ņ"</span>,
  <span class="org-string">"ncedil;"</span>: <span class=
"org-string">"ņ"</span>,
  <span class="org-string">"nearhk;"</span>: <span class=
"org-string">"⤤"</span>,
  <span class="org-string">"nequiv;"</span>: <span class=
"org-string">"≢"</span>,
  <span class="org-string">"nesear;"</span>: <span class=
"org-string">"⤨"</span>,
  <span class="org-string">"nexist;"</span>: <span class=
"org-string">"∄"</span>,
  <span class="org-string">"nltrie;"</span>: <span class=
"org-string">"⋬"</span>,
  <span class="org-string">"notinE;"</span>: <span class=
"org-string">"⋹̸"</span>,
  <span class="org-string">"nparsl;"</span>: <span class=
"org-string">"⫽⃥"</span>,
  <span class="org-string">"nprcue;"</span>: <span class=
"org-string">"⋠"</span>,
  <span class="org-string">"nrarrc;"</span>: <span class=
"org-string">"⤳̸"</span>,
  <span class="org-string">"nrarrw;"</span>: <span class=
"org-string">"↝̸"</span>,
  <span class="org-string">"nrtrie;"</span>: <span class=
"org-string">"⋭"</span>,
  <span class="org-string">"nsccue;"</span>: <span class=
"org-string">"⋡"</span>,
  <span class="org-string">"nsimeq;"</span>: <span class=
"org-string">"≄"</span>,
  <span class="org-string">"Ntilde;"</span>: <span class=
"org-string">"Ñ"</span>,
  <span class="org-string">"ntilde;"</span>: <span class=
"org-string">"ñ"</span>,
  <span class="org-string">"numero;"</span>: <span class=
"org-string">"№"</span>,
  <span class="org-string">"nVDash;"</span>: <span class=
"org-string">"⊯"</span>,
  <span class="org-string">"nVdash;"</span>: <span class=
"org-string">"⊮"</span>,
  <span class="org-string">"nvDash;"</span>: <span class=
"org-string">"⊭"</span>,
  <span class="org-string">"nvdash;"</span>: <span class=
"org-string">"⊬"</span>,
  <span class="org-string">"nvHarr;"</span>: <span class=
"org-string">"⤄"</span>,
  <span class="org-string">"nvlArr;"</span>: <span class=
"org-string">"⤂"</span>,
  <span class="org-string">"nvrArr;"</span>: <span class=
"org-string">"⤃"</span>,
  <span class="org-string">"nwarhk;"</span>: <span class=
"org-string">"⤣"</span>,
  <span class="org-string">"nwnear;"</span>: <span class=
"org-string">"⤧"</span>,
  <span class="org-string">"Oacute;"</span>: <span class=
"org-string">"Ó"</span>,
  <span class="org-string">"oacute;"</span>: <span class=
"org-string">"ó"</span>,
  <span class="org-string">"Odblac;"</span>: <span class=
"org-string">"Ő"</span>,
  <span class="org-string">"odblac;"</span>: <span class=
"org-string">"ő"</span>,
  <span class="org-string">"odsold;"</span>: <span class=
"org-string">"⦼"</span>,
  <span class="org-string">"Ograve;"</span>: <span class=
"org-string">"Ò"</span>,
  <span class="org-string">"ograve;"</span>: <span class=
"org-string">"ò"</span>,
  <span class="org-string">"ominus;"</span>: <span class=
"org-string">"⊖"</span>,
  <span class="org-string">"origof;"</span>: <span class=
"org-string">"⊶"</span>,
  <span class="org-string">"Oslash;"</span>: <span class=
"org-string">"Ø"</span>,
  <span class="org-string">"oslash;"</span>: <span class=
"org-string">"ø"</span>,
  <span class="org-string">"Otilde;"</span>: <span class=
"org-string">"Õ"</span>,
  <span class="org-string">"otilde;"</span>: <span class=
"org-string">"õ"</span>,
  <span class="org-string">"Otimes;"</span>: <span class=
"org-string">"⨷"</span>,
  <span class="org-string">"otimes;"</span>: <span class=
"org-string">"⊗"</span>,
  <span class="org-string">"parsim;"</span>: <span class=
"org-string">"⫳"</span>,
  <span class="org-string">"percnt;"</span>: <span class=
"org-string">"%"</span>,
  <span class="org-string">"period;"</span>: <span class=
"org-string">"."</span>,
  <span class="org-string">"permil;"</span>: <span class=
"org-string">"‰"</span>,
  <span class="org-string">"phmmat;"</span>: <span class=
"org-string">"ℳ"</span>,
  <span class="org-string">"planck;"</span>: <span class=
"org-string">"ℏ"</span>,
  <span class="org-string">"plankv;"</span>: <span class=
"org-string">"ℏ"</span>,
  <span class="org-string">"plusdo;"</span>: <span class=
"org-string">"∔"</span>,
  <span class="org-string">"plusdu;"</span>: <span class=
"org-string">"⨥"</span>,
  <span class="org-string">"plusmn;"</span>: <span class=
"org-string">"±"</span>,
  <span class="org-string">"preceq;"</span>: <span class=
"org-string">"⪯"</span>,
  <span class="org-string">"primes;"</span>: <span class=
"org-string">"ℙ"</span>,
  <span class="org-string">"prnsim;"</span>: <span class=
"org-string">"⋨"</span>,
  <span class="org-string">"propto;"</span>: <span class=
"org-string">"∝"</span>,
  <span class="org-string">"prurel;"</span>: <span class=
"org-string">"⊰"</span>,
  <span class="org-string">"puncsp;"</span>: <span class=
"org-string">" "</span>,
  <span class="org-string">"qprime;"</span>: <span class=
"org-string">"⁗"</span>,
  <span class="org-string">"Racute;"</span>: <span class=
"org-string">"Ŕ"</span>,
  <span class="org-string">"racute;"</span>: <span class=
"org-string">"ŕ"</span>,
  <span class="org-string">"rangle;"</span>: <span class=
"org-string">"⟩"</span>,
  <span class="org-string">"rarrap;"</span>: <span class=
"org-string">"⥵"</span>,
  <span class="org-string">"rarrfs;"</span>: <span class=
"org-string">"⤞"</span>,
  <span class="org-string">"rarrhk;"</span>: <span class=
"org-string">"↪"</span>,
  <span class="org-string">"rarrlp;"</span>: <span class=
"org-string">"↬"</span>,
  <span class="org-string">"rarrpl;"</span>: <span class=
"org-string">"⥅"</span>,
  <span class="org-string">"Rarrtl;"</span>: <span class=
"org-string">"⤖"</span>,
  <span class="org-string">"rarrtl;"</span>: <span class=
"org-string">"↣"</span>,
  <span class="org-string">"rAtail;"</span>: <span class=
"org-string">"⤜"</span>,
  <span class="org-string">"ratail;"</span>: <span class=
"org-string">"⤚"</span>,
  <span class="org-string">"rbrace;"</span>: <span class=
"org-string">"}"</span>,
  <span class="org-string">"rbrack;"</span>: <span class=
"org-string">"]"</span>,
  <span class="org-string">"Rcaron;"</span>: <span class=
"org-string">"Ř"</span>,
  <span class="org-string">"rcaron;"</span>: <span class=
"org-string">"ř"</span>,
  <span class="org-string">"Rcedil;"</span>: <span class=
"org-string">"Ŗ"</span>,
  <span class="org-string">"rcedil;"</span>: <span class=
"org-string">"ŗ"</span>,
  <span class="org-string">"rdquor;"</span>: <span class=
"org-string">"”"</span>,
  <span class="org-string">"rfisht;"</span>: <span class=
"org-string">"⥽"</span>,
  <span class="org-string">"rfloor;"</span>: <span class=
"org-string">"⌋"</span>,
  <span class="org-string">"rharul;"</span>: <span class=
"org-string">"⥬"</span>,
  <span class="org-string">"rmoust;"</span>: <span class=
"org-string">"⎱"</span>,
  <span class="org-string">"roplus;"</span>: <span class=
"org-string">"⨮"</span>,
  <span class="org-string">"rpargt;"</span>: <span class=
"org-string">"⦔"</span>,
  <span class="org-string">"rsaquo;"</span>: <span class=
"org-string">"›"</span>,
  <span class="org-string">"rsquor;"</span>: <span class=
"org-string">"’"</span>,
  <span class="org-string">"rthree;"</span>: <span class=
"org-string">"⋌"</span>,
  <span class="org-string">"rtimes;"</span>: <span class=
"org-string">"⋊"</span>,
  <span class="org-string">"Sacute;"</span>: <span class=
"org-string">"Ś"</span>,
  <span class="org-string">"sacute;"</span>: <span class=
"org-string">"ś"</span>,
  <span class="org-string">"Scaron;"</span>: <span class=
"org-string">"Š"</span>,
  <span class="org-string">"scaron;"</span>: <span class=
"org-string">"š"</span>,
  <span class="org-string">"Scedil;"</span>: <span class=
"org-string">"Ş"</span>,
  <span class="org-string">"scedil;"</span>: <span class=
"org-string">"ş"</span>,
  <span class="org-string">"scnsim;"</span>: <span class=
"org-string">"⋩"</span>,
  <span class="org-string">"searhk;"</span>: <span class=
"org-string">"⤥"</span>,
  <span class="org-string">"seswar;"</span>: <span class=
"org-string">"⤩"</span>,
  <span class="org-string">"sfrown;"</span>: <span class=
"org-string">"⌢"</span>,
  <span class="org-string">"SHCHcy;"</span>: <span class=
"org-string">"Щ"</span>,
  <span class="org-string">"shchcy;"</span>: <span class=
"org-string">"щ"</span>,
  <span class="org-string">"sigmaf;"</span>: <span class=
"org-string">"ς"</span>,
  <span class="org-string">"sigmav;"</span>: <span class=
"org-string">"ς"</span>,
  <span class="org-string">"simdot;"</span>: <span class=
"org-string">"⩪"</span>,
  <span class="org-string">"smashp;"</span>: <span class=
"org-string">"⨳"</span>,
  <span class="org-string">"SOFTcy;"</span>: <span class=
"org-string">"Ь"</span>,
  <span class="org-string">"softcy;"</span>: <span class=
"org-string">"ь"</span>,
  <span class="org-string">"solbar;"</span>: <span class=
"org-string">"⌿"</span>,
  <span class="org-string">"spades;"</span>: <span class=
"org-string">"♠"</span>,
  <span class="org-string">"sqcaps;"</span>: <span class=
"org-string">"⊓︀"</span>,
  <span class="org-string">"sqcups;"</span>: <span class=
"org-string">"⊔︀"</span>,
  <span class="org-string">"sqsube;"</span>: <span class=
"org-string">"⊑"</span>,
  <span class="org-string">"sqsupe;"</span>: <span class=
"org-string">"⊒"</span>,
  <span class="org-string">"Square;"</span>: <span class=
"org-string">"□"</span>,
  <span class="org-string">"square;"</span>: <span class=
"org-string">"□"</span>,
  <span class="org-string">"squarf;"</span>: <span class=
"org-string">"▪"</span>,
  <span class="org-string">"ssetmn;"</span>: <span class=
"org-string">"∖"</span>,
  <span class="org-string">"ssmile;"</span>: <span class=
"org-string">"⌣"</span>,
  <span class="org-string">"sstarf;"</span>: <span class=
"org-string">"⋆"</span>,
  <span class="org-string">"subdot;"</span>: <span class=
"org-string">"⪽"</span>,
  <span class="org-string">"Subset;"</span>: <span class=
"org-string">"⋐"</span>,
  <span class="org-string">"subset;"</span>: <span class=
"org-string">"⊂"</span>,
  <span class="org-string">"subsim;"</span>: <span class=
"org-string">"⫇"</span>,
  <span class="org-string">"subsub;"</span>: <span class=
"org-string">"⫕"</span>,
  <span class="org-string">"subsup;"</span>: <span class=
"org-string">"⫓"</span>,
  <span class="org-string">"succeq;"</span>: <span class=
"org-string">"⪰"</span>,
  <span class="org-string">"supdot;"</span>: <span class=
"org-string">"⪾"</span>,
  <span class="org-string">"Supset;"</span>: <span class=
"org-string">"⋑"</span>,
  <span class="org-string">"supset;"</span>: <span class=
"org-string">"⊃"</span>,
  <span class="org-string">"supsim;"</span>: <span class=
"org-string">"⫈"</span>,
  <span class="org-string">"supsub;"</span>: <span class=
"org-string">"⫔"</span>,
  <span class="org-string">"supsup;"</span>: <span class=
"org-string">"⫖"</span>,
  <span class="org-string">"swarhk;"</span>: <span class=
"org-string">"⤦"</span>,
  <span class="org-string">"swnwar;"</span>: <span class=
"org-string">"⤪"</span>,
  <span class="org-string">"target;"</span>: <span class=
"org-string">"⌖"</span>,
  <span class="org-string">"Tcaron;"</span>: <span class=
"org-string">"Ť"</span>,
  <span class="org-string">"tcaron;"</span>: <span class=
"org-string">"ť"</span>,
  <span class="org-string">"Tcedil;"</span>: <span class=
"org-string">"Ţ"</span>,
  <span class="org-string">"tcedil;"</span>: <span class=
"org-string">"ţ"</span>,
  <span class="org-string">"telrec;"</span>: <span class=
"org-string">"⌕"</span>,
  <span class="org-string">"there4;"</span>: <span class=
"org-string">"∴"</span>,
  <span class="org-string">"thetav;"</span>: <span class=
"org-string">"ϑ"</span>,
  <span class="org-string">"thinsp;"</span>: <span class=
"org-string">" "</span>,
  <span class="org-string">"thksim;"</span>: <span class=
"org-string">"∼"</span>,
  <span class="org-string">"timesb;"</span>: <span class=
"org-string">"⊠"</span>,
  <span class="org-string">"timesd;"</span>: <span class=
"org-string">"⨰"</span>,
  <span class="org-string">"topbot;"</span>: <span class=
"org-string">"⌶"</span>,
  <span class="org-string">"topcir;"</span>: <span class=
"org-string">"⫱"</span>,
  <span class="org-string">"tprime;"</span>: <span class=
"org-string">"‴"</span>,
  <span class="org-string">"tridot;"</span>: <span class=
"org-string">"◬"</span>,
  <span class="org-string">"Tstrok;"</span>: <span class=
"org-string">"Ŧ"</span>,
  <span class="org-string">"tstrok;"</span>: <span class=
"org-string">"ŧ"</span>,
  <span class="org-string">"Uacute;"</span>: <span class=
"org-string">"Ú"</span>,
  <span class="org-string">"uacute;"</span>: <span class=
"org-string">"ú"</span>,
  <span class="org-string">"Ubreve;"</span>: <span class=
"org-string">"Ŭ"</span>,
  <span class="org-string">"ubreve;"</span>: <span class=
"org-string">"ŭ"</span>,
  <span class="org-string">"Udblac;"</span>: <span class=
"org-string">"Ű"</span>,
  <span class="org-string">"udblac;"</span>: <span class=
"org-string">"ű"</span>,
  <span class="org-string">"ufisht;"</span>: <span class=
"org-string">"⥾"</span>,
  <span class="org-string">"Ugrave;"</span>: <span class=
"org-string">"Ù"</span>,
  <span class="org-string">"ugrave;"</span>: <span class=
"org-string">"ù"</span>,
  <span class="org-string">"ulcorn;"</span>: <span class=
"org-string">"⌜"</span>,
  <span class="org-string">"ulcrop;"</span>: <span class=
"org-string">"⌏"</span>,
  <span class="org-string">"urcorn;"</span>: <span class=
"org-string">"⌝"</span>,
  <span class="org-string">"urcrop;"</span>: <span class=
"org-string">"⌎"</span>,
  <span class="org-string">"Utilde;"</span>: <span class=
"org-string">"Ũ"</span>,
  <span class="org-string">"utilde;"</span>: <span class=
"org-string">"ũ"</span>,
  <span class="org-string">"vangrt;"</span>: <span class=
"org-string">"⦜"</span>,
  <span class="org-string">"varphi;"</span>: <span class=
"org-string">"ϕ"</span>,
  <span class="org-string">"varrho;"</span>: <span class=
"org-string">"ϱ"</span>,
  <span class="org-string">"Vdashl;"</span>: <span class=
"org-string">"⫦"</span>,
  <span class="org-string">"veebar;"</span>: <span class=
"org-string">"⊻"</span>,
  <span class="org-string">"vellip;"</span>: <span class=
"org-string">"⋮"</span>,
  <span class="org-string">"Verbar;"</span>: <span class=
"org-string">"‖"</span>,
  <span class="org-string">"verbar;"</span>: <span class=
"org-string">"|"</span>,
  <span class="org-string">"vsubnE;"</span>: <span class=
"org-string">"⫋︀"</span>,
  <span class="org-string">"vsubne;"</span>: <span class=
"org-string">"⊊︀"</span>,
  <span class="org-string">"vsupnE;"</span>: <span class=
"org-string">"⫌︀"</span>,
  <span class="org-string">"vsupne;"</span>: <span class=
"org-string">"⊋︀"</span>,
  <span class="org-string">"Vvdash;"</span>: <span class=
"org-string">"⊪"</span>,
  <span class="org-string">"wedbar;"</span>: <span class=
"org-string">"⩟"</span>,
  <span class="org-string">"wedgeq;"</span>: <span class=
"org-string">"≙"</span>,
  <span class="org-string">"weierp;"</span>: <span class=
"org-string">"℘"</span>,
  <span class="org-string">"wreath;"</span>: <span class=
"org-string">"≀"</span>,
  <span class="org-string">"xoplus;"</span>: <span class=
"org-string">"⨁"</span>,
  <span class="org-string">"xotime;"</span>: <span class=
"org-string">"⨂"</span>,
  <span class="org-string">"xsqcup;"</span>: <span class=
"org-string">"⨆"</span>,
  <span class="org-string">"xuplus;"</span>: <span class=
"org-string">"⨄"</span>,
  <span class="org-string">"xwedge;"</span>: <span class=
"org-string">"⋀"</span>,
  <span class="org-string">"Yacute;"</span>: <span class=
"org-string">"Ý"</span>,
  <span class="org-string">"yacute;"</span>: <span class=
"org-string">"ý"</span>,
  <span class="org-string">"Zacute;"</span>: <span class=
"org-string">"Ź"</span>,
  <span class="org-string">"zacute;"</span>: <span class=
"org-string">"ź"</span>,
  <span class="org-string">"Zcaron;"</span>: <span class=
"org-string">"Ž"</span>,
  <span class="org-string">"zcaron;"</span>: <span class=
"org-string">"ž"</span>,
  <span class="org-string">"zeetrf;"</span>: <span class=
"org-string">"ℨ"</span>,
  <span class="org-string">"alefsym;"</span>: <span class=
"org-string">"ℵ"</span>,
  <span class="org-string">"angrtvb;"</span>: <span class=
"org-string">"⊾"</span>,
  <span class="org-string">"angzarr;"</span>: <span class=
"org-string">"⍼"</span>,
  <span class="org-string">"asympeq;"</span>: <span class=
"org-string">"≍"</span>,
  <span class="org-string">"backsim;"</span>: <span class=
"org-string">"∽"</span>,
  <span class="org-string">"Because;"</span>: <span class=
"org-string">"∵"</span>,
  <span class="org-string">"because;"</span>: <span class=
"org-string">"∵"</span>,
  <span class="org-string">"bemptyv;"</span>: <span class=
"org-string">"⦰"</span>,
  <span class="org-string">"between;"</span>: <span class=
"org-string">"≬"</span>,
  <span class="org-string">"bigcirc;"</span>: <span class=
"org-string">"◯"</span>,
  <span class="org-string">"bigodot;"</span>: <span class=
"org-string">"⨀"</span>,
  <span class="org-string">"bigstar;"</span>: <span class=
"org-string">"★"</span>,
  <span class="org-string">"bnequiv;"</span>: <span class=
"org-string">"≡⃥"</span>,
  <span class="org-string">"boxplus;"</span>: <span class=
"org-string">"⊞"</span>,
  <span class="org-string">"Cayleys;"</span>: <span class=
"org-string">"ℭ"</span>,
  <span class="org-string">"Cconint;"</span>: <span class=
"org-string">"∰"</span>,
  <span class="org-string">"ccupssm;"</span>: <span class=
"org-string">"⩐"</span>,
  <span class="org-string">"Cedilla;"</span>: <span class=
"org-string">"¸"</span>,
  <span class="org-string">"cemptyv;"</span>: <span class=
"org-string">"⦲"</span>,
  <span class="org-string">"cirscir;"</span>: <span class=
"org-string">"⧂"</span>,
  <span class="org-string">"coloneq;"</span>: <span class=
"org-string">"≔"</span>,
  <span class="org-string">"congdot;"</span>: <span class=
"org-string">"⩭"</span>,
  <span class="org-string">"cudarrl;"</span>: <span class=
"org-string">"⤸"</span>,
  <span class="org-string">"cudarrr;"</span>: <span class=
"org-string">"⤵"</span>,
  <span class="org-string">"cularrp;"</span>: <span class=
"org-string">"⤽"</span>,
  <span class="org-string">"curarrm;"</span>: <span class=
"org-string">"⤼"</span>,
  <span class="org-string">"dbkarow;"</span>: <span class=
"org-string">"⤏"</span>,
  <span class="org-string">"ddagger;"</span>: <span class=
"org-string">"‡"</span>,
  <span class="org-string">"ddotseq;"</span>: <span class=
"org-string">"⩷"</span>,
  <span class="org-string">"demptyv;"</span>: <span class=
"org-string">"⦱"</span>,
  <span class="org-string">"Diamond;"</span>: <span class=
"org-string">"⋄"</span>,
  <span class="org-string">"diamond;"</span>: <span class=
"org-string">"⋄"</span>,
  <span class="org-string">"digamma;"</span>: <span class=
"org-string">"ϝ"</span>,
  <span class="org-string">"dotplus;"</span>: <span class=
"org-string">"∔"</span>,
  <span class="org-string">"DownTee;"</span>: <span class=
"org-string">"⊤"</span>,
  <span class="org-string">"dwangle;"</span>: <span class=
"org-string">"⦦"</span>,
  <span class="org-string">"Element;"</span>: <span class=
"org-string">"∈"</span>,
  <span class="org-string">"Epsilon;"</span>: <span class=
"org-string">"Ε"</span>,
  <span class="org-string">"epsilon;"</span>: <span class=
"org-string">"ε"</span>,
  <span class="org-string">"eqcolon;"</span>: <span class=
"org-string">"≕"</span>,
  <span class="org-string">"equivDD;"</span>: <span class=
"org-string">"⩸"</span>,
  <span class="org-string">"gesdoto;"</span>: <span class=
"org-string">"⪂"</span>,
  <span class="org-string">"gtquest;"</span>: <span class=
"org-string">"⩼"</span>,
  <span class="org-string">"gtrless;"</span>: <span class=
"org-string">"≷"</span>,
  <span class="org-string">"harrcir;"</span>: <span class=
"org-string">"⥈"</span>,
  <span class="org-string">"Implies;"</span>: <span class=
"org-string">"⇒"</span>,
  <span class="org-string">"intprod;"</span>: <span class=
"org-string">"⨼"</span>,
  <span class="org-string">"isindot;"</span>: <span class=
"org-string">"⋵"</span>,
  <span class="org-string">"larrbfs;"</span>: <span class=
"org-string">"⤟"</span>,
  <span class="org-string">"larrsim;"</span>: <span class=
"org-string">"⥳"</span>,
  <span class="org-string">"lbrksld;"</span>: <span class=
"org-string">"⦏"</span>,
  <span class="org-string">"lbrkslu;"</span>: <span class=
"org-string">"⦍"</span>,
  <span class="org-string">"ldrdhar;"</span>: <span class=
"org-string">"⥧"</span>,
  <span class="org-string">"LeftTee;"</span>: <span class=
"org-string">"⊣"</span>,
  <span class="org-string">"lesdoto;"</span>: <span class=
"org-string">"⪁"</span>,
  <span class="org-string">"lessdot;"</span>: <span class=
"org-string">"⋖"</span>,
  <span class="org-string">"lessgtr;"</span>: <span class=
"org-string">"≶"</span>,
  <span class="org-string">"lesssim;"</span>: <span class=
"org-string">"≲"</span>,
  <span class="org-string">"lotimes;"</span>: <span class=
"org-string">"⨴"</span>,
  <span class="org-string">"lozenge;"</span>: <span class=
"org-string">"◊"</span>,
  <span class="org-string">"ltquest;"</span>: <span class=
"org-string">"⩻"</span>,
  <span class="org-string">"luruhar;"</span>: <span class=
"org-string">"⥦"</span>,
  <span class="org-string">"maltese;"</span>: <span class=
"org-string">"✠"</span>,
  <span class="org-string">"minusdu;"</span>: <span class=
"org-string">"⨪"</span>,
  <span class="org-string">"napprox;"</span>: <span class=
"org-string">"≉"</span>,
  <span class="org-string">"natural;"</span>: <span class=
"org-string">"♮"</span>,
  <span class="org-string">"nearrow;"</span>: <span class=
"org-string">"↗"</span>,
  <span class="org-string">"NewLine;"</span>: <span class=
"org-string">"\n"</span>,
  <span class="org-string">"nexists;"</span>: <span class=
"org-string">"∄"</span>,
  <span class="org-string">"NoBreak;"</span>: <span class=
"org-string">"⁠"</span>,
  <span class="org-string">"notinva;"</span>: <span class=
"org-string">"∉"</span>,
  <span class="org-string">"notinvb;"</span>: <span class=
"org-string">"⋷"</span>,
  <span class="org-string">"notinvc;"</span>: <span class=
"org-string">"⋶"</span>,
  <span class="org-string">"NotLess;"</span>: <span class=
"org-string">"≮"</span>,
  <span class="org-string">"notniva;"</span>: <span class=
"org-string">"∌"</span>,
  <span class="org-string">"notnivb;"</span>: <span class=
"org-string">"⋾"</span>,
  <span class="org-string">"notnivc;"</span>: <span class=
"org-string">"⋽"</span>,
  <span class="org-string">"npolint;"</span>: <span class=
"org-string">"⨔"</span>,
  <span class="org-string">"npreceq;"</span>: <span class=
"org-string">"⪯̸"</span>,
  <span class="org-string">"nsqsube;"</span>: <span class=
"org-string">"⋢"</span>,
  <span class="org-string">"nsqsupe;"</span>: <span class=
"org-string">"⋣"</span>,
  <span class="org-string">"nsubset;"</span>: <span class=
"org-string">"⊂⃒"</span>,
  <span class="org-string">"nsucceq;"</span>: <span class=
"org-string">"⪰̸"</span>,
  <span class="org-string">"nsupset;"</span>: <span class=
"org-string">"⊃⃒"</span>,
  <span class="org-string">"nvinfin;"</span>: <span class=
"org-string">"⧞"</span>,
  <span class="org-string">"nvltrie;"</span>: <span class=
"org-string">"⊴⃒"</span>,
  <span class="org-string">"nvrtrie;"</span>: <span class=
"org-string">"⊵⃒"</span>,
  <span class="org-string">"nwarrow;"</span>: <span class=
"org-string">"↖"</span>,
  <span class="org-string">"olcross;"</span>: <span class=
"org-string">"⦻"</span>,
  <span class="org-string">"Omicron;"</span>: <span class=
"org-string">"Ο"</span>,
  <span class="org-string">"omicron;"</span>: <span class=
"org-string">"ο"</span>,
  <span class="org-string">"orderof;"</span>: <span class=
"org-string">"ℴ"</span>,
  <span class="org-string">"orslope;"</span>: <span class=
"org-string">"⩗"</span>,
  <span class="org-string">"OverBar;"</span>: <span class=
"org-string">"‾"</span>,
  <span class="org-string">"pertenk;"</span>: <span class=
"org-string">"‱"</span>,
  <span class="org-string">"planckh;"</span>: <span class=
"org-string">"ℎ"</span>,
  <span class="org-string">"pluscir;"</span>: <span class=
"org-string">"⨢"</span>,
  <span class="org-string">"plussim;"</span>: <span class=
"org-string">"⨦"</span>,
  <span class="org-string">"plustwo;"</span>: <span class=
"org-string">"⨧"</span>,
  <span class="org-string">"precsim;"</span>: <span class=
"org-string">"≾"</span>,
  <span class="org-string">"Product;"</span>: <span class=
"org-string">"∏"</span>,
  <span class="org-string">"quatint;"</span>: <span class=
"org-string">"⨖"</span>,
  <span class="org-string">"questeq;"</span>: <span class=
"org-string">"≟"</span>,
  <span class="org-string">"rarrbfs;"</span>: <span class=
"org-string">"⤠"</span>,
  <span class="org-string">"rarrsim;"</span>: <span class=
"org-string">"⥴"</span>,
  <span class="org-string">"rbrksld;"</span>: <span class=
"org-string">"⦎"</span>,
  <span class="org-string">"rbrkslu;"</span>: <span class=
"org-string">"⦐"</span>,
  <span class="org-string">"rdldhar;"</span>: <span class=
"org-string">"⥩"</span>,
  <span class="org-string">"realine;"</span>: <span class=
"org-string">"ℛ"</span>,
  <span class="org-string">"rotimes;"</span>: <span class=
"org-string">"⨵"</span>,
  <span class="org-string">"ruluhar;"</span>: <span class=
"org-string">"⥨"</span>,
  <span class="org-string">"searrow;"</span>: <span class=
"org-string">"↘"</span>,
  <span class="org-string">"simplus;"</span>: <span class=
"org-string">"⨤"</span>,
  <span class="org-string">"simrarr;"</span>: <span class=
"org-string">"⥲"</span>,
  <span class="org-string">"subedot;"</span>: <span class=
"org-string">"⫃"</span>,
  <span class="org-string">"submult;"</span>: <span class=
"org-string">"⫁"</span>,
  <span class="org-string">"subplus;"</span>: <span class=
"org-string">"⪿"</span>,
  <span class="org-string">"subrarr;"</span>: <span class=
"org-string">"⥹"</span>,
  <span class="org-string">"succsim;"</span>: <span class=
"org-string">"≿"</span>,
  <span class="org-string">"supdsub;"</span>: <span class=
"org-string">"⫘"</span>,
  <span class="org-string">"supedot;"</span>: <span class=
"org-string">"⫄"</span>,
  <span class="org-string">"suphsol;"</span>: <span class=
"org-string">"⟉"</span>,
  <span class="org-string">"suphsub;"</span>: <span class=
"org-string">"⫗"</span>,
  <span class="org-string">"suplarr;"</span>: <span class=
"org-string">"⥻"</span>,
  <span class="org-string">"supmult;"</span>: <span class=
"org-string">"⫂"</span>,
  <span class="org-string">"supplus;"</span>: <span class=
"org-string">"⫀"</span>,
  <span class="org-string">"swarrow;"</span>: <span class=
"org-string">"↙"</span>,
  <span class="org-string">"topfork;"</span>: <span class=
"org-string">"⫚"</span>,
  <span class="org-string">"triplus;"</span>: <span class=
"org-string">"⨹"</span>,
  <span class="org-string">"tritime;"</span>: <span class=
"org-string">"⨻"</span>,
  <span class="org-string">"UpArrow;"</span>: <span class=
"org-string">"↑"</span>,
  <span class="org-string">"Uparrow;"</span>: <span class=
"org-string">"⇑"</span>,
  <span class="org-string">"uparrow;"</span>: <span class=
"org-string">"↑"</span>,
  <span class="org-string">"Upsilon;"</span>: <span class=
"org-string">"Υ"</span>,
  <span class="org-string">"upsilon;"</span>: <span class=
"org-string">"υ"</span>,
  <span class="org-string">"uwangle;"</span>: <span class=
"org-string">"⦧"</span>,
  <span class="org-string">"vzigzag;"</span>: <span class=
"org-string">"⦚"</span>,
  <span class="org-string">"zigrarr;"</span>: <span class=
"org-string">"⇝"</span>,
  <span class="org-string">"andslope;"</span>: <span class=
"org-string">"⩘"</span>,
  <span class="org-string">"angmsdaa;"</span>: <span class=
"org-string">"⦨"</span>,
  <span class="org-string">"angmsdab;"</span>: <span class=
"org-string">"⦩"</span>,
  <span class="org-string">"angmsdac;"</span>: <span class=
"org-string">"⦪"</span>,
  <span class="org-string">"angmsdad;"</span>: <span class=
"org-string">"⦫"</span>,
  <span class="org-string">"angmsdae;"</span>: <span class=
"org-string">"⦬"</span>,
  <span class="org-string">"angmsdaf;"</span>: <span class=
"org-string">"⦭"</span>,
  <span class="org-string">"angmsdag;"</span>: <span class=
"org-string">"⦮"</span>,
  <span class="org-string">"angmsdah;"</span>: <span class=
"org-string">"⦯"</span>,
  <span class="org-string">"angrtvbd;"</span>: <span class=
"org-string">"⦝"</span>,
  <span class="org-string">"approxeq;"</span>: <span class=
"org-string">"≊"</span>,
  <span class="org-string">"awconint;"</span>: <span class=
"org-string">"∳"</span>,
  <span class="org-string">"backcong;"</span>: <span class=
"org-string">"≌"</span>,
  <span class="org-string">"barwedge;"</span>: <span class=
"org-string">"⌅"</span>,
  <span class="org-string">"bbrktbrk;"</span>: <span class=
"org-string">"⎶"</span>,
  <span class="org-string">"bigoplus;"</span>: <span class=
"org-string">"⨁"</span>,
  <span class="org-string">"bigsqcup;"</span>: <span class=
"org-string">"⨆"</span>,
  <span class="org-string">"biguplus;"</span>: <span class=
"org-string">"⨄"</span>,
  <span class="org-string">"bigwedge;"</span>: <span class=
"org-string">"⋀"</span>,
  <span class="org-string">"boxminus;"</span>: <span class=
"org-string">"⊟"</span>,
  <span class="org-string">"boxtimes;"</span>: <span class=
"org-string">"⊠"</span>,
  <span class="org-string">"bsolhsub;"</span>: <span class=
"org-string">"⟈"</span>,
  <span class="org-string">"capbrcup;"</span>: <span class=
"org-string">"⩉"</span>,
  <span class="org-string">"circledR;"</span>: <span class=
"org-string">"®"</span>,
  <span class="org-string">"circledS;"</span>: <span class=
"org-string">"Ⓢ"</span>,
  <span class="org-string">"cirfnint;"</span>: <span class=
"org-string">"⨐"</span>,
  <span class="org-string">"clubsuit;"</span>: <span class=
"org-string">"♣"</span>,
  <span class="org-string">"cupbrcap;"</span>: <span class=
"org-string">"⩈"</span>,
  <span class="org-string">"curlyvee;"</span>: <span class=
"org-string">"⋎"</span>,
  <span class="org-string">"cwconint;"</span>: <span class=
"org-string">"∲"</span>,
  <span class="org-string">"DDotrahd;"</span>: <span class=
"org-string">"⤑"</span>,
  <span class="org-string">"doteqdot;"</span>: <span class=
"org-string">"≑"</span>,
  <span class="org-string">"DotEqual;"</span>: <span class=
"org-string">"≐"</span>,
  <span class="org-string">"dotminus;"</span>: <span class=
"org-string">"∸"</span>,
  <span class="org-string">"drbkarow;"</span>: <span class=
"org-string">"⤐"</span>,
  <span class="org-string">"dzigrarr;"</span>: <span class=
"org-string">"⟿"</span>,
  <span class="org-string">"elinters;"</span>: <span class=
"org-string">"⏧"</span>,
  <span class="org-string">"emptyset;"</span>: <span class=
"org-string">"∅"</span>,
  <span class="org-string">"eqvparsl;"</span>: <span class=
"org-string">"⧥"</span>,
  <span class="org-string">"fpartint;"</span>: <span class=
"org-string">"⨍"</span>,
  <span class="org-string">"geqslant;"</span>: <span class=
"org-string">"⩾"</span>,
  <span class="org-string">"gesdotol;"</span>: <span class=
"org-string">"⪄"</span>,
  <span class="org-string">"gnapprox;"</span>: <span class=
"org-string">"⪊"</span>,
  <span class="org-string">"hksearow;"</span>: <span class=
"org-string">"⤥"</span>,
  <span class="org-string">"hkswarow;"</span>: <span class=
"org-string">"⤦"</span>,
  <span class="org-string">"imagline;"</span>: <span class=
"org-string">"ℐ"</span>,
  <span class="org-string">"imagpart;"</span>: <span class=
"org-string">"ℑ"</span>,
  <span class="org-string">"infintie;"</span>: <span class=
"org-string">"⧝"</span>,
  <span class="org-string">"integers;"</span>: <span class=
"org-string">"ℤ"</span>,
  <span class="org-string">"Integral;"</span>: <span class=
"org-string">"∫"</span>,
  <span class="org-string">"intercal;"</span>: <span class=
"org-string">"⊺"</span>,
  <span class="org-string">"intlarhk;"</span>: <span class=
"org-string">"⨗"</span>,
  <span class="org-string">"laemptyv;"</span>: <span class=
"org-string">"⦴"</span>,
  <span class="org-string">"ldrushar;"</span>: <span class=
"org-string">"⥋"</span>,
  <span class="org-string">"leqslant;"</span>: <span class=
"org-string">"⩽"</span>,
  <span class="org-string">"lesdotor;"</span>: <span class=
"org-string">"⪃"</span>,
  <span class="org-string">"LessLess;"</span>: <span class=
"org-string">"⪡"</span>,
  <span class="org-string">"llcorner;"</span>: <span class=
"org-string">"⌞"</span>,
  <span class="org-string">"lnapprox;"</span>: <span class=
"org-string">"⪉"</span>,
  <span class="org-string">"lrcorner;"</span>: <span class=
"org-string">"⌟"</span>,
  <span class="org-string">"lurdshar;"</span>: <span class=
"org-string">"⥊"</span>,
  <span class="org-string">"mapstoup;"</span>: <span class=
"org-string">"↥"</span>,
  <span class="org-string">"multimap;"</span>: <span class=
"org-string">"⊸"</span>,
  <span class="org-string">"naturals;"</span>: <span class=
"org-string">"ℕ"</span>,
  <span class="org-string">"ncongdot;"</span>: <span class=
"org-string">"⩭̸"</span>,
  <span class="org-string">"NotEqual;"</span>: <span class=
"org-string">"≠"</span>,
  <span class="org-string">"notindot;"</span>: <span class=
"org-string">"⋵̸"</span>,
  <span class="org-string">"NotTilde;"</span>: <span class=
"org-string">"≁"</span>,
  <span class="org-string">"otimesas;"</span>: <span class=
"org-string">"⨶"</span>,
  <span class="org-string">"parallel;"</span>: <span class=
"org-string">"∥"</span>,
  <span class="org-string">"PartialD;"</span>: <span class=
"org-string">"∂"</span>,
  <span class="org-string">"plusacir;"</span>: <span class=
"org-string">"⨣"</span>,
  <span class="org-string">"pointint;"</span>: <span class=
"org-string">"⨕"</span>,
  <span class="org-string">"Precedes;"</span>: <span class=
"org-string">"≺"</span>,
  <span class="org-string">"precneqq;"</span>: <span class=
"org-string">"⪵"</span>,
  <span class="org-string">"precnsim;"</span>: <span class=
"org-string">"⋨"</span>,
  <span class="org-string">"profalar;"</span>: <span class=
"org-string">"⌮"</span>,
  <span class="org-string">"profline;"</span>: <span class=
"org-string">"⌒"</span>,
  <span class="org-string">"profsurf;"</span>: <span class=
"org-string">"⌓"</span>,
  <span class="org-string">"raemptyv;"</span>: <span class=
"org-string">"⦳"</span>,
  <span class="org-string">"realpart;"</span>: <span class=
"org-string">"ℜ"</span>,
  <span class="org-string">"RightTee;"</span>: <span class=
"org-string">"⊢"</span>,
  <span class="org-string">"rppolint;"</span>: <span class=
"org-string">"⨒"</span>,
  <span class="org-string">"rtriltri;"</span>: <span class=
"org-string">"⧎"</span>,
  <span class="org-string">"scpolint;"</span>: <span class=
"org-string">"⨓"</span>,
  <span class="org-string">"setminus;"</span>: <span class=
"org-string">"∖"</span>,
  <span class="org-string">"shortmid;"</span>: <span class=
"org-string">"∣"</span>,
  <span class="org-string">"smeparsl;"</span>: <span class=
"org-string">"⧤"</span>,
  <span class="org-string">"sqsubset;"</span>: <span class=
"org-string">"⊏"</span>,
  <span class="org-string">"sqsupset;"</span>: <span class=
"org-string">"⊐"</span>,
  <span class="org-string">"subseteq;"</span>: <span class=
"org-string">"⊆"</span>,
  <span class="org-string">"Succeeds;"</span>: <span class=
"org-string">"≻"</span>,
  <span class="org-string">"succneqq;"</span>: <span class=
"org-string">"⪶"</span>,
  <span class="org-string">"succnsim;"</span>: <span class=
"org-string">"⋩"</span>,
  <span class="org-string">"SuchThat;"</span>: <span class=
"org-string">"∋"</span>,
  <span class="org-string">"Superset;"</span>: <span class=
"org-string">"⊃"</span>,
  <span class="org-string">"supseteq;"</span>: <span class=
"org-string">"⊇"</span>,
  <span class="org-string">"thetasym;"</span>: <span class=
"org-string">"ϑ"</span>,
  <span class="org-string">"thicksim;"</span>: <span class=
"org-string">"∼"</span>,
  <span class="org-string">"timesbar;"</span>: <span class=
"org-string">"⨱"</span>,
  <span class="org-string">"triangle;"</span>: <span class=
"org-string">"▵"</span>,
  <span class="org-string">"triminus;"</span>: <span class=
"org-string">"⨺"</span>,
  <span class="org-string">"trpezium;"</span>: <span class=
"org-string">"⏢"</span>,
  <span class="org-string">"Uarrocir;"</span>: <span class=
"org-string">"⥉"</span>,
  <span class="org-string">"ulcorner;"</span>: <span class=
"org-string">"⌜"</span>,
  <span class="org-string">"UnderBar;"</span>: <span class=
"org-string">"_"</span>,
  <span class="org-string">"urcorner;"</span>: <span class=
"org-string">"⌝"</span>,
  <span class="org-string">"varkappa;"</span>: <span class=
"org-string">"ϰ"</span>,
  <span class="org-string">"varsigma;"</span>: <span class=
"org-string">"ς"</span>,
  <span class="org-string">"vartheta;"</span>: <span class=
"org-string">"ϑ"</span>,
  <span class="org-string">"backprime;"</span>: <span class=
"org-string">"‵"</span>,
  <span class="org-string">"backsimeq;"</span>: <span class=
"org-string">"⋍"</span>,
  <span class="org-string">"Backslash;"</span>: <span class=
"org-string">"∖"</span>,
  <span class="org-string">"bigotimes;"</span>: <span class=
"org-string">"⨂"</span>,
  <span class="org-string">"CenterDot;"</span>: <span class=
"org-string">"·"</span>,
  <span class="org-string">"centerdot;"</span>: <span class=
"org-string">"·"</span>,
  <span class="org-string">"checkmark;"</span>: <span class=
"org-string">"✓"</span>,
  <span class="org-string">"CircleDot;"</span>: <span class=
"org-string">"⊙"</span>,
  <span class="org-string">"complexes;"</span>: <span class=
"org-string">"ℂ"</span>,
  <span class="org-string">"Congruent;"</span>: <span class=
"org-string">"≡"</span>,
  <span class="org-string">"Coproduct;"</span>: <span class=
"org-string">"∐"</span>,
  <span class="org-string">"dotsquare;"</span>: <span class=
"org-string">"⊡"</span>,
  <span class="org-string">"DoubleDot;"</span>: <span class=
"org-string">"¨"</span>,
  <span class="org-string">"DownArrow;"</span>: <span class=
"org-string">"↓"</span>,
  <span class="org-string">"Downarrow;"</span>: <span class=
"org-string">"⇓"</span>,
  <span class="org-string">"downarrow;"</span>: <span class=
"org-string">"↓"</span>,
  <span class="org-string">"DownBreve;"</span>: <span class=
"org-string">"̑"</span>,
  <span class="org-string">"gtrapprox;"</span>: <span class=
"org-string">"⪆"</span>,
  <span class="org-string">"gtreqless;"</span>: <span class=
"org-string">"⋛"</span>,
  <span class="org-string">"gvertneqq;"</span>: <span class=
"org-string">"≩︀"</span>,
  <span class="org-string">"heartsuit;"</span>: <span class=
"org-string">"♥"</span>,
  <span class="org-string">"HumpEqual;"</span>: <span class=
"org-string">"≏"</span>,
  <span class="org-string">"LeftArrow;"</span>: <span class=
"org-string">"←"</span>,
  <span class="org-string">"Leftarrow;"</span>: <span class=
"org-string">"⇐"</span>,
  <span class="org-string">"leftarrow;"</span>: <span class=
"org-string">"←"</span>,
  <span class="org-string">"LeftFloor;"</span>: <span class=
"org-string">"⌊"</span>,
  <span class="org-string">"lesseqgtr;"</span>: <span class=
"org-string">"⋚"</span>,
  <span class="org-string">"LessTilde;"</span>: <span class=
"org-string">"≲"</span>,
  <span class="org-string">"lvertneqq;"</span>: <span class=
"org-string">"≨︀"</span>,
  <span class="org-string">"Mellintrf;"</span>: <span class=
"org-string">"ℳ"</span>,
  <span class="org-string">"MinusPlus;"</span>: <span class=
"org-string">"∓"</span>,
  <span class="org-string">"ngeqslant;"</span>: <span class=
"org-string">"⩾̸"</span>,
  <span class="org-string">"nleqslant;"</span>: <span class=
"org-string">"⩽̸"</span>,
  <span class="org-string">"NotCupCap;"</span>: <span class=
"org-string">"≭"</span>,
  <span class="org-string">"NotExists;"</span>: <span class=
"org-string">"∄"</span>,
  <span class="org-string">"NotSubset;"</span>: <span class=
"org-string">"⊂⃒"</span>,
  <span class="org-string">"nparallel;"</span>: <span class=
"org-string">"∦"</span>,
  <span class="org-string">"nshortmid;"</span>: <span class=
"org-string">"∤"</span>,
  <span class="org-string">"nsubseteq;"</span>: <span class=
"org-string">"⊈"</span>,
  <span class="org-string">"nsupseteq;"</span>: <span class=
"org-string">"⊉"</span>,
  <span class="org-string">"OverBrace;"</span>: <span class=
"org-string">"⏞"</span>,
  <span class="org-string">"pitchfork;"</span>: <span class=
"org-string">"⋔"</span>,
  <span class="org-string">"PlusMinus;"</span>: <span class=
"org-string">"±"</span>,
  <span class="org-string">"rationals;"</span>: <span class=
"org-string">"ℚ"</span>,
  <span class="org-string">"spadesuit;"</span>: <span class=
"org-string">"♠"</span>,
  <span class="org-string">"subseteqq;"</span>: <span class=
"org-string">"⫅"</span>,
  <span class="org-string">"subsetneq;"</span>: <span class=
"org-string">"⊊"</span>,
  <span class="org-string">"supseteqq;"</span>: <span class=
"org-string">"⫆"</span>,
  <span class="org-string">"supsetneq;"</span>: <span class=
"org-string">"⊋"</span>,
  <span class="org-string">"Therefore;"</span>: <span class=
"org-string">"∴"</span>,
  <span class="org-string">"therefore;"</span>: <span class=
"org-string">"∴"</span>,
  <span class="org-string">"ThinSpace;"</span>: <span class=
"org-string">" "</span>,
  <span class="org-string">"triangleq;"</span>: <span class=
"org-string">"≜"</span>,
  <span class="org-string">"TripleDot;"</span>: <span class=
"org-string">"⃛"</span>,
  <span class="org-string">"UnionPlus;"</span>: <span class=
"org-string">"⊎"</span>,
  <span class="org-string">"varpropto;"</span>: <span class=
"org-string">"∝"</span>,
  <span class="org-string">"Bernoullis;"</span>: <span class=
"org-string">"ℬ"</span>,
  <span class="org-string">"circledast;"</span>: <span class=
"org-string">"⊛"</span>,
  <span class="org-string">"CirclePlus;"</span>: <span class=
"org-string">"⊕"</span>,
  <span class="org-string">"complement;"</span>: <span class=
"org-string">"∁"</span>,
  <span class="org-string">"curlywedge;"</span>: <span class=
"org-string">"⋏"</span>,
  <span class="org-string">"eqslantgtr;"</span>: <span class=
"org-string">"⪖"</span>,
  <span class="org-string">"EqualTilde;"</span>: <span class=
"org-string">"≂"</span>,
  <span class="org-string">"Fouriertrf;"</span>: <span class=
"org-string">"ℱ"</span>,
  <span class="org-string">"gtreqqless;"</span>: <span class=
"org-string">"⪌"</span>,
  <span class="org-string">"ImaginaryI;"</span>: <span class=
"org-string">"ⅈ"</span>,
  <span class="org-string">"Laplacetrf;"</span>: <span class=
"org-string">"ℒ"</span>,
  <span class="org-string">"LeftVector;"</span>: <span class=
"org-string">"↼"</span>,
  <span class="org-string">"lessapprox;"</span>: <span class=
"org-string">"⪅"</span>,
  <span class="org-string">"lesseqqgtr;"</span>: <span class=
"org-string">"⪋"</span>,
  <span class="org-string">"Lleftarrow;"</span>: <span class=
"org-string">"⇚"</span>,
  <span class="org-string">"lmoustache;"</span>: <span class=
"org-string">"⎰"</span>,
  <span class="org-string">"longmapsto;"</span>: <span class=
"org-string">"⟼"</span>,
  <span class="org-string">"mapstodown;"</span>: <span class=
"org-string">"↧"</span>,
  <span class="org-string">"mapstoleft;"</span>: <span class=
"org-string">"↤"</span>,
  <span class="org-string">"nLeftarrow;"</span>: <span class=
"org-string">"⇍"</span>,
  <span class="org-string">"nleftarrow;"</span>: <span class=
"org-string">"↚"</span>,
  <span class="org-string">"NotElement;"</span>: <span class=
"org-string">"∉"</span>,
  <span class="org-string">"NotGreater;"</span>: <span class=
"org-string">"≯"</span>,
  <span class="org-string">"nsubseteqq;"</span>: <span class=
"org-string">"⫅̸"</span>,
  <span class="org-string">"nsupseteqq;"</span>: <span class=
"org-string">"⫆̸"</span>,
  <span class="org-string">"precapprox;"</span>: <span class=
"org-string">"⪷"</span>,
  <span class="org-string">"Proportion;"</span>: <span class=
"org-string">"∷"</span>,
  <span class="org-string">"RightArrow;"</span>: <span class=
"org-string">"→"</span>,
  <span class="org-string">"Rightarrow;"</span>: <span class=
"org-string">"⇒"</span>,
  <span class="org-string">"rightarrow;"</span>: <span class=
"org-string">"→"</span>,
  <span class="org-string">"RightFloor;"</span>: <span class=
"org-string">"⌋"</span>,
  <span class="org-string">"rmoustache;"</span>: <span class=
"org-string">"⎱"</span>,
  <span class="org-string">"sqsubseteq;"</span>: <span class=
"org-string">"⊑"</span>,
  <span class="org-string">"sqsupseteq;"</span>: <span class=
"org-string">"⊒"</span>,
  <span class="org-string">"subsetneqq;"</span>: <span class=
"org-string">"⫋"</span>,
  <span class="org-string">"succapprox;"</span>: <span class=
"org-string">"⪸"</span>,
  <span class="org-string">"supsetneqq;"</span>: <span class=
"org-string">"⫌"</span>,
  <span class="org-string">"ThickSpace;"</span>: <span class=
"org-string">"  "</span>,
  <span class="org-string">"TildeEqual;"</span>: <span class=
"org-string">"≃"</span>,
  <span class="org-string">"TildeTilde;"</span>: <span class=
"org-string">"≈"</span>,
  <span class="org-string">"UnderBrace;"</span>: <span class=
"org-string">"⏟"</span>,
  <span class="org-string">"UpArrowBar;"</span>: <span class=
"org-string">"⤒"</span>,
  <span class="org-string">"UpTeeArrow;"</span>: <span class=
"org-string">"↥"</span>,
  <span class="org-string">"upuparrows;"</span>: <span class=
"org-string">"⇈"</span>,
  <span class="org-string">"varepsilon;"</span>: <span class=
"org-string">"ϵ"</span>,
  <span class="org-string">"varnothing;"</span>: <span class=
"org-string">"∅"</span>,
  <span class="org-string">"backepsilon;"</span>: <span class=
"org-string">"϶"</span>,
  <span class="org-string">"blacksquare;"</span>: <span class=
"org-string">"▪"</span>,
  <span class="org-string">"circledcirc;"</span>: <span class=
"org-string">"⊚"</span>,
  <span class="org-string">"circleddash;"</span>: <span class=
"org-string">"⊝"</span>,
  <span class="org-string">"CircleMinus;"</span>: <span class=
"org-string">"⊖"</span>,
  <span class="org-string">"CircleTimes;"</span>: <span class=
"org-string">"⊗"</span>,
  <span class="org-string">"curlyeqprec;"</span>: <span class=
"org-string">"⋞"</span>,
  <span class="org-string">"curlyeqsucc;"</span>: <span class=
"org-string">"⋟"</span>,
  <span class="org-string">"diamondsuit;"</span>: <span class=
"org-string">"♦"</span>,
  <span class="org-string">"eqslantless;"</span>: <span class=
"org-string">"⪕"</span>,
  <span class="org-string">"Equilibrium;"</span>: <span class=
"org-string">"⇌"</span>,
  <span class="org-string">"expectation;"</span>: <span class=
"org-string">"ℰ"</span>,
  <span class="org-string">"GreaterLess;"</span>: <span class=
"org-string">"≷"</span>,
  <span class="org-string">"LeftCeiling;"</span>: <span class=
"org-string">"⌈"</span>,
  <span class="org-string">"LessGreater;"</span>: <span class=
"org-string">"≶"</span>,
  <span class="org-string">"MediumSpace;"</span>: <span class=
"org-string">" "</span>,
  <span class="org-string">"NotLessLess;"</span>: <span class=
"org-string">"≪̸"</span>,
  <span class="org-string">"NotPrecedes;"</span>: <span class=
"org-string">"⊀"</span>,
  <span class="org-string">"NotSucceeds;"</span>: <span class=
"org-string">"⊁"</span>,
  <span class="org-string">"NotSuperset;"</span>: <span class=
"org-string">"⊃⃒"</span>,
  <span class="org-string">"nRightarrow;"</span>: <span class=
"org-string">"⇏"</span>,
  <span class="org-string">"nrightarrow;"</span>: <span class=
"org-string">"↛"</span>,
  <span class="org-string">"OverBracket;"</span>: <span class=
"org-string">"⎴"</span>,
  <span class="org-string">"preccurlyeq;"</span>: <span class=
"org-string">"≼"</span>,
  <span class="org-string">"precnapprox;"</span>: <span class=
"org-string">"⪹"</span>,
  <span class="org-string">"quaternions;"</span>: <span class=
"org-string">"ℍ"</span>,
  <span class="org-string">"RightVector;"</span>: <span class=
"org-string">"⇀"</span>,
  <span class="org-string">"Rrightarrow;"</span>: <span class=
"org-string">"⇛"</span>,
  <span class="org-string">"RuleDelayed;"</span>: <span class=
"org-string">"⧴"</span>,
  <span class="org-string">"SmallCircle;"</span>: <span class=
"org-string">"∘"</span>,
  <span class="org-string">"SquareUnion;"</span>: <span class=
"org-string">"⊔"</span>,
  <span class="org-string">"straightphi;"</span>: <span class=
"org-string">"ϕ"</span>,
  <span class="org-string">"SubsetEqual;"</span>: <span class=
"org-string">"⊆"</span>,
  <span class="org-string">"succcurlyeq;"</span>: <span class=
"org-string">"≽"</span>,
  <span class="org-string">"succnapprox;"</span>: <span class=
"org-string">"⪺"</span>,
  <span class="org-string">"thickapprox;"</span>: <span class=
"org-string">"≈"</span>,
  <span class="org-string">"UpDownArrow;"</span>: <span class=
"org-string">"↕"</span>,
  <span class="org-string">"Updownarrow;"</span>: <span class=
"org-string">"⇕"</span>,
  <span class="org-string">"updownarrow;"</span>: <span class=
"org-string">"↕"</span>,
  <span class="org-string">"VerticalBar;"</span>: <span class=
"org-string">"∣"</span>,
  <span class="org-string">"blacklozenge;"</span>: <span class=
"org-string">"⧫"</span>,
  <span class="org-string">"DownArrowBar;"</span>: <span class=
"org-string">"⤓"</span>,
  <span class="org-string">"DownTeeArrow;"</span>: <span class=
"org-string">"↧"</span>,
  <span class="org-string">"ExponentialE;"</span>: <span class=
"org-string">"ⅇ"</span>,
  <span class="org-string">"exponentiale;"</span>: <span class=
"org-string">"ⅇ"</span>,
  <span class="org-string">"GreaterEqual;"</span>: <span class=
"org-string">"≥"</span>,
  <span class="org-string">"GreaterTilde;"</span>: <span class=
"org-string">"≳"</span>,
  <span class="org-string">"HilbertSpace;"</span>: <span class=
"org-string">"ℋ"</span>,
  <span class="org-string">"HumpDownHump;"</span>: <span class=
"org-string">"≎"</span>,
  <span class="org-string">"Intersection;"</span>: <span class=
"org-string">"⋂"</span>,
  <span class="org-string">"LeftArrowBar;"</span>: <span class=
"org-string">"⇤"</span>,
  <span class="org-string">"LeftTeeArrow;"</span>: <span class=
"org-string">"↤"</span>,
  <span class="org-string">"LeftTriangle;"</span>: <span class=
"org-string">"⊲"</span>,
  <span class="org-string">"LeftUpVector;"</span>: <span class=
"org-string">"↿"</span>,
  <span class="org-string">"NotCongruent;"</span>: <span class=
"org-string">"≢"</span>,
  <span class="org-string">"NotHumpEqual;"</span>: <span class=
"org-string">"≏̸"</span>,
  <span class="org-string">"NotLessEqual;"</span>: <span class=
"org-string">"≰"</span>,
  <span class="org-string">"NotLessTilde;"</span>: <span class=
"org-string">"≴"</span>,
  <span class="org-string">"Proportional;"</span>: <span class=
"org-string">"∝"</span>,
  <span class="org-string">"RightCeiling;"</span>: <span class=
"org-string">"⌉"</span>,
  <span class="org-string">"risingdotseq;"</span>: <span class=
"org-string">"≓"</span>,
  <span class="org-string">"RoundImplies;"</span>: <span class=
"org-string">"⥰"</span>,
  <span class="org-string">"ShortUpArrow;"</span>: <span class=
"org-string">"↑"</span>,
  <span class="org-string">"SquareSubset;"</span>: <span class=
"org-string">"⊏"</span>,
  <span class="org-string">"triangledown;"</span>: <span class=
"org-string">"▿"</span>,
  <span class="org-string">"triangleleft;"</span>: <span class=
"org-string">"◃"</span>,
  <span class="org-string">"UnderBracket;"</span>: <span class=
"org-string">"⎵"</span>,
  <span class="org-string">"varsubsetneq;"</span>: <span class=
"org-string">"⊊︀"</span>,
  <span class="org-string">"varsupsetneq;"</span>: <span class=
"org-string">"⊋︀"</span>,
  <span class="org-string">"VerticalLine;"</span>: <span class=
"org-string">"|"</span>,
  <span class="org-string">"ApplyFunction;"</span>: <span class=
"org-string">"⁡"</span>,
  <span class="org-string">"bigtriangleup;"</span>: <span class=
"org-string">"△"</span>,
  <span class="org-string">"blacktriangle;"</span>: <span class=
"org-string">"▴"</span>,
  <span class="org-string">"DifferentialD;"</span>: <span class=
"org-string">"ⅆ"</span>,
  <span class="org-string">"divideontimes;"</span>: <span class=
"org-string">"⋇"</span>,
  <span class="org-string">"DoubleLeftTee;"</span>: <span class=
"org-string">"⫤"</span>,
  <span class="org-string">"DoubleUpArrow;"</span>: <span class=
"org-string">"⇑"</span>,
  <span class="org-string">"fallingdotseq;"</span>: <span class=
"org-string">"≒"</span>,
  <span class="org-string">"hookleftarrow;"</span>: <span class=
"org-string">"↩"</span>,
  <span class="org-string">"leftarrowtail;"</span>: <span class=
"org-string">"↢"</span>,
  <span class="org-string">"leftharpoonup;"</span>: <span class=
"org-string">"↼"</span>,
  <span class="org-string">"LeftTeeVector;"</span>: <span class=
"org-string">"⥚"</span>,
  <span class="org-string">"LeftVectorBar;"</span>: <span class=
"org-string">"⥒"</span>,
  <span class="org-string">"LessFullEqual;"</span>: <span class=
"org-string">"≦"</span>,
  <span class="org-string">"LongLeftArrow;"</span>: <span class=
"org-string">"⟵"</span>,
  <span class="org-string">"Longleftarrow;"</span>: <span class=
"org-string">"⟸"</span>,
  <span class="org-string">"longleftarrow;"</span>: <span class=
"org-string">"⟵"</span>,
  <span class="org-string">"looparrowleft;"</span>: <span class=
"org-string">"↫"</span>,
  <span class="org-string">"measuredangle;"</span>: <span class=
"org-string">"∡"</span>,
  <span class="org-string">"NotEqualTilde;"</span>: <span class=
"org-string">"≂̸"</span>,
  <span class="org-string">"NotTildeEqual;"</span>: <span class=
"org-string">"≄"</span>,
  <span class="org-string">"NotTildeTilde;"</span>: <span class=
"org-string">"≉"</span>,
  <span class="org-string">"ntriangleleft;"</span>: <span class=
"org-string">"⋪"</span>,
  <span class="org-string">"Poincareplane;"</span>: <span class=
"org-string">"ℌ"</span>,
  <span class="org-string">"PrecedesEqual;"</span>: <span class=
"org-string">"⪯"</span>,
  <span class="org-string">"PrecedesTilde;"</span>: <span class=
"org-string">"≾"</span>,
  <span class="org-string">"RightArrowBar;"</span>: <span class=
"org-string">"⇥"</span>,
  <span class="org-string">"RightTeeArrow;"</span>: <span class=
"org-string">"↦"</span>,
  <span class="org-string">"RightTriangle;"</span>: <span class=
"org-string">"⊳"</span>,
  <span class="org-string">"RightUpVector;"</span>: <span class=
"org-string">"↾"</span>,
  <span class="org-string">"shortparallel;"</span>: <span class=
"org-string">"∥"</span>,
  <span class="org-string">"smallsetminus;"</span>: <span class=
"org-string">"∖"</span>,
  <span class="org-string">"SucceedsEqual;"</span>: <span class=
"org-string">"⪰"</span>,
  <span class="org-string">"SucceedsTilde;"</span>: <span class=
"org-string">"≿"</span>,
  <span class="org-string">"SupersetEqual;"</span>: <span class=
"org-string">"⊇"</span>,
  <span class="org-string">"triangleright;"</span>: <span class=
"org-string">"▹"</span>,
  <span class="org-string">"UpEquilibrium;"</span>: <span class=
"org-string">"⥮"</span>,
  <span class="org-string">"upharpoonleft;"</span>: <span class=
"org-string">"↿"</span>,
  <span class="org-string">"varsubsetneqq;"</span>: <span class=
"org-string">"⫋︀"</span>,
  <span class="org-string">"varsupsetneqq;"</span>: <span class=
"org-string">"⫌︀"</span>,
  <span class="org-string">"VerticalTilde;"</span>: <span class=
"org-string">"≀"</span>,
  <span class="org-string">"VeryThinSpace;"</span>: <span class=
"org-string">" "</span>,
  <span class="org-string">"curvearrowleft;"</span>: <span class=
"org-string">"↶"</span>,
  <span class="org-string">"DiacriticalDot;"</span>: <span class=
"org-string">"˙"</span>,
  <span class="org-string">"doublebarwedge;"</span>: <span class=
"org-string">"⌆"</span>,
  <span class="org-string">"DoubleRightTee;"</span>: <span class=
"org-string">"⊨"</span>,
  <span class="org-string">"downdownarrows;"</span>: <span class=
"org-string">"⇊"</span>,
  <span class="org-string">"DownLeftVector;"</span>: <span class=
"org-string">"↽"</span>,
  <span class="org-string">"GreaterGreater;"</span>: <span class=
"org-string">"⪢"</span>,
  <span class="org-string">"hookrightarrow;"</span>: <span class=
"org-string">"↪"</span>,
  <span class="org-string">"HorizontalLine;"</span>: <span class=
"org-string">"─"</span>,
  <span class="org-string">"InvisibleComma;"</span>: <span class=
"org-string">"⁣"</span>,
  <span class="org-string">"InvisibleTimes;"</span>: <span class=
"org-string">"⁢"</span>,
  <span class="org-string">"LeftDownVector;"</span>: <span class=
"org-string">"⇃"</span>,
  <span class="org-string">"leftleftarrows;"</span>: <span class=
"org-string">"⇇"</span>,
  <span class="org-string">"LeftRightArrow;"</span>: <span class=
"org-string">"↔"</span>,
  <span class="org-string">"Leftrightarrow;"</span>: <span class=
"org-string">"⇔"</span>,
  <span class="org-string">"leftrightarrow;"</span>: <span class=
"org-string">"↔"</span>,
  <span class="org-string">"leftthreetimes;"</span>: <span class=
"org-string">"⋋"</span>,
  <span class="org-string">"LessSlantEqual;"</span>: <span class=
"org-string">"⩽"</span>,
  <span class="org-string">"LongRightArrow;"</span>: <span class=
"org-string">"⟶"</span>,
  <span class="org-string">"Longrightarrow;"</span>: <span class=
"org-string">"⟹"</span>,
  <span class="org-string">"longrightarrow;"</span>: <span class=
"org-string">"⟶"</span>,
  <span class="org-string">"looparrowright;"</span>: <span class=
"org-string">"↬"</span>,
  <span class="org-string">"LowerLeftArrow;"</span>: <span class=
"org-string">"↙"</span>,
  <span class="org-string">"NestedLessLess;"</span>: <span class=
"org-string">"≪"</span>,
  <span class="org-string">"NotGreaterLess;"</span>: <span class=
"org-string">"≹"</span>,
  <span class="org-string">"NotLessGreater;"</span>: <span class=
"org-string">"≸"</span>,
  <span class="org-string">"NotSubsetEqual;"</span>: <span class=
"org-string">"⊈"</span>,
  <span class="org-string">"NotVerticalBar;"</span>: <span class=
"org-string">"∤"</span>,
  <span class="org-string">"nshortparallel;"</span>: <span class=
"org-string">"∦"</span>,
  <span class="org-string">"ntriangleright;"</span>: <span class=
"org-string">"⋫"</span>,
  <span class="org-string">"OpenCurlyQuote;"</span>: <span class=
"org-string">"‘"</span>,
  <span class="org-string">"ReverseElement;"</span>: <span class=
"org-string">"∋"</span>,
  <span class="org-string">"rightarrowtail;"</span>: <span class=
"org-string">"↣"</span>,
  <span class="org-string">"rightharpoonup;"</span>: <span class=
"org-string">"⇀"</span>,
  <span class="org-string">"RightTeeVector;"</span>: <span class=
"org-string">"⥛"</span>,
  <span class="org-string">"RightVectorBar;"</span>: <span class=
"org-string">"⥓"</span>,
  <span class="org-string">"ShortDownArrow;"</span>: <span class=
"org-string">"↓"</span>,
  <span class="org-string">"ShortLeftArrow;"</span>: <span class=
"org-string">"←"</span>,
  <span class="org-string">"SquareSuperset;"</span>: <span class=
"org-string">"⊐"</span>,
  <span class="org-string">"TildeFullEqual;"</span>: <span class=
"org-string">"≅"</span>,
  <span class="org-string">"trianglelefteq;"</span>: <span class=
"org-string">"⊴"</span>,
  <span class="org-string">"upharpoonright;"</span>: <span class=
"org-string">"↾"</span>,
  <span class="org-string">"UpperLeftArrow;"</span>: <span class=
"org-string">"↖"</span>,
  <span class="org-string">"ZeroWidthSpace;"</span>: <span class=
"org-string">"​"</span>,
  <span class="org-string">"bigtriangledown;"</span>: <span class=
"org-string">"▽"</span>,
  <span class="org-string">"circlearrowleft;"</span>: <span class=
"org-string">"↺"</span>,
  <span class="org-string">"CloseCurlyQuote;"</span>: <span class=
"org-string">"’"</span>,
  <span class="org-string">"ContourIntegral;"</span>: <span class=
"org-string">"∮"</span>,
  <span class="org-string">"curvearrowright;"</span>: <span class=
"org-string">"↷"</span>,
  <span class="org-string">"DoubleDownArrow;"</span>: <span class=
"org-string">"⇓"</span>,
  <span class="org-string">"DoubleLeftArrow;"</span>: <span class=
"org-string">"⇐"</span>,
  <span class="org-string">"downharpoonleft;"</span>: <span class=
"org-string">"⇃"</span>,
  <span class="org-string">"DownRightVector;"</span>: <span class=
"org-string">"⇁"</span>,
  <span class="org-string">"leftharpoondown;"</span>: <span class=
"org-string">"↽"</span>,
  <span class="org-string">"leftrightarrows;"</span>: <span class=
"org-string">"⇆"</span>,
  <span class="org-string">"LeftRightVector;"</span>: <span class=
"org-string">"⥎"</span>,
  <span class="org-string">"LeftTriangleBar;"</span>: <span class=
"org-string">"⧏"</span>,
  <span class="org-string">"LeftUpTeeVector;"</span>: <span class=
"org-string">"⥠"</span>,
  <span class="org-string">"LeftUpVectorBar;"</span>: <span class=
"org-string">"⥘"</span>,
  <span class="org-string">"LowerRightArrow;"</span>: <span class=
"org-string">"↘"</span>,
  <span class="org-string">"nLeftrightarrow;"</span>: <span class=
"org-string">"⇎"</span>,
  <span class="org-string">"nleftrightarrow;"</span>: <span class=
"org-string">"↮"</span>,
  <span class="org-string">"NotGreaterEqual;"</span>: <span class=
"org-string">"≱"</span>,
  <span class="org-string">"NotGreaterTilde;"</span>: <span class=
"org-string">"≵"</span>,
  <span class="org-string">"NotHumpDownHump;"</span>: <span class=
"org-string">"≎̸"</span>,
  <span class="org-string">"NotLeftTriangle;"</span>: <span class=
"org-string">"⋪"</span>,
  <span class="org-string">"NotSquareSubset;"</span>: <span class=
"org-string">"⊏̸"</span>,
  <span class="org-string">"ntrianglelefteq;"</span>: <span class=
"org-string">"⋬"</span>,
  <span class="org-string">"OverParenthesis;"</span>: <span class=
"org-string">"⏜"</span>,
  <span class="org-string">"RightDownVector;"</span>: <span class=
"org-string">"⇂"</span>,
  <span class="org-string">"rightleftarrows;"</span>: <span class=
"org-string">"⇄"</span>,
  <span class="org-string">"rightsquigarrow;"</span>: <span class=
"org-string">"↝"</span>,
  <span class="org-string">"rightthreetimes;"</span>: <span class=
"org-string">"⋌"</span>,
  <span class="org-string">"ShortRightArrow;"</span>: <span class=
"org-string">"→"</span>,
  <span class="org-string">"straightepsilon;"</span>: <span class=
"org-string">"ϵ"</span>,
  <span class="org-string">"trianglerighteq;"</span>: <span class=
"org-string">"⊵"</span>,
  <span class="org-string">"UpperRightArrow;"</span>: <span class=
"org-string">"↗"</span>,
  <span class="org-string">"vartriangleleft;"</span>: <span class=
"org-string">"⊲"</span>,
  <span class="org-string">"circlearrowright;"</span>: <span class=
"org-string">"↻"</span>,
  <span class="org-string">"DiacriticalAcute;"</span>: <span class=
"org-string">"´"</span>,
  <span class="org-string">"DiacriticalGrave;"</span>: <span class=
"org-string">"`"</span>,
  <span class="org-string">"DiacriticalTilde;"</span>: <span class=
"org-string">"˜"</span>,
  <span class="org-string">"DoubleRightArrow;"</span>: <span class=
"org-string">"⇒"</span>,
  <span class="org-string">"DownArrowUpArrow;"</span>: <span class=
"org-string">"⇵"</span>,
  <span class="org-string">"downharpoonright;"</span>: <span class=
"org-string">"⇂"</span>,
  <span class="org-string">"EmptySmallSquare;"</span>: <span class=
"org-string">"◻"</span>,
  <span class="org-string">"GreaterEqualLess;"</span>: <span class=
"org-string">"⋛"</span>,
  <span class="org-string">"GreaterFullEqual;"</span>: <span class=
"org-string">"≧"</span>,
  <span class="org-string">"LeftAngleBracket;"</span>: <span class=
"org-string">"⟨"</span>,
  <span class="org-string">"LeftUpDownVector;"</span>: <span class=
"org-string">"⥑"</span>,
  <span class="org-string">"LessEqualGreater;"</span>: <span class=
"org-string">"⋚"</span>,
  <span class="org-string">"NonBreakingSpace;"</span>: <span class=
"org-string">" "</span>,
  <span class="org-string">"NotPrecedesEqual;"</span>: <span class=
"org-string">"⪯̸"</span>,
  <span class="org-string">"NotRightTriangle;"</span>: <span class=
"org-string">"⋫"</span>,
  <span class="org-string">"NotSucceedsEqual;"</span>: <span class=
"org-string">"⪰̸"</span>,
  <span class="org-string">"NotSucceedsTilde;"</span>: <span class=
"org-string">"≿̸"</span>,
  <span class="org-string">"NotSupersetEqual;"</span>: <span class=
"org-string">"⊉"</span>,
  <span class="org-string">"ntrianglerighteq;"</span>: <span class=
"org-string">"⋭"</span>,
  <span class="org-string">"rightharpoondown;"</span>: <span class=
"org-string">"⇁"</span>,
  <span class="org-string">"rightrightarrows;"</span>: <span class=
"org-string">"⇉"</span>,
  <span class="org-string">"RightTriangleBar;"</span>: <span class=
"org-string">"⧐"</span>,
  <span class="org-string">"RightUpTeeVector;"</span>: <span class=
"org-string">"⥜"</span>,
  <span class="org-string">"RightUpVectorBar;"</span>: <span class=
"org-string">"⥔"</span>,
  <span class="org-string">"twoheadleftarrow;"</span>: <span class=
"org-string">"↞"</span>,
  <span class="org-string">"UnderParenthesis;"</span>: <span class=
"org-string">"⏝"</span>,
  <span class="org-string">"UpArrowDownArrow;"</span>: <span class=
"org-string">"⇅"</span>,
  <span class="org-string">"vartriangleright;"</span>: <span class=
"org-string">"⊳"</span>,
  <span class=
"org-string">"blacktriangledown;"</span>: <span class="org-string">"▾"</span>,
  <span class=
"org-string">"blacktriangleleft;"</span>: <span class="org-string">"◂"</span>,
  <span class=
"org-string">"DoubleUpDownArrow;"</span>: <span class="org-string">"⇕"</span>,
  <span class=
"org-string">"DoubleVerticalBar;"</span>: <span class="org-string">"∥"</span>,
  <span class=
"org-string">"DownLeftTeeVector;"</span>: <span class="org-string">"⥞"</span>,
  <span class=
"org-string">"DownLeftVectorBar;"</span>: <span class="org-string">"⥖"</span>,
  <span class=
"org-string">"FilledSmallSquare;"</span>: <span class="org-string">"◼"</span>,
  <span class=
"org-string">"GreaterSlantEqual;"</span>: <span class="org-string">"⩾"</span>,
  <span class=
"org-string">"LeftDoubleBracket;"</span>: <span class="org-string">"⟦"</span>,
  <span class=
"org-string">"LeftDownTeeVector;"</span>: <span class="org-string">"⥡"</span>,
  <span class=
"org-string">"LeftDownVectorBar;"</span>: <span class="org-string">"⥙"</span>,
  <span class=
"org-string">"leftrightharpoons;"</span>: <span class="org-string">"⇋"</span>,
  <span class=
"org-string">"LeftTriangleEqual;"</span>: <span class="org-string">"⊴"</span>,
  <span class=
"org-string">"NegativeThinSpace;"</span>: <span class="org-string">"​"</span>,
  <span class=
"org-string">"NotGreaterGreater;"</span>: <span class="org-string">"≫̸"</span>,
  <span class=
"org-string">"NotLessSlantEqual;"</span>: <span class="org-string">"⩽̸"</span>,
  <span class=
"org-string">"NotNestedLessLess;"</span>: <span class="org-string">"⪡̸"</span>,
  <span class=
"org-string">"NotReverseElement;"</span>: <span class="org-string">"∌"</span>,
  <span class=
"org-string">"NotSquareSuperset;"</span>: <span class="org-string">"⊐̸"</span>,
  <span class=
"org-string">"NotTildeFullEqual;"</span>: <span class="org-string">"≇"</span>,
  <span class=
"org-string">"RightAngleBracket;"</span>: <span class="org-string">"⟩"</span>,
  <span class=
"org-string">"rightleftharpoons;"</span>: <span class="org-string">"⇌"</span>,
  <span class=
"org-string">"RightUpDownVector;"</span>: <span class="org-string">"⥏"</span>,
  <span class=
"org-string">"SquareSubsetEqual;"</span>: <span class="org-string">"⊑"</span>,
  <span class=
"org-string">"twoheadrightarrow;"</span>: <span class="org-string">"↠"</span>,
  <span class=
"org-string">"VerticalSeparator;"</span>: <span class="org-string">"❘"</span>,
  <span class=
"org-string">"blacktriangleright;"</span>: <span class=
"org-string">"▸"</span>,
  <span class=
"org-string">"DownRightTeeVector;"</span>: <span class=
"org-string">"⥟"</span>,
  <span class=
"org-string">"DownRightVectorBar;"</span>: <span class=
"org-string">"⥗"</span>,
  <span class=
"org-string">"LongLeftRightArrow;"</span>: <span class=
"org-string">"⟷"</span>,
  <span class=
"org-string">"Longleftrightarrow;"</span>: <span class=
"org-string">"⟺"</span>,
  <span class=
"org-string">"longleftrightarrow;"</span>: <span class=
"org-string">"⟷"</span>,
  <span class=
"org-string">"NegativeThickSpace;"</span>: <span class=
"org-string">"​"</span>,
  <span class=
"org-string">"NotLeftTriangleBar;"</span>: <span class=
"org-string">"⧏̸"</span>,
  <span class=
"org-string">"PrecedesSlantEqual;"</span>: <span class=
"org-string">"≼"</span>,
  <span class=
"org-string">"ReverseEquilibrium;"</span>: <span class=
"org-string">"⇋"</span>,
  <span class=
"org-string">"RightDoubleBracket;"</span>: <span class=
"org-string">"⟧"</span>,
  <span class=
"org-string">"RightDownTeeVector;"</span>: <span class=
"org-string">"⥝"</span>,
  <span class=
"org-string">"RightDownVectorBar;"</span>: <span class=
"org-string">"⥕"</span>,
  <span class=
"org-string">"RightTriangleEqual;"</span>: <span class=
"org-string">"⊵"</span>,
  <span class=
"org-string">"SquareIntersection;"</span>: <span class=
"org-string">"⊓"</span>,
  <span class=
"org-string">"SucceedsSlantEqual;"</span>: <span class=
"org-string">"≽"</span>,
  <span class=
"org-string">"DoubleLongLeftArrow;"</span>: <span class=
"org-string">"⟸"</span>,
  <span class=
"org-string">"DownLeftRightVector;"</span>: <span class=
"org-string">"⥐"</span>,
  <span class=
"org-string">"LeftArrowRightArrow;"</span>: <span class=
"org-string">"⇆"</span>,
  <span class=
"org-string">"leftrightsquigarrow;"</span>: <span class=
"org-string">"↭"</span>,
  <span class=
"org-string">"NegativeMediumSpace;"</span>: <span class=
"org-string">"​"</span>,
  <span class=
"org-string">"NotGreaterFullEqual;"</span>: <span class=
"org-string">"≧̸"</span>,
  <span class=
"org-string">"NotRightTriangleBar;"</span>: <span class=
"org-string">"⧐̸"</span>,
  <span class=
"org-string">"RightArrowLeftArrow;"</span>: <span class=
"org-string">"⇄"</span>,
  <span class=
"org-string">"SquareSupersetEqual;"</span>: <span class=
"org-string">"⊒"</span>,
  <span class=
"org-string">"CapitalDifferentialD;"</span>: <span class=
"org-string">"ⅅ"</span>,
  <span class=
"org-string">"DoubleLeftRightArrow;"</span>: <span class=
"org-string">"⇔"</span>,
  <span class=
"org-string">"DoubleLongRightArrow;"</span>: <span class=
"org-string">"⟹"</span>,
  <span class=
"org-string">"EmptyVerySmallSquare;"</span>: <span class=
"org-string">"▫"</span>,
  <span class=
"org-string">"NestedGreaterGreater;"</span>: <span class=
"org-string">"≫"</span>,
  <span class=
"org-string">"NotDoubleVerticalBar;"</span>: <span class=
"org-string">"∦"</span>,
  <span class=
"org-string">"NotGreaterSlantEqual;"</span>: <span class=
"org-string">"⩾̸"</span>,
  <span class=
"org-string">"NotLeftTriangleEqual;"</span>: <span class=
"org-string">"⋬"</span>,
  <span class=
"org-string">"NotSquareSubsetEqual;"</span>: <span class=
"org-string">"⋢"</span>,
  <span class=
"org-string">"OpenCurlyDoubleQuote;"</span>: <span class=
"org-string">"“"</span>,
  <span class=
"org-string">"ReverseUpEquilibrium;"</span>: <span class=
"org-string">"⥯"</span>,
  <span class=
"org-string">"CloseCurlyDoubleQuote;"</span>: <span class=
"org-string">"”"</span>,
  <span class=
"org-string">"DoubleContourIntegral;"</span>: <span class=
"org-string">"∯"</span>,
  <span class=
"org-string">"FilledVerySmallSquare;"</span>: <span class=
"org-string">"▪"</span>,
  <span class=
"org-string">"NegativeVeryThinSpace;"</span>: <span class=
"org-string">"​"</span>,
  <span class=
"org-string">"NotPrecedesSlantEqual;"</span>: <span class=
"org-string">"⋠"</span>,
  <span class=
"org-string">"NotRightTriangleEqual;"</span>: <span class=
"org-string">"⋭"</span>,
  <span class=
"org-string">"NotSucceedsSlantEqual;"</span>: <span class=
"org-string">"⋡"</span>,
  <span class=
"org-string">"DiacriticalDoubleAcute;"</span>: <span class=
"org-string">"˝"</span>,
  <span class=
"org-string">"NotSquareSupersetEqual;"</span>: <span class=
"org-string">"⋣"</span>,
  <span class=
"org-string">"NotNestedGreaterGreater;"</span>: <span class=
"org-string">"⪢̸"</span>,
  <span class=
"org-string">"ClockwiseContourIntegral;"</span>: <span class=
"org-string">"∲"</span>,
  <span class=
"org-string">"DoubleLongLeftRightArrow;"</span>: <span class=
"org-string">"⟺"</span>,
  <span class=
"org-string">"CounterClockwiseContourIntegral;"</span>: <span class="org-string">"∳"</span>
}

<span class="org-keyword">const</span> <span class=
"org-variable-name">decodeHtml</span> = (rawText, asAttr) =&gt; {
  <span class="org-keyword">let</span> <span class=
"org-variable-name">offset</span> = <span class=
"org-highlight-numbers-number">0</span>
  <span class="org-keyword">const</span> <span class=
"org-variable-name">end</span> = rawText.length
  <span class="org-keyword">let</span> <span class=
"org-variable-name">decodedText</span> = <span class=
"org-string">''</span>

  <span class="org-keyword">function</span> <span class=
"org-function-name">advance</span>(<span class=
"org-variable-name">length</span>) {
    offset += length
    rawText = rawText.slice(length)
  }

  <span class="org-keyword">while</span> (offset &lt; end) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">head</span> = <span class=
"org-string">/&amp;(?:#x?)?/</span>i.exec(rawText)
    <span class=
"org-keyword">if</span> (!head || offset + head.index &gt;= end) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">remaining</span> = end - offset
      decodedText += rawText.slice(<span class=
"org-highlight-numbers-number">0</span>, remaining)
      advance(remaining)
      <span class="org-keyword">break</span>
    }

    <span class="org-comment-delimiter">// </span><span class=
"org-comment">Advance to the "&amp;".</span>
    decodedText += rawText.slice(<span class=
"org-highlight-numbers-number">0</span>, head.index)
    advance(head.index)

    <span class="org-keyword">if</span> (head[<span class=
"org-highlight-numbers-number">0</span>] === <span class=
"org-string">'&amp;'</span>) {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">Named character reference.</span>
      <span class="org-keyword">let</span> <span class=
"org-variable-name">name</span> = <span class=
"org-string">''</span>
      <span class="org-keyword">let</span> <span class=
"org-variable-name">value</span> = <span class=
"org-constant">undefined</span>
      <span class="org-keyword">if</span> (<span class=
"org-string">/[0-9a-z]/</span>i.test(rawText[<span class=
"org-highlight-numbers-number">1</span>])) {
        <span class="org-keyword">if</span> (!maxCRNameLength) {
          maxCRNameLength = Object.keys(namedCharacterReferences).reduce(
            (max, name) =&gt; Math.max(max, name.length),
            <span class="org-highlight-numbers-number">0</span>
          )
        }
        <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">length</span> = maxCRNameLength; !value &amp;& length &gt; <span class="org-highlight-numbers-number">0</span>; --length) {
          name = rawText.slice(<span class=
"org-highlight-numbers-number">1</span>, <span class=
"org-highlight-numbers-number">1</span> + length)
          value = namedCharacterReferences[name]
        }
        <span class="org-keyword">if</span> (value) {
          <span class="org-keyword">const</span> <span class=
"org-variable-name">semi</span> = name.endsWith(<span class=
"org-string">';'</span>)
          <span class="org-keyword">if</span> (
            asAttr &amp;&
            !semi &amp;&
            /[=a-z0-<span class=
"org-highlight-numbers-number">9</span>]/i.test(rawText[name.length + <span class="org-highlight-numbers-number">1</span>] || <span class="org-string">''</span>)
          ) {
            decodedText += <span class=
"org-string">'&amp;'</span> + name
            advance(<span class=
"org-highlight-numbers-number">1</span> + name.length)
          } <span class="org-keyword">else</span> {
            decodedText += value
            advance(<span class=
"org-highlight-numbers-number">1</span> + name.length)
          }
        } <span class="org-keyword">else</span> {
          decodedText += <span class=
"org-string">'&amp;'</span> + name
          advance(<span class=
"org-highlight-numbers-number">1</span> + name.length)
        }
      } <span class="org-keyword">else</span> {
        decodedText += <span class="org-string">'&amp;'</span>
        advance(<span class=
"org-highlight-numbers-number">1</span>)
      }
    } <span class="org-keyword">else</span> {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">Numeric character reference.</span>
      <span class="org-keyword">const</span> <span class=
"org-variable-name">hex</span> = head[<span class=
"org-highlight-numbers-number">0</span>] === <span class=
"org-string">'&amp;#x'</span>
      <span class="org-keyword">const</span> <span class=
"org-variable-name">pattern</span> = hex ? /^&amp;#x([<span class=
"org-highlight-numbers-number">0</span>-9a-f]+);?/i : <span class=
"org-string">/^&amp;#([0-9]+);?/</span>
      <span class="org-keyword">const</span> <span class=
"org-variable-name">body</span> = pattern.exec(rawText)
      <span class="org-keyword">if</span> (!body) {
        decodedText += head[<span class=
"org-highlight-numbers-number">0</span>]
        advance(head[<span class=
"org-highlight-numbers-number">0</span>].length)
      } <span class="org-keyword">else</span> {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state</span>
        <span class="org-keyword">let</span> <span class=
"org-variable-name">cp</span> = Number.parseInt(body[<span class=
"org-highlight-numbers-number">1</span>], hex ? <span class=
"org-highlight-numbers-number">16</span> : <span class=
"org-highlight-numbers-number">10</span>)
        <span class="org-keyword">if</span> (cp === <span class=
"org-highlight-numbers-number">0</span>) {
          cp = 0xfffd
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (cp &gt; 0x10ffff) {
          cp = 0xfffd
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (cp &gt;= 0xd800 &amp;& cp &lt;= 0xdfff) {
          cp = 0xfffd
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> ((cp &gt;= 0xfdd0 &amp;& cp &lt;= 0xfdef) || (cp & 0xfffe) === 0xfffe) {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">noop</span>
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (
          (cp &gt;= 0x01 &amp;& cp &lt;= 0x08) ||
          cp === 0x0b ||
          (cp &gt;= 0x0d &amp;& cp &lt;= 0x1f) ||
          (cp &gt;= 0x7f &amp;& cp &lt;= 0x9f)
        ) {
          cp = CCR_REPLACEMENTS[cp] || cp
        }
        decodedText += String.fromCodePoint(cp)
        advance(body[<span class=
"org-highlight-numbers-number">0</span>].length)
      }
    }
  }
  <span class="org-keyword">return</span> decodedText
}

<span class="org-comment-delimiter">// </span><span class=
"org-comment">https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">CCR_REPLACEMENTS</span> = {
  0x80: 0x20ac,
  0x82: 0x201a,
  0x83: 0x0192,
  0x84: 0x201e,
  0x85: 0x2026,
  0x86: 0x2020,
  0x87: 0x2021,
  0x88: 0x02c6,
  0x89: 0x2030,
  0x8a: 0x0160,
  0x8b: 0x2039,
  0x8c: 0x0152,
  0x8e: 0x017d,
  0x91: 0x2018,
  0x92: 0x2019,
  0x93: 0x201c,
  0x94: 0x201d,
  0x95: 0x2022,
  0x96: 0x2013,
  0x97: 0x2014,
  0x98: 0x02dc,
  0x99: 0x2122,
  0x9a: 0x0161,
  0x9b: 0x203a,
  0x9c: 0x0153,
  0x9e: 0x017e,
  0x9f: 0x0178
}

<span class="org-keyword">let</span> <span class=
"org-variable-name">decoder</span>

<span class="org-keyword">function</span> <span class=
"org-function-name">decodeHtmlBrowser</span>(<span class=
"org-variable-name">raw</span>, <span class=
"org-variable-name">asAttr</span> = <span class=
"org-constant">false</span>) {
  <span class="org-keyword">if</span> (!decoder) {
    decoder = document.createElement(<span class=
"org-string">'div'</span>)
  }
  <span class="org-keyword">if</span> (asAttr) {
    decoder.innerHTML = <span class=
"org-string">`&lt;div foo="${raw.replace(/"/g, '&amp;quot;')}"&gt;`</span>
    <span class=
"org-keyword">return</span> decoder.children[<span class=
"org-highlight-numbers-number">0</span>].getAttribute(<span class=
"org-string">'foo'</span>)
  } <span class="org-keyword">else</span> {
    decoder.innerHTML = raw
    <span class="org-keyword">return</span> decoder.textContent
  }
}

<span class="org-keyword">const</span> <span class=
"org-variable-name">V_MODEL_RADIO</span> = Symbol(__DEV__ ? <span class="org-string">`vModelRadio`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">V_MODEL_CHECKBOX</span> = Symbol(__DEV__ ? <span class="org-string">`vModelCheckbox`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">V_MODEL_TEXT</span> = Symbol(__DEV__ ? <span class="org-string">`vModelText`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">V_MODEL_SELECT</span> = Symbol(__DEV__ ? <span class="org-string">`vModelSelect`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">V_MODEL_DYNAMIC</span> = Symbol(__DEV__ ? <span class="org-string">`vModelDynamic`</span> : <span class="org-string">``</span>)

<span class="org-keyword">const</span> <span class=
"org-variable-name">V_ON_WITH_MODIFIERS</span> = Symbol(__DEV__ ? <span class="org-string">`vOnModifiersGuard`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">V_ON_WITH_KEYS</span> = Symbol(__DEV__ ? <span class="org-string">`vOnKeysGuard`</span> : <span class="org-string">``</span>)

<span class="org-keyword">const</span> <span class=
"org-variable-name">V_SHOW</span> = Symbol(__DEV__ ? <span class=
"org-string">`vShow`</span> : <span class="org-string">``</span>)

<span class="org-keyword">const</span> <span class=
"org-variable-name">TRANSITION</span> = Symbol(__DEV__ ? <span class="org-string">`Transition`</span> : <span class="org-string">``</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">TRANSITION_GROUP</span> = Symbol(__DEV__ ? <span class="org-string">`TransitionGroup`</span> : <span class="org-string">``</span>)

registerRuntimeHelpers({
  [V_MODEL_RADIO]: <span class="org-string">`vModelRadio`</span>,
  [V_MODEL_CHECKBOX]: <span class=
"org-string">`vModelCheckbox`</span>,
  [V_MODEL_TEXT]: <span class="org-string">`vModelText`</span>,
  [V_MODEL_SELECT]: <span class="org-string">`vModelSelect`</span>,
  [V_MODEL_DYNAMIC]: <span class=
"org-string">`vModelDynamic`</span>,
  [V_ON_WITH_MODIFIERS]: <span class=
"org-string">`withModifiers`</span>,
  [V_ON_WITH_KEYS]: <span class="org-string">`withKeys`</span>,
  [V_SHOW]: <span class="org-string">`vShow`</span>,
  [TRANSITION]: <span class="org-string">`Transition`</span>,
  [TRANSITION_GROUP]: <span class=
"org-string">`TransitionGroup`</span>
})


<span class="org-doc">/**</span>
<span class=
"org-doc"> * On the client we only need to offer special cases for boolean attributes that</span>
<span class=
"org-doc"> * have different names from their corresponding dom properties:</span>
<span class="org-doc"> * - itemscope -&gt; N/A</span>
<span class=
"org-doc"> * - allowfullscreen -&gt; allowFullscreen</span>
<span class=
"org-doc"> * - formnovalidate -&gt; formNoValidate</span>
<span class="org-doc"> * - ismap -&gt; isMap</span>
<span class="org-doc"> * - nomodule -&gt; noModule</span>
<span class="org-doc"> * - novalidate -&gt; noValidate</span>
<span class="org-doc"> * - readonly -&gt; readOnly</span>
<span class="org-doc"> */</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">specialBooleanAttrs</span> = <span class=
"org-string">`itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">isSpecialBooleanAttr</span> = <span class=
"org-comment-delimiter">/*</span><span class=
"org-comment">#__PURE__</span><span class=
"org-comment-delimiter">*/</span> makeMap(specialBooleanAttrs)

<span class="org-doc">/**</span>
<span class=
"org-doc"> * The full list is needed during SSR to produce the correct initial markup.</span>
<span class="org-doc"> */</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">isBooleanAttr</span> = <span class=
"org-comment-delimiter">/*</span><span class=
"org-comment">#__PURE__</span><span class=
"org-comment-delimiter">*/</span> makeMap(
  specialBooleanAttrs +
    <span class=
"org-string">`,async,autofocus,autoplay,controls,default,defer,disabled,hidden,`</span> +
    <span class=
"org-string">`loop,open,required,reversed,scoped,seamless,`</span> +
    <span class=
"org-string">`checked,muted,multiple,selected`</span>
)

<span class="org-doc">/**</span>
<span class=
"org-doc"> * Boolean attributes should be included if the value is truthy or ''.</span>
<span class=
"org-doc"> * e.g. `&lt;select multiple&gt;` compiles to `{ multiple: '' }`</span>
<span class="org-doc"> */</span>
<span class="org-keyword">function</span> <span class=
"org-function-name">includeBooleanAttr</span>(<span class=
"org-variable-name">value</span>) {
  <span class=
"org-keyword">return</span> !!value || value === <span class=
"org-string">''</span>
}

<span class="org-keyword">const</span> <span class=
"org-variable-name">unsafeAttrCharRE</span> = <span class=
"org-string">/[&gt;/="'\u0009\u000a\u000c\u0020]/</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">attrValidationCache</span> = {}

<span class="org-keyword">function</span> <span class=
"org-function-name">isSSRSafeAttrName</span>(<span class=
"org-variable-name">name</span>) {
  <span class=
"org-keyword">if</span> (attrValidationCache.hasOwnProperty(name)) {
    <span class=
"org-keyword">return</span> attrValidationCache[name]
  }
  <span class="org-keyword">const</span> <span class=
"org-variable-name">isUnsafe</span> = unsafeAttrCharRE.test(name)
  <span class="org-keyword">if</span> (isUnsafe) {
    console.error(<span class=
"org-string">`unsafe attribute name: ${name}`</span>)
  }
  <span class=
"org-keyword">return</span> (attrValidationCache[name] = !isUnsafe)
}

<span class="org-keyword">const</span> <span class=
"org-variable-name">propsToAttrMap</span> = {
  acceptCharset: <span class="org-string">'accept-charset'</span>,
  className: <span class="org-string">'class'</span>,
  htmlFor: <span class="org-string">'for'</span>,
  httpEquiv: <span class="org-string">'http-equiv'</span>
}

<span class="org-doc">/**</span>
<span class=
"org-doc"> * CSS properties that accept plain numbers</span>
<span class="org-doc"> */</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">isNoUnitNumericStyleProp</span> = <span class=
"org-comment-delimiter">/*</span><span class=
"org-comment">#__PURE__</span><span class=
"org-comment-delimiter">*/</span> makeMap(
  <span class=
"org-string">`animation-iteration-count,border-image-outset,border-image-slice,`</span> +
    <span class=
"org-string">`border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,`</span> +
    <span class=
"org-string">`columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,`</span> +
    <span class=
"org-string">`grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,`</span> +
    <span class=
"org-string">`grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,`</span> +
    <span class=
"org-string">`line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,`</span> +
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">SVG</span>
    <span class=
"org-string">`fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,`</span> +
    <span class=
"org-string">`stroke-miterlimit,stroke-opacity,stroke-width`</span>
)

<span class="org-doc">/**</span>
<span class=
"org-doc"> * Known attributes, this is used for stringification of runtime static nodes</span>
<span class=
"org-doc"> * so that we don't stringify bindings that cannot be set from HTML.</span>
<span class=
"org-doc"> * Don't also forget to allow `data-*` and `aria-*`!</span>
<span class=
"org-doc"> * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes</span>
<span class="org-doc"> */</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">isKnownHtmlAttr</span> = <span class=
"org-comment-delimiter">/*</span><span class=
"org-comment">#__PURE__</span><span class=
"org-comment-delimiter">*/</span> makeMap(
  <span class=
"org-string">`accept,accept-charset,accesskey,action,align,allow,alt,async,`</span> +
    <span class=
"org-string">`autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,`</span> +
    <span class=
"org-string">`border,buffered,capture,challenge,charset,checked,cite,class,code,`</span> +
    <span class=
"org-string">`codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,`</span> +
    <span class=
"org-string">`coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,`</span> +
    <span class=
"org-string">`disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,`</span> +
    <span class=
"org-string">`formaction,formenctype,formmethod,formnovalidate,formtarget,headers,`</span> +
    <span class=
"org-string">`height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,`</span> +
    <span class=
"org-string">`ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,`</span> +
    <span class=
"org-string">`manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,`</span> +
    <span class=
"org-string">`open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,`</span> +
    <span class=
"org-string">`referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,`</span> +
    <span class=
"org-string">`selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,`</span> +
    <span class=
"org-string">`start,step,style,summary,tabindex,target,title,translate,type,usemap,`</span> +
    <span class="org-string">`value,width,wrap`</span>
)

<span class="org-doc">/**</span>
<span class=
"org-doc"> * Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute</span>
<span class="org-doc"> */</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">isKnownSvgAttr</span> = <span class=
"org-comment-delimiter">/*</span><span class=
"org-comment">#__PURE__</span><span class=
"org-comment-delimiter">*/</span> makeMap(
  <span class=
"org-string">`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,`</span> +
    <span class=
"org-string">`arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,`</span> +
    <span class=
"org-string">`baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,`</span> +
    <span class=
"org-string">`clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,`</span> +
    <span class=
"org-string">`color-interpolation-filters,color-profile,color-rendering,`</span> +
    <span class=
"org-string">`contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,`</span> +
    <span class=
"org-string">`descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,`</span> +
    <span class=
"org-string">`dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,`</span> +
    <span class=
"org-string">`fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,`</span> +
    <span class=
"org-string">`font-family,font-size,font-size-adjust,font-stretch,font-style,`</span> +
    <span class=
"org-string">`font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,`</span> +
    <span class=
"org-string">`glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,`</span> +
    <span class=
"org-string">`gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,`</span> +
    <span class=
"org-string">`horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,`</span> +
    <span class=
"org-string">`k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,`</span> +
    <span class=
"org-string">`lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,`</span> +
    <span class=
"org-string">`marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,`</span> +
    <span class=
"org-string">`mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,`</span> +
    <span class=
"org-string">`name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,`</span> +
    <span class=
"org-string">`overflow,overline-position,overline-thickness,panose-1,paint-order,path,`</span> +
    <span class=
"org-string">`pathLength,patternContentUnits,patternTransform,patternUnits,ping,`</span> +
    <span class=
"org-string">`pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,`</span> +
    <span class=
"org-string">`preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,`</span> +
    <span class=
"org-string">`rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,`</span> +
    <span class=
"org-string">`restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,`</span> +
    <span class=
"org-string">`specularConstant,specularExponent,speed,spreadMethod,startOffset,`</span> +
    <span class=
"org-string">`stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,`</span> +
    <span class=
"org-string">`strikethrough-position,strikethrough-thickness,string,stroke,`</span> +
    <span class=
"org-string">`stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,`</span> +
    <span class=
"org-string">`stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,`</span> +
    <span class=
"org-string">`systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,`</span> +
    <span class=
"org-string">`text-decoration,text-rendering,textLength,to,transform,transform-origin,`</span> +
    <span class=
"org-string">`type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,`</span> +
    <span class=
"org-string">`unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,`</span> +
    <span class=
"org-string">`v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,`</span> +
    <span class=
"org-string">`vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,`</span> +
    <span class=
"org-string">`writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,`</span> +
    <span class=
"org-string">`xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,`</span> +
    <span class=
"org-string">`xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`</span>
)

<span class="org-comment-delimiter">// </span><span class=
"org-comment">https://developer.mozilla.org/en-US/docs/Web/HTML/Element</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">HTML_TAGS</span> =
  <span class=
"org-string">'html,body,base,head,link,meta,style,title,address,article,aside,footer,'</span> +
  <span class=
"org-string">'header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,'</span> +
  <span class=
"org-string">'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,'</span> +
  <span class=
"org-string">'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,'</span> +
  <span class=
"org-string">'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,'</span> +
  <span class=
"org-string">'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,'</span> +
  <span class=
"org-string">'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,'</span> +
  <span class=
"org-string">'option,output,progress,select,textarea,details,dialog,menu,'</span> +
  <span class=
"org-string">'summary,template,blockquote,iframe,tfoot'</span>

<span class="org-comment-delimiter">// </span><span class=
"org-comment">https://developer.mozilla.org/en-US/docs/Web/SVG/Element</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">SVG_TAGS</span> =
  <span class=
"org-string">'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,'</span> +
  <span class=
"org-string">'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,'</span> +
  <span class=
"org-string">'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,'</span> +
  <span class=
"org-string">'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,'</span> +
  <span class=
"org-string">'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,'</span> +
  <span class=
"org-string">'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,'</span> +
  <span class=
"org-string">'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,'</span> +
  <span class=
"org-string">'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,'</span> +
  <span class=
"org-string">'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,'</span> +
  <span class=
"org-string">'text,textPath,title,tspan,unknown,use,view'</span>

<span class="org-keyword">const</span> <span class=
"org-variable-name">VOID_TAGS</span> =
  <span class=
"org-string">'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr'</span>

<span class="org-keyword">const</span> <span class=
"org-variable-name">isHTMLTag</span> = <span class=
"org-comment-delimiter">/*</span><span class=
"org-comment">#__PURE__</span><span class=
"org-comment-delimiter">*/</span> makeMap(HTML_TAGS)
<span class="org-doc">/**</span>
<span class="org-doc"> * Compiler only.</span>
<span class=
"org-doc"> * Do NOT use in runtime code paths unless behind `__DEV__` flag.</span>
<span class="org-doc"> */</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">isSVGTag</span> = <span class=
"org-comment-delimiter">/*</span><span class=
"org-comment">#__PURE__</span><span class=
"org-comment-delimiter">*/</span> makeMap(SVG_TAGS)
<span class="org-keyword">const</span> <span class=
"org-variable-name">isVoidTag</span> = <span class=
"org-comment-delimiter">/*</span><span class=
"org-comment">#__PURE__</span><span class=
"org-comment-delimiter">*/</span> makeMap(VOID_TAGS)


<span id="coderef-normalizeStyle" class="coderef-off"><span class=
"org-keyword">function</span> <span class=
"org-function-name">normalizeStyle</span>(<span class=
"org-variable-name">value</span>) { <span class=
"org-comment-delimiter">//</span> (normalizeStyle)</span>
  <span class="org-keyword">if</span> (isArray(value)) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">res</span> = {}
    <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; value.length; i++) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">item</span> = value[i]
      <span class="org-keyword">const</span> <span class=
"org-variable-name">normalized</span> = isString(item)
        ? parseStringStyle(item)
        : normalizeStyle(item)
      <span class="org-keyword">if</span> (normalized) {
        <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">in</span> normalized) {
          res[key] = normalized[key]
        }
      }
    }
    <span class="org-keyword">return</span> res
  } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (isString(value)) {
    <span class="org-keyword">return</span> value
  } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (isObject(value)) {
    <span class="org-keyword">return</span> value
  }
}

<span class="org-keyword">const</span> <span class=
"org-variable-name">listDelimiterRE</span> = <span class=
"org-string">/;(?![^(]*\))/</span>g
<span class="org-keyword">const</span> <span class=
"org-variable-name">propertyDelimiterRE</span> = <span class=
"org-string">/:(.+)/</span>

<span id="coderef-parseStringStyle" class=
"coderef-off"><span class="org-keyword">function</span> <span class="org-function-name">parseStringStyle</span>(<span class="org-variable-name">cssText</span>) { <span class="org-comment-delimiter">//</span> (parseStringStyle)</span>
  <span class="org-keyword">const</span> <span class=
"org-variable-name">ret</span> = {}
  cssText.split(listDelimiterRE).forEach(item =&gt; {
    <span class="org-keyword">if</span> (item) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">tmp</span> = item.split(propertyDelimiterRE)
      tmp.length &gt; <span class=
"org-highlight-numbers-number">1</span> &amp;& (ret[tmp[<span class="org-highlight-numbers-number">0</span>].trim()] = tmp[<span class="org-highlight-numbers-number">1</span>].trim())
    }
  })
  <span class="org-keyword">return</span> ret
}

<span id="coderef-stringifyStyle" class="coderef-off"><span class=
"org-keyword">function</span> <span class=
"org-function-name">stringifyStyle</span>(<span class=
"org-variable-name">styles</span>) { <span class=
"org-comment-delimiter">//</span> (stringifyStyle)</span>
  <span class="org-keyword">let</span> <span class=
"org-variable-name">ret</span> = <span class="org-string">''</span>
  <span class=
"org-keyword">if</span> (!styles || isString(styles)) {
    <span class="org-keyword">return</span> ret
  }
  <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">in</span> styles) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">value</span> = styles[key]
    <span class="org-keyword">const</span> <span class=
"org-variable-name">normalizedKey</span> = key.startsWith(<span class="org-string">`--`</span>) ? key : hyphenate(key)
    <span class="org-keyword">if</span> (
      isString(value) ||
      (<span class=
"org-keyword">typeof</span> value === <span class=
"org-string">'number'</span> &amp;& isNoUnitNumericStyleProp(normalizedKey))
    ) {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">only render valid values</span>
      ret += <span class=
"org-string">`${normalizedKey}:${value};`</span>
    }
  }
  <span class="org-keyword">return</span> ret
}

<span id="coderef-normalizeClass" class="coderef-off"><span class=
"org-keyword">function</span> <span class=
"org-function-name">normalizeClass</span>(<span class=
"org-variable-name">value</span>) { <span class=
"org-comment-delimiter">//</span> (normalizeClass)</span>
  <span class="org-keyword">let</span> <span class=
"org-variable-name">res</span> = <span class="org-string">''</span>
  <span class="org-keyword">if</span> (isString(value)) {
    res = value
  } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (isArray(value)) {
    <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; value.length; i++) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">normalized</span> = normalizeClass(value[i])
      <span class="org-keyword">if</span> (normalized) {
        res += normalized + <span class="org-string">' '</span>
      }
    }
  } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (isObject(value)) {
    <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">name</span> <span class=
"org-keyword">in</span> value) {
      <span class="org-keyword">if</span> (value[name]) {
        res += name + <span class="org-string">' '</span>
      }
    }
  }
  <span class="org-keyword">return</span> res.trim()
}

<span id="coderef-normalizeProps" class="coderef-off"><span class=
"org-keyword">function</span> <span class=
"org-function-name">normalizeProps</span>(<span class=
"org-variable-name">props</span>) { <span class=
"org-comment-delimiter">//</span> (normalizeProps)</span>
  <span class="org-keyword">if</span> (!props) <span class=
"org-keyword">return</span> <span class="org-constant">null</span>
  <span class="org-keyword">let</span> { <span class=
"org-keyword">class</span>: klass, style } = props
  <span class=
"org-keyword">if</span> (klass &amp;& !isString(klass)) {
    props.<span class=
"org-keyword">class</span> = normalizeClass(klass)
  }
  <span class="org-keyword">if</span> (style) {
    props.style = normalizeStyle(style)
  }
  <span class="org-keyword">return</span> props
}

<span class="org-keyword">const</span> <span class=
"org-variable-name">escapeRE</span> = <span class=
"org-string">/["'&amp;&lt;&gt;]/</span>

<span class="org-keyword">function</span> <span class=
"org-function-name">escapeHtml</span>(<span class=
"org-variable-name">string</span>) {
  <span class="org-keyword">const</span> <span class=
"org-variable-name">str</span> = <span class=
"org-string">''</span> + string
  <span class="org-keyword">const</span> <span class=
"org-variable-name">match</span> = escapeRE.exec(str)

  <span class="org-keyword">if</span> (!match) {
    <span class="org-keyword">return</span> str
  }

  <span class="org-keyword">let</span> <span class=
"org-variable-name">html</span> = <span class=
"org-string">''</span>
  <span class="org-keyword">let</span> <span class=
"org-variable-name">escaped</span>
  <span class="org-keyword">let</span> <span class=
"org-variable-name">index</span>
  <span class="org-keyword">let</span> <span class=
"org-variable-name">lastIndex</span> = <span class=
"org-highlight-numbers-number">0</span>
  <span class=
"org-keyword">for</span> (index = match.index; index &lt; str.length; index++) {
    <span class=
"org-keyword">switch</span> (str.charCodeAt(index)) {
      <span class="org-keyword">case</span> <span class=
"org-highlight-numbers-number">34</span>: <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">"</span>
        escaped = <span class="org-string">'&amp;quot;'</span>
        <span class="org-keyword">break</span>
      <span class="org-keyword">case</span> <span class=
"org-highlight-numbers-number">38</span>: <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">&</span>
        escaped = <span class="org-string">'&amp;amp;'</span>
        <span class="org-keyword">break</span>
      <span class="org-keyword">case</span> <span class=
"org-highlight-numbers-number">39</span>: <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">'</span>
        escaped = <span class="org-string">'&amp;#39;'</span>
        <span class="org-keyword">break</span>
      <span class="org-keyword">case</span> <span class=
"org-highlight-numbers-number">60</span>: <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">&lt;</span>
        escaped = <span class="org-string">'&amp;lt;'</span>
        <span class="org-keyword">break</span>
      <span class="org-keyword">case</span> <span class=
"org-highlight-numbers-number">62</span>: <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">&gt;</span>
        escaped = <span class="org-string">'&amp;gt;'</span>
        <span class="org-keyword">break</span>
      <span class="org-keyword">default</span>:
        <span class="org-keyword">continue</span>
    }

    <span class="org-keyword">if</span> (lastIndex !== index) {
      html += str.slice(lastIndex, index)
    }

    lastIndex = index + <span class=
"org-highlight-numbers-number">1</span>
    html += escaped
  }

  <span class=
"org-keyword">return</span> lastIndex !== index ? html + str.slice(lastIndex, index) : html
}

<span class="org-comment-delimiter">// </span><span class=
"org-comment">https://www.w3.org/TR/html52/syntax.html#comments</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">commentStripRE</span> = <span class=
"org-string">/^-?&gt;|&lt;!--|--&gt;|--!&gt;|&lt;!-$/</span>g

<span class="org-keyword">function</span> <span class=
"org-function-name">escapeHtmlComment</span>(<span class=
"org-variable-name">src</span>) {
  <span class=
"org-keyword">return</span> src.replace(commentStripRE, <span class="org-string">''</span>)
}

<span class="org-keyword">const</span> <span class=
"org-variable-name">toDisplayString</span> = (val) =&gt; {
  <span class="org-keyword">return</span> isString(val)
    ? val
    : val == <span class="org-constant">null</span>
    ? <span class="org-string">''</span>
    : isArray(val) ||
      (isObject(val) &amp;&
        (val.toString === objectToString || !isFunction(val.toString)))
    ? JSON.stringify(val, replacer, <span class=
"org-highlight-numbers-number">2</span>)
    : String(val)
}

<span class="org-keyword">const</span> <span class=
"org-variable-name">replacer</span> = (_key, val) =&gt; {
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">can't use isRef here since @vue/shared has no deps</span>
  <span class="org-keyword">if</span> (val &amp;& val.__v_isRef) {
    <span class=
"org-keyword">return</span> replacer(_key, val.value)
  } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (isMap(val)) {
    <span class="org-keyword">return</span> {
      [<span class=
"org-string">`Map(${val.size})`</span>]: [...val.entries()].reduce((entries, [key, val]) =&gt; {
        ;entries[<span class=
"org-string">`${key} =&gt;`</span>] = val
        <span class="org-keyword">return</span> entries
      }, {})
    }
  } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (isSet(val)) {
    <span class="org-keyword">return</span> {
      [<span class=
"org-string">`Set(${val.size})`</span>]: [...val.values()]
    }
  } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (isObject(val) &amp;& !isArray(val) &amp;& !isPlainObject(val)) {
    <span class="org-keyword">return</span> String(val)
  }
  <span class="org-keyword">return</span> val
}

<span class="org-keyword">const</span> <span class=
"org-variable-name">noopDirectiveTransform</span> = () =&gt; ({ props: [] })

<span class="org-keyword">const</span> <span class=
"org-variable-name">isRawTextContainer</span> = <span class=
"org-comment-delimiter">/*</span><span class=
"org-comment">#__PURE__</span><span class=
"org-comment-delimiter">*/</span> makeMap(
  <span class="org-string">'style,iframe,script,noscript'</span>,
  <span class="org-constant">true</span>
)

<span class="org-keyword">const</span> <span class=
"org-variable-name">DOMNamespaces</span> = {
  HTML: Namespaces.HTML,
  SVG: <span class="org-highlight-numbers-number">1</span>,
  MATH_ML: <span class="org-highlight-numbers-number">2</span>
}

<span class="org-keyword">const</span> <span class=
"org-variable-name">parserOptions</span> = {
  isVoidTag,
  isNativeTag: tag =&gt; isHTMLTag(tag) || isSVGTag(tag),
  isPreTag: tag =&gt; tag === <span class=
"org-string">'pre'</span>,
  decodeEntities: __BROWSER__ ? decodeHtmlBrowser : decodeHtml,

  isBuiltInComponent: tag =&gt; {
    <span class=
"org-keyword">if</span> (isBuiltInType(tag, <span class=
"org-string">`Transition`</span>)) {
      <span class="org-keyword">return</span> TRANSITION
    } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (isBuiltInType(tag, <span class=
"org-string">`TransitionGroup`</span>)) {
      <span class="org-keyword">return</span> TRANSITION_GROUP
    }
  },

  <span class="org-comment-delimiter">// </span><span class=
"org-comment">https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher</span>
  getNamespace(tag, parent) {
    <span class="org-keyword">let</span> <span class=
"org-variable-name">ns</span> = parent ? parent.ns : DOMNamespaces.HTML

    <span class=
"org-keyword">if</span> (parent &amp;& ns === DOMNamespaces.MATH_ML) {
      <span class=
"org-keyword">if</span> (parent.tag === <span class=
"org-string">'annotation-xml'</span>) {
        <span class="org-keyword">if</span> (tag === <span class=
"org-string">'svg'</span>) {
          <span class="org-keyword">return</span> DOMNamespaces.SVG
        }
        <span class="org-keyword">if</span> (
          parent.props.some(
            a =&gt;
              a.type === NodeTypes.ATTRIBUTE &amp;&
              a.name === <span class=
"org-string">'encoding'</span> &amp;&
              a.value != <span class=
"org-constant">null</span> &amp;&
              (a.value.content === <span class=
"org-string">'text/html'</span> ||
                a.value.content === <span class=
"org-string">'application/xhtml+xml'</span>)
          )
        ) {
          ns = DOMNamespaces.HTML
        }
      } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (
        <span class=
"org-string">/^m(?:[ions]|text)$/</span>.test(parent.tag) &amp;&
        tag !== <span class="org-string">'mglyph'</span> &amp;&
        tag !== <span class="org-string">'malignmark'</span>
      ) {
        ns = DOMNamespaces.HTML
      }
    } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (parent &amp;& ns === DOMNamespaces.SVG) {
      <span class="org-keyword">if</span> (
        parent.tag === <span class=
"org-string">'foreignObject'</span> ||
        parent.tag === <span class="org-string">'desc'</span> ||
        parent.tag === <span class="org-string">'title'</span>
      ) {
        ns = DOMNamespaces.HTML
      }
    }

    <span class=
"org-keyword">if</span> (ns === DOMNamespaces.HTML) {
      <span class="org-keyword">if</span> (tag === <span class=
"org-string">'svg'</span>) {
        <span class="org-keyword">return</span> DOMNamespaces.SVG
      }
      <span class="org-keyword">if</span> (tag === <span class=
"org-string">'math'</span>) {
        <span class=
"org-keyword">return</span> DOMNamespaces.MATH_ML
      }
    }
    <span class="org-keyword">return</span> ns
  },

  <span class="org-comment-delimiter">// </span><span class=
"org-comment">https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments</span>
  getTextMode({ tag, ns }) {
    <span class=
"org-keyword">if</span> (ns === DOMNamespaces.HTML) {
      <span class="org-keyword">if</span> (tag === <span class=
"org-string">'textarea'</span> || tag === <span class=
"org-string">'title'</span>) {
        <span class="org-keyword">return</span> TextModes.RCDATA
      }
      <span class=
"org-keyword">if</span> (isRawTextContainer(tag)) {
        <span class="org-keyword">return</span> TextModes.RAWTEXT
      }
    }
    <span class="org-keyword">return</span> TextModes.DATA
  }
}

<span class="org-keyword">function</span> <span class=
"org-function-name">hasDynamicKeyVBind</span>(<span class=
"org-variable-name">node</span>) {
  <span class="org-keyword">return</span> node.props.some(
    p =&gt;
      p.type === NodeTypes.DIRECTIVE &amp;&
      p.name === <span class="org-string">'bind'</span> &amp;&
      (!p.arg || <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">v-bind="obj"</span>
        p.arg.type !== NodeTypes.SIMPLE_EXPRESSION || <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">v-bind:[_ctx.foo]</span>
        !p.arg.isStatic) <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">v-bind:[foo]</span>
  )
}


<span class="org-keyword">function</span> <span class=
"org-function-name">hasMultipleChildren</span>(<span class=
"org-variable-name">node</span>) {
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">#1352 filter out potential comment nodes.</span>
  <span class="org-keyword">const</span> <span class=
"org-variable-name">children</span> = (node.children = node.children.filter(
    c =&gt;
      c.type !== NodeTypes.COMMENT &amp;&
      !(c.type === NodeTypes.TEXT &amp;& !c.content.trim())
  ))
  <span class="org-keyword">const</span> <span class=
"org-variable-name">child</span> = children[<span class=
"org-highlight-numbers-number">0</span>]
  <span class="org-keyword">return</span> (
    children.length !== <span class=
"org-highlight-numbers-number">1</span> ||
    child.type === NodeTypes.FOR ||
    (child.type === NodeTypes.IF &amp;& child.branches.some(hasMultipleChildren))
  )
}

<span class="org-keyword">const</span> <span class=
"org-variable-name">warnTransitionChildren</span> = (node, context) =&gt; {
  <span class="org-keyword">if</span> (
    node.type === NodeTypes.ELEMENT &amp;&
    node.tagType === ElementTypes.COMPONENT
  ) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">component</span> = context.isBuiltInComponent(node.tag)
    <span class=
"org-keyword">if</span> (component === TRANSITION) {
      <span class="org-keyword">return</span> () =&gt; {
        <span class=
"org-keyword">if</span> (node.children.length &amp;& hasMultipleChildren(node)) {
          console.warn(<span class=
"org-string">`X_TRANSITION_INVALID_CHILDREN`</span>, node)
        }
      }
    }
  }
}


<span class="org-keyword">const</span> <span class=
"org-variable-name">ignoreSideEffectTags</span> = (node, context) =&gt; {
  <span class="org-keyword">if</span> (
    node.type === NodeTypes.ELEMENT &amp;&
    node.tagType === ElementTypes.ELEMENT &amp;&
    (node.tag === <span class=
"org-string">'script'</span> || node.tag === <span class=
"org-string">'style'</span>)
  ) {
    console.warn(<span class=
"org-string">`X_IGNORED_SIDE_EFFECT_TAG`</span>)
    context.removeNode()
  }
}
<span class="org-keyword">const</span> <span class=
"org-variable-name">compilerDom</span> = (<span class=
"org-keyword">function</span>() {
  
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">Parse inline CSS strings for static style attributes into an object.</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">This is a NodeTransform since it works on the static `style` attribute and</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">converts it into a dynamic equivalent:</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">style="color: red" -&gt; :style='{ "color": "red" }'</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">It is then processed by `transformElement` and included in the generated</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">props.</span>
  <span class="org-keyword">const</span> <span class=
"org-variable-name">transformStyle</span> = node =&gt; {
    <span class=
"org-keyword">if</span> (node.type === NodeTypes.ELEMENT) {
      node.props.forEach((p, i) =&gt; {
        <span class=
"org-keyword">if</span> (p.type === NodeTypes.ATTRIBUTE &amp;& p.name === <span class="org-string">'style'</span> &amp;& p.value) {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">replace p with an expression node</span>
          node.props[i] = {
            type: NodeTypes.DIRECTIVE,
            name: <span class="org-string">`bind`</span>,
            arg: createSimpleExpression(<span class=
"org-string">`style`</span>, <span class=
"org-constant">true</span>, p.loc),
            exp: parseInlineCSS(p.value.content, p.loc),
            modifiers: [],
            loc: p.loc
          }
        }
      })
    }
  }
  
  <span class="org-keyword">const</span> <span class=
"org-variable-name">parseInlineCSS</span> = (cssText, loc) =&gt; {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">normalized</span> = parseStringStyle(cssText)
    <span class="org-keyword">return</span> createSimpleExpression(
      JSON.stringify(normalized),
      <span class="org-constant">false</span>,
      loc,
      ConstantTypes.CAN_STRINGIFY
    )
  }
  <span class="org-keyword">const</span> <span class=
"org-variable-name">transformVHtml</span> = (dir, node, context) =&gt; {
    <span class="org-keyword">const</span> { exp, loc } = dir
    <span class="org-keyword">if</span> (!exp) {
      logg(<span class="org-string">"v-html no exp"</span>)
    }
    <span class="org-keyword">if</span> (node.children.length) {
      logg(<span class=
"org-string">'v-html can not has children'</span>)
      node.children.length = <span class=
"org-highlight-numbers-number">0</span>
    }
    <span class="org-keyword">return</span> {
      props: [
        createObjectProperty(
          createSimpleExpression(<span class=
"org-string">`innerHTML`</span>, <span class=
"org-constant">true</span>, loc),
          exp || createSimpleExpression(<span class=
"org-string">''</span>, <span class="org-constant">true</span>)
        )
      ]
    }
  }
  <span class="org-keyword">const</span> <span class=
"org-variable-name">transformVText</span> = (dir, node, context) =&gt; {
    <span class="org-keyword">const</span> { exp, loc } = dir
    <span class="org-keyword">if</span> (!exp) {
      logg(<span class="org-string">'v-text no exp'</span>)
    }
    <span class="org-keyword">if</span> (node.children.length) {
      logg(<span class=
"org-string">'v-text can not have children'</span>)
      node.children.length = <span class=
"org-highlight-numbers-number">0</span>
    }
    <span class="org-keyword">return</span> {
      props: [
        createObjectProperty(
          createSimpleExpression(<span class=
"org-string">`textContent`</span>, <span class=
"org-constant">true</span>),
          exp
            ? createCallExpression(
                context.helperString(TO_DISPLAY_STRING),
                [exp],
                loc
              )
            : createSimpleExpression(<span class=
"org-string">''</span>, <span class="org-constant">true</span>)
        )
      ]
    }
  }
  <span class="org-keyword">const</span> <span class=
"org-variable-name">transformModel</span> = (dir, node, context) =&gt; {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">baseResult</span> = transformModel(dir, node, context)
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">base transform has errors OR component v-model (only need props)</span>
    <span class=
"org-keyword">if</span> (!baseResult.props.length || node.tagType === ElementTypes.COMPONENT) {
      <span class="org-keyword">return</span> baseResult
    }
  
    <span class="org-keyword">if</span> (dir.arg) {
      logg(<span class=
"org-string">"transfromModel - X_V_MODEL_ARG_ON_ELEMENT"</span>)
    }
  
    <span class="org-keyword">function</span> <span class=
"org-function-name">checkDuplicatedValue</span>() {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">value</span> = findProp(node, <span class=
"org-string">'value'</span>)
      <span class="org-keyword">if</span> (value) {
        logg(<span class=
"org-string">"transfromModel - X_V_MODEL_UNNECESSARY_VALUE"</span>)
      }
    }
  
    <span class="org-keyword">const</span> { tag } = node
    <span class="org-keyword">const</span> <span class=
"org-variable-name">isCustomElement</span> = context.isCustomElement(tag)
    <span class="org-keyword">if</span> (
      tag === <span class="org-string">'input'</span> ||
      tag === <span class="org-string">'textarea'</span> ||
      tag === <span class="org-string">'select'</span> ||
      isCustomElement
    ) {
      <span class="org-keyword">let</span> <span class=
"org-variable-name">directiveToUse</span> = V_MODEL_TEXT
      <span class="org-keyword">let</span> <span class=
"org-variable-name">isInvalidType</span> = <span class=
"org-constant">false</span>
      <span class="org-keyword">if</span> (tag === <span class=
"org-string">'input'</span> || isCustomElement) {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">type</span> = findProp(node, <span class=
"org-string">`type`</span>)
        <span class="org-keyword">if</span> (type) {
          <span class=
"org-keyword">if</span> (type.type === NodeTypes.DIRECTIVE) {
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">:type="foo"</span>
            directiveToUse = V_MODEL_DYNAMIC
          } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (type.value) {
            <span class=
"org-keyword">switch</span> (type.value.content) {
              <span class="org-keyword">case</span> <span class=
"org-string">'radio'</span>:
                directiveToUse = V_MODEL_RADIO
                <span class="org-keyword">break</span>
              <span class="org-keyword">case</span> <span class=
"org-string">'checkbox'</span>:
                directiveToUse = V_MODEL_CHECKBOX
                <span class="org-keyword">break</span>
              <span class="org-keyword">case</span> <span class=
"org-string">'file'</span>:
                isInvalidType = <span class=
"org-constant">true</span>
                logg(<span class=
"org-string">"[DOM]transformModel - X_V_MODEL_ON_FILE_INPUT_ELEMENT"</span>)
                <span class="org-keyword">break</span>
              <span class="org-keyword">default</span>:
                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">text type</span>
                __DEV__ &amp;& checkDuplicatedValue()
                <span class="org-keyword">break</span>
            }
          }
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (hasDynamicKeyVBind(node)) {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">element has bindings with dynamic keys, which can possibly contain</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">"type".</span>
          directiveToUse = V_MODEL_DYNAMIC
        } <span class="org-keyword">else</span> {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">text type</span>
          __DEV__ &amp;& checkDuplicatedValue()
        }
      } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (tag === <span class=
"org-string">'select'</span>) {
        directiveToUse = V_MODEL_SELECT
      } <span class="org-keyword">else</span> {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">textarea</span>
        __DEV__ &amp;& checkDuplicatedValue()
      }
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">inject runtime directive</span>
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">by returning the helper symbol via needRuntime</span>
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">the import will replaced a resolveDirective call.</span>
      <span class="org-keyword">if</span> (!isInvalidType) {
        baseResult.needRuntime = context.helper(directiveToUse)
      }
    } <span class="org-keyword">else</span> {
      logg(<span class=
"org-string">"[DOM]transformModel - X_V_MODEL_ON_INVALID_ELEMENT"</span>)
    }
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">native vmodel doesn't need the `modelValue` props since they are also</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">passed to the runtime as `binding.value`. removing it reduces code size.</span>
    baseResult.props = baseResult.props.filter(
      p =&gt;
        !(
          p.key.type === NodeTypes.SIMPLE_EXPRESSION &amp;&
          p.key.content === <span class=
"org-string">'modelValue'</span>
        )
    )
  
    <span class="org-keyword">return</span> baseResult
  }
  <span class="org-keyword">const</span> <span class=
"org-variable-name">isEventOptionModifier</span> = <span class=
"org-comment-delimiter">/*</span><span class=
"org-comment">#__PURE__</span><span class=
"org-comment-delimiter">*/</span> makeMap(<span class=
"org-string">`passive,once,capture`</span>)
  <span class="org-keyword">const</span> <span class=
"org-variable-name">isNonKeyModifier</span> = <span class=
"org-comment-delimiter">/*</span><span class=
"org-comment">#__PURE__</span><span class=
"org-comment-delimiter">*/</span> makeMap(
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">event propagation management</span>
    <span class="org-string">`stop,prevent,self,`</span> +
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">system modifiers + exact</span>
      <span class=
"org-string">`ctrl,shift,alt,meta,exact,`</span> +
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">mouse</span>
      <span class="org-string">`middle`</span>
  )
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">left & right could be mouse or key modifiers based on event type</span>
  <span class="org-keyword">const</span> <span class=
"org-variable-name">maybeKeyModifier</span> = <span class=
"org-comment-delimiter">/*</span><span class=
"org-comment">#__PURE__</span><span class=
"org-comment-delimiter">*/</span> makeMap(<span class=
"org-string">'left,right'</span>)
  <span class="org-keyword">const</span> <span class=
"org-variable-name">isKeyboardEvent</span> = <span class=
"org-comment-delimiter">/*</span><span class=
"org-comment">#__PURE__</span><span class=
"org-comment-delimiter">*/</span> makeMap(
    <span class="org-string">`onkeyup,onkeydown,onkeypress`</span>,
    <span class="org-constant">true</span>
  )
  
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">将修饰符分类</span>
  <span class="org-keyword">const</span> <span class=
"org-variable-name">resolveModifiers</span> = (key, modifiers, context, loc) =&gt; {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">keyModifiers</span> = []
    <span class="org-keyword">const</span> <span class=
"org-variable-name">nonKeyModifiers</span> = []
    <span class="org-keyword">const</span> <span class=
"org-variable-name">eventOptionModifiers</span> = []
  
    <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; modifiers.length; i++) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">modifier</span> = modifiers[i]
  
      <span class=
"org-keyword">if</span> (isEventOptionModifier(modifier)) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">eventOptionModifiers: modifiers for addEventListener() options,</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">e.g. .passive & .capture</span>
        eventOptionModifiers.push(modifier)
      } <span class="org-keyword">else</span> {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">runtimeModifiers: modifiers that needs runtime guards</span>
        <span class=
"org-keyword">if</span> (maybeKeyModifier(modifier)) {
          <span class="org-keyword">if</span> (isStaticExp(key)) {
            <span class=
"org-keyword">if</span> (isKeyboardEvent(key.content)) {
              keyModifiers.push(modifier)
            } <span class="org-keyword">else</span> {
              nonKeyModifiers.push(modifier)
            }
          } <span class="org-keyword">else</span> {
            keyModifiers.push(modifier)
            nonKeyModifiers.push(modifier)
          }
        } <span class="org-keyword">else</span> {
          <span class=
"org-keyword">if</span> (isNonKeyModifier(modifier)) {
            nonKeyModifiers.push(modifier)
          } <span class="org-keyword">else</span> {
            keyModifiers.push(modifier)
          }
        }
      }
    }
  
    <span class="org-keyword">return</span> {
      keyModifiers,
      nonKeyModifiers,
      eventOptionModifiers
    }
  }
  
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">原生 click 事件</span>
  <span class="org-keyword">const</span> <span class=
"org-variable-name">transformClick</span> = (key, event) =&gt; {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">isStaticClick</span> =
      isStaticExp(key) &amp;& key.content.toLowerCase() === <span class="org-string">'onclick'</span>
    <span class="org-keyword">return</span> isStaticClick
      ? createSimpleExpression(event, <span class=
"org-constant">true</span>)
      : key.type !== NodeTypes.SIMPLE_EXPRESSION
      ? createCompoundExpression([
          <span class="org-string">`(`</span>,
          key,
          <span class=
"org-string">`) === "onClick" ? "${event}" : (`</span>,
          key,
          <span class="org-string">`)`</span>
        ])
      : key
  }
  
  <span class="org-keyword">const</span> <span class=
"org-variable-name">transformOn</span> = (dir, node, context) =&gt; {
    <span class=
"org-keyword">return</span> transformOn(dir, node, context, baseResult =&gt; {
      <span class="org-keyword">const</span> { modifiers } = dir
      <span class=
"org-keyword">if</span> (!modifiers.length) <span class=
"org-keyword">return</span> baseResult
  
      <span class=
"org-keyword">let</span> { key, value: handlerExp } = baseResult.props[<span class="org-highlight-numbers-number">0</span>]
      <span class=
"org-keyword">const</span> { keyModifiers, nonKeyModifiers, eventOptionModifiers } =
        resolveModifiers(key, modifiers, context, dir.loc)
  
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">normalize click.right and click.middle since they don't actually fire</span>
      <span class=
"org-keyword">if</span> (nonKeyModifiers.includes(<span class=
"org-string">'right'</span>)) {
        key = transformClick(key, <span class=
"org-string">`onContextmenu`</span>)
      }
      <span class=
"org-keyword">if</span> (nonKeyModifiers.includes(<span class=
"org-string">'middle'</span>)) {
        key = transformClick(key, <span class=
"org-string">`onMouseup`</span>)
      }
  
      <span class=
"org-keyword">if</span> (nonKeyModifiers.length) {
        handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
          handlerExp,
          JSON.stringify(nonKeyModifiers)
        ])
      }
  
      <span class="org-keyword">if</span> (
        keyModifiers.length &amp;&
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">if event name is dynamic, always wrap with keys guard</span>
        (!isStaticExp(key) || isKeyboardEvent(key.content))
      ) {
        handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [
          handlerExp,
          JSON.stringify(keyModifiers)
        ])
      }
  
      <span class=
"org-keyword">if</span> (eventOptionModifiers.length) {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">modifierPostfix</span> = eventOptionModifiers.map(capitalize).join(<span class="org-string">''</span>)
        key = isStaticExp(key)
          ? createSimpleExpression(<span class=
"org-string">`${key.content}${modifierPostfix}`</span>, <span class="org-constant">true</span>)
          : createCompoundExpression([<span class=
"org-string">`(`</span>, key, <span class=
"org-string">`) + "${modifierPostfix}"`</span>])
      }
  
      <span class="org-keyword">return</span> {
        props: [createObjectProperty(key, handlerExp)]
      }
    })
  }
  <span class="org-keyword">const</span> <span class=
"org-variable-name">transformShow</span> = (dir, node, context) =&gt; {
    <span class="org-keyword">const</span> { exp, loc } = dir
    <span class="org-keyword">if</span> (!exp) {
      logg(<span class="org-string">'transformShow no exp.'</span>)
    }
  
    <span class="org-keyword">return</span> {
      props: [],
      needRuntime: context.helper(V_SHOW)
    }
  }
   <span class="org-keyword">const</span> <span class=
"org-variable-name">StringifyThresholds</span> = {
     ELEMENT_WITH_BINDING_COUNT: <span class=
"org-highlight-numbers-number">5</span>,
     NODE_COUNT: <span class=
"org-highlight-numbers-number">20</span>
  }
  
  <span class="org-doc">/**</span>
<span class=
"org-doc">   * Regex for replacing placeholders for embedded constant variables</span>
<span class=
"org-doc">   * (e.g. import URL string constants generated by compiler-sfc)</span>
<span class="org-doc">   */</span>
  <span class="org-keyword">const</span> <span class=
"org-variable-name">expReplaceRE</span> = <span class=
"org-string">/__VUE_EXP_START__(.*?)__VUE_EXP_END__/</span>g
  
  <span class="org-doc">/**</span>
<span class=
"org-doc">   * Turn eligible hoisted static trees into stringified static nodes, e.g.</span>
<span class="org-doc">   *</span>
<span class="org-doc">   * ```js</span>
<span class=
"org-doc">   * const _hoisted_1 = createStaticVNode(`&lt;div class="foo"&gt;bar&lt;/div&gt;`)</span>
<span class="org-doc">   * ```</span>
<span class="org-doc">   *</span>
<span class=
"org-doc">   * A single static vnode can contain stringified content for **multiple**</span>
<span class=
"org-doc">   * consecutive nodes (element and plain text), called a "chunk".</span>
<span class=
"org-doc">   * `@vue/runtime-dom` will create the content via innerHTML in a hidden</span>
<span class=
"org-doc">   * container element and insert all the nodes in place. The call must also</span>
<span class=
"org-doc">   * provide the number of nodes contained in the chunk so that during hydration</span>
<span class=
"org-doc">   * we can know how many nodes the static vnode should adopt.</span>
<span class="org-doc">   *</span>
<span class=
"org-doc">   * The optimization scans a children list that contains hoisted nodes, and</span>
<span class=
"org-doc">   * tries to find the largest chunk of consecutive hoisted nodes before running</span>
<span class=
"org-doc">   * into a non-hoisted node or the end of the list. A chunk is then converted</span>
<span class=
"org-doc">   * into a single static vnode and replaces the hoisted expression of the first</span>
<span class=
"org-doc">   * node in the chunk. Other nodes in the chunk are considered "merged" and</span>
<span class=
"org-doc">   * therefore removed from both the hoist list and the children array.</span>
<span class="org-doc">   *</span>
<span class=
"org-doc">   * This optimization is only performed in Node.js.</span>
<span class="org-doc">   */</span>
  <span class="org-keyword">const</span> <span class=
"org-variable-name">stringifyStatic</span> = (children, context, parent) =&gt; {
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">bail stringification for slot content</span>
    <span class=
"org-keyword">if</span> (context.scopes.vSlot &gt; <span class=
"org-highlight-numbers-number">0</span>) {
      <span class="org-keyword">return</span>
    }
  
    <span class="org-keyword">let</span> <span class=
"org-variable-name">nc</span> = <span class=
"org-highlight-numbers-number">0</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">current node count</span>
    <span class="org-keyword">let</span> <span class=
"org-variable-name">ec</span> = <span class=
"org-highlight-numbers-number">0</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">current element with binding count</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">currentChunk</span> = []
  
    logg(<span class=
"org-string">`stringifyStatic - children.length = ${children.length}`</span>)
    <span class="org-keyword">const</span> <span class=
"org-variable-name">stringifyCurrentChunk</span> = (currentIndex) =&gt; {
      <span class="org-keyword">if</span> (
        nc &gt;= StringifyThresholds.NODE_COUNT ||
        ec &gt;= StringifyThresholds.ELEMENT_WITH_BINDING_COUNT
      ) {
        logg(<span class=
"org-string">`stringifyCurrentChunk - index = ${currentIndex}`</span>)
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">combine all currently eligible nodes into a single static vnode call</span>
        <span class="org-keyword">const</span> <span class=
"org-variable-name">staticCall</span> = createCallExpression(context.helper(CREATE_STATIC), [
          JSON.stringify(
            currentChunk.map(node =&gt; stringifyNode(node, context)).join(<span class="org-string">''</span>)
          ).replace(expReplaceRE, <span class=
"org-string">`" + $1 + "`</span>),
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">the 2nd argument indicates the number of DOM nodes this static vnode</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">will insert / hydrate</span>
          String(currentChunk.length)
        ])
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">replace the first node's hoisted expression with the static vnode call</span>
        replaceHoist(currentChunk[<span class=
"org-highlight-numbers-number">0</span>], staticCall, context)
  
        <span class=
"org-keyword">if</span> (currentChunk.length &gt; <span class=
"org-highlight-numbers-number">1</span>) {
          <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">1</span>; i &lt; currentChunk.length; i++) {
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">for the merged nodes, set their hoisted expression to null</span>
            replaceHoist(currentChunk[i], <span class=
"org-constant">null</span>, context)
          }
  
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">also remove merged nodes from children</span>
          <span class="org-keyword">const</span> <span class=
"org-variable-name">deleteCount</span> = currentChunk.length - <span class="org-highlight-numbers-number">1</span>
          children.splice(currentIndex - currentChunk.length + <span class="org-highlight-numbers-number">1</span>, deleteCount)
          <span class="org-keyword">return</span> deleteCount
        }
      }
      <span class="org-keyword">return</span> <span class=
"org-highlight-numbers-number">0</span>
    }
  
    <span class="org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>
    <span class=
"org-keyword">for</span> (; i &lt; children.length; i++) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">child</span> = children[i]
      <span class="org-keyword">const</span> <span class=
"org-variable-name">hoisted</span> = getHoistedNode(child)
      <span class="org-keyword">if</span> (hoisted) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">presence of hoisted means child must be a stringifiable node</span>
        <span class="org-keyword">const</span> <span class=
"org-variable-name">node</span> = child
        <span class="org-keyword">const</span> <span class=
"org-variable-name">result</span> = analyzeNode(node)
        <span class="org-keyword">if</span> (result) {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">node is stringifiable, record state</span>
          nc += result[<span class=
"org-highlight-numbers-number">0</span>]
          ec += result[<span class=
"org-highlight-numbers-number">1</span>]
          currentChunk.push(node)
          <span class="org-keyword">continue</span>
        }
      }
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">we only reach here if we ran into a node that is not stringifiable</span>
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">check if currently analyzed nodes meet criteria for stringification.</span>
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">adjust iteration index</span>
      i -= stringifyCurrentChunk(i)
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">reset state</span>
      nc = <span class="org-highlight-numbers-number">0</span>
      ec = <span class="org-highlight-numbers-number">0</span>
      currentChunk.length = <span class=
"org-highlight-numbers-number">0</span>
    }
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">in case the last node was also stringifiable</span>
    stringifyCurrentChunk(i)
  }
  
  <span class="org-keyword">const</span> <span class=
"org-variable-name">getHoistedNode</span> = (node) =&gt;
    ((node.type === NodeTypes.ELEMENT &amp;& node.tagType === ElementTypes.ELEMENT) ||
      node.type == NodeTypes.TEXT_CALL) &amp;&
    node.codegenNode &amp;&
    node.codegenNode.type === NodeTypes.SIMPLE_EXPRESSION &amp;&
    node.codegenNode.hoisted
  
  <span class="org-keyword">const</span> <span class=
"org-variable-name">dataAriaRE</span> = <span class=
"org-string">/^(data|aria)-/</span>
  <span class="org-keyword">const</span> <span class=
"org-variable-name">isStringifiableAttr</span> = (name, ns) =&gt; {
    <span class="org-keyword">return</span> (
      (ns === DOMNamespaces.HTML
        ? isKnownHtmlAttr(name)
        : ns === DOMNamespaces.SVG
        ? isKnownSvgAttr(name)
        : <span class=
"org-constant">false</span>) || dataAriaRE.test(name)
    )
  }
  
  <span class="org-keyword">const</span> <span class=
"org-variable-name">replaceHoist</span> = (node,replacement,context) =&gt; {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">hoistToReplace</span> = node.codegenNode.hoisted
    context.hoists[context.hoists.indexOf(hoistToReplace)] = replacement
  }
  
  <span class="org-keyword">const</span> <span class=
"org-variable-name">isNonStringifiable</span> = <span class=
"org-comment-delimiter">/*</span><span class=
"org-comment">#__PURE__</span><span class=
"org-comment-delimiter">*/</span> makeMap(
    <span class=
"org-string">`caption,thead,tr,th,tbody,td,tfoot,colgroup,col`</span>
  )
  
  <span class="org-doc">/**</span>
<span class=
"org-doc">   * for a hoisted node, analyze it and return:</span>
<span class=
"org-doc">   * - false: bailed (contains non-stringifiable props or runtime constant)</span>
<span class="org-doc">   * - [nc, ec] where</span>
<span class=
"org-doc">   *   - nc is the number of nodes inside</span>
<span class=
"org-doc">   *   - ec is the number of element with bindings inside</span>
<span class="org-doc">   */</span>
  <span class="org-keyword">function</span> <span class=
"org-function-name">analyzeNode</span>(<span class=
"org-variable-name">node</span>) {
    <span class=
"org-keyword">if</span> (node.type === NodeTypes.ELEMENT &amp;& isNonStringifiable(node.tag)) {
      <span class="org-keyword">return</span> <span class=
"org-constant">false</span>
    }
  
    <span class=
"org-keyword">if</span> (node.type === NodeTypes.TEXT_CALL) {
      <span class="org-keyword">return</span> [<span class=
"org-highlight-numbers-number">1</span>, <span class=
"org-highlight-numbers-number">0</span>]
    }
  
    <span class="org-keyword">let</span> <span class=
"org-variable-name">nc</span> = <span class=
"org-highlight-numbers-number">1</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">node count</span>
    <span class="org-keyword">let</span> <span class=
"org-variable-name">ec</span> = node.props.length &gt; <span class=
"org-highlight-numbers-number">0</span> ? <span class=
"org-highlight-numbers-number">1</span> : <span class=
"org-highlight-numbers-number">0</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">element w/ binding count</span>
    <span class="org-keyword">let</span> <span class=
"org-variable-name">bailed</span> = <span class=
"org-constant">false</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">bail</span> = () =&gt; {
      bailed = <span class="org-constant">true</span>
      <span class="org-keyword">return</span> <span class=
"org-constant">false</span>
    }
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment"><span class="org-bold"><span class=
"org-warning">TODO:</span></span></span><span class=
"org-comment"> check for cases where using innerHTML will result in different</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">output compared to imperative node insertions.</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">probably only need to check for most common case</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">i.e. non-phrasing-content tags inside `&lt;p&gt;`</span>
    <span class="org-keyword">function</span> <span class=
"org-function-name">walk</span>(<span class=
"org-variable-name">node</span>) {
      <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; node.props.length; i++) {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">p</span> = node.props[i]
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">bail on non-attr bindings</span>
        <span class="org-keyword">if</span> (
          p.type === NodeTypes.ATTRIBUTE &amp;&
          !isStringifiableAttr(p.name, node.ns)
        ) {
          <span class="org-keyword">return</span> bail()
        }
        <span class=
"org-keyword">if</span> (p.type === NodeTypes.DIRECTIVE &amp;& p.name === <span class="org-string">'bind'</span>) {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">bail on non-attr bindings</span>
          <span class="org-keyword">if</span> (
            p.arg &amp;&
            (p.arg.type === NodeTypes.COMPOUND_EXPRESSION ||
              (p.arg.isStatic &amp;& !isStringifiableAttr(p.arg.content, node.ns)))
          ) {
            <span class="org-keyword">return</span> bail()
          }
          <span class="org-keyword">if</span> (
            p.exp &amp;&
            (p.exp.type === NodeTypes.COMPOUND_EXPRESSION ||
              p.exp.constType &lt; ConstantTypes.CAN_STRINGIFY)
          ) {
            <span class="org-keyword">return</span> bail()
          }
        }
      }
      <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; node.children.length; i++) {
        nc++
        <span class="org-keyword">const</span> <span class=
"org-variable-name">child</span> = node.children[i]
        <span class=
"org-keyword">if</span> (child.type === NodeTypes.ELEMENT) {
          <span class=
"org-keyword">if</span> (child.props.length &gt; <span class=
"org-highlight-numbers-number">0</span>) {
            ec++
          }
          walk(child)
          <span class="org-keyword">if</span> (bailed) {
            <span class="org-keyword">return</span> <span class=
"org-constant">false</span>
          }
        }
      }
      <span class="org-keyword">return</span> <span class=
"org-constant">true</span>
    }
  
    <span class=
"org-keyword">return</span> walk(node) ? [nc, ec] : <span class=
"org-constant">false</span>
  }
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">stringifyNode</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
    <span class="org-keyword">if</span> (isString(node)) {
      <span class="org-keyword">return</span> node
    }
    <span class="org-keyword">if</span> (isSymbol(node)) {
      <span class="org-keyword">return</span> <span class=
"org-string">``</span>
    }
    <span class="org-keyword">switch</span> (node.type) {
      <span class="org-keyword">case</span> NodeTypes.ELEMENT:
        <span class=
"org-keyword">return</span> stringifyElement(node, context)
      <span class="org-keyword">case</span> NodeTypes.TEXT:
        <span class=
"org-keyword">return</span> escapeHtml(node.content)
      <span class="org-keyword">case</span> NodeTypes.COMMENT:
        <span class="org-keyword">return</span> <span class=
"org-string">`&lt;!--${escapeHtml(node.content)}--&gt;`</span>
      <span class=
"org-keyword">case</span> NodeTypes.INTERPOLATION:
        <span class=
"org-keyword">return</span> escapeHtml(toDisplayString(evaluateConstant(node.content)))
      <span class=
"org-keyword">case</span> NodeTypes.COMPOUND_EXPRESSION:
        <span class=
"org-keyword">return</span> escapeHtml(evaluateConstant(node))
      <span class="org-keyword">case</span> NodeTypes.TEXT_CALL:
        <span class=
"org-keyword">return</span> stringifyNode(node.content, context)
      <span class="org-keyword">default</span>:
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">static trees will not contain if/for nodes</span>
        <span class="org-keyword">return</span> <span class=
"org-string">''</span>
    }
  }
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">stringifyElement</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">context</span>) {
    <span class="org-keyword">let</span> <span class=
"org-variable-name">res</span> = <span class=
"org-string">`&lt;${node.tag}`</span>
    <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; node.props.length; i++) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">p</span> = node.props[i]
      <span class=
"org-keyword">if</span> (p.type === NodeTypes.ATTRIBUTE) {
        res += <span class="org-string">` ${p.name}`</span>
        <span class="org-keyword">if</span> (p.value) {
          res += <span class=
"org-string">`="${escapeHtml(p.value.content)}"`</span>
        }
      } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (p.type === NodeTypes.DIRECTIVE &amp;& p.name === <span class="org-string">'bind'</span>) {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">exp</span> = p.exp
        <span class=
"org-keyword">if</span> (exp.content[<span class=
"org-highlight-numbers-number">0</span>] === <span class=
"org-string">'_'</span>) {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">internally generated string constant references</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">e.g. imported URL strings via compiler-sfc transformAssetUrl plugin</span>
          res += <span class=
"org-string">` ${p.arg.content}="__VUE_EXP_START__${</span>
<span class="org-string">            exp.content</span>
<span class="org-string">          }__VUE_EXP_END__"`</span>
          <span class="org-keyword">continue</span>
        }
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">constant v-bind, e.g. :foo="1"</span>
        <span class="org-keyword">let</span> <span class=
"org-variable-name">evaluated</span> = evaluateConstant(exp)
        <span class=
"org-keyword">if</span> (evaluated != <span class=
"org-constant">null</span>) {
          <span class="org-keyword">const</span> <span class=
"org-variable-name">arg</span> = p.arg &amp;& p.arg.content
          <span class="org-keyword">if</span> (arg === <span class=
"org-string">'class'</span>) {
            evaluated = normalizeClass(evaluated)
          } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (arg === <span class=
"org-string">'style'</span>) {
            evaluated = stringifyStyle(normalizeStyle(evaluated))
          }
          res += <span class=
"org-string">` ${p.arg.content}="${escapeHtml(evaluated)}"`</span>
        }
      }
    }
    <span class="org-keyword">if</span> (context.scopeId) {
      res += <span class="org-string">` ${context.scopeId}`</span>
    }
    res += <span class="org-string">`&gt;`</span>
    <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; node.children.length; i++) {
      res += stringifyNode(node.children[i], context)
    }
    <span class="org-keyword">if</span> (!isVoidTag(node.tag)) {
      res += <span class="org-string">`&lt;/${node.tag}&gt;`</span>
    }
    <span class="org-keyword">return</span> res
  }
  
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">__UNSAFE__</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">Reason: eval.</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">It's technically safe to eval because only constant expressions are possible</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">here, e.g. `{{ 1 }}` or `{{ 'foo' }}`</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">in addition, constant exps bail on presence of parens so you can't even</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">run JSFuck in here. But we mark it unsafe for security review purposes.</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">(see compiler-core/src/transformExpressions)</span>
  <span class="org-keyword">function</span> <span class=
"org-function-name">evaluateConstant</span>(<span class=
"org-variable-name">exp</span>) {
    <span class=
"org-keyword">if</span> (exp.type === NodeTypes.SIMPLE_EXPRESSION) {
      <span class="org-keyword">return</span> <span class=
"org-keyword">new</span> <span class=
"org-type">Function</span>(<span class=
"org-string">`return ${exp.content}`</span>)()
    } <span class="org-keyword">else</span> {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">compound</span>
      <span class="org-keyword">let</span> <span class=
"org-variable-name">res</span> = <span class="org-string">``</span>
      exp.children.forEach(c =&gt; {
        <span class=
"org-keyword">if</span> (isString(c) || isSymbol(c)) {
          <span class="org-keyword">return</span>
        }
        <span class=
"org-keyword">if</span> (c.type === NodeTypes.TEXT) {
          res += c.content
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (c.type === NodeTypes.INTERPOLATION) {
          res += toDisplayString(evaluateConstant(c.content))
        } <span class="org-keyword">else</span> {
          res += evaluateConstant(c)
        }
      })
      <span class="org-keyword">return</span> res
    }
  }
  
  <span class="org-keyword">const</span> <span class=
"org-variable-name">DOMDirectiveTransforms</span> = {
    cloak: noopDirectiveTransform,
    html: transformVHtml,
    text: transformVText,
    model: transformModel, <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">override compiler-core</span>
    on: transformOn, <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">override compiler-core</span>
    show: transformShow
  }
  <span class="org-keyword">const</span> <span class=
"org-variable-name">DOMNodeTransforms</span> = [
    transformStyle,
    ...(__DEV__ ? [warnTransitionChildren] : [])
  ]
  <span class="org-keyword">function</span> <span class=
"org-function-name">compile</span>(<span class=
"org-variable-name">template</span>, <span class=
"org-variable-name">options</span> = {}) {
    <span class="org-keyword">return</span> baseCompile(
      template,
      extend({}, parserOptions, options, {
        nodeTransforms: [
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">ignore &lt;script&gt; and &lt;tag&gt;</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">this is not put inside DOMNodeTransforms because that list is used</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">by compiler-ssr to generate vnode fallback branches</span>
          ignoreSideEffectTags,
          ...DOMNodeTransforms,
          ...(options.nodeTransforms || [])
        ],
        directiveTransforms: extend(
          {},
          DOMDirectiveTransforms,
          options.directiveTransforms || {}
        ),
        transformHoist: __BROWSER__ ? <span class=
"org-constant">null</span> : stringifyStatic
      })
    )
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">parse</span>(<span class=
"org-variable-name">template</span>, <span class=
"org-variable-name">options</span> = {}) {
    <span class=
"org-keyword">return</span> baseParse(template, extend({}, parserOptions, options))
  }

  <span class="org-keyword">return</span> {
    DOMNodeTransforms,
    DOMDirectiveTransforms,
    compile,
    parse,
    transformStyle,
  }
}())
<span class="org-keyword">const</span> <span class=
"org-variable-name">__ESM_BROWSER__</span> = <span class=
"org-constant">false</span>, <span class=
"org-variable-name">__GLOBAL__</span> = <span class=
"org-constant">true</span>
<span class="org-keyword">let</span> <span class=
"org-variable-name">MagicString</span> = require(process.env.NODE_LIB + <span class="org-string">'/magic-string'</span>)

<span class="org-keyword">function</span> <span class=
"org-function-name">createCache</span>(<span class=
"org-variable-name">size</span> = <span class=
"org-highlight-numbers-number">500</span>) {
  <span class="org-keyword">return</span> <span class=
"org-keyword">new</span> <span class="org-type">Map</span>()
}


<span class="org-keyword">const</span> <span class=
"org-variable-name">defaultExportRE</span> = <span class=
"org-string">/((?:^|\n|;)\s*)export(\s*)default/</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">namedDefaultExportRE</span> = <span class=
"org-string">/((?:^|\n|;)\s*)export(.+)as(\s*)default/</span>s
<span class="org-keyword">const</span> <span class=
"org-variable-name">exportDefaultClassRE</span> =
  <span class=
"org-string">/((?:^|\n|;)\s*)export\s+default\s+class\s+([\w$]+)/</span>

<span class="org-doc">/**</span>
<span class=
"org-doc"> * Utility for rewriting `export default` in a script block into a variable</span>
<span class=
"org-doc"> * declaration so that we can inject things into it</span>
<span class="org-doc"> */</span>
<span class="org-keyword">function</span> <span class=
"org-function-name">rewriteDefault</span>(<span class=
"org-variable-name">input</span>, <span class=
"org-variable-name">as</span>, <span class=
"org-variable-name">parserPlugins</span>) {
  <span class="org-keyword">if</span> (!hasDefaultExport(input)) {
    <span class="org-keyword">return</span> input + <span class=
"org-string">`\nconst ${as} = {}`</span>
  }

  <span class="org-keyword">let</span> <span class=
"org-variable-name">replaced</span>

  <span class="org-keyword">const</span> <span class=
"org-variable-name">classMatch</span> = input.match(exportDefaultClassRE)
  <span class="org-keyword">if</span> (classMatch) {
    replaced =
      input.replace(exportDefaultClassRE, <span class=
"org-string">'$1class $2'</span>) +
      <span class=
"org-string">`\nconst ${as} = ${classMatch[2]}`</span>
  } <span class="org-keyword">else</span> {
    replaced = input.replace(defaultExportRE, <span class=
"org-string">`$1const ${as} =`</span>)
  }
  <span class=
"org-keyword">if</span> (!hasDefaultExport(replaced)) {
    <span class="org-keyword">return</span> replaced
  }

  <span class="org-comment-delimiter">// </span><span class=
"org-comment">if the script somehow still contains `default export`, it probably has</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">multi-line comments or template strings. fallback to a full parse.</span>
  <span class="org-keyword">const</span> <span class=
"org-variable-name">s</span> = <span class=
"org-keyword">new</span> <span class=
"org-type">MagicString</span>(input)
  <span class="org-keyword">const</span> <span class=
"org-variable-name">ast</span> = babelParser.parse(input, {
    sourceType: <span class="org-string">'module'</span>,
    plugins: parserPlugins
  }).program.body
  ast.forEach(node =&gt; {
    <span class="org-keyword">if</span> (node.type === <span class=
"org-string">'ExportDefaultDeclaration'</span>) {
      s.overwrite(node.start, node.declaration.start, <span class=
"org-string">`const ${as} = `</span>)
    }
    <span class="org-keyword">if</span> (node.type === <span class=
"org-string">'ExportNamedDeclaration'</span>) {
      node.specifiers.forEach(specifier =&gt; {
        <span class="org-keyword">if</span> (
          specifier.type === <span class=
"org-string">'ExportSpecifier'</span> &amp;&
          specifier.exported.type === <span class=
"org-string">'Identifier'</span> &amp;&
          specifier.exported.name === <span class=
"org-string">'default'</span>
        ) {
          <span class="org-keyword">const</span> <span class=
"org-variable-name">end</span> = specifier.end
          s.overwrite(
            specifier.start,
            input.charAt(end) === <span class=
"org-string">','</span> ? end + <span class=
"org-highlight-numbers-number">1</span> : end,
            <span class="org-string">``</span>
          )
          s.append(<span class=
"org-string">`\nconst ${as} = ${specifier.local.name}`</span>)
        }
      })
    }
  })
  <span class="org-keyword">return</span> s.toString()
}

<span class="org-keyword">function</span> <span class=
"org-function-name">hasDefaultExport</span>(<span class=
"org-variable-name">input</span>) {
  <span class=
"org-keyword">return</span> defaultExportRE.test(input) || namedDefaultExportRE.test(input)
}
<span class="org-keyword">const</span> <span class=
"org-variable-name">RT</span> = (<span class=
"org-keyword">function</span>() {
  <span class="org-keyword">const</span> <span class=
"org-variable-name">CONVERT_SYMBOL</span> = <span class=
"org-string">'$'</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">ESCAPE_SYMBOL</span> = <span class=
"org-string">'$$'</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">shorthands</span> = [<span class=
"org-string">'ref'</span>, <span class=
"org-string">'computed'</span>, <span class=
"org-string">'shallowRef'</span>, <span class=
"org-string">'toRef'</span>, <span class=
"org-string">'customRef'</span>]
<span class="org-keyword">const</span> <span class=
"org-variable-name">transformCheckRE</span> = <span class=
"org-string">/[^\w]\$(?:\$|ref|computed|shallowRef)?\s*(\(|\&lt;)/</span>

<span class="org-keyword">function</span> <span class=
"org-function-name">shouldTransform</span>(<span class=
"org-variable-name">src</span>) {
  <span class=
"org-keyword">return</span> transformCheckRE.test(src)
}

<span class="org-keyword">function</span> <span class=
"org-function-name">transform</span>(
  <span class="org-variable-name">src</span>,
  {
    filename,
    sourceMap,
    parserPlugins,
    importHelpersFrom = <span class="org-string">'vue'</span>
  } = {}
) {
  <span class="org-keyword">const</span> <span class=
"org-variable-name">plugins</span> = parserPlugins || []
  <span class="org-keyword">if</span> (filename) {
    <span class="org-keyword">if</span> (<span class=
"org-string">/\.tsx?$/</span>.test(filename)) {
      plugins.push(<span class="org-string">'typescript'</span>)
    }
    <span class=
"org-keyword">if</span> (filename.endsWith(<span class=
"org-string">'x'</span>)) {
      plugins.push(<span class="org-string">'jsx'</span>)
    }
  }

  <span class="org-keyword">const</span> <span class=
"org-variable-name">ast</span> = babelParser.parse(src, {
    sourceType: <span class="org-string">'module'</span>,
    plugins
  })
  <span class="org-keyword">const</span> <span class=
"org-variable-name">s</span> = <span class=
"org-keyword">new</span> <span class=
"org-type">MagicString</span>(src)
  <span class="org-keyword">const</span> <span class=
"org-variable-name">res</span> = transformAST(ast.program, s, <span class="org-highlight-numbers-number">0</span>)

  <span class="org-comment-delimiter">// </span><span class=
"org-comment">inject helper imports</span>
  <span class=
"org-keyword">if</span> (res.importedHelpers.length) {
    s.prepend(
      <span class=
"org-string">`import { ${res.importedHelpers</span>
<span class=
"org-string">        .map(h =&gt; `</span>${h} as _${h}<span class=
"org-string">`)</span>
<span class=
"org-string">        .join(', ')} } from '${importHelpersFrom}'\n`</span>
    )
  }

  <span class="org-keyword">return</span> {
    ...res,
    code: s.toString(),
    map: sourceMap
      ? s.generateMap({
          source: filename,
          hires: <span class="org-constant">true</span>,
          includeContent: <span class="org-constant">true</span>
        })
      : <span class="org-constant">null</span>
  }
}

<span class="org-keyword">function</span> <span class=
"org-function-name">transformAST</span>(
  <span class="org-variable-name">ast</span>,
  <span class="org-variable-name">s</span>,
  offset = <span class="org-highlight-numbers-number">0</span>,
  <span class="org-variable-name">knownRefs</span>,
  knownProps
) {
  <span class="org-keyword">let</span> <span class=
"org-variable-name">convertSymbol</span> = CONVERT_SYMBOL
  <span class="org-keyword">let</span> <span class=
"org-variable-name">escapeSymbol</span> = ESCAPE_SYMBOL

  <span class="org-comment-delimiter">// </span><span class=
"org-comment">macro import handling</span>
  <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">node</span> <span class=
"org-keyword">of</span> ast.body) {
    <span class="org-keyword">if</span> (
      node.type === <span class=
"org-string">'ImportDeclaration'</span> &amp;&
      node.source.value === <span class=
"org-string">'vue/macros'</span>
    ) {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">remove macro imports</span>
      s.remove(node.start + offset, node.end + offset)
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">check aliasing</span>
      <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">specifier</span> <span class=
"org-keyword">of</span> node.specifiers) {
        <span class=
"org-keyword">if</span> (specifier.type === <span class=
"org-string">'ImportSpecifier'</span>) {
          <span class="org-keyword">const</span> <span class=
"org-variable-name">imported</span> = specifier.imported.name
          <span class="org-keyword">const</span> <span class=
"org-variable-name">local</span> = specifier.local.name
          <span class=
"org-keyword">if</span> (local !== imported) {
            <span class=
"org-keyword">if</span> (imported === ESCAPE_SYMBOL) {
              escapeSymbol = local
            } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (imported === CONVERT_SYMBOL) {
              convertSymbol = local
            } <span class="org-keyword">else</span> {
              error(
                <span class=
"org-string">`macro imports for ref-creating methods do not support aliasing.`</span>,
                specifier
              )
            }
          }
        }
      }
    }
  }

  <span class="org-keyword">const</span> <span class=
"org-variable-name">importedHelpers</span> = <span class=
"org-keyword">new</span> <span class="org-type">Set</span>()
  <span class="org-keyword">const</span> <span class=
"org-variable-name">rootScope</span> = {}
  <span class="org-keyword">const</span> <span class=
"org-variable-name">scopeStack</span> = [rootScope]
  <span class="org-keyword">let</span> <span class=
"org-variable-name">currentScope</span> = rootScope
  <span class="org-keyword">let</span> <span class=
"org-variable-name">escapeScope</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">inside $$()</span>
  <span class="org-keyword">const</span> <span class=
"org-variable-name">excludedIds</span> = <span class=
"org-keyword">new</span> <span class="org-type">WeakSet</span>()
  <span class="org-keyword">const</span> <span class=
"org-variable-name">parentStack</span> = []
  <span class="org-keyword">const</span> <span class=
"org-variable-name">propsLocalToPublicMap</span> = Object.create(<span class="org-constant">null</span>)

  <span class="org-keyword">if</span> (knownRefs) {
    <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">of</span> knownRefs) {
      rootScope[key] = <span class="org-constant">true</span>
    }
  }
  <span class="org-keyword">if</span> (knownProps) {
    <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">in</span> knownProps) {
      <span class=
"org-keyword">const</span> { local } = knownProps[key]
      rootScope[local] = <span class="org-string">'prop'</span>
      propsLocalToPublicMap[local] = key
    }
  }

  <span class="org-keyword">function</span> <span class=
"org-function-name">isRefCreationCall</span>(<span class=
"org-variable-name">callee</span>) {
    <span class=
"org-keyword">if</span> (callee === convertSymbol) {
      <span class="org-keyword">return</span> convertSymbol
    }
    <span class="org-keyword">if</span> (callee[<span class=
"org-highlight-numbers-number">0</span>] === <span class=
"org-string">'$'</span> &amp;& shorthands.includes(callee.slice(<span class="org-highlight-numbers-number">1</span>))) {
      <span class="org-keyword">return</span> callee
    }
    <span class="org-keyword">return</span> <span class=
"org-constant">false</span>
  }

  <span class="org-keyword">function</span> <span class=
"org-function-name">error</span>(<span class=
"org-variable-name">msg</span>, <span class=
"org-variable-name">node</span>) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">e</span> = <span class=
"org-keyword">new</span> <span class="org-type">Error</span>(msg)
    e.node = node
    <span class="org-keyword">throw</span> e
  }

  <span class="org-keyword">function</span> <span class=
"org-function-name">helper</span>(<span class=
"org-variable-name">msg</span>) {
    importedHelpers.add(msg)
    <span class="org-keyword">return</span> <span class=
"org-string">`_${msg}`</span>
  }

  <span class="org-keyword">function</span> <span class=
"org-function-name">registerBinding</span>(<span class=
"org-variable-name">id</span>, <span class=
"org-variable-name">isRef</span> = <span class=
"org-constant">false</span>) {
    excludedIds.add(id)
    <span class="org-keyword">if</span> (currentScope) {
      currentScope[id.name] = isRef
    } <span class="org-keyword">else</span> {
      error(
        <span class=
"org-string">'registerBinding called without active scope, something is wrong.'</span>,
        id
      )
    }
  }

  <span class="org-keyword">const</span> <span class=
"org-variable-name">registerRefBinding</span> = (id) =&gt; registerBinding(id, <span class="org-constant">true</span>)

  <span class="org-keyword">let</span> <span class=
"org-variable-name">tempVarCount</span> = <span class=
"org-highlight-numbers-number">0</span>
  <span class="org-keyword">function</span> <span class=
"org-function-name">genTempVar</span>() {
    <span class="org-keyword">return</span> <span class=
"org-string">`__$temp_${++tempVarCount}`</span>
  }

  <span class="org-keyword">function</span> <span class=
"org-function-name">snip</span>(<span class=
"org-variable-name">nod</span>) {
    <span class=
"org-keyword">return</span> s.original.slice(node.start + offset, node.end + offset)
  }

  <span class="org-keyword">function</span> <span class=
"org-function-name">walkScope</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">isRoot</span> = <span class=
"org-constant">false</span>) {
    <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">stmt</span> <span class=
"org-keyword">of</span> node.body) {
      <span class=
"org-keyword">if</span> (stmt.type === <span class=
"org-string">'VariableDeclaration'</span>) {
        walkVariableDeclaration(stmt, isRoot)
      } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (
        stmt.type === <span class=
"org-string">'FunctionDeclaration'</span> ||
        stmt.type === <span class=
"org-string">'ClassDeclaration'</span>
      ) {
        <span class=
"org-keyword">if</span> (stmt.declare || !stmt.id) <span class=
"org-keyword">continue</span>
        registerBinding(stmt.id)
      } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (
        (stmt.type === <span class=
"org-string">'ForOfStatement'</span> || stmt.type === <span class=
"org-string">'ForInStatement'</span>) &amp;&
        stmt.left.type === <span class=
"org-string">'VariableDeclaration'</span>
      ) {
        walkVariableDeclaration(stmt.left)
      } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (
        stmt.type === <span class=
"org-string">'ExportNamedDeclaration'</span> &amp;&
        stmt.declaration &amp;&
        stmt.declaration.type === <span class=
"org-string">'VariableDeclaration'</span>
      ) {
        walkVariableDeclaration(stmt.declaration, isRoot)
      } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (
        stmt.type === <span class=
"org-string">'LabeledStatement'</span> &amp;&
        stmt.body.type === <span class=
"org-string">'VariableDeclaration'</span>
      ) {
        walkVariableDeclaration(stmt.body, isRoot)
      }
    }
  }

  <span class="org-keyword">function</span> <span class=
"org-function-name">walkVariableDeclaration</span>(<span class=
"org-variable-name">stmt</span>, <span class=
"org-variable-name">isRoot</span> = <span class=
"org-constant">false</span>) {
    <span class="org-keyword">if</span> (stmt.declare) {
      <span class="org-keyword">return</span>
    }
    <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">decl</span> <span class=
"org-keyword">of</span> stmt.declarations) {
      <span class="org-keyword">let</span> <span class=
"org-variable-name">refCall</span>
      <span class="org-keyword">const</span> <span class=
"org-variable-name">isCall</span> =
        decl.init &amp;&
        decl.init.type === <span class=
"org-string">'CallExpression'</span> &amp;&
        decl.init.callee.type === <span class=
"org-string">'Identifier'</span>
      <span class="org-keyword">if</span> (
        isCall &amp;&
        (refCall = isRefCreationCall(decl.init.callee.name))
      ) {
        processRefDeclaration(refCall, decl.id, decl.init)
      } <span class="org-keyword">else</span> {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">isProps</span> =
          isRoot &amp;& isCall &amp;& decl.init.callee.name === <span class="org-string">'defineProps'</span>
        <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">id</span> <span class=
"org-keyword">of</span> extractIdentifiers(decl.id)) {
          <span class="org-keyword">if</span> (isProps) {
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">for defineProps destructure, only exclude them since they</span>
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">are already passed in as knownProps</span>
            excludedIds.add(id)
          } <span class="org-keyword">else</span> {
            registerBinding(id)
          }
        }
      }
    }
  }

  <span class="org-keyword">function</span> <span class=
"org-function-name">processRefDeclaration</span>(<span class=
"org-variable-name">method</span>, <span class=
"org-variable-name">id</span>, <span class=
"org-variable-name">call</span>) {
    excludedIds.add(call.callee)
    <span class=
"org-keyword">if</span> (method === convertSymbol) {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">$</span>
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">remove macro</span>
      s.remove(call.callee.start + offset, call.callee.end + offset)
      <span class="org-keyword">if</span> (id.type === <span class=
"org-string">'Identifier'</span>) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">single variable</span>
        registerRefBinding(id)
      } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (id.type === <span class=
"org-string">'ObjectPattern'</span>) {
        processRefObjectPattern(id, call)
      } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (id.type === <span class=
"org-string">'ArrayPattern'</span>) {
        processRefArrayPattern(id, call)
      }
    } <span class="org-keyword">else</span> {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">shorthands</span>
      <span class="org-keyword">if</span> (id.type === <span class=
"org-string">'Identifier'</span>) {
        registerRefBinding(id)
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">replace call</span>
        s.overwrite(
          call.start + offset,
          call.start + method.length + offset,
          helper(method.slice(<span class=
"org-highlight-numbers-number">1</span>))
        )
      } <span class="org-keyword">else</span> {
        error(<span class=
"org-string">`${method}() cannot be used with destructure patterns.`</span>, call)
      }
    }
  }

  <span class="org-keyword">function</span> <span class=
"org-function-name">processRefObjectPattern</span>(<span class=
"org-variable-name">pattern</span>, <span class=
"org-variable-name">call</span>, <span class=
"org-variable-name">tempVar</span>, <span class=
"org-variable-name">path</span> = []) {
    <span class="org-keyword">if</span> (!tempVar) {
      tempVar = genTempVar()
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">const { x } = $(useFoo()) --&gt; const __$temp_1 = useFoo()</span>
      s.overwrite(pattern.start + offset, pattern.end + offset, tempVar)
    }

    <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">p</span> <span class=
"org-keyword">of</span> pattern.properties) {
      <span class="org-keyword">let</span> <span class=
"org-variable-name">nameId</span>
      <span class="org-keyword">let</span> <span class=
"org-variable-name">key</span>
      <span class="org-keyword">let</span> <span class=
"org-variable-name">defaultValue</span>
      <span class="org-keyword">if</span> (p.type === <span class=
"org-string">'ObjectProperty'</span>) {
        <span class=
"org-keyword">if</span> (p.key.start === p.value.start) {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">shorthand { foo }</span>
          nameId = p.key
          <span class=
"org-keyword">if</span> (p.value.type === <span class=
"org-string">'Identifier'</span>) {
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">avoid shorthand value identifier from being processed</span>
            excludedIds.add(p.value)
          } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (
            p.value.type === <span class=
"org-string">'AssignmentPattern'</span> &amp;&
            p.value.left.type === <span class=
"org-string">'Identifier'</span>
          ) {
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">{ foo = 1 }</span>
            excludedIds.add(p.value.left)
            defaultValue = p.value.right
          }
        } <span class="org-keyword">else</span> {
          key = p.computed ? p.key : p.key.name
          <span class=
"org-keyword">if</span> (p.value.type === <span class=
"org-string">'Identifier'</span>) {
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">{ foo: bar }</span>
            nameId = p.value
          } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (p.value.type === <span class=
"org-string">'ObjectPattern'</span>) {
            processRefObjectPattern(p.value, call, tempVar, [...path, key])
          } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (p.value.type === <span class=
"org-string">'ArrayPattern'</span>) {
            processRefArrayPattern(p.value, call, tempVar, [...path, key])
          } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (p.value.type === <span class=
"org-string">'AssignmentPattern'</span>) {
            <span class=
"org-keyword">if</span> (p.value.left.type === <span class=
"org-string">'Identifier'</span>) {
              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">{ foo: bar = 1 }</span>
              nameId = p.value.left
              defaultValue = p.value.right
            } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (p.value.left.type === <span class=
"org-string">'ObjectPattern'</span>) {
              processRefObjectPattern(p.value.left, call, tempVar, [
                ...path,
                [key, p.value.right]
              ])
            } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (p.value.left.type === <span class=
"org-string">'ArrayPattern'</span>) {
              processRefArrayPattern(p.value.left, call, tempVar, [
                ...path,
                [key, p.value.right]
              ])
            } <span class="org-keyword">else</span> {
              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">MemberExpression case is not possible here, ignore</span>
            }
          }
        }
      } <span class="org-keyword">else</span> {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">rest element { ...foo }</span>
        error(<span class=
"org-string">`reactivity destructure does not support rest elements.`</span>, p)
      }
      <span class="org-keyword">if</span> (nameId) {
        registerRefBinding(nameId)
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">inject toRef() after original replaced pattern</span>
        <span class="org-keyword">const</span> <span class=
"org-variable-name">source</span> = pathToString(tempVar, path)
        <span class="org-keyword">const</span> <span class=
"org-variable-name">keyStr</span> = isString(key)
          ? <span class="org-string">`'${key}'`</span>
          : key
          ? snip(key)
          : <span class="org-string">`'${nameId.name}'`</span>
        <span class="org-keyword">const</span> <span class=
"org-variable-name">defaultStr</span> = defaultValue ? <span class=
"org-string">`, ${snip(defaultValue)}`</span> : <span class=
"org-string">``</span>
        s.appendLeft(
          call.end + offset,
          <span class=
"org-string">`,\n  ${nameId.name} = ${helper(</span>
<span class="org-string">            'toRef'</span>
<span class=
"org-string">          )}(${source}, ${keyStr}${defaultStr})`</span>
        )
      }
    }
  }

  <span class="org-keyword">function</span> <span class=
"org-function-name">processRefArrayPattern</span>(<span class=
"org-variable-name">pattern</span>, <span class=
"org-variable-name">call</span>, <span class=
"org-variable-name">tempVar</span>, <span class=
"org-variable-name">path</span> = []) {
    <span class="org-keyword">if</span> (!tempVar) {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">const [x] = $(useFoo()) --&gt; const __$temp_1 = useFoo()</span>
      tempVar = genTempVar()
      s.overwrite(pattern.start + offset, pattern.end + offset, tempVar)
    }

    <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; pattern.elements.length; i++) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">e</span> = pattern.elements[i]
      <span class="org-keyword">if</span> (!e) <span class=
"org-keyword">continue</span>
      <span class="org-keyword">let</span> <span class=
"org-variable-name">nameId</span>
      <span class="org-keyword">let</span> <span class=
"org-variable-name">defaultValue</span>
      <span class="org-keyword">if</span> (e.type === <span class=
"org-string">'Identifier'</span>) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">[a] --&gt; [__a]</span>
        nameId = e
      } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (e.type === <span class=
"org-string">'AssignmentPattern'</span>) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">[a = 1]</span>
        nameId = e.left
        defaultValue = e.right
      } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (e.type === <span class=
"org-string">'RestElement'</span>) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">[...a]</span>
        error(<span class=
"org-string">`reactivity destructure does not support rest elements.`</span>, e)
      } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (e.type === <span class=
"org-string">'ObjectPattern'</span>) {
        processRefObjectPattern(e, call, tempVar, [...path, i])
      } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (e.type === <span class=
"org-string">'ArrayPattern'</span>) {
        processRefArrayPattern(e, call, tempVar, [...path, i])
      }
      <span class="org-keyword">if</span> (nameId) {
        registerRefBinding(nameId)
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">inject toRef() after original replaced pattern</span>
        <span class="org-keyword">const</span> <span class=
"org-variable-name">source</span> = pathToString(tempVar, path)
        <span class="org-keyword">const</span> <span class=
"org-variable-name">defaultStr</span> = defaultValue ? <span class=
"org-string">`, ${snip(defaultValue)}`</span> : <span class=
"org-string">``</span>
        s.appendLeft(
          call.end + offset,
          <span class=
"org-string">`,\n  ${nameId.name} = ${helper(</span>
<span class="org-string">            'toRef'</span>
<span class=
"org-string">          )}(${source}, ${i}${defaultStr})`</span>
        )
      }
    }
  }

  <span class="org-keyword">function</span> <span class=
"org-function-name">pathToString</span>(<span class=
"org-variable-name">source</span>, <span class=
"org-variable-name">path</span>) {
    <span class="org-keyword">if</span> (path.length) {
      <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">seg</span> <span class=
"org-keyword">of</span> path) {
        <span class="org-keyword">if</span> (isArray(seg)) {
          source = <span class=
"org-string">`(${source}${segToString(seg[0])} || ${snip(seg[1])})`</span>
        } <span class="org-keyword">else</span> {
          source += segToString(seg)
        }
      }
    }
    <span class="org-keyword">return</span> source
  }

  <span class="org-keyword">function</span> <span class=
"org-function-name">segToString</span>(<span class=
"org-variable-name">seg</span>) {
    <span class="org-keyword">if</span> (<span class=
"org-keyword">typeof</span> seg === <span class=
"org-string">'number'</span>) {
      <span class="org-keyword">return</span> <span class=
"org-string">`[${seg}]`</span>
    } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (<span class=
"org-keyword">typeof</span> seg === <span class=
"org-string">'string'</span>) {
      <span class="org-keyword">return</span> <span class=
"org-string">`.${seg}`</span>
    } <span class="org-keyword">else</span> {
      <span class="org-keyword">return</span> snip(seg)
    }
  }

  <span class="org-keyword">function</span> <span class=
"org-function-name">rewriteId</span>(<span class=
"org-variable-name">scope</span>, <span class=
"org-variable-name">id</span>, <span class=
"org-variable-name">parent</span>, <span class=
"org-variable-name">parentStack</span>) {
    <span class="org-keyword">if</span> (hasOwn(scope, id.name)) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">bindingType</span> = scope[id.name]
      <span class="org-keyword">if</span> (bindingType) {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">isProp</span> = bindingType === <span class=
"org-string">'prop'</span>
        <span class=
"org-keyword">if</span> (isStaticProperty(parent) &amp;& parent.shorthand) {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">let binding used in a property shorthand</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">skip for destructure patterns</span>
          <span class="org-keyword">if</span> (
            !parent.inPattern ||
            isInDestructureAssignment(parent, parentStack)
          ) {
            <span class="org-keyword">if</span> (isProp) {
              <span class="org-keyword">if</span> (escapeScope) {
                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">prop binding in $$()</span>
                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">{ prop } -&gt; { prop: __prop_prop }</span>
                registerEscapedPropBinding(id)
                s.appendLeft(
                  id.end + offset,
                  <span class=
"org-string">`: __props_${propsLocalToPublicMap[id.name]}`</span>
                )
              } <span class="org-keyword">else</span> {
                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">{ prop } -&gt; { prop: __prop.prop }</span>
                s.appendLeft(
                  id.end + offset,
                  <span class=
"org-string">`: __props.${propsLocalToPublicMap[id.name]}`</span>
                )
              }
            } <span class="org-keyword">else</span> {
              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">{ foo } -&gt; { foo: foo.value }</span>
              s.appendLeft(id.end + offset, <span class=
"org-string">`: ${id.name}.value`</span>)
            }
          }
        } <span class="org-keyword">else</span> {
          <span class="org-keyword">if</span> (isProp) {
            <span class="org-keyword">if</span> (escapeScope) {
              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">x --&gt; __props_x</span>
              registerEscapedPropBinding(id)
              s.overwrite(
                id.start + offset,
                id.end + offset,
                <span class=
"org-string">`__props_${propsLocalToPublicMap[id.name]}`</span>
              )
            } <span class="org-keyword">else</span> {
              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">x --&gt; __props.x</span>
              s.overwrite(
                id.start + offset,
                id.end + offset,
                <span class=
"org-string">`__props.${propsLocalToPublicMap[id.name]}`</span>
              )
            }
          } <span class="org-keyword">else</span> {
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">x --&gt; x.value</span>
            s.appendLeft(id.end + offset, <span class=
"org-string">'.value'</span>)
          }
        }
      }
      <span class="org-keyword">return</span> <span class=
"org-constant">true</span>
    }
    <span class="org-keyword">return</span> <span class=
"org-constant">false</span>
  }

  <span class="org-keyword">const</span> <span class=
"org-variable-name">propBindingRefs</span> = {}
  <span class="org-keyword">function</span> <span class=
"org-function-name">registerEscapedPropBinding</span>(<span class=
"org-variable-name">id</span>) {
    <span class=
"org-keyword">if</span> (!propBindingRefs.hasOwnProperty(id.name)) {
      propBindingRefs[id.name] = <span class=
"org-constant">true</span>
      <span class="org-keyword">const</span> <span class=
"org-variable-name">publicKey</span> = propsLocalToPublicMap[id.name]
      s.prependRight(
        offset,
        <span class=
"org-string">`const __props_${publicKey} = ${helper(</span>
<span class="org-string">          `</span>toRef<span class=
"org-string">`</span>
<span class=
"org-string">        )}(__props, '${publicKey}')\n`</span>
      )
    }
  }

  <span class="org-comment-delimiter">// </span><span class=
"org-comment">check root scope first</span>
  walkScope(ast, <span class="org-constant">true</span>)
  walk(ast, {
    enter(node, parent) {
      parent &amp;& parentStack.push(parent)

      <span class="org-comment-delimiter">// </span><span class=
"org-comment">function scopes</span>
      <span class="org-keyword">if</span> (isFunctionType(node)) {
        scopeStack.push((currentScope = {}))
        walkFunctionParams(node, registerBinding)
        <span class=
"org-keyword">if</span> (node.body.type === <span class=
"org-string">'BlockStatement'</span>) {
          walkScope(node.body)
        }
        <span class="org-keyword">return</span>
      }

      <span class="org-comment-delimiter">// </span><span class=
"org-comment">catch param</span>
      <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'CatchClause'</span>) {
        scopeStack.push((currentScope = {}))
        <span class=
"org-keyword">if</span> (node.param &amp;& node.param.type === <span class="org-string">'Identifier'</span>) {
          registerBinding(node.param)
        }
        walkScope(node.body)
        <span class="org-keyword">return</span>
      }

      <span class="org-comment-delimiter">// </span><span class=
"org-comment">non-function block scopes</span>
      <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'BlockStatement'</span> &amp;& !isFunctionType(parent)) {
        scopeStack.push((currentScope = {}))
        walkScope(node)
        <span class="org-keyword">return</span>
      }

      <span class="org-comment-delimiter">// </span><span class=
"org-comment">skip type nodes</span>
      <span class="org-keyword">if</span> (
        parent &amp;&
        parent.type.startsWith(<span class=
"org-string">'TS'</span>) &amp;&
        parent.type !== <span class=
"org-string">'TSAsExpression'</span> &amp;&
        parent.type !== <span class=
"org-string">'TSNonNullExpression'</span> &amp;&
        parent.type !== <span class=
"org-string">'TSTypeAssertion'</span>
      ) {
        <span class="org-keyword">return</span> <span class=
"org-constant">this</span>.skip()
      }

      <span class="org-keyword">if</span> (
        node.type === <span class=
"org-string">'Identifier'</span> &amp;&
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">if inside $$(), skip unless this is a destructured prop binding</span>
        !(escapeScope &amp;& rootScope[node.name] !== <span class=
"org-string">'prop'</span>) &amp;&
        isReferencedIdentifier(node, parent, parentStack) &amp;&
        !excludedIds.has(node)
      ) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">walk up the scope chain to check if id should be appended .value</span>
        <span class="org-keyword">let</span> <span class=
"org-variable-name">i</span> = scopeStack.length
        <span class="org-keyword">while</span> (i--) {
          <span class=
"org-keyword">if</span> (rewriteId(scopeStack[i], node, parent, parentStack)) {
            <span class="org-keyword">return</span>
          }
        }
      }

      <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'CallExpression'</span> &amp;& node.callee.type === <span class="org-string">'Identifier'</span>) {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">callee</span> = node.callee.name

        <span class="org-keyword">const</span> <span class=
"org-variable-name">refCall</span> = isRefCreationCall(callee)
        <span class=
"org-keyword">if</span> (refCall &amp;& (!parent || parent.type !== <span class="org-string">'VariableDeclarator'</span>)) {
          <span class="org-keyword">return</span> error(
            <span class=
"org-string">`${refCall} can only be used as the initializer of `</span> +
              <span class=
"org-string">`a variable declaration.`</span>,
            node
          )
        }

        <span class=
"org-keyword">if</span> (callee === escapeSymbol) {
          s.remove(node.callee.start + offset, node.callee.end + offset)
          escapeScope = node
        }

        <span class="org-comment-delimiter">// </span><span class=
"org-comment"><span class="org-bold"><span class=
"org-warning">TODO</span></span></span><span class=
"org-comment"> remove when out of experimental</span>
        <span class=
"org-keyword">if</span> (callee === <span class="org-string">'$raw'</span>) {
          error(
            <span class=
"org-string">`$raw() has been replaced by $$(). `</span> +
              <span class=
"org-string">`See ${RFC_LINK} for latest updates.`</span>,
            node
          )
        }
        <span class=
"org-keyword">if</span> (callee === <span class="org-string">'$fromRef'</span>) {
          error(
            <span class=
"org-string">`$fromRef() has been replaced by $(). `</span> +
              <span class=
"org-string">`See ${RFC_LINK} for latest updates.`</span>,
            node
          )
        }
      }
    },
    leave(node, parent) {
      parent &amp;& parentStack.pop()
      <span class="org-keyword">if</span> (
        (node.type === <span class=
"org-string">'BlockStatement'</span> &amp;& !isFunctionType(parent)) ||
        isFunctionType(node)
      ) {
        scopeStack.pop()
        currentScope = scopeStack[scopeStack.length - <span class=
"org-highlight-numbers-number">1</span>] || <span class=
"org-constant">null</span>
      }
      <span class="org-keyword">if</span> (node === escapeScope) {
        escapeScope = <span class="org-constant">undefined</span>
      }
    }
  })

  <span class="org-keyword">return</span> {
    rootRefs: Object.keys(rootScope).filter(key =&gt; rootScope[key] === <span class="org-constant">true</span>),
    importedHelpers: [...importedHelpers]
  }
}

  <span class=
"org-keyword">return</span> { transformAST, transform, shouldTransform }
}())

<span class="org-keyword">const</span> <span class=
"org-variable-name">range</span> = <span class=
"org-highlight-numbers-number">2</span>

<span class="org-keyword">function</span> <span class=
"org-function-name">generateCodeFrame</span>(
  <span class="org-variable-name">source</span>,
  start = <span class="org-highlight-numbers-number">0</span>,
  end = source.length
) {
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">Split the content into individual lines but capture the newline sequence</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">that separated each line. This is important because the actual sequence is</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">needed to properly take into account the full line length for offset</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">comparison</span>
  <span class="org-keyword">let</span> <span class=
"org-variable-name">lines</span> = source.split(<span class=
"org-string">/(\r?\n)/</span>)

  <span class="org-comment-delimiter">// </span><span class=
"org-comment">Separate the lines and newline sequences into separate arrays for easier referencing</span>
  <span class="org-keyword">const</span> <span class=
"org-variable-name">newlineSequences</span> = lines.filter((_, idx) =&gt; idx % <span class="org-highlight-numbers-number">2</span> === <span class="org-highlight-numbers-number">1</span>)
  lines = lines.filter((_, idx) =&gt; idx % <span class=
"org-highlight-numbers-number">2</span> === <span class=
"org-highlight-numbers-number">0</span>)

  <span class="org-keyword">let</span> <span class=
"org-variable-name">count</span> = <span class=
"org-highlight-numbers-number">0</span>
  <span class="org-keyword">const</span> <span class=
"org-variable-name">res</span> = []
  <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; lines.length; i++) {
    count +=
      lines[i].length +
      ((newlineSequences[i] &amp;& newlineSequences[i].length) || <span class="org-highlight-numbers-number">0</span>)
    <span class="org-keyword">if</span> (count &gt;= start) {
      <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">j</span> = i - range; j &lt;= i + range || end &gt; count; j++) {
        <span class="org-keyword">if</span> (j &lt; <span class=
"org-highlight-numbers-number">0</span> || j &gt;= lines.length) <span class="org-keyword">continue</span>
        <span class="org-keyword">const</span> <span class=
"org-variable-name">line</span> = j + <span class=
"org-highlight-numbers-number">1</span>
        res.push(
          <span class=
"org-string">`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${</span>
<span class="org-string">            lines[j]</span>
<span class="org-string">          }`</span>
        )
        <span class="org-keyword">const</span> <span class=
"org-variable-name">lineLength</span> = lines[j].length
        <span class="org-keyword">const</span> <span class=
"org-variable-name">newLineSeqLength</span> =
          (newlineSequences[j] &amp;& newlineSequences[j].length) || <span class="org-highlight-numbers-number">0</span>

        <span class="org-keyword">if</span> (j === i) {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">push underline</span>
          <span class="org-keyword">const</span> <span class=
"org-variable-name">pad</span> = start - (count - (lineLength + newLineSeqLength))
          <span class="org-keyword">const</span> <span class=
"org-variable-name">length</span> = Math.max(
            <span class="org-highlight-numbers-number">1</span>,
            end &gt; count ? lineLength - pad : end - start
          )
          res.push(<span class=
"org-string">`   |  `</span> + <span class=
"org-string">' '</span>.repeat(pad) + <span class=
"org-string">'^'</span>.repeat(length))
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (j &gt; i) {
          <span class="org-keyword">if</span> (end &gt; count) {
            <span class="org-keyword">const</span> <span class=
"org-variable-name">length</span> = Math.max(Math.min(end - count, lineLength), <span class="org-highlight-numbers-number">1</span>)
            res.push(<span class=
"org-string">`   |  `</span> + <span class=
"org-string">'^'</span>.repeat(length))
          }

          count += lineLength + newLineSeqLength
        }
      }
      <span class="org-keyword">break</span>
    }
  }
  <span class="org-keyword">return</span> res.join(<span class=
"org-string">'\n'</span>)
}

<span class="org-keyword">function</span> <span class=
"org-function-name">registerBinding</span>(<span class=
"org-variable-name">bindings</span>, <span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">type</span>) {
  bindings[node.name] = type
}
<span class="org-keyword">function</span> <span class=
"org-function-name">walkDeclaration</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">bindings</span>, <span class=
"org-variable-name">userImportAlias</span>) {
  <span class="org-keyword">if</span> (node.type === <span class=
"org-string">'VariableDeclaration'</span>) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">isConst</span> = node.kind === <span class=
"org-string">'const'</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">export const foo = ...</span>
    <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> { id, init } <span class=
"org-keyword">of</span> node.declarations) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">isDefineCall</span> = !!(
        isConst &amp;&
        isCallOf(
          init,
          c =&gt; c === DEFINE_PROPS || c === DEFINE_EMITS || c === WITH_DEFAULTS
        )
      )
      <span class="org-keyword">if</span> (id.type === <span class=
"org-string">'Identifier'</span>) {
        <span class="org-keyword">let</span> <span class=
"org-variable-name">bindingType</span>
        <span class="org-keyword">const</span> <span class=
"org-variable-name">userReactiveBinding</span> = userImportAlias[<span class="org-string">'reactive'</span>] || <span class="org-string">'reactive'</span>
        <span class=
"org-keyword">if</span> (isCallOf(init, userReactiveBinding)) {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">treat reactive() calls as let since it's meant to be mutable</span>
          bindingType = BindingTypes.SETUP_LET
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">if a declaration is a const literal, we can mark it so that</span>
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">the generated render fn code doesn't need to unref() it</span>
          isDefineCall ||
          (isConst &amp;& canNeverBeRef(init, userReactiveBinding))
        ) {
          bindingType = BindingTypes.SETUP_CONST
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (isConst) {
          <span class=
"org-keyword">if</span> (isCallOf(init, userImportAlias[<span class="org-string">'ref'</span>] || <span class="org-string">'ref'</span>)) {
            bindingType = BindingTypes.SETUP_REF
          } <span class="org-keyword">else</span> {
            bindingType = BindingTypes.SETUP_MAYBE_REF
          }
        } <span class="org-keyword">else</span> {
          bindingType = BindingTypes.SETUP_LET
        }
        registerBinding(bindings, id, bindingType)
      } <span class="org-keyword">else</span> {
        <span class=
"org-keyword">if</span> (isCallOf(init, DEFINE_PROPS)) {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">skip walking props destructure</span>
          <span class="org-keyword">return</span>
        }
        <span class=
"org-keyword">if</span> (id.type === <span class=
"org-string">'ObjectPattern'</span>) {
          walkObjectPattern(id, bindings, isConst, isDefineCall)
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (id.type === <span class=
"org-string">'ArrayPattern'</span>) {
          walkArrayPattern(id, bindings, isConst, isDefineCall)
        }
      }
    }
  } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (
    node.type === <span class=
"org-string">'TSEnumDeclaration'</span> ||
    node.type === <span class=
"org-string">'FunctionDeclaration'</span> ||
    node.type === <span class=
"org-string">'ClassDeclaration'</span>
  ) {
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">export function foo() {} / export class Foo {}</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">export declarations must be named.</span>
    bindings[node.id.name] = BindingTypes.SETUP_CONST
  }
}

<span class="org-keyword">function</span> <span class=
"org-function-name">walkObjectPattern</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">bindings</span>, <span class=
"org-variable-name">isConst</span>, <span class=
"org-variable-name">isDefineCall</span> = <span class=
"org-constant">false</span>) {
  <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">p</span> <span class=
"org-keyword">of</span> node.properties) {
    <span class="org-keyword">if</span> (p.type === <span class=
"org-string">'ObjectProperty'</span>) {
      <span class=
"org-keyword">if</span> (p.key.type === <span class=
"org-string">'Identifier'</span> &amp;& p.key === p.value) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">shorthand: const { x } = ...</span>
        <span class="org-keyword">const</span> <span class=
"org-variable-name">type</span> = isDefineCall
          ? BindingTypes.SETUP_CONST
          : isConst
          ? BindingTypes.SETUP_MAYBE_REF
          : BindingTypes.SETUP_LET
        registerBinding(bindings, p.key, type)
      } <span class="org-keyword">else</span> {
        walkPattern(p.value, bindings, isConst, isDefineCall)
      }
    } <span class="org-keyword">else</span> {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">...rest</span>
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">argument can only be identifier when destructuring</span>
      <span class="org-keyword">const</span> <span class=
"org-variable-name">type</span> = isConst ? BindingTypes.SETUP_CONST : BindingTypes.SETUP_LET
      registerBinding(bindings, p.argument, type)
    }
  }
}


<span class="org-keyword">function</span> <span class=
"org-function-name">walkArrayPattern</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">bindings</span>, <span class=
"org-variable-name">isConst</span>, <span class=
"org-variable-name">isDefineCall</span> = <span class=
"org-constant">false</span>) {
  <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">e</span> <span class=
"org-keyword">of</span> node.elements) {
    e &amp;& walkPattern(e, bindings, isConst, isDefineCall)
  }
}
<span class="org-keyword">function</span> <span class=
"org-function-name">walkPattern</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">bindings</span>, <span class=
"org-variable-name">isConst</span>, <span class=
"org-variable-name">isDefineCall</span> = <span class=
"org-constant">false</span>) {
  <span class="org-keyword">if</span> (node.type === <span class=
"org-string">'Identifier'</span>) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">type</span> = isDefineCall
      ? BindingTypes.SETUP_CONST
      : isConst
      ? BindingTypes.SETUP_MAYBE_REF
      : BindingTypes.SETUP_LET
    registerBinding(bindings, node, type)
  } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'RestElement'</span>) {
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">argument can only be identifier when destructuring</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">type</span> = isConst ? BindingTypes.SETUP_CONST : BindingTypes.SETUP_LET
    registerBinding(bindings, node.argument, type)
  } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'ObjectPattern'</span>) {
    walkObjectPattern(node, bindings, isConst)
  } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'ArrayPattern'</span>) {
    walkArrayPattern(node, bindings, isConst)
  } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'AssignmentPattern'</span>) {
    <span class=
"org-keyword">if</span> (node.left.type === <span class=
"org-string">'Identifier'</span>) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">type</span> = isDefineCall
        ? BindingTypes.SETUP_CONST
        : isConst
        ? BindingTypes.SETUP_MAYBE_REF
        : BindingTypes.SETUP_LET
      registerBinding(bindings, node.left, type)
    } <span class="org-keyword">else</span> {
      walkPattern(node.left, bindings, isConst)
    }
  }
}
<span class="org-keyword">function</span> <span class=
"org-function-name">recordType</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">declaredTypes</span>) {
  <span class="org-keyword">if</span> (node.type === <span class=
"org-string">'TSInterfaceDeclaration'</span>) {
    declaredTypes[node.id.name] = [<span class=
"org-string">`Object`</span>]
  } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'TSTypeAliasDeclaration'</span>) {
    declaredTypes[node.id.name] = inferRuntimeType(
      node.typeAnnotation,
      declaredTypes
    )
  } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'ExportNamedDeclaration'</span> &amp;& node.declaration) {
    recordType(node.declaration, declaredTypes)
  }
}
<span class="org-keyword">function</span> <span class=
"org-function-name">extractRuntimeProps</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">props</span>, <span class=
"org-variable-name">declaredTypes</span>, <span class=
"org-variable-name">isProd</span>) {
  <span class="org-keyword">const</span> <span class=
"org-variable-name">members</span> = node.type === <span class=
"org-string">'TSTypeLiteral'</span> ? node.members : node.body
  <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">m</span> <span class=
"org-keyword">of</span> members) {
    <span class="org-keyword">if</span> (
      (m.type === <span class=
"org-string">'TSPropertySignature'</span> || m.type === <span class="org-string">'TSMethodSignature'</span>) &amp;&
      m.key.type === <span class="org-string">'Identifier'</span>
    ) {
      <span class="org-keyword">let</span> <span class=
"org-variable-name">type</span>
      <span class="org-keyword">if</span> (m.type === <span class=
"org-string">'TSMethodSignature'</span>) {
        type = [<span class="org-string">'Function'</span>]
      } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (m.typeAnnotation) {
        type = inferRuntimeType(m.typeAnnotation.typeAnnotation, declaredTypes)
      }
      props[m.key.name] = {
        key: m.key.name,
        required: !m.optional,
        type: type || [<span class="org-string">`null`</span>]
      }
    }
  }
}


<span class="org-keyword">function</span> <span class=
"org-function-name">inferRuntimeType</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">declaredTypes</span>) {
  <span class="org-keyword">switch</span> (node.type) {
    <span class="org-keyword">case</span> <span class=
"org-string">'TSStringKeyword'</span>:
      <span class="org-keyword">return</span> [<span class=
"org-string">'String'</span>]
    <span class="org-keyword">case</span> <span class=
"org-string">'TSNumberKeyword'</span>:
      <span class="org-keyword">return</span> [<span class=
"org-string">'Number'</span>]
    <span class="org-keyword">case</span> <span class=
"org-string">'TSBooleanKeyword'</span>:
      <span class="org-keyword">return</span> [<span class=
"org-string">'Boolean'</span>]
    <span class="org-keyword">case</span> <span class=
"org-string">'TSObjectKeyword'</span>:
      <span class="org-keyword">return</span> [<span class=
"org-string">'Object'</span>]
    <span class="org-keyword">case</span> <span class=
"org-string">'TSTypeLiteral'</span>:
      <span class="org-comment-delimiter">// </span><span class=
"org-comment"><span class="org-bold"><span class=
"org-warning">TODO</span></span></span><span class=
"org-comment"> (nice to have) generate runtime property validation</span>
      <span class="org-keyword">return</span> [<span class=
"org-string">'Object'</span>]
    <span class="org-keyword">case</span> <span class=
"org-string">'TSFunctionType'</span>:
      <span class="org-keyword">return</span> [<span class=
"org-string">'Function'</span>]
    <span class="org-keyword">case</span> <span class=
"org-string">'TSArrayType'</span>:
    <span class="org-keyword">case</span> <span class=
"org-string">'TSTupleType'</span>:
      <span class="org-comment-delimiter">// </span><span class=
"org-comment"><span class="org-bold"><span class=
"org-warning">TODO</span></span></span><span class=
"org-comment"> (nice to have) generate runtime element type/length checks</span>
      <span class="org-keyword">return</span> [<span class=
"org-string">'Array'</span>]

    <span class="org-keyword">case</span> <span class=
"org-string">'TSLiteralType'</span>:
      <span class="org-keyword">switch</span> (node.literal.type) {
        <span class="org-keyword">case</span> <span class=
"org-string">'StringLiteral'</span>:
          <span class="org-keyword">return</span> [<span class=
"org-string">'String'</span>]
        <span class="org-keyword">case</span> <span class=
"org-string">'BooleanLiteral'</span>:
          <span class="org-keyword">return</span> [<span class=
"org-string">'Boolean'</span>]
        <span class="org-keyword">case</span> <span class=
"org-string">'NumericLiteral'</span>:
        <span class="org-keyword">case</span> <span class=
"org-string">'BigIntLiteral'</span>:
          <span class="org-keyword">return</span> [<span class=
"org-string">'Number'</span>]
        <span class="org-keyword">default</span>:
          <span class="org-keyword">return</span> [<span class=
"org-string">`null`</span>]
      }

    <span class="org-keyword">case</span> <span class=
"org-string">'TSTypeReference'</span>:
      <span class=
"org-keyword">if</span> (node.typeName.type === <span class=
"org-string">'Identifier'</span>) {
        <span class=
"org-keyword">if</span> (declaredTypes[node.typeName.name]) {
          <span class=
"org-keyword">return</span> declaredTypes[node.typeName.name]
        }
        <span class=
"org-keyword">switch</span> (node.typeName.name) {
          <span class="org-keyword">case</span> <span class=
"org-string">'Array'</span>:
          <span class="org-keyword">case</span> <span class=
"org-string">'Function'</span>:
          <span class="org-keyword">case</span> <span class=
"org-string">'Object'</span>:
          <span class="org-keyword">case</span> <span class=
"org-string">'Set'</span>:
          <span class="org-keyword">case</span> <span class=
"org-string">'Map'</span>:
          <span class="org-keyword">case</span> <span class=
"org-string">'WeakSet'</span>:
          <span class="org-keyword">case</span> <span class=
"org-string">'WeakMap'</span>:
          <span class="org-keyword">case</span> <span class=
"org-string">'Date'</span>:
            <span class=
"org-keyword">return</span> [node.typeName.name]
          <span class="org-keyword">case</span> <span class=
"org-string">'Record'</span>:
          <span class="org-keyword">case</span> <span class=
"org-string">'Partial'</span>:
          <span class="org-keyword">case</span> <span class=
"org-string">'Readonly'</span>:
          <span class="org-keyword">case</span> <span class=
"org-string">'Pick'</span>:
          <span class="org-keyword">case</span> <span class=
"org-string">'Omit'</span>:
          <span class="org-keyword">case</span> <span class=
"org-string">'Exclude'</span>:
          <span class="org-keyword">case</span> <span class=
"org-string">'Extract'</span>:
          <span class="org-keyword">case</span> <span class=
"org-string">'Required'</span>:
          <span class="org-keyword">case</span> <span class=
"org-string">'InstanceType'</span>:
            <span class="org-keyword">return</span> [<span class=
"org-string">'Object'</span>]
        }
      }
      <span class="org-keyword">return</span> [<span class=
"org-string">`null`</span>]

    <span class="org-keyword">case</span> <span class=
"org-string">'TSParenthesizedType'</span>:
      <span class=
"org-keyword">return</span> inferRuntimeType(node.typeAnnotation, declaredTypes)
    <span class="org-keyword">case</span> <span class=
"org-string">'TSUnionType'</span>:
      <span class="org-keyword">return</span> [
        ...<span class="org-keyword">new</span> <span class=
"org-type">Set</span>(
          [].concat(
            ...(node.types.map(t =&gt; inferRuntimeType(t, declaredTypes)))
          )
        )
      ]
    <span class="org-keyword">case</span> <span class=
"org-string">'TSIntersectionType'</span>:
      <span class="org-keyword">return</span> [<span class=
"org-string">'Object'</span>]

    <span class="org-keyword">case</span> <span class=
"org-string">'TSSymbolKeyword'</span>:
      <span class="org-keyword">return</span> [<span class=
"org-string">'Symbol'</span>]

    <span class="org-keyword">default</span>:
      <span class="org-keyword">return</span> [<span class=
"org-string">`null`</span>] <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no runtime check</span>
  }
}
<span class="org-keyword">function</span> <span class=
"org-function-name">toRuntimeTypeString</span>(<span class=
"org-variable-name">types</span>) {
  <span class=
"org-keyword">return</span> types.length &gt; <span class=
"org-highlight-numbers-number">1</span> ? <span class=
"org-string">`[${types.join(', ')}]`</span> : types[<span class=
"org-highlight-numbers-number">0</span>]
}
<span class="org-keyword">function</span> <span class=
"org-function-name">extractRuntimeEmits</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">emits</span>) {
  <span class="org-keyword">if</span> (node.type === <span class=
"org-string">'TSTypeLiteral'</span> || node.type === <span class=
"org-string">'TSInterfaceBody'</span>) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">members</span> = node.type === <span class=
"org-string">'TSTypeLiteral'</span> ? node.members : node.body
    <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">t</span> <span class=
"org-keyword">of</span> members) {
      <span class="org-keyword">if</span> (t.type === <span class=
"org-string">'TSCallSignatureDeclaration'</span>) {
        extractEventNames(t.parameters[<span class=
"org-highlight-numbers-number">0</span>], emits)
      }
    }
    <span class="org-keyword">return</span>
  } <span class="org-keyword">else</span> {
    extractEventNames(node.parameters[<span class=
"org-highlight-numbers-number">0</span>], emits)
  }
}
<span class="org-keyword">function</span> <span class=
"org-function-name">extractEventNames</span>(<span class=
"org-variable-name">eventName</span>, <span class=
"org-variable-name">emits</span>) {
  <span class="org-keyword">if</span> (
    eventName.type === <span class=
"org-string">'Identifier'</span> &amp;&
    eventName.typeAnnotation &amp;&
    eventName.typeAnnotation.type === <span class=
"org-string">'TSTypeAnnotation'</span>
  ) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">typeNode</span> = eventName.typeAnnotation.typeAnnotation
    <span class=
"org-keyword">if</span> (typeNode.type === <span class=
"org-string">'TSLiteralType'</span>) {
      <span class=
"org-keyword">if</span> (typeNode.literal.type !== <span class=
"org-string">'UnaryExpression'</span>) {
        emits.add(String(typeNode.literal.value))
      }
    } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (typeNode.type === <span class=
"org-string">'TSUnionType'</span>) {
      <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">t</span> <span class=
"org-keyword">of</span> typeNode.types) {
        <span class="org-keyword">if</span> (
          t.type === <span class=
"org-string">'TSLiteralType'</span> &amp;&
          t.literal.type !== <span class=
"org-string">'UnaryExpression'</span>
        ) {
          emits.add(String(t.literal.value))
        }
      }
    }
  }
}
<span class="org-keyword">function</span> <span class=
"org-function-name">genRuntimeEmits</span>(<span class=
"org-variable-name">emits</span>) {
  <span class="org-keyword">return</span> emits.size
    ? <span class=
"org-string">`\n  emits: [${Array.from(emits)</span>
<span class=
"org-string">        .map(p =&gt; JSON.stringify(p))</span>
<span class="org-string">        .join(', ')}],`</span>
    : <span class="org-string">``</span>
}
<span class="org-keyword">function</span> <span class=
"org-function-name">isCallOf</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">test</span>) {
  <span class="org-keyword">return</span> !!(
    node &amp;&
    node.type === <span class=
"org-string">'CallExpression'</span> &amp;&
    node.callee.type === <span class=
"org-string">'Identifier'</span> &amp;&
    (<span class="org-keyword">typeof</span> test === <span class=
"org-string">'string'</span>
      ? node.callee.name === test
      : test(node.callee.name))
  )
}
<span class="org-keyword">function</span> <span class=
"org-function-name">canNeverBeRef</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">userReactiveImport</span>) {
  <span class=
"org-keyword">if</span> (isCallOf(node, userReactiveImport)) {
    <span class="org-keyword">return</span> <span class=
"org-constant">true</span>
  }
  <span class="org-keyword">switch</span> (node.type) {
    <span class="org-keyword">case</span> <span class=
"org-string">'UnaryExpression'</span>:
    <span class="org-keyword">case</span> <span class=
"org-string">'BinaryExpression'</span>:
    <span class="org-keyword">case</span> <span class=
"org-string">'ArrayExpression'</span>:
    <span class="org-keyword">case</span> <span class=
"org-string">'ObjectExpression'</span>:
    <span class="org-keyword">case</span> <span class=
"org-string">'FunctionExpression'</span>:
    <span class="org-keyword">case</span> <span class=
"org-string">'ArrowFunctionExpression'</span>:
    <span class="org-keyword">case</span> <span class=
"org-string">'UpdateExpression'</span>:
    <span class="org-keyword">case</span> <span class=
"org-string">'ClassExpression'</span>:
    <span class="org-keyword">case</span> <span class=
"org-string">'TaggedTemplateExpression'</span>:
      <span class="org-keyword">return</span> <span class=
"org-constant">true</span>
    <span class="org-keyword">case</span> <span class=
"org-string">'SequenceExpression'</span>:
      <span class="org-keyword">return</span> canNeverBeRef(
        node.expressions[node.expressions.length - <span class=
"org-highlight-numbers-number">1</span>],
        userReactiveImport
      )
    <span class="org-keyword">default</span>:
      <span class=
"org-keyword">if</span> (node.type.endsWith(<span class=
"org-string">'Literal'</span>)) {
        <span class="org-keyword">return</span> <span class=
"org-constant">true</span>
      }
      <span class="org-keyword">return</span> <span class=
"org-constant">false</span>
  }
}


<span class="org-doc">/**</span>
<span class=
"org-doc"> * Analyze bindings in normal `&lt;script&gt;`</span>
<span class=
"org-doc"> * Note that `compileScriptSetup` already analyzes bindings as part of its</span>
<span class=
"org-doc"> * compilation process so this should only be used on single `&lt;script&gt;` SFCs.</span>
<span class="org-doc"> */</span>
<span class="org-keyword">function</span> <span class=
"org-function-name">analyzeScriptBindings</span>(<span class=
"org-variable-name">ast</span>) {
  <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">node</span> <span class=
"org-keyword">of</span> ast) {
    <span class="org-keyword">if</span> (
      node.type === <span class=
"org-string">'ExportDefaultDeclaration'</span> &amp;&
      node.declaration.type === <span class=
"org-string">'ObjectExpression'</span>
    ) {
      <span class=
"org-keyword">return</span> analyzeBindingsFromOptions(node.declaration)
    }
  }
  <span class="org-keyword">return</span> {}
}
<span class="org-keyword">function</span> <span class=
"org-function-name">analyzeBindingsFromOptions</span>(<span class=
"org-variable-name">node</span>) {
  <span class="org-keyword">const</span> <span class=
"org-variable-name">bindings</span> = {}
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">#3270, #3275</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">mark non-script-setup so we don't resolve components/directives from these</span>
  Object.defineProperty(bindings, <span class=
"org-string">'__isScriptSetup'</span>, {
    enumerable: <span class="org-constant">false</span>,
    value: <span class="org-constant">false</span>
  })
  <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">property</span> <span class=
"org-keyword">of</span> node.properties) {
    <span class="org-keyword">if</span> (
      property.type === <span class=
"org-string">'ObjectProperty'</span> &amp;&
      !property.computed &amp;&
      property.key.type === <span class=
"org-string">'Identifier'</span>
    ) {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">props</span>
      <span class=
"org-keyword">if</span> (property.key.name === <span class=
"org-string">'props'</span>) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">props: ['foo']</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">props: { foo: ... }</span>
        <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">of</span> getObjectOrArrayExpressionKeys(property.value)) {
          bindings[key] = BindingTypes.PROPS
        }
      }

      <span class="org-comment-delimiter">// </span><span class=
"org-comment">inject</span>
      <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (property.key.name === <span class=
"org-string">'inject'</span>) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">inject: ['foo']</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">inject: { foo: {} }</span>
        <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">of</span> getObjectOrArrayExpressionKeys(property.value)) {
          bindings[key] = BindingTypes.OPTIONS
        }
      }

      <span class="org-comment-delimiter">// </span><span class=
"org-comment">computed & methods</span>
      <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (
        property.value.type === <span class=
"org-string">'ObjectExpression'</span> &amp;&
        (property.key.name === <span class=
"org-string">'computed'</span> || property.key.name === <span class="org-string">'methods'</span>)
      ) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">methods: { foo() {} }</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">computed: { foo() {} }</span>
        <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">of</span> getObjectExpressionKeys(property.value)) {
          bindings[key] = BindingTypes.OPTIONS
        }
      }
    }

    <span class="org-comment-delimiter">// </span><span class=
"org-comment">setup & data</span>
    <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (
      property.type === <span class=
"org-string">'ObjectMethod'</span> &amp;&
      property.key.type === <span class=
"org-string">'Identifier'</span> &amp;&
      (property.key.name === <span class=
"org-string">'setup'</span> || property.key.name === <span class=
"org-string">'data'</span>)
    ) {
      <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">bodyItem</span> <span class=
"org-keyword">of</span> property.body.body) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">setup() {</span>
        <span class=
"org-comment-delimiter">//   </span><span class="org-comment">return {</span>
        <span class=
"org-comment-delimiter">//     </span><span class=
"org-comment">foo: null</span>
        <span class=
"org-comment-delimiter">//   </span><span class="org-comment">}</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">}</span>
        <span class="org-keyword">if</span> (
          bodyItem.type === <span class=
"org-string">'ReturnStatement'</span> &amp;&
          bodyItem.argument &amp;&
          bodyItem.argument.type === <span class=
"org-string">'ObjectExpression'</span>
        ) {
          <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">of</span> getObjectExpressionKeys(bodyItem.argument)) {
            bindings[key] =
              property.key.name === <span class=
"org-string">'setup'</span>
                ? BindingTypes.SETUP_MAYBE_REF
                : BindingTypes.DATA
          }
        }
      }
    }
  }

  <span class="org-keyword">return</span> bindings
}
<span class="org-keyword">function</span> <span class=
"org-function-name">getObjectExpressionKeys</span>(<span class=
"org-variable-name">node</span>) {
  <span class="org-keyword">const</span> <span class=
"org-variable-name">keys</span> = []
  <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">prop</span> <span class=
"org-keyword">of</span> node.properties) {
    <span class="org-keyword">if</span> (
      (prop.type === <span class=
"org-string">'ObjectProperty'</span> || prop.type === <span class=
"org-string">'ObjectMethod'</span>) &amp;&
      !prop.computed
    ) {
      <span class=
"org-keyword">if</span> (prop.key.type === <span class=
"org-string">'Identifier'</span>) {
        keys.push(prop.key.name)
      } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (prop.key.type === <span class=
"org-string">'StringLiteral'</span>) {
        keys.push(prop.key.value)
      }
    }
  }
  <span class="org-keyword">return</span> keys
}
<span class="org-keyword">function</span> <span class=
"org-function-name">getArrayExpressionKeys</span>(<span class=
"org-variable-name">node</span>) {
  <span class="org-keyword">const</span> <span class=
"org-variable-name">keys</span> = []
  <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">element</span> <span class=
"org-keyword">of</span> node.elements) {
    <span class=
"org-keyword">if</span> (element &amp;& element.type === <span class="org-string">'StringLiteral'</span>) {
      keys.push(element.value)
    }
  }
  <span class="org-keyword">return</span> keys
}
<span class="org-keyword">function</span> <span class=
"org-function-name">getObjectOrArrayExpressionKeys</span>(<span class="org-variable-name">value</span>) {
  <span class="org-keyword">if</span> (value.type === <span class=
"org-string">'ArrayExpression'</span>) {
    <span class=
"org-keyword">return</span> getArrayExpressionKeys(value)
  }
  <span class="org-keyword">if</span> (value.type === <span class=
"org-string">'ObjectExpression'</span>) {
    <span class=
"org-keyword">return</span> getObjectExpressionKeys(value)
  }
  <span class="org-keyword">return</span> []
}
<span class="org-keyword">function</span> <span class=
"org-function-name">resolveTemplateUsageCheckString</span>(<span class="org-variable-name">sfc</span>) {
  <span class=
"org-keyword">const</span> { content, ast } = sfc.template
  <span class="org-keyword">const</span> <span class=
"org-variable-name">cached</span> = templateUsageCheckCache.get(content)
  <span class="org-keyword">if</span> (cached) {
    <span class="org-keyword">return</span> cached
  }

  <span class="org-keyword">let</span> <span class=
"org-variable-name">code</span> = <span class=
"org-string">''</span>
  transform(createRoot([ast]), {
    nodeTransforms: [
      node =&gt; {
        <span class=
"org-keyword">if</span> (node.type === NodeTypes.ELEMENT) {
          <span class="org-keyword">if</span> (
            !parserOptions.isNativeTag(node.tag) &amp;&
            !parserOptions.isBuiltInComponent(node.tag)
          ) {
            code += <span class=
"org-string">`,${camelize(node.tag)},${capitalize(camelize(node.tag))}`</span>
          }
          <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; node.props.length; i++) {
            <span class="org-keyword">const</span> <span class=
"org-variable-name">prop</span> = node.props[i]
            <span class=
"org-keyword">if</span> (prop.type === NodeTypes.DIRECTIVE) {
              <span class=
"org-keyword">if</span> (!isBuiltInDir(prop.name)) {
                code += <span class=
"org-string">`,v${capitalize(camelize(prop.name))}`</span>
              }
              <span class="org-keyword">if</span> (prop.exp) {
                code += <span class=
"org-string">`,${stripStrings(prop.exp.content)}`</span>
              }
            }
          }
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (node.type === NodeTypes.INTERPOLATION) {
          code += <span class=
"org-string">`,${stripStrings(node.content.content)}`</span>
        }
      }
    ]
  })

  code += <span class="org-string">';'</span>
  templateUsageCheckCache.set(content, code)
  <span class="org-keyword">return</span> code
}
<span class="org-keyword">function</span> <span class=
"org-function-name">stripStrings</span>(<span class=
"org-variable-name">exp</span>) {
  <span class="org-keyword">return</span> exp
    .replace(<span class=
"org-string">/'[^']*'|"[^"]*"/</span>g, <span class=
"org-string">''</span>)
    .replace(<span class=
"org-string">/`[^`]+`/</span>g, stripTemplateString)
}
<span class="org-keyword">function</span> <span class=
"org-function-name">isImportUsed</span>(<span class=
"org-variable-name">local</span>, <span class=
"org-variable-name">sfc</span>) {
  <span class="org-keyword">return</span> <span class=
"org-keyword">new</span> <span class="org-type">RegExp</span>(
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">#4274 escape $ since it's a special char in regex</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">(and is the only regex special char that is valid in identifiers)</span>
    <span class=
"org-string">`[^\\w$_]${local.replace(/\$/g, '\\$')}[^\\w$_]`</span>
  ).test(resolveTemplateUsageCheckString(sfc))
}
<span class="org-doc">/**</span>
<span class=
"org-doc"> * Note: this comparison assumes the prev/next script are already identical,</span>
<span class=
"org-doc"> * and only checks the special case where &lt;script setup lang="ts"&gt; unused import</span>
<span class=
"org-doc"> * pruning result changes due to template changes.</span>
<span class="org-doc"> */</span>
<span class="org-keyword">function</span> <span class=
"org-function-name">hmrShouldReload</span>(<span class=
"org-variable-name">prevImports</span>, <span class=
"org-variable-name">next</span>) {
  <span class="org-keyword">if</span> (
    !next.scriptSetup ||
    (next.scriptSetup.lang !== <span class=
"org-string">'ts'</span> &amp;& next.scriptSetup.lang !== <span class="org-string">'tsx'</span>)
  ) {
    <span class="org-keyword">return</span> <span class=
"org-constant">false</span>
  }

  <span class="org-comment-delimiter">// </span><span class=
"org-comment">for each previous import, check if its used status remain the same based on</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">the next descriptor's template</span>
  <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">in</span> prevImports) {
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">if an import was previous unused, but now is used, we need to force</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">reload so that the script now includes that import.</span>
    <span class=
"org-keyword">if</span> (!prevImports[key].isUsedInTemplate &amp;& isImportUsed(key, next)) {
      <span class="org-keyword">return</span> <span class=
"org-constant">true</span>
    }
  }

  <span class="org-keyword">return</span> <span class=
"org-constant">false</span>
}
<span class="org-keyword">function</span> <span class=
"org-function-name">compileTemplate</span>(<span class=
"org-variable-name">options</span>) {
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">...省略直接使用现有的 compile</span>

  <span class=
"org-keyword">return</span> doCompileTemplate(options)
}

<span class="org-keyword">function</span> <span class=
"org-function-name">doCompileTemplate</span>({
  filename,
  id,
  scoped,
  slotted,
  inMap,
  source,
  ssr = <span class="org-constant">false</span>,
  ssrCssVars,
  isProd = <span class="org-constant">false</span>,
  compiler,
  compilerOptions = {},
  transformAssetUrls
}) {
  <span class="org-keyword">const</span> <span class=
"org-variable-name">errors</span> = []
  <span class="org-keyword">const</span> <span class=
"org-variable-name">warnings</span> = []

  <span class="org-keyword">let</span> <span class=
"org-variable-name">nodeTransforms</span> = []
  <span class=
"org-keyword">if</span> (isObject(transformAssetUrls)) {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">assetOptions</span> = normalizeOptions(transformAssetUrls)
    nodeTransforms = [
      createAssetUrlTransformWithOptions(assetOptions),
      createSrcsetTransformWithOptions(assetOptions)
    ]
  } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (transformAssetUrls !== <span class=
"org-constant">false</span>) {
    nodeTransforms = [transformAssetUrl, transformSrcset]
  }

  <span class="org-keyword">if</span> (!id) {
    id = <span class="org-string">''</span>
  }

  <span class="org-keyword">const</span> <span class=
"org-variable-name">shortId</span> = id.replace(<span class=
"org-string">/^data-v-/</span>, <span class="org-string">''</span>)
  <span class="org-keyword">const</span> <span class=
"org-variable-name">longId</span> = <span class=
"org-string">`data-v-${shortId}`</span>

  <span class=
"org-keyword">let</span> { code, ast, preamble, map } = baseCompile(source, {
    mode: <span class="org-string">'module'</span>,
    prefixIdentifiers: <span class="org-constant">true</span>,
    hoistStatic: <span class="org-constant">true</span>,
    cacheHandlers: <span class="org-constant">true</span>,
    ssrCssVars:
      ssr &amp;& ssrCssVars &amp;& ssrCssVars.length
        ? genCssVarsFromList(ssrCssVars, shortId, isProd)
        : <span class="org-string">''</span>,
    scopeId: scoped ? longId : <span class=
"org-constant">undefined</span>,
    slotted,
    sourceMap: <span class="org-constant">true</span>,
    ...compilerOptions,
    nodeTransforms: nodeTransforms.concat(compilerOptions.nodeTransforms || []),
    filename,
    onError: e =&gt; errors.push(e),
    onWarn: w =&gt; warnings.push(w)
  })

  <span class=
"org-keyword">return</span> { code, ast, preamble, source, errors, tips, map }
}
<span class="org-keyword">const</span> <span class=
"org-variable-name">hash</span> = require(process.env.NODE_LIB + <span class="org-string">'/hash-sum'</span>)
<span class="org-keyword">const</span> <span class=
"org-variable-name">CSS_VARS_HELPER</span> = <span class=
"org-string">`useCssVars`</span>
<span class="org-comment-delimiter">// </span><span class=
"org-comment">match v-bind() with max 2-levels of nested parens.</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">cssVarRE</span> = <span class=
"org-string">/v-bind\s*\(((?:[^)(]+|\((?:[^)(]+|\([^)(]*\))*\))*)\)/</span>g

<span class="org-keyword">function</span> <span class=
"org-function-name">genCssVarsFromList</span>(
  <span class="org-variable-name">vars</span>,
  <span class="org-variable-name">id</span>,
  isProd
) {
  <span class="org-keyword">return</span> <span class=
"org-string">`{\n  ${vars</span>
<span class=
"org-string">    .map(key =&gt; `"${genVarName(id, key, isProd)}"</span>: (${key})<span class="org-string">`)</span>
<span class="org-string">    .join(',\n  ')}\n}`</span>
}

<span class="org-keyword">function</span> <span class=
"org-function-name">genVarName</span>(<span class=
"org-variable-name">id</span>, <span class=
"org-variable-name">raw</span>, <span class=
"org-variable-name">isProd</span>) {
  <span class="org-keyword">if</span> (isProd) {
    <span class="org-keyword">return</span> hash(id + raw)
  } <span class="org-keyword">else</span> {
    <span class="org-keyword">return</span> <span class=
"org-string">`${id}-${raw.replace(/([^\w-])/g, '_')}`</span>
  }
}

<span class="org-keyword">function</span> <span class=
"org-function-name">noramlizeExpression</span>(<span class=
"org-variable-name">exp</span>) {
  exp = exp.trim()
  <span class="org-keyword">if</span> (
    (exp[<span class=
"org-highlight-numbers-number">0</span>] === <span class=
"org-string">`'`</span> &amp;& exp[exp.length - <span class=
"org-highlight-numbers-number">1</span>] === <span class=
"org-string">`'`</span>) ||
    (exp[<span class=
"org-highlight-numbers-number">0</span>] === <span class=
"org-string">`"`</span> &amp;& exp[exp.length - <span class=
"org-highlight-numbers-number">1</span>] === <span class=
"org-string">`"`</span>)
  ) {
    <span class="org-keyword">return</span> exp.slice(<span class=
"org-highlight-numbers-number">1</span>, -<span class=
"org-highlight-numbers-number">1</span>)
  }
  <span class="org-keyword">return</span> exp
}

<span class="org-keyword">function</span> <span class=
"org-function-name">parseCssVars</span>(<span class=
"org-variable-name">sfc</span>) {
  <span class="org-keyword">const</span> <span class=
"org-variable-name">vars</span> = []
  sfc.styles.forEach(style =&gt; {
    <span class="org-keyword">let</span> <span class=
"org-variable-name">match</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">ignore v-bind() in comments /* ... */</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">content</span> = style.content.replace(<span class="org-string">/\/\*([\s\S]*?)\*\//</span>g, <span class="org-string">''</span>)
    <span class=
"org-keyword">while</span> ((match = cssVarRE.exec(content))) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">variable</span> = noramlizeExpression(match[<span class="org-highlight-numbers-number">1</span>])
      <span class=
"org-keyword">if</span> (!vars.includes(variable)) {
        vars.push(variable)
      }
    }
  })
  <span class="org-keyword">return</span> vars
}

<span class="org-comment-delimiter">// </span><span class=
"org-comment">for compileStyle</span>

<span class="org-keyword">const</span> <span class=
"org-variable-name">cssVarsPlugin</span> = opts =&gt; {
  <span class="org-keyword">const</span> { id, isProd } = opts
  <span class="org-keyword">return</span> {
    postcssPlugin: <span class="org-string">'vue-sfc-vars'</span>,
    Declaration(decl) {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">rewrite CSS variables</span>
      <span class=
"org-keyword">if</span> (cssVarRE.test(decl.value)) {
        decl.value = decl.value.replace(cssVarRE, (_, $1) =&gt; {
          <span class="org-keyword">return</span> <span class=
"org-string">`var(--${genVarName(id, noramlizeExpression($1), isProd)})`</span>
        })
      }
    }
  }
}
cssVarsPlugin.postcss = <span class="org-constant">true</span>

<span class="org-keyword">function</span> <span class=
"org-function-name">genCssVarsCode</span>(
  <span class="org-variable-name">vars</span>,
  <span class="org-variable-name">bindings</span>,
  <span class="org-variable-name">id</span>,
  isProd
) {
  <span class="org-keyword">const</span> <span class=
"org-variable-name">varsExp</span> = genCssVarsFromList(vars, id, isProd)
  <span class="org-keyword">const</span> <span class=
"org-variable-name">exp</span> = createSimpleExpression(varsExp, <span class="org-constant">false</span>)
  <span class="org-keyword">const</span> <span class=
"org-variable-name">context</span> = createTransformContext(createRoot([]), {
    prefixIdentifiers: <span class="org-constant">true</span>,
    inline: <span class="org-constant">true</span>,
    bindingMetadata: bindings.__isScriptSetup === <span class=
"org-constant">false</span> ? <span class=
"org-constant">undefined</span> : bindings
  })
  <span class="org-keyword">const</span> <span class=
"org-variable-name">transformed</span> = processExpression(exp, context)
  <span class="org-keyword">const</span> <span class=
"org-variable-name">transformedString</span> =
    transformed.type === NodeTypes.SIMPLE_EXPRESSION
      ? transformed.content
      : transformed.children
          .map(c =&gt; {
            <span class="org-keyword">return</span> <span class=
"org-keyword">typeof</span> c === <span class=
"org-string">'string'</span>
              ? c
              : c.content
          })
          .join(<span class="org-string">''</span>)

  <span class="org-keyword">return</span> <span class=
"org-string">`_${CSS_VARS_HELPER}(_ctx =&gt; (${transformedString}))`</span>
}

<span class="org-comment-delimiter">// </span><span class=
"org-comment">&lt;script setup&gt; already gets the calls injected as part of the transform</span>
<span class="org-comment-delimiter">// </span><span class=
"org-comment">this is only for single normal &lt;script&gt;</span>
<span class="org-keyword">function</span> <span class=
"org-function-name">genNormalScriptCssVarsCode</span>(
  <span class="org-variable-name">cssVars</span>,
  <span class="org-variable-name">bindings</span>,
  <span class="org-variable-name">id</span>,
  isProd
) {
  <span class="org-keyword">return</span> (
    <span class=
"org-string">`\nimport { ${CSS_VARS_HELPER} as _${CSS_VARS_HELPER} } from 'vue'\n`</span> +
    <span class=
"org-string">`const __injectCSSVars__ = () =&gt; {\n${genCssVarsCode(</span>
<span class="org-string">      cssVars,</span>
<span class="org-string">      bindings,</span>
<span class="org-string">      id,</span>
<span class="org-string">      isProd</span>
<span class="org-string">    )}}\n`</span> +
    <span class=
"org-string">`const __setup__ = __default__.setup\n`</span> +
    <span class=
"org-string">`__default__.setup = __setup__\n`</span> +
    <span class=
"org-string">`  ? (props, ctx) =&gt; { __injectCSSVars__();return __setup__(props, ctx) }\n`</span> +
    <span class="org-string">`  : __injectCSSVars__\n`</span>
  )
}


<span class="org-comment-delimiter">// </span><span class=
"org-comment">Special compiler macros</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">DEFINE_PROPS</span> = <span class=
"org-string">'defineProps'</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">DEFINE_EMITS</span> = <span class=
"org-string">'defineEmits'</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">DEFINE_EXPOSE</span> = <span class=
"org-string">'defineExpose'</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">WITH_DEFAULTS</span> = <span class=
"org-string">'withDefaults'</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">templateUsageCheckCache</span> = createCache()

<span class="org-comment-delimiter">// </span><span class=
"org-comment">constants</span>
<span class="org-keyword">const</span> <span class=
"org-variable-name">DEFAULT_VAR</span> = <span class=
"org-string">`__default__`</span>

<span class="org-keyword">const</span> <span class=
"org-variable-name">isBuiltInDir</span> = makeMap(
  <span class=
"org-string">`once,memo,if,else,else-if,slot,text,html,on,bind,model,show,cloak,is`</span>
)

<span class="org-keyword">function</span> <span class=
"org-function-name">compileScript</span>(<span class=
"org-variable-name">sfc</span>, <span class=
"org-variable-name">options</span>) {
  <span class=
"org-keyword">let</span> { script, scriptSetup, source, filename } = sfc
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">feature flags</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment"><span class="org-bold"><span class=
"org-warning">TODO</span></span></span><span class=
"org-comment"> remove support for deprecated options when out of experimental</span>
  <span class="org-keyword">const</span> <span class=
"org-variable-name">enableReactivityTransform</span> =
    !!options.reactivityTransform ||
    !!options.refSugar ||
    !!options.refTransform
  <span class="org-keyword">const</span> <span class=
"org-variable-name">enablePropsTransform</span> =
    !!options.reactivityTransform || !!options.propsDestructureTransform
  <span class="org-keyword">const</span> <span class=
"org-variable-name">isProd</span> = !!options.isProd
  <span class="org-keyword">const</span> <span class=
"org-variable-name">genSourceMap</span> = options.sourceMap !== <span class="org-constant">false</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">ref 声明的变量</span>
  <span class="org-keyword">let</span> <span class=
"org-variable-name">refBindings</span>

  <span class="org-keyword">const</span> <span class=
"org-variable-name">scopeId</span> = options.id ? options.id.replace(<span class="org-string">/^data-v-/</span>, <span class="org-string">''</span>) : <span class="org-string">''</span>
  <span class="org-keyword">const</span> <span class=
"org-variable-name">cssVars</span> = sfc.cssVars
  <span class="org-keyword">const</span> <span class=
"org-variable-name">scriptLang</span> = script &amp;& script.lang
  <span class="org-keyword">const</span> <span class=
"org-variable-name">scriptSetupLang</span> = scriptSetup &amp;& scriptSetup.lang
  <span class="org-keyword">const</span> <span class=
"org-variable-name">isTS</span> =
    scriptLang === <span class="org-string">'ts'</span> ||
    scriptLang === <span class="org-string">'tsx'</span> ||
    scriptSetupLang === <span class="org-string">'ts'</span> ||
    scriptSetupLang === <span class="org-string">'tsx'</span>

  <span class="org-comment-delimiter">// </span><span class=
"org-comment">resolve parser plugins</span>
  <span class="org-keyword">const</span> <span class=
"org-variable-name">plugins</span> = []
  <span class=
"org-keyword">if</span> (!isTS || scriptLang === <span class=
"org-string">'tsx'</span> || scriptSetupLang === <span class=
"org-string">'tsx'</span>) {
    plugins.push(<span class="org-string">'jsx'</span>)
  }
  <span class=
"org-keyword">if</span> (options.babelParserPlugins) plugins.push(...options.babelParserPlugins)
  <span class=
"org-keyword">if</span> (isTS) plugins.push(<span class=
"org-string">'typescript'</span>, <span class=
"org-string">'decorators-legacy'</span>)

  <span class="org-keyword">if</span> (!scriptSetup) {
    <span class="org-keyword">if</span> (!script) {
      <span class="org-keyword">throw</span> <span class=
"org-keyword">new</span> <span class=
"org-type">Error</span>(<span class=
"org-string">`[@vue/compiler-sfc] SFC contains no &lt;script&gt; tags.`</span>)
    }
    <span class=
"org-keyword">if</span> (scriptLang &amp;& !isTS &amp;& scriptLang !== <span class="org-string">'jsx'</span>) {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">do not process non js/ts script blocks</span>
      <span class="org-keyword">return</span> script
    }
    <span class="org-keyword">try</span> {
      <span class="org-keyword">let</span> <span class=
"org-variable-name">content</span> = script.content
      <span class="org-keyword">let</span> <span class=
"org-variable-name">map</span> = script.map
      <span class="org-keyword">const</span> <span class=
"org-variable-name">scriptAst</span> = babelParser.parse(content, {
        plugins,
        sourceType: <span class="org-string">'module'</span>
      }).program
      <span class="org-keyword">const</span> <span class=
"org-variable-name">bindings</span> = analyzeScriptBindings(scriptAst.body)
      <span class=
"org-keyword">if</span> (enableReactivityTransform &amp;& RT.shouldTransform(content)) {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">s</span> = <span class=
"org-keyword">new</span> <span class=
"org-type">MagicString</span>(source)
        <span class="org-keyword">const</span> <span class=
"org-variable-name">startOffset</span> = script.loc.start.offset
        <span class="org-keyword">const</span> <span class=
"org-variable-name">endOffset</span> = script.loc.end.offset
        <span class=
"org-keyword">const</span> { importedHelpers } = RT.transformAST(scriptAst, s, startOffset)
        <span class=
"org-keyword">if</span> (importedHelpers.length) {
          s.prepend(
            <span class=
"org-string">`import { ${importedHelpers</span>
<span class=
"org-string">              .map(h =&gt; `</span>${h} as _${h}<span class="org-string">`)</span>
<span class=
"org-string">              .join(', ')} } from 'vue'\n`</span>
          )
        }
        s.remove(<span class=
"org-highlight-numbers-number">0</span>, startOffset)
        s.remove(endOffset, source.length)
        content = s.toString()
        <span class="org-keyword">if</span> (genSourceMap) {
          map = s.generateMap({
            source: filename,
            hires: <span class="org-constant">true</span>,
            includeContent: <span class="org-constant">true</span>
          })
        }
      }
      <span class="org-keyword">if</span> (cssVars.length) {
        content = rewriteDefault(content, DEFAULT_VAR, plugins)
        content += genNormalScriptCssVarsCode(
          cssVars,
          bindings,
          scopeId,
          isProd
        )
        content += <span class=
"org-string">`\nexport default ${DEFAULT_VAR}`</span>
      }
      <span class="org-keyword">return</span> {
        ...script,
        content,
        map,
        bindings,
        scriptAst: scriptAst.body
      }
    } <span class="org-keyword">catch</span> (e) {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">silently fallback if parse fails since user may be using custom</span>
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">babel syntax</span>
      <span class="org-keyword">return</span> script
    }
  }

  <span class="org-comment-delimiter">// </span><span class=
"org-comment">script 和 script setup 的语言必须一致</span>
  <span class=
"org-keyword">if</span> (script &amp;& scriptLang !== scriptSetupLang) {
    <span class="org-keyword">throw</span> <span class=
"org-keyword">new</span> <span class="org-type">Error</span>(
      <span class=
"org-string">`[@vue/compiler-sfc] &lt;script&gt; and &lt;script setup&gt; must have the same `</span> +
        <span class="org-string">`language type.`</span>
    )
  }

  <span class="org-comment-delimiter">// </span><span class=
"org-comment">只处理 js/ts script</span>
  <span class=
"org-keyword">if</span> (scriptSetupLang &amp;& !isTS &amp;& scriptSetupLang !== <span class="org-string">'jsx'</span>) {
    <span class="org-keyword">return</span> scriptSetup
  }

  <span class="org-comment-delimiter">// </span><span class=
"org-comment">变量，imports 都需要导出</span>
  <span class="org-keyword">const</span> <span class=
"org-variable-name">bindingMetadata</span> = {}
  <span class="org-keyword">const</span> <span class=
"org-variable-name">helperImports</span> = <span class=
"org-keyword">new</span> <span class="org-type">Set</span>()
  <span class="org-keyword">const</span> <span class=
"org-variable-name">userImports</span> = Object.create(<span class=
"org-constant">null</span>)
  <span class="org-keyword">const</span> <span class=
"org-variable-name">userImportAlias</span> = Object.create(<span class="org-constant">null</span>)
  <span class="org-keyword">const</span> <span class=
"org-variable-name">scriptBindings</span> = Object.create(<span class="org-constant">null</span>)
  <span class="org-keyword">const</span> <span class=
"org-variable-name">setupBindings</span> = Object.create(<span class="org-constant">null</span>)

  <span class="org-keyword">let</span> <span class=
"org-variable-name">defaultExport</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">export default</span>
  <span class="org-keyword">let</span> <span class=
"org-variable-name">hasDefinePropsCall</span> = <span class=
"org-constant">false</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">defineProps()</span>
  <span class="org-keyword">let</span> <span class=
"org-variable-name">hasDefineEmitCall</span> = <span class=
"org-constant">false</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">defineEmits()</span>
  <span class="org-keyword">let</span> <span class=
"org-variable-name">hasDefineExposeCall</span> = <span class=
"org-constant">false</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">defineExpose()</span>
  <span class="org-keyword">let</span> <span class=
"org-variable-name">propsRuntimeDecl</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">属性声明</span>
  <span class="org-keyword">let</span> <span class=
"org-variable-name">propsRuntimeDefaults</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">属性默认值</span>
  <span class="org-keyword">let</span> <span class=
"org-variable-name">propsDestructureDecl</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">属性解构声明</span>
  <span class="org-keyword">let</span> <span class=
"org-variable-name">propsDestructureRestId</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">属性解构的 ... 符号</span>
  <span class="org-keyword">let</span> <span class=
"org-variable-name">propsTypeDecl</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">属性类型声明</span>
  <span class="org-keyword">let</span> <span class=
"org-variable-name">propsTypeDeclRaw</span>
  <span class="org-keyword">let</span> <span class=
"org-variable-name">propsIdentifier</span>
  <span class="org-keyword">let</span> <span class=
"org-variable-name">emitsRuntimeDecl</span>
  <span class="org-keyword">let</span> <span class=
"org-variable-name">emitsTypeDecl</span>
  <span class="org-keyword">let</span> <span class=
"org-variable-name">emitsTypeDeclRaw</span>
  <span class="org-keyword">let</span> <span class=
"org-variable-name">emitIdentifier</span>
  <span class="org-keyword">let</span> <span class=
"org-variable-name">hasAwait</span> = <span class=
"org-constant">false</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">有没 await 符号，如果有则会转成 async setup</span>
  <span class="org-keyword">let</span> <span class=
"org-variable-name">hasInlinedSsrRenderFn</span> = <span class=
"org-constant">false</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">props/emits declared via types</span>
  <span class="org-keyword">const</span> <span class=
"org-variable-name">typeDeclaredProps</span> = {}
  <span class="org-keyword">const</span> <span class=
"org-variable-name">typeDeclaredEmits</span> = <span class=
"org-keyword">new</span> <span class="org-type">Set</span>()
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">record declared types for runtime props type generation</span>
  <span class="org-keyword">const</span> <span class=
"org-variable-name">declaredTypes</span> = {}
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">props destructure data</span>
  <span class="org-keyword">const</span> <span class=
"org-variable-name">propsDestructuredBindings</span> = Object.create(<span class="org-constant">null</span>)

  <span class="org-comment-delimiter">// </span><span class=
"org-comment">magic-string state</span>
  <span class="org-keyword">const</span> <span class=
"org-variable-name">s</span> = <span class=
"org-keyword">new</span> <span class=
"org-type">MagicString</span>(source)
  <span class="org-keyword">const</span> <span class=
"org-variable-name">startOffset</span> = scriptSetup.loc.start.offset
  <span class="org-keyword">const</span> <span class=
"org-variable-name">endOffset</span> = scriptSetup.loc.end.offset
  <span class="org-keyword">const</span> <span class=
"org-variable-name">scriptStartOffset</span> = script &amp;& script.loc.start.offset
  <span class="org-keyword">const</span> <span class=
"org-variable-name">scriptEndOffset</span> = script &amp;& script.loc.end.offset

  <span class="org-keyword">function</span> <span class=
"org-function-name">helper</span>(<span class=
"org-variable-name">key</span>) {
    helperImports.add(key)
    <span class="org-keyword">return</span> <span class=
"org-string">`_${key}`</span>
  }
    <span class="org-keyword">function</span> <span class=
"org-function-name">parse</span>(<span class=
"org-variable-name">input</span>, <span class=
"org-variable-name">options</span>, <span class=
"org-variable-name">offset</span>) {
      <span class="org-keyword">try</span> {
        <span class=
"org-keyword">return</span> babelParser.parse(input, options).program
      } <span class="org-keyword">catch</span> (e) {
        e.message = <span class=
"org-string">`[@vue/compiler-sfc] ${e.message}\n\n${</span>
<span class="org-string">          sfc.filename</span>
<span class=
"org-string">        }\n${generateCodeFrame(source, e.pos + offset, e.pos + offset + 1)}`</span>
        <span class="org-keyword">throw</span> e
      }
    }
  
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">error</span>(<span class=
"org-variable-name">msg</span>, <span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">end</span> = <span class=
"org-variable-name">node</span>.<span class=
"org-variable-name">end</span> + <span class=
"org-variable-name">startOffset</span>) {
    <span class="org-keyword">throw</span> <span class=
"org-keyword">new</span> <span class="org-type">Error</span>(
      <span class=
"org-string">`[@vue/compiler-sfc] ${msg}\n\n${sfc.filename}\n${generateCodeFrame(</span>
<span class="org-string">      source,</span>
<span class="org-string">      node.start + startOffset,</span>
<span class="org-string">      end</span>
<span class="org-string">      )}`</span>
    )
  }
    <span class="org-keyword">function</span> <span class=
"org-function-name">registerUserImport</span>(<span class=
"org-variable-name">source</span>, <span class=
"org-variable-name">local</span>, <span class=
"org-variable-name">imported</span>, <span class=
"org-variable-name">isType</span>, <span class=
"org-variable-name">isFromSetup</span>) {
      <span class="org-keyword">if</span> (source === <span class=
"org-string">'vue'</span> &amp;& imported) {
        userImportAlias[imported] = local
      }
  
      <span class="org-keyword">let</span> <span class=
"org-variable-name">isUsedInTemplate</span> = <span class=
"org-constant">true</span>
      <span class=
"org-keyword">if</span> (isTS &amp;& sfc.template &amp;& !sfc.template.src &amp;& !sfc.template.lang) {
        isUsedInTemplate = isImportUsed(local, sfc)
      }
  
      userImports[local] = {
        isType,
        imported: imported || <span class=
"org-string">'default'</span>,
        source,
        isFromSetup,
        isUsedInTemplate
      }
    }
  
    <span class="org-keyword">function</span> <span class=
"org-function-name">processDefineProps</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">declId</span>) {
      <span class=
"org-keyword">if</span> (!isCallOf(node, DEFINE_PROPS)) {
        <span class="org-keyword">return</span> <span class=
"org-constant">false</span>
      }
  
      <span class="org-keyword">if</span> (hasDefinePropsCall) {
        error(<span class=
"org-string">`duplicate ${DEFINE_PROPS}() call`</span>, node)
      }
      hasDefinePropsCall = <span class="org-constant">true</span>
  
      propsRuntimeDecl = node.<span class=
"org-constant">arguments</span>[<span class=
"org-highlight-numbers-number">0</span>]
  
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">call has type parameters - infer runtime types from it</span>
      <span class="org-keyword">if</span> (node.typeParameters) {
        <span class="org-keyword">if</span> (propsRuntimeDecl) {
          error(
            <span class=
"org-string">`${DEFINE_PROPS}() cannot accept both type and non-type arguments `</span> +
              <span class=
"org-string">`at the same time. Use one or the other.`</span>,
            node
          )
        }
  
        propsTypeDeclRaw = node.typeParameters.params[<span class=
"org-highlight-numbers-number">0</span>]
        propsTypeDecl = resolveQualifiedType(
          propsTypeDeclRaw,
          node =&gt; node.type === <span class=
"org-string">'TSTypeLiteral'</span>
        )
  
        <span class="org-keyword">if</span> (!propsTypeDecl) {
          error(
            <span class=
"org-string">`type argument passed to ${DEFINE_PROPS}() must be a literal type, `</span> +
              <span class=
"org-string">`or a reference to an interface or literal type.`</span>,
            propsTypeDeclRaw
          )
        }
      }
  
      <span class="org-keyword">if</span> (declId) {
        <span class=
"org-keyword">if</span> (enablePropsTransform &amp;& declId.type === <span class="org-string">'ObjectPattern'</span>) {
          propsDestructureDecl = declId
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">props destructure - handle compilation sugar</span>
          <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">prop</span> <span class=
"org-keyword">of</span> declId.properties) {
            <span class=
"org-keyword">if</span> (prop.type === <span class=
"org-string">'ObjectProperty'</span>) {
              <span class="org-keyword">if</span> (prop.computed) {
                error(
                  <span class=
"org-string">`${DEFINE_PROPS}() destructure cannot use computed key.`</span>,
                  prop.key
                )
              }
              <span class="org-keyword">const</span> <span class=
"org-variable-name">propKey</span> = prop.key.name
              <span class=
"org-keyword">if</span> (prop.value.type === <span class=
"org-string">'AssignmentPattern'</span>) {
                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">default value { foo = 123 }</span>
                <span class=
"org-keyword">const</span> { left, right } = prop.value
                <span class=
"org-keyword">if</span> (left.type !== <span class=
"org-string">'Identifier'</span>) {
                  error(
                    <span class=
"org-string">`${DEFINE_PROPS}() destructure does not support nested patterns.`</span>,
                    left
                  )
                }
                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">store default value</span>
                propsDestructuredBindings[propKey] = {
                  local: left.name,
                  <span class="org-keyword">default</span>: right
                }
              } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (prop.value.type === <span class=
"org-string">'Identifier'</span>) {
                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">simple destructure</span>
                propsDestructuredBindings[propKey] = {
                  local: prop.value.name
                }
              } <span class="org-keyword">else</span> {
                error(
                  <span class=
"org-string">`${DEFINE_PROPS}() destructure does not support nested patterns.`</span>,
                  prop.value
                )
              }
            } <span class="org-keyword">else</span> {
              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">rest spread</span>
              propsDestructureRestId = prop.argument.name
            }
          }
        } <span class="org-keyword">else</span> {
          propsIdentifier = scriptSetup.content.slice(declId.start, declId.end)
        }
      }
  
      <span class="org-keyword">return</span> <span class=
"org-constant">true</span>
    }
  
  
    <span class="org-keyword">function</span> <span class=
"org-function-name">processWithDefaults</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">declId</span>) {
      <span class=
"org-keyword">if</span> (!isCallOf(node, WITH_DEFAULTS)) {
        <span class="org-keyword">return</span> <span class=
"org-constant">false</span>
      }
      <span class=
"org-keyword">if</span> (processDefineProps(node.<span class=
"org-constant">arguments</span>[<span class=
"org-highlight-numbers-number">0</span>], declId)) {
        <span class="org-keyword">if</span> (propsRuntimeDecl) {
          error(
            <span class=
"org-string">`${WITH_DEFAULTS} can only be used with type-based `</span> +
              <span class=
"org-string">`${DEFINE_PROPS} declaration.`</span>,
            node
          )
        }
        <span class=
"org-keyword">if</span> (propsDestructureDecl) {
          error(
            <span class=
"org-string">`${WITH_DEFAULTS}() is unnecessary when using destructure with ${DEFINE_PROPS}().\n`</span> +
              <span class=
"org-string">`Prefer using destructure default values, e.g. const { foo = 1 } = defineProps(...).`</span>,
            node.callee
          )
        }
        propsRuntimeDefaults = node.<span class=
"org-constant">arguments</span>[<span class=
"org-highlight-numbers-number">1</span>]
        <span class="org-keyword">if</span> (
          !propsRuntimeDefaults ||
          propsRuntimeDefaults.type !== <span class=
"org-string">'ObjectExpression'</span>
        ) {
          error(
            <span class=
"org-string">`The 2nd argument of ${WITH_DEFAULTS} must be an object literal.`</span>,
            propsRuntimeDefaults || node
          )
        }
      } <span class="org-keyword">else</span> {
        error(
          <span class=
"org-string">`${WITH_DEFAULTS}' first argument must be a ${DEFINE_PROPS} call.`</span>,
          node.<span class=
"org-constant">arguments</span>[<span class=
"org-highlight-numbers-number">0</span>] || node
        )
      }
      <span class="org-keyword">return</span> <span class=
"org-constant">true</span>
    }
  
  
  
    <span class="org-keyword">function</span> <span class=
"org-function-name">processDefineEmits</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">declId</span>) {
      <span class=
"org-keyword">if</span> (!isCallOf(node, DEFINE_EMITS)) {
        <span class="org-keyword">return</span> <span class=
"org-constant">false</span>
      }
      <span class="org-keyword">if</span> (hasDefineEmitCall) {
        error(<span class=
"org-string">`duplicate ${DEFINE_EMITS}() call`</span>, node)
      }
      hasDefineEmitCall = <span class="org-constant">true</span>
      emitsRuntimeDecl = node.<span class=
"org-constant">arguments</span>[<span class=
"org-highlight-numbers-number">0</span>]
      <span class="org-keyword">if</span> (node.typeParameters) {
        <span class="org-keyword">if</span> (emitsRuntimeDecl) {
          error(
            <span class=
"org-string">`${DEFINE_EMITS}() cannot accept both type and non-type arguments `</span> +
              <span class=
"org-string">`at the same time. Use one or the other.`</span>,
            node
          )
        }
  
        emitsTypeDeclRaw = node.typeParameters.params[<span class=
"org-highlight-numbers-number">0</span>]
        emitsTypeDecl = resolveQualifiedType(
          emitsTypeDeclRaw,
          node =&gt; node.type === <span class=
"org-string">'TSFunctionType'</span> || node.type === <span class=
"org-string">'TSTypeLiteral'</span>
        )
  
        <span class="org-keyword">if</span> (!emitsTypeDecl) {
          error(
            <span class=
"org-string">`type argument passed to ${DEFINE_EMITS}() must be a function type, `</span> +
              <span class=
"org-string">`a literal type with call signatures, or a reference to the above types.`</span>,
            emitsTypeDeclRaw
          )
        }
      }
  
      <span class="org-keyword">if</span> (declId) {
        emitIdentifier = scriptSetup.content.slice(declId.start, declId.end)
      }
  
      <span class="org-keyword">return</span> <span class=
"org-constant">true</span>
    }
  
  
  
    <span class="org-keyword">function</span> <span class=
"org-function-name">resolveQualifiedType</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">qualifier</span>) {
      <span class="org-keyword">if</span> (qualifier(node)) {
        <span class="org-keyword">return</span> node
      }
      <span class="org-keyword">if</span> (
        node.type === <span class=
"org-string">'TSTypeReference'</span> &amp;&
        node.typeName.type === <span class=
"org-string">'Identifier'</span>
      ) {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">refName</span> = node.typeName.name
        <span class="org-keyword">const</span> <span class=
"org-variable-name">isQualifiedType</span> = (node) =&gt; {
          <span class="org-keyword">if</span> (
            node.type === <span class=
"org-string">'TSInterfaceDeclaration'</span> &amp;&
            node.id.name === refName
          ) {
            <span class="org-keyword">return</span> node.body
          } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (
            node.type === <span class=
"org-string">'TSTypeAliasDeclaration'</span> &amp;&
            node.id.name === refName &amp;&
            qualifier(node.typeAnnotation)
          ) {
            <span class=
"org-keyword">return</span> node.typeAnnotation
          } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'ExportNamedDeclaration'</span> &amp;& node.declaration) {
            <span class=
"org-keyword">return</span> isQualifiedType(node.declaration)
          }
        }
        <span class="org-keyword">const</span> <span class=
"org-variable-name">body</span> = scriptAst
          ? [...scriptSetupAst.body, ...scriptAst.body]
          : scriptSetupAst.body
        <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">node</span> <span class=
"org-keyword">of</span> body) {
          <span class="org-keyword">const</span> <span class=
"org-variable-name">qualified</span> = isQualifiedType(node)
          <span class="org-keyword">if</span> (qualified) {
            <span class="org-keyword">return</span> qualified
          }
        }
      }
    }
  
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">processDefineExpose</span>(<span class=
"org-variable-name">node</span>) {
      <span class=
"org-keyword">if</span> (isCallOf(node, DEFINE_EXPOSE)) {
        <span class="org-keyword">if</span> (hasDefineExposeCall) {
          error(<span class=
"org-string">`duplicate ${DEFINE_EXPOSE}() call`</span>, node)
        }
        hasDefineExposeCall = <span class=
"org-constant">true</span>
        <span class="org-keyword">return</span> <span class=
"org-constant">true</span>
      }
      <span class="org-keyword">return</span> <span class=
"org-constant">false</span>
    }
  
  <span class="org-doc">/**</span>
<span class="org-doc">     * await foo()</span>
<span class="org-doc">     * --&gt;</span>
<span class="org-doc">     * ;(</span>
<span class=
"org-doc">     *   ([__temp,__restore] = withAsyncContext(() =&gt; foo())),</span>
<span class="org-doc">     *   await __temp,</span>
<span class="org-doc">     *   __restore()</span>
<span class="org-doc">     * )</span>
<span class="org-doc">     *</span>
<span class="org-doc">     * const a = await foo()</span>
<span class="org-doc">     * --&gt;</span>
<span class="org-doc">     * const a = (</span>
<span class=
"org-doc">     *   ([__temp, __restore] = withAsyncContext(() =&gt; foo())),</span>
<span class="org-doc">     *   __temp = await __temp,</span>
<span class="org-doc">     *   __restore(),</span>
<span class="org-doc">     *   __temp</span>
<span class="org-doc">     * )</span>
<span class="org-doc">     */</span>
    <span class="org-keyword">function</span> <span class=
"org-function-name">processAwait</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">needSemi</span>, <span class=
"org-variable-name">isStatement</span>) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">argumentStart</span> =
        node.argument.extra &amp;& node.argument.extra.parenthesized
          ? node.argument.extra.parenStart
          : node.argument.start
  
      <span class="org-keyword">const</span> <span class=
"org-variable-name">argumentStr</span> = source.slice(
        argumentStart + startOffset,
        node.argument.end + startOffset
      )
  
      <span class="org-keyword">const</span> <span class=
"org-variable-name">containsNestedAwait</span> = <span class=
"org-string">/\bawait\b/</span>.test(argumentStr)
  
      s.overwrite(
        node.start + startOffset,
        argumentStart + startOffset,
        <span class=
"org-string">`${needSemi ? `</span>;<span class="org-string">` : ``}(\n  ([__temp,__restore] = ${helper(</span>
<span class=
"org-string">          `</span>withAsyncContext<span class=
"org-string">`</span>
<span class=
"org-string">        )}(${containsNestedAwait ? `</span><span class="org-keyword">async</span> <span class="org-string">` : ``}() =&gt; `</span>
      )
      s.appendLeft(
        node.end + startOffset,
        <span class=
"org-string">`)),\n  ${isStatement ? `` : `</span>__temp = <span class="org-string">`}await __temp,\n  __restore()${</span>
<span class=
"org-string">          isStatement ? `` : `</span>,\n  __temp<span class="org-string">`</span>
<span class="org-string">        }\n)`</span>
      )
    }
  
  
  <span class="org-doc">/**</span>
<span class=
"org-doc">     * check defaults. If the default object is an object literal with only</span>
<span class=
"org-doc">     * static properties, we can directly generate more optimized default</span>
<span class=
"org-doc">     * declarations. Otherwise we will have to fallback to runtime merging.</span>
<span class="org-doc">     */</span>
    <span class="org-keyword">function</span> <span class=
"org-function-name">hasStaticWithDefaults</span>() {
      <span class="org-keyword">return</span> (
        propsRuntimeDefaults &amp;&
        propsRuntimeDefaults.type === <span class=
"org-string">'ObjectExpression'</span> &amp;&
        propsRuntimeDefaults.properties.every(
          node =&gt;
            (node.type === <span class=
"org-string">'ObjectProperty'</span> &amp;& !node.computed) ||
            node.type === <span class=
"org-string">'ObjectMethod'</span>
        )
      )
    }
  <span class="org-keyword">function</span> <span class=
"org-function-name">genRuntimeProps</span>(<span class=
"org-variable-name">props</span>) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">keys</span> = Object.keys(props)
      <span class="org-keyword">if</span> (!keys.length) {
        <span class="org-keyword">return</span> <span class=
"org-string">``</span>
      }
      <span class="org-keyword">const</span> <span class=
"org-variable-name">hasStaticDefaults</span> = hasStaticWithDefaults()
      <span class="org-keyword">const</span> <span class=
"org-variable-name">scriptSetupSource</span> = scriptSetup.content
      <span class="org-keyword">let</span> <span class=
"org-variable-name">propsDecls</span> = <span class=
"org-string">`{</span>
<span class="org-string">      ${keys</span>
<span class="org-string">        .map(key =&gt; {</span>
<span class="org-string">          let defaultString</span>
<span class=
"org-string">          const destructured = genDestructuredDefaultValue(key)</span>
<span class="org-string">          if (destructured) {</span>
<span class=
"org-string">            defaultString = `</span><span class=
"org-keyword">default</span>: ${destructured}<span class=
"org-string">`</span>
<span class=
"org-string">          } else if (hasStaticDefaults) {</span>
<span class=
"org-string">            const prop = propsRuntimeDefaults.properties.find(</span>
<span class=
"org-string">              (node) =&gt; node.key.name === key</span>
<span class="org-string">            )</span>
<span class="org-string">            if (prop) {</span>
<span class=
"org-string">              if (prop.type === 'ObjectProperty') {</span>
<span class=
"org-string">                // prop has corresponding static default value</span>
<span class=
"org-string">                defaultString = `</span><span class=
"org-keyword">default</span>: ${scriptSetupSource.slice(
                  prop.value.start,
                  prop.value.end
                )}<span class="org-string">`</span>
<span class="org-string">              } else {</span>
<span class=
"org-string">                defaultString = `</span><span class=
"org-keyword">default</span>() ${scriptSetupSource.slice(
                  prop.body.start,
                  prop.body.end
                )}<span class="org-string">`</span>
<span class="org-string">              }</span>
<span class="org-string">            }</span>
<span class="org-string">          }</span>
<span class="org-string">  </span>
<span class=
"org-string">          const { type, required } = props[key]</span>
<span class="org-string">          if (!isProd) {</span>
<span class=
"org-string">            return `</span>${key}: { type: ${toRuntimeTypeString(
              type
            )}, required: ${required}${
              defaultString ? <span class=
"org-string">`, ${defaultString}`</span> : <span class=
"org-string">``</span>
            } }<span class="org-string">`</span>
<span class="org-string">          } else if (</span>
<span class="org-string">            type.some(</span>
<span class=
"org-string">              el =&gt; el === 'Boolean' || (defaultString &amp;& el === 'Function')</span>
<span class="org-string">            )</span>
<span class="org-string">          ) {</span>
<span class=
"org-string">            // #4783 production: if boolean or defaultString and function exists, should keep the type.</span>
<span class=
"org-string">            return `</span>${key}: { type: ${toRuntimeTypeString(type)}${
              defaultString ? <span class=
"org-string">`, ${defaultString}`</span> : <span class=
"org-string">``</span>
            } }<span class="org-string">`</span>
<span class="org-string">          } else {</span>
<span class=
"org-string">            // production: checks are useless</span>
<span class=
"org-string">            return `</span>${key}: ${defaultString ? <span class="org-string">`{ ${defaultString} }`</span> : <span class="org-string">'null'</span>}<span class="org-string">`</span>
<span class="org-string">          }</span>
<span class="org-string">        })</span>
<span class="org-string">        .join(',\n    ')}\n  }`</span>
  
      <span class=
"org-keyword">if</span> (propsRuntimeDefaults &amp;& !hasStaticDefaults) {
        propsDecls = <span class=
"org-string">`${helper('mergeDefaults')}(${propsDecls}, ${source.slice(</span>
<span class=
"org-string">          propsRuntimeDefaults.start + startOffset,</span>
<span class=
"org-string">          propsRuntimeDefaults.end + startOffset</span>
<span class="org-string">        )})`</span>
      }
  
      <span class="org-keyword">return</span> <span class=
"org-string">`\n  props: ${propsDecls},`</span>
    }
  
  
  <span class="org-keyword">function</span> <span class=
"org-function-name">genDestructuredDefaultValue</span>(<span class=
"org-variable-name">key</span>) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">destructured</span> = propsDestructuredBindings[key]
      <span class=
"org-keyword">if</span> (destructured &amp;& destructured.<span class="org-keyword">default</span>) {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">value</span> = scriptSetup.content.slice(
          destructured.<span class=
"org-keyword">default</span>.start,
          destructured.<span class="org-keyword">default</span>.end
        )
        <span class="org-keyword">const</span> <span class=
"org-variable-name">isLiteral</span> = destructured.<span class=
"org-keyword">default</span>.type.endsWith(<span class=
"org-string">'Literal'</span>)
        <span class=
"org-keyword">return</span> isLiteral ? value : <span class=
"org-string">`() =&gt; ${value}`</span>
      }
    }
  
    <span class="org-keyword">function</span> <span class=
"org-function-name">genSetupPropsType</span>(<span class=
"org-variable-name">node</span>) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">scriptSetupSource</span> = scriptSetup.content
      <span class=
"org-keyword">if</span> (hasStaticWithDefaults()) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">if withDefaults() is used, we need to remove the optional flags</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">on props that have default values</span>
        <span class="org-keyword">let</span> <span class=
"org-variable-name">res</span> = <span class=
"org-string">`{ `</span>
        <span class="org-keyword">const</span> <span class=
"org-variable-name">members</span> = node.type === <span class=
"org-string">'TSTypeLiteral'</span> ? node.members : node.body
        <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">m</span> <span class=
"org-keyword">of</span> members) {
          <span class="org-keyword">if</span> (
            (m.type === <span class=
"org-string">'TSPropertySignature'</span> ||
              m.type === <span class=
"org-string">'TSMethodSignature'</span>) &amp;&
            m.typeAnnotation &amp;&
            m.key.type === <span class=
"org-string">'Identifier'</span>
          ) {
            <span class="org-keyword">if</span> (
              propsRuntimeDefaults.properties.some(
                (p) =&gt; p.key.name === m.key.name
              )
            ) {
              res +=
                m.key.name +
                (m.type === <span class=
"org-string">'TSMethodSignature'</span> ? <span class=
"org-string">'()'</span> : <span class="org-string">''</span>) +
                scriptSetupSource.slice(
                  m.typeAnnotation.start,
                  m.typeAnnotation.end
                ) +
                <span class="org-string">', '</span>
            } <span class="org-keyword">else</span> {
              res +=
                scriptSetupSource.slice(m.start, m.typeAnnotation.end) + <span class="org-string">`, `</span>
            }
          }
        }
        <span class=
"org-keyword">return</span> (res.length ? res.slice(<span class=
"org-highlight-numbers-number">0</span>, -<span class=
"org-highlight-numbers-number">2</span>) : res) + <span class=
"org-string">` }`</span>
      } <span class="org-keyword">else</span> {
        <span class=
"org-keyword">return</span> scriptSetupSource.slice(node.start, node.end)
      }
    }
  <span class="org-keyword">function</span> <span class=
"org-function-name">processNormalScript</span>() {
    <span class="org-keyword">let</span> <span class=
"org-variable-name">scriptAst</span>
    <span class="org-keyword">if</span> (script) {
      scriptAst = parse(
        script.content,
        {
          plugins,
          sourceType: <span class="org-string">'module'</span>
        },
        scriptStartOffset
      )
  
      <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">node</span> <span class=
"org-keyword">of</span> scriptAst.body) {
        <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'ImportDeclaration'</span>) {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">record imports for dedupe</span>
          <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">specifier</span> <span class=
"org-keyword">of</span> node.specifiers) {
            <span class="org-keyword">const</span> <span class=
"org-variable-name">imported</span> =
              specifier.type === <span class=
"org-string">'ImportSpecifier'</span> &amp;&
              specifier.imported.type === <span class=
"org-string">'Identifier'</span> &amp;&
              specifier.imported.name
            registerUserImport(
              node.source.value,
              specifier.local.name,
              imported,
              node.importKind === <span class=
"org-string">'type'</span> ||
                (specifier.type === <span class=
"org-string">'ImportSpecifier'</span> &amp;&
                  specifier.importKind === <span class=
"org-string">'type'</span>),
              <span class="org-constant">false</span>
            )
          }
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'ExportDefaultDeclaration'</span>) {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">export default</span>
          defaultExport = node
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">export default { ... } --&gt; const __default__ = { ... }</span>
          <span class="org-keyword">const</span> <span class=
"org-variable-name">start</span> = node.start + scriptStartOffset
          <span class="org-keyword">const</span> <span class=
"org-variable-name">end</span> = node.declaration.start + scriptStartOffset
          s.overwrite(start, end, <span class=
"org-string">`const ${DEFAULT_VAR} = `</span>)
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'ExportNamedDeclaration'</span>) {
          <span class="org-keyword">const</span> <span class=
"org-variable-name">defaultSpecifier</span> = node.specifiers.find(
            s =&gt; s.exported.type === <span class=
"org-string">'Identifier'</span> &amp;& s.exported.name === <span class="org-string">'default'</span>
          )
          <span class="org-keyword">if</span> (defaultSpecifier) {
            defaultExport = node
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">1. remove specifier</span>
            <span class=
"org-keyword">if</span> (node.specifiers.length &gt; <span class=
"org-highlight-numbers-number">1</span>) {
              s.remove(
                defaultSpecifier.start + scriptStartOffset,
                defaultSpecifier.end + scriptStartOffset
              )
            } <span class="org-keyword">else</span> {
              s.remove(
                node.start + scriptStartOffset,
                node.end + scriptStartOffset
              )
            }
            <span class="org-keyword">if</span> (node.source) {
              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">export { x as default } from './x'</span>
              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">rewrite to `import { x as __default__ } from './x'` and</span>
              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">add to top</span>
              s.prepend(
                <span class=
"org-string">`import { ${defaultSpecifier.local.name} as ${DEFAULT_VAR} } from '${node.source.value}'\n`</span>
              )
            } <span class="org-keyword">else</span> {
              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">export { x as default }</span>
              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">rewrite to `const __default__ = x` and move to end</span>
              s.appendLeft(
                scriptEndOffset,
                <span class=
"org-string">`\nconst ${DEFAULT_VAR} = ${defaultSpecifier.local.name}\n`</span>
              )
            }
          }
          <span class="org-keyword">if</span> (node.declaration) {
            walkDeclaration(node.declaration, scriptBindings, userImportAlias)
          }
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (
          (node.type === <span class=
"org-string">'VariableDeclaration'</span> ||
            node.type === <span class=
"org-string">'FunctionDeclaration'</span> ||
            node.type === <span class=
"org-string">'ClassDeclaration'</span> ||
            node.type === <span class=
"org-string">'TSEnumDeclaration'</span>) &amp;&
          !node.declare
        ) {
          walkDeclaration(node, scriptBindings, userImportAlias)
        }
      }
  
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">apply reactivity transform</span>
      <span class=
"org-keyword">if</span> (enableReactivityTransform &amp;& RT.shouldTransform(script.content)) {
        <span class=
"org-keyword">const</span> { rootRefs, importedHelpers } = transformAST(
          scriptAst,
          s,
          scriptStartOffset
        )
        refBindings = rootRefs
        <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">h</span> <span class=
"org-keyword">of</span> importedHelpers) {
          helperImports.add(h)
        }
      }
  
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">&lt;script&gt; after &lt;script setup&gt;</span>
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">we need to move the block up so that `const __default__` is</span>
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">declared before being used in the actual component definition</span>
      <span class=
"org-keyword">if</span> (scriptStartOffset &gt; startOffset) {
        s.move(scriptStartOffset, scriptEndOffset, <span class=
"org-highlight-numbers-number">0</span>)
      }
    }
  
    <span class="org-keyword">return</span> scriptAst
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">processSetupScript</span>() {
    <span class="org-keyword">const</span> <span class=
"org-variable-name">scriptSetupAst</span> = babelParser.parse(
      scriptSetup.content,
      {
        plugins: [
          ...plugins,
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">allow top level await but only inside &lt;script setup&gt;</span>
          <span class="org-string">'topLevelAwait'</span>
        ],
        sourceType: <span class="org-string">'module'</span>
      },
      startOffset
    )
  
    <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">node</span> <span class=
"org-keyword">of</span> scriptSetupAst.body) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">start</span> = node.start + startOffset
      <span class="org-keyword">let</span> <span class=
"org-variable-name">end</span> = node.end + startOffset
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">locate comment</span>
      <span class=
"org-keyword">if</span> (node.trailingComments &amp;& node.trailingComments.length &gt; <span class="org-highlight-numbers-number">0</span>) {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">lastCommentNode</span> =
          node.trailingComments[node.trailingComments.length - <span class="org-highlight-numbers-number">1</span>]
        end = lastCommentNode.end + startOffset
      }
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">locate the end of whitespace between this statement and the next</span>
      <span class=
"org-keyword">while</span> (end &lt;= source.length) {
        <span class="org-keyword">if</span> (!<span class=
"org-string">/\s/</span>.test(source.charAt(end))) {
          <span class="org-keyword">break</span>
        }
        end++
      }
  
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">(Dropped) `ref: x` bindings</span>
      <span class="org-keyword">if</span> (
        node.type === <span class=
"org-string">'LabeledStatement'</span> &amp;&
        node.label.name === <span class=
"org-string">'ref'</span> &amp;&
        node.body.type === <span class=
"org-string">'ExpressionStatement'</span>
      ) {
        error(
          <span class=
"org-string">`ref sugar using the label syntax was an experimental proposal and `</span> +
            <span class=
"org-string">`has been dropped based on community feedback. Please check out `</span> +
            <span class=
"org-string">`the new proposal at https://github.com/vuejs/rfcs/discussions/369`</span>,
          node
        )
      }
  
      <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'ImportDeclaration'</span>) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">import declarations are moved to top</span>
        s.move(start, end, <span class=
"org-highlight-numbers-number">0</span>)
  
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">dedupe imports</span>
        <span class="org-keyword">let</span> <span class=
"org-variable-name">removed</span> = <span class=
"org-highlight-numbers-number">0</span>
        <span class="org-keyword">const</span> <span class=
"org-variable-name">removeSpecifier</span> = (i) =&gt; {
          <span class="org-keyword">const</span> <span class=
"org-variable-name">removeLeft</span> = i &gt; removed
          removed++
          <span class="org-keyword">const</span> <span class=
"org-variable-name">current</span> = node.specifiers[i]
          <span class="org-keyword">const</span> <span class=
"org-variable-name">next</span> = node.specifiers[i + <span class=
"org-highlight-numbers-number">1</span>]
          s.remove(
            removeLeft
              ? node.specifiers[i - <span class=
"org-highlight-numbers-number">1</span>].end + startOffset
              : current.start + startOffset,
            next &amp;& !removeLeft
              ? next.start + startOffset
              : current.end + startOffset
          )
        }
  
        <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; node.specifiers.length; i++) {
          <span class="org-keyword">const</span> <span class=
"org-variable-name">specifier</span> = node.specifiers[i]
          <span class="org-keyword">const</span> <span class=
"org-variable-name">local</span> = specifier.local.name
          <span class="org-keyword">const</span> <span class=
"org-variable-name">imported</span> =
            specifier.type === <span class=
"org-string">'ImportSpecifier'</span> &amp;&
            specifier.imported.type === <span class=
"org-string">'Identifier'</span> &amp;&
            specifier.imported.name
          <span class="org-keyword">const</span> <span class=
"org-variable-name">source</span> = node.source.value
          <span class="org-keyword">const</span> <span class=
"org-variable-name">existing</span> = userImports[local]
          <span class="org-keyword">if</span> (
            source === <span class="org-string">'vue'</span> &amp;&
            (imported === DEFINE_PROPS ||
              imported === DEFINE_EMITS ||
              imported === DEFINE_EXPOSE)
          ) {
            removeSpecifier(i)
          } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (existing) {
            <span class=
"org-keyword">if</span> (existing.source === source &amp;& existing.imported === imported) {
              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">already imported in &lt;script setup&gt;, dedupe</span>
              removeSpecifier(i)
            } <span class="org-keyword">else</span> {
              error(<span class=
"org-string">`different imports aliased to same local name.`</span>, specifier)
            }
          } <span class="org-keyword">else</span> {
            registerUserImport(
              source,
              local,
              imported,
              node.importKind === <span class=
"org-string">'type'</span> ||
                (specifier.type === <span class=
"org-string">'ImportSpecifier'</span> &amp;&
                  specifier.importKind === <span class=
"org-string">'type'</span>),
              <span class="org-constant">true</span>
            )
          }
        }
        <span class=
"org-keyword">if</span> (node.specifiers.length &amp;& removed === node.specifiers.length) {
          s.remove(node.start + startOffset, node.end + startOffset)
        }
      }
  
      <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'ExpressionStatement'</span>) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">process `defineProps` and `defineEmit(s)` calls</span>
        <span class="org-keyword">if</span> (
          processDefineProps(node.expression) ||
          processDefineEmits(node.expression) ||
          processWithDefaults(node.expression)
        ) {
          s.remove(node.start + startOffset, node.end + startOffset)
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (processDefineExpose(node.expression)) {
          <span class=
"org-comment-delimiter">// </span><span class="org-comment">defineExpose({}) -&gt; expose({})</span>
          <span class="org-keyword">const</span> <span class=
"org-variable-name">callee</span> = node.expression.callee
          s.overwrite(
            callee.start + startOffset,
            callee.end + startOffset,
            <span class="org-string">'expose'</span>
          )
        }
      }
  
      <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'VariableDeclaration'</span> &amp;& !node.declare) {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">total</span> = node.declarations.length
        <span class="org-keyword">let</span> <span class=
"org-variable-name">left</span> = total
        <span class="org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; total; i++) {
          <span class="org-keyword">const</span> <span class=
"org-variable-name">decl</span> = node.declarations[i]
          <span class="org-keyword">if</span> (decl.init) {
            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">defineProps / defineEmits</span>
            <span class="org-keyword">const</span> <span class=
"org-variable-name">isDefineProps</span> =
              processDefineProps(decl.init, decl.id) ||
              processWithDefaults(decl.init, decl.id)
            <span class="org-keyword">const</span> <span class=
"org-variable-name">isDefineEmits</span> = processDefineEmits(decl.init, decl.id)
            <span class=
"org-keyword">if</span> (isDefineProps || isDefineEmits) {
              <span class=
"org-keyword">if</span> (left === <span class=
"org-highlight-numbers-number">1</span>) {
                s.remove(node.start + startOffset, node.end + startOffset)
              } <span class="org-keyword">else</span> {
                <span class="org-keyword">let</span> <span class=
"org-variable-name">start</span> = decl.start + startOffset
                <span class="org-keyword">let</span> <span class=
"org-variable-name">end</span> = decl.end + startOffset
                <span class=
"org-keyword">if</span> (i &lt; total - <span class=
"org-highlight-numbers-number">1</span>) {
                  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">not the last one, locate the start of the next</span>
                  end = node.declarations[i + <span class=
"org-highlight-numbers-number">1</span>].start + startOffset
                } <span class="org-keyword">else</span> {
                  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">last one, locate the end of the prev</span>
                  start = node.declarations[i - <span class=
"org-highlight-numbers-number">1</span>].end + startOffset
                }
                s.remove(start, end)
                left--
              }
            }
          }
        }
      }
  
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">walk declarations to record declared bindings</span>
      <span class="org-keyword">if</span> (
        (node.type === <span class=
"org-string">'VariableDeclaration'</span> ||
          node.type === <span class=
"org-string">'FunctionDeclaration'</span> ||
          node.type === <span class=
"org-string">'ClassDeclaration'</span>) &amp;&
        !node.declare
      ) {
        walkDeclaration(node, setupBindings, userImportAlias)
      }
  
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">walk statements & named exports / variable declarations for top level</span>
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">await</span>
      <span class="org-keyword">if</span> (
        (node.type === <span class=
"org-string">'VariableDeclaration'</span> &amp;& !node.declare) ||
        node.type.endsWith(<span class=
"org-string">'Statement'</span>)
      ) {
        walk(node, {
          enter(child, parent) {
            <span class=
"org-keyword">if</span> (isFunctionType(child)) {
              <span class="org-constant">this</span>.skip()
            }
            <span class=
"org-keyword">if</span> (child.type === <span class=
"org-string">'AwaitExpression'</span>) {
              hasAwait = <span class="org-constant">true</span>
              <span class="org-keyword">const</span> <span class=
"org-variable-name">needsSemi</span> = scriptSetupAst.body.some(n =&gt; {
                <span class=
"org-keyword">return</span> n.type === <span class=
"org-string">'ExpressionStatement'</span> &amp;& n.start === child.start
              })
              processAwait(
                child,
                needsSemi,
                parent.type === <span class=
"org-string">'ExpressionStatement'</span>
              )
            }
          }
        })
      }
  
      <span class="org-keyword">if</span> (
        (node.type === <span class=
"org-string">'ExportNamedDeclaration'</span> &amp;& node.exportKind !== <span class="org-string">'type'</span>) ||
        node.type === <span class=
"org-string">'ExportAllDeclaration'</span> ||
        node.type === <span class=
"org-string">'ExportDefaultDeclaration'</span>
      ) {
        error(
          <span class=
"org-string">`&lt;script setup&gt; cannot contain ES module exports. `</span> +
            <span class=
"org-string">`If you are using a previous version of &lt;script setup&gt;, please `</span> +
            <span class=
"org-string">`consult the updated RFC at https://github.com/vuejs/rfcs/pull/227.`</span>,
          node
        )
      }
  
      <span class="org-keyword">if</span> (isTS) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">runtime enum</span>
        <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'TSEnumDeclaration'</span>) {
          registerBinding(setupBindings, node.id, BindingTypes.SETUP_CONST)
        }
  
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">move all Type declarations to outer scope</span>
        <span class="org-keyword">if</span> (
          node.type.startsWith(<span class=
"org-string">'TS'</span>) ||
          (node.type === <span class=
"org-string">'ExportNamedDeclaration'</span> &amp;&
            node.exportKind === <span class=
"org-string">'type'</span>) ||
          (node.type === <span class=
"org-string">'VariableDeclaration'</span> &amp;& node.declare)
        ) {
          recordType(node, declaredTypes)
          s.move(start, end, <span class=
"org-highlight-numbers-number">0</span>)
        }
      }
    }
  
    <span class="org-keyword">return</span> scriptSetupAst
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">applyReactivityTransform</span>() {
    <span class="org-keyword">if</span> (
      (enableReactivityTransform &amp;&
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">normal &lt;script&gt; had ref bindings that maybe used in &lt;script setup&gt;</span>
        (refBindings || RT.shouldTransform(scriptSetup.content))) ||
      propsDestructureDecl
    ) {
      <span class=
"org-keyword">const</span> { rootRefs, importedHelpers } = transformAST(
        scriptSetupAst,
        s,
        startOffset,
        refBindings,
        propsDestructuredBindings
      )
      refBindings = refBindings ? [...refBindings, ...rootRefs] : rootRefs
      <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">h</span> <span class=
"org-keyword">of</span> importedHelpers) {
        helperImports.add(h)
      }
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">extractRuntimePropsEmits</span>() {
    <span class="org-keyword">if</span> (propsTypeDecl) {
      extractRuntimeProps(propsTypeDecl, typeDeclaredProps, declaredTypes, isProd)
    }
    <span class="org-keyword">if</span> (emitsTypeDecl) {
      extractRuntimeEmits(emitsTypeDecl, typeDeclaredEmits)
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">checkUseOptions</span>() {
    checkInvalidScopeReference(propsRuntimeDecl, DEFINE_PROPS)
    checkInvalidScopeReference(propsRuntimeDefaults, DEFINE_PROPS)
    checkInvalidScopeReference(propsDestructureDecl, DEFINE_PROPS)
    checkInvalidScopeReference(emitsRuntimeDecl, DEFINE_PROPS)
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">removeNonScriptContent</span>() {
    <span class="org-keyword">if</span> (script) {
      <span class=
"org-keyword">if</span> (startOffset &lt; scriptStartOffset) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">&lt;script setup&gt; before &lt;script&gt;</span>
        s.remove(<span class=
"org-highlight-numbers-number">0</span>, startOffset)
        s.remove(endOffset, scriptStartOffset)
        s.remove(scriptEndOffset, source.length)
      } <span class="org-keyword">else</span> {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">&lt;script&gt; before &lt;script setup&gt;</span>
        s.remove(<span class=
"org-highlight-numbers-number">0</span>, scriptStartOffset)
        s.remove(scriptEndOffset, startOffset)
        s.remove(endOffset, source.length)
      }
    } <span class="org-keyword">else</span> {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">only &lt;script setup&gt;</span>
      s.remove(<span class=
"org-highlight-numbers-number">0</span>, startOffset)
      s.remove(endOffset, source.length)
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">analyzeBindingMetadata</span>() {
    <span class="org-keyword">if</span> (scriptAst) {
      Object.assign(bindingMetadata, analyzeScriptBindings(scriptAst.body))
    }
    <span class="org-keyword">if</span> (propsRuntimeDecl) {
      <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">of</span> getObjectOrArrayExpressionKeys(propsRuntimeDecl)) {
        bindingMetadata[key] = BindingTypes.PROPS
      }
    }
    <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">in</span> typeDeclaredProps) {
      bindingMetadata[key] = BindingTypes.PROPS
    }
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">props aliases</span>
    <span class="org-keyword">if</span> (propsDestructureDecl) {
      <span class=
"org-keyword">if</span> (propsDestructureRestId) {
        bindingMetadata[propsDestructureRestId] = BindingTypes.SETUP_CONST
      }
      <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">in</span> propsDestructuredBindings) {
        <span class=
"org-keyword">const</span> { local } = propsDestructuredBindings[key]
        <span class="org-keyword">if</span> (local !== key) {
          bindingMetadata[local] = BindingTypes.PROPS_ALIASED
          ;(bindingMetadata.__propsAliases ||
            (bindingMetadata.__propsAliases = {}))[local] = key
        }
      }
    }
    <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> [key, { isType, imported, source }] <span class="org-keyword">of</span> Object.entries(
      userImports
    )) {
      <span class="org-keyword">if</span> (isType) <span class=
"org-keyword">continue</span>
      bindingMetadata[key] =
        (imported === <span class=
"org-string">'default'</span> &amp;& source.endsWith(<span class=
"org-string">'.vue'</span>)) || source === <span class=
"org-string">'vue'</span>
          ? BindingTypes.SETUP_CONST
          : BindingTypes.SETUP_MAYBE_REF
    }
    <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">in</span> scriptBindings) {
      bindingMetadata[key] = scriptBindings[key]
    }
    <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">in</span> setupBindings) {
      bindingMetadata[key] = setupBindings[key]
    }
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">known ref bindings</span>
    <span class="org-keyword">if</span> (refBindings) {
      <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">of</span> refBindings) {
        bindingMetadata[key] = BindingTypes.SETUP_REF
      }
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">injectUseCssVarsCalls</span>() {
    <span class="org-keyword">if</span> (cssVars.length) {
      helperImports.add(CSS_VARS_HELPER)
      helperImports.add(<span class="org-string">'unref'</span>)
      s.prependRight(
        startOffset,
        <span class=
"org-string">`\n${genCssVarsCode(cssVars, bindingMetadata, scopeId, isProd)}\n`</span>
      )
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">finalizeSetupArgumentSignature</span>() {
    <span class="org-keyword">if</span> (propsTypeDecl) {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">mark as any and only cast on assignment</span>
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">since the user defined complex types may be incompatible with the</span>
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">inferred type from generated runtime declarations</span>
      args += <span class="org-string">`: any`</span>
    }
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">inject user assignment of props</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">we use a default __props so that template expressions referencing props</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">can use it directly</span>
    <span class="org-keyword">if</span> (propsIdentifier) {
      s.prependLeft(
        startOffset,
        <span class=
"org-string">`\nconst ${propsIdentifier} = __props${</span>
<span class=
"org-string">          propsTypeDecl ? `</span> as ${genSetupPropsType(propsTypeDecl)}<span class="org-string">` : ``</span>
<span class="org-string">        }\n`</span>
      )
    }
    <span class="org-keyword">if</span> (propsDestructureRestId) {
      s.prependLeft(
        startOffset,
        <span class=
"org-string">`\nconst ${propsDestructureRestId} = ${helper(</span>
<span class=
"org-string">          `</span>createPropsRestProxy<span class=
"org-string">`</span>
<span class=
"org-string">        )}(__props, ${JSON.stringify(Object.keys(propsDestructuredBindings))})\n`</span>
      )
    }
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">inject temp variables for async context preservation</span>
    <span class="org-keyword">if</span> (hasAwait) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">any</span> = isTS ? <span class=
"org-string">`: any`</span> : <span class="org-string">``</span>
      s.prependLeft(startOffset, <span class=
"org-string">`\nlet __temp${any}, __restore${any}\n`</span>)
    }
  
    <span class="org-keyword">const</span> <span class=
"org-variable-name">destructureElements</span> =
      hasDefineExposeCall || !options.inlineTemplate ? [<span class="org-string">`expose`</span>] : []
    <span class="org-keyword">if</span> (emitIdentifier) {
      destructureElements.push(
        emitIdentifier === <span class=
"org-string">`emit`</span> ? <span class=
"org-string">`emit`</span> : <span class=
"org-string">`emit: ${emitIdentifier}`</span>
      )
    }
    <span class=
"org-keyword">if</span> (destructureElements.length) {
      args += <span class=
"org-string">`, { ${destructureElements.join(', ')} }`</span>
      <span class="org-keyword">if</span> (emitsTypeDecl) {
        args += <span class=
"org-string">`: { emit: (${scriptSetup.content.slice(</span>
<span class="org-string">          emitsTypeDecl.start,</span>
<span class="org-string">          emitsTypeDecl.end</span>
<span class=
"org-string">        )}), expose: any, slots: any, attrs: any }`</span>
      }
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">finalizeSetupArgumentSignature</span>() {
    <span class="org-keyword">if</span> (propsTypeDecl) {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">mark as any and only cast on assignment</span>
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">since the user defined complex types may be incompatible with the</span>
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">inferred type from generated runtime declarations</span>
      args += <span class="org-string">`: any`</span>
    }
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">inject user assignment of props</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">we use a default __props so that template expressions referencing props</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">can use it directly</span>
    <span class="org-keyword">if</span> (propsIdentifier) {
      s.prependLeft(
        startOffset,
        <span class=
"org-string">`\nconst ${propsIdentifier} = __props${</span>
<span class=
"org-string">          propsTypeDecl ? `</span> as ${genSetupPropsType(propsTypeDecl)}<span class="org-string">` : ``</span>
<span class="org-string">        }\n`</span>
      )
    }
    <span class="org-keyword">if</span> (propsDestructureRestId) {
      s.prependLeft(
        startOffset,
        <span class=
"org-string">`\nconst ${propsDestructureRestId} = ${helper(</span>
<span class=
"org-string">          `</span>createPropsRestProxy<span class=
"org-string">`</span>
<span class=
"org-string">        )}(__props, ${JSON.stringify(Object.keys(propsDestructuredBindings))})\n`</span>
      )
    }
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">inject temp variables for async context preservation</span>
    <span class="org-keyword">if</span> (hasAwait) {
      <span class="org-keyword">const</span> <span class=
"org-variable-name">any</span> = isTS ? <span class=
"org-string">`: any`</span> : <span class="org-string">``</span>
      s.prependLeft(startOffset, <span class=
"org-string">`\nlet __temp${any}, __restore${any}\n`</span>)
    }
  
    <span class="org-keyword">const</span> <span class=
"org-variable-name">destructureElements</span> =
      hasDefineExposeCall || !options.inlineTemplate ? [<span class="org-string">`expose`</span>] : []
    <span class="org-keyword">if</span> (emitIdentifier) {
      destructureElements.push(
        emitIdentifier === <span class=
"org-string">`emit`</span> ? <span class=
"org-string">`emit`</span> : <span class=
"org-string">`emit: ${emitIdentifier}`</span>
      )
    }
    <span class=
"org-keyword">if</span> (destructureElements.length) {
      args += <span class=
"org-string">`, { ${destructureElements.join(', ')} }`</span>
      <span class="org-keyword">if</span> (emitsTypeDecl) {
        args += <span class=
"org-string">`: { emit: (${scriptSetup.content.slice(</span>
<span class="org-string">          emitsTypeDecl.start,</span>
<span class="org-string">          emitsTypeDecl.end</span>
<span class=
"org-string">        )}), expose: any, slots: any, attrs: any }`</span>
      }
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">generateReturnStatement</span>() {
    <span class="org-keyword">if</span> (options.inlineTemplate) {
      <span class=
"org-keyword">if</span> (sfc.template &amp;& !sfc.template.src) {
        <span class=
"org-keyword">if</span> (options.templateOptions &amp;& options.templateOptions.ssr) {
          hasInlinedSsrRenderFn = <span class=
"org-constant">true</span>
        }
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">inline render function mode - we are going to compile the template and</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">inline it right here</span>
        <span class=
"org-keyword">const</span> { code, ast, preamble, tips, errors } = compileTemplate({
          filename,
          source: sfc.template.content,
          inMap: sfc.template.map,
          ...options.templateOptions,
          id: scopeId,
          scoped: sfc.styles.some(s =&gt; s.scoped),
          isProd: options.isProd,
          ssrCssVars: sfc.cssVars,
          compilerOptions: {
            ...(options.templateOptions &amp;&
              options.templateOptions.compilerOptions),
            inline: <span class="org-constant">true</span>,
            isTS,
            bindingMetadata
          }
        })
  
        <span class="org-keyword">const</span> <span class=
"org-variable-name">err</span> = errors[<span class=
"org-highlight-numbers-number">0</span>]
        <span class="org-keyword">if</span> (<span class=
"org-keyword">typeof</span> err === <span class=
"org-string">'string'</span>) {
          <span class="org-keyword">throw</span> <span class=
"org-keyword">new</span> <span class="org-type">Error</span>(err)
        } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (err) {
          <span class="org-keyword">if</span> (err.loc) {
            err.message +=
              <span class="org-string">`\n\n`</span> +
              sfc.filename +
              <span class="org-string">'\n'</span> +
              generateCodeFrame(
                source,
                err.loc.start.offset,
                err.loc.end.offset
              ) +
              <span class="org-string">`\n`</span>
          }
          <span class="org-keyword">throw</span> err
        }
        <span class="org-keyword">if</span> (preamble) {
          s.prepend(preamble)
        }
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">avoid duplicated unref import</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">as this may get injected by the render function preamble OR the</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">css vars codegen</span>
        <span class=
"org-keyword">if</span> (ast &amp;& ast.helpers.includes(UNREF)) {
          helperImports.<span class=
"org-keyword">delete</span>(<span class=
"org-string">'unref'</span>)
        }
        returned = code
      } <span class="org-keyword">else</span> {
        returned = <span class="org-string">`() =&gt; {}`</span>
      }
    } <span class="org-keyword">else</span> {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">return bindings from script and script setup</span>
      <span class="org-keyword">const</span> <span class=
"org-variable-name">allBindings</span>= {
        ...scriptBindings,
        ...setupBindings
      }
      <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">in</span> userImports) {
        <span class=
"org-keyword">if</span> (!userImports[key].isType &amp;& userImports[key].isUsedInTemplate) {
          allBindings[key] = <span class="org-constant">true</span>
        }
      }
      returned = <span class=
"org-string">`{ ${Object.keys(allBindings).join(', ')} }`</span>
    }
  
    <span class="org-keyword">if</span> (!options.inlineTemplate) {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">in non-inline mode, the `__isScriptSetup: true` flag is used by</span>
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">componentPublicInstance proxy to allow properties that start with $ or _</span>
      s.appendRight(
        endOffset,
        <span class=
"org-string">`\nconst __returned__ = ${returned}\n`</span> +
          <span class=
"org-string">`Object.defineProperty(__returned__, '__isScriptSetup', { enumerable: false, value: true })\n`</span> +
          <span class="org-string">`return __returned__`</span> +
          <span class="org-string">`\n}\n\n`</span>
      )
    } <span class="org-keyword">else</span> {
      s.appendRight(endOffset, <span class=
"org-string">`\nreturn ${returned}\n}\n\n`</span>)
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">finalizeDefaultExport</span>() {
    <span class="org-keyword">let</span> <span class=
"org-variable-name">runtimeOptions</span> = <span class=
"org-string">``</span>
    <span class="org-keyword">if</span> (hasInlinedSsrRenderFn) {
      runtimeOptions += <span class=
"org-string">`\n  __ssrInlineRender: true,`</span>
    }
    <span class="org-keyword">if</span> (propsRuntimeDecl) {
      <span class="org-keyword">let</span> <span class=
"org-variable-name">declCode</span> = scriptSetup.content
        .slice(propsRuntimeDecl.start, propsRuntimeDecl.end)
        .trim()
      <span class="org-keyword">if</span> (propsDestructureDecl) {
        <span class="org-keyword">const</span> <span class=
"org-variable-name">defaults</span> = []
        <span class="org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">in</span> propsDestructuredBindings) {
          <span class="org-keyword">const</span> <span class=
"org-variable-name">d</span> = genDestructuredDefaultValue(key)
          <span class=
"org-keyword">if</span> (d) defaults.push(<span class=
"org-string">`${key}: ${d}`</span>)
        }
        <span class="org-keyword">if</span> (defaults.length) {
          declCode = <span class="org-string">`${helper(</span>
<span class=
"org-string">            `</span>mergeDefaults<span class=
"org-string">`</span>
<span class=
"org-string">          )}(${declCode}, {\n  ${defaults.join(',\n  ')}\n})`</span>
        }
      }
      runtimeOptions += <span class=
"org-string">`\n  props: ${declCode},`</span>
    } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (propsTypeDecl) {
      runtimeOptions += genRuntimeProps(typeDeclaredProps)
    }
    <span class="org-keyword">if</span> (emitsRuntimeDecl) {
      runtimeOptions += <span class=
"org-string">`\n  emits: ${scriptSetup.content</span>
<span class=
"org-string">        .slice(emitsRuntimeDecl.start, emitsRuntimeDecl.end)</span>
<span class="org-string">        .trim()},`</span>
    } <span class="org-keyword">else</span> <span class=
"org-keyword">if</span> (emitsTypeDecl) {
      runtimeOptions += genRuntimeEmits(typeDeclaredEmits)
    }
  
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">&lt;script setup&gt; components are closed by default. If the user did not</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">explicitly call `defineExpose`, call expose() with no args.</span>
    <span class="org-keyword">const</span> <span class=
"org-variable-name">exposeCall</span> =
      hasDefineExposeCall || options.inlineTemplate ? <span class=
"org-string">``</span> : <span class=
"org-string">`  expose();\n`</span>
    <span class="org-comment-delimiter">// </span><span class=
"org-comment">wrap setup code with function.</span>
    <span class="org-keyword">if</span> (isTS) {
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">for TS, make sure the exported type is still valid type with</span>
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">correct props information</span>
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">we have to use object spread for types to be merged properly</span>
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">user's TS setting should compile it down to proper targets</span>
      <span class="org-comment-delimiter">// </span><span class=
"org-comment">export default defineComponent({ ...__default__, ... })</span>
      <span class="org-keyword">const</span> <span class=
"org-variable-name">def</span> = defaultExport ? <span class=
"org-string">`\n  ...${DEFAULT_VAR},`</span> : <span class=
"org-string">``</span>
      s.prependLeft(
        startOffset,
        <span class=
"org-string">`\nexport default /*#__PURE__*/${helper(</span>
<span class=
"org-string">          `</span>defineComponent<span class=
"org-string">`</span>
<span class=
"org-string">        )}({${def}${runtimeOptions}\n  ${</span>
<span class="org-string">          hasAwait ? `</span><span class=
"org-keyword">async</span> <span class="org-string">` : ``</span>
<span class=
"org-string">        }setup(${args}) {\n${exposeCall}`</span>
      )
      s.appendRight(endOffset, <span class=
"org-string">`})`</span>)
    } <span class="org-keyword">else</span> {
      <span class="org-keyword">if</span> (defaultExport) {
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">without TS, can't rely on rest spread, so we use Object.assign</span>
        <span class="org-comment-delimiter">// </span><span class=
"org-comment">export default Object.assign(__default__, { ... })</span>
        s.prependLeft(
          startOffset,
          <span class=
"org-string">`\nexport default /*#__PURE__*/Object.assign(${DEFAULT_VAR}, {${runtimeOptions}\n  `</span> +
            <span class=
"org-string">`${hasAwait ? `</span><span class=
"org-keyword">async</span> <span class=
"org-string">` : ``}setup(${args}) {\n${exposeCall}`</span>
        )
        s.appendRight(endOffset, <span class=
"org-string">`})`</span>)
      } <span class="org-keyword">else</span> {
        s.prependLeft(
          startOffset,
          <span class=
"org-string">`\nexport default {${runtimeOptions}\n  `</span> +
            <span class=
"org-string">`${hasAwait ? `</span><span class=
"org-keyword">async</span> <span class=
"org-string">` : ``}setup(${args}) {\n${exposeCall}`</span>
        )
        s.appendRight(endOffset, <span class=
"org-string">`}`</span>)
      }
    }
  }
  <span class="org-keyword">function</span> <span class=
"org-function-name">finalizeVueHelperImports</span>() {
    <span class=
"org-keyword">if</span> (helperImports.size &gt; <span class=
"org-highlight-numbers-number">0</span>) {
      s.prepend(
        <span class=
"org-string">`import { ${[...helperImports]</span>
<span class=
"org-string">          .map(h =&gt; `</span>${h} as _${h}<span class="org-string">`)</span>
<span class=
"org-string">          .join(', ')} } from 'vue'\n`</span>
      )
    }
  }

  <span class="org-comment-delimiter">// </span><span class=
"org-comment">1. process normal &lt;script&gt; first if it exists</span>
  <span class="org-keyword">let</span> <span class=
"org-variable-name">scriptAst</span> = processNormalScript()
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">2. parse &lt;script setup&gt; and  walk over top level statements</span>
  <span class="org-keyword">const</span> <span class=
"org-variable-name">scriptSetupAst</span> = processSetupScript()

  <span class="org-comment-delimiter">// </span><span class=
"org-comment">3. Apply reactivity transform</span>
  applyReactivityTransform()
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">4. extract runtime props/emits code from setup context type</span>
  extractRuntimePropsEmits()
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">5. check useOptions args to make sure it doesn't reference setup scope</span>
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">variables</span>
  checkUseOptions()
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">6. remove non-script content</span>
  removeNonScriptContent()
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">7. analyze binding metadata</span>
  analyzeBindingMetadata()
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">8. inject `useCssVars` calls</span>
  injectUseCssVarsCalls()
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">9. finalize setup() argument signature</span>
  <span class="org-keyword">let</span> <span class=
"org-variable-name">args</span> = <span class=
"org-string">`__props`</span>
  finalizeSetupArgumentSignature()
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">10. generate return statement</span>
  <span class="org-keyword">let</span> <span class=
"org-variable-name">returned</span>
  generateReturnStatement()
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">11. finalize default export</span>
  <span class="org-keyword">let</span> <span class=
"org-variable-name">runtimeOptions</span> = <span class=
"org-string">''</span>
  finalizeDefaultExport()
  <span class="org-comment-delimiter">// </span><span class=
"org-comment">12. finalize Vue helper imports</span>
  finalizeVueHelperImports()

  s.trim()

  <span class="org-keyword">return</span> {
    ...scriptSetup,
    bindings: bindingMetadata,
    imports: userImports,
    content: s.toString(),
    map: genSourceMap
      ? (s.generateMap({
          source: filename,
          hires: <span class="org-constant">true</span>,
          includeContent: <span class="org-constant">true</span>
        }))
      : <span class="org-constant">undefined</span>,
    scriptAst: scriptAst?.body,
    scriptSetupAst: scriptSetupAst?.body
  }
}
</pre>
          </div>
        </details>
      </div>
      <div id="outline-container-org8e66a57" class="outline-3">
        <h3 id="org8e66a57"><span class=
        "section-number-3">1.1.</span> compileScript()</h3>
        <div class="outline-text-3" id="text-1-1">
          <div class="org-src-container">
            <pre class="src src-js" id="org1c3e7fb"><span class=
            "linenr">  1: </span>&lt;&lt;compileScript-functions&gt;&gt;
<span class="linenr">  2: </span>&lt;&lt;compileTemplate&gt;&gt;
<span class="linenr">  3: </span>&lt;&lt;sfc-cssVars&gt;&gt;
<span class="linenr">  4: </span>
<span class="linenr">  5: </span><span class=
"org-comment-delimiter">// </span><span class=
"org-comment">Special compiler macros</span>
<span class="linenr">  6: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">DEFINE_PROPS</span> = <span class=
"org-string">'defineProps'</span>
<span class="linenr">  7: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">DEFINE_EMITS</span> = <span class=
"org-string">'defineEmits'</span>
<span class="linenr">  8: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">DEFINE_EXPOSE</span> = <span class=
"org-string">'defineExpose'</span>
<span class="linenr">  9: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">WITH_DEFAULTS</span> = <span class=
"org-string">'withDefaults'</span>
<span class="linenr"> 10: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">templateUsageCheckCache</span> = createCache()
<span class="linenr"> 11: </span>
<span class="linenr"> 12: </span><span class=
"org-comment-delimiter">// </span><span class=
"org-comment">constants</span>
<span class="linenr"> 13: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">DEFAULT_VAR</span> = <span class=
"org-string">`__default__`</span>
<span class="linenr"> 14: </span>
<span class="linenr"> 15: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">isBuiltInDir</span> = makeMap(
<span class="linenr"> 16: </span>  <span class=
"org-string">`once,memo,if,else,else-if,slot,text,html,on,bind,model,show,cloak,is`</span>
<span class="linenr"> 17: </span>)
<span class="linenr"> 18: </span>
<span class="linenr"> 19: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">compileScript</span>(<span class=
"org-variable-name">sfc</span>, <span class=
"org-variable-name">options</span>) {
<span class="linenr"> 20: </span>  <span class=
"org-keyword">let</span> { script, scriptSetup, source, filename } = sfc
<span class="linenr"> 21: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">feature flags</span>
<span class="linenr"> 22: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment"><span class="org-bold"><span class=
"org-warning">TODO</span></span></span><span class=
"org-comment"> remove support for deprecated options when out of experimental</span>
<span class="linenr"> 23: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">enableReactivityTransform</span> =
<span class=
"linenr"> 24: </span>    !!options.reactivityTransform ||
<span class="linenr"> 25: </span>    !!options.refSugar ||
<span class="linenr"> 26: </span>    !!options.refTransform
<span class="linenr"> 27: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">enablePropsTransform</span> =
<span class=
"linenr"> 28: </span>    !!options.reactivityTransform || !!options.propsDestructureTransform
<span class="linenr"> 29: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isProd</span> = !!options.isProd
<span class="linenr"> 30: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">genSourceMap</span> = options.sourceMap !== <span class="org-constant">false</span>
<span class="linenr"> 31: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">ref 声明的变量</span>
<span class="linenr"> 32: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">refBindings</span>
<span class="linenr"> 33: </span>
<span class="linenr"> 34: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">scopeId</span> = options.id ? options.id.replace(<span class="org-string">/^data-v-/</span>, <span class="org-string">''</span>) : <span class="org-string">''</span>
<span class="linenr"> 35: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">cssVars</span> = sfc.cssVars
<span class="linenr"> 36: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">scriptLang</span> = script &amp;& script.lang
<span class="linenr"> 37: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">scriptSetupLang</span> = scriptSetup &amp;& scriptSetup.lang
<span class="linenr"> 38: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isTS</span> =
<span class="linenr"> 39: </span>    scriptLang === <span class=
"org-string">'ts'</span> ||
<span class="linenr"> 40: </span>    scriptLang === <span class=
"org-string">'tsx'</span> ||
<span class=
"linenr"> 41: </span>    scriptSetupLang === <span class=
"org-string">'ts'</span> ||
<span class=
"linenr"> 42: </span>    scriptSetupLang === <span class=
"org-string">'tsx'</span>
<span class="linenr"> 43: </span>
<span class="linenr"> 44: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">resolve parser plugins</span>
<span class="linenr"> 45: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">plugins</span> = []
<span class="linenr"> 46: </span>  <span class=
"org-keyword">if</span> (!isTS || scriptLang === <span class=
"org-string">'tsx'</span> || scriptSetupLang === <span class=
"org-string">'tsx'</span>) {
<span class="linenr"> 47: </span>    plugins.push(<span class=
"org-string">'jsx'</span>)
<span class="linenr"> 48: </span>  }
<span class="linenr"> 49: </span>  <span class=
"org-keyword">if</span> (options.babelParserPlugins) plugins.push(...options.babelParserPlugins)
<span class="linenr"> 50: </span>  <span class=
"org-keyword">if</span> (isTS) plugins.push(<span class=
"org-string">'typescript'</span>, <span class=
"org-string">'decorators-legacy'</span>)
<span class="linenr"> 51: </span>
<span class="linenr"> 52: </span>  <span class=
"org-keyword">if</span> (!scriptSetup) {
<span class="linenr"> 53: </span>    <span class=
"org-keyword">if</span> (!script) {
<span class="linenr"> 54: </span>      <span class=
"org-keyword">throw</span> <span class=
"org-keyword">new</span> <span class=
"org-type">Error</span>(<span class=
"org-string">`[@vue/compiler-sfc] SFC contains no &lt;script&gt; tags.`</span>)
<span class="linenr"> 55: </span>    }
<span class="linenr"> 56: </span>    <span class=
"org-keyword">if</span> (scriptLang &amp;& !isTS &amp;& scriptLang !== <span class="org-string">'jsx'</span>) {
<span class="linenr"> 57: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">do not process non js/ts script blocks</span>
<span class="linenr"> 58: </span>      <span class=
"org-keyword">return</span> script
<span class="linenr"> 59: </span>    }
<span class="linenr"> 60: </span>    <span class=
"org-keyword">try</span> {
<span class="linenr"> 61: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">content</span> = script.content
<span class="linenr"> 62: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">map</span> = script.map
<span class="linenr"> 63: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">scriptAst</span> = babelParser.parse(content, {
<span class="linenr"> 64: </span>        plugins,
<span class="linenr"> 65: </span>        sourceType: <span class=
"org-string">'module'</span>
<span class="linenr"> 66: </span>      }).program
<span class="linenr"> 67: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">bindings</span> = analyzeScriptBindings(scriptAst.body)
<span class="linenr"> 68: </span>      <span class=
"org-keyword">if</span> (enableReactivityTransform &amp;& RT.shouldTransform(content)) {
<span class="linenr"> 69: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">s</span> = <span class=
"org-keyword">new</span> <span class=
"org-type">MagicString</span>(source)
<span class="linenr"> 70: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">startOffset</span> = script.loc.start.offset
<span class="linenr"> 71: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">endOffset</span> = script.loc.end.offset
<span class="linenr"> 72: </span>        <span class=
"org-keyword">const</span> { importedHelpers } = RT.transformAST(scriptAst, s, startOffset)
<span class="linenr"> 73: </span>        <span class=
"org-keyword">if</span> (importedHelpers.length) {
<span class="linenr"> 74: </span>          s.prepend(
<span class="linenr"> 75: </span>            <span class=
"org-string">`import { ${importedHelpers</span>
<span class="linenr"> 76: </span><span class=
"org-string">              .map(h =&gt; `</span>${h} as _${h}<span class="org-string">`)</span>
<span class="linenr"> 77: </span><span class=
"org-string">              .join(', ')} } from 'vue'\n`</span>
<span class="linenr"> 78: </span>          )
<span class="linenr"> 79: </span>        }
<span class="linenr"> 80: </span>        s.remove(<span class=
"org-highlight-numbers-number">0</span>, startOffset)
<span class=
"linenr"> 81: </span>        s.remove(endOffset, source.length)
<span class="linenr"> 82: </span>        content = s.toString()
<span class="linenr"> 83: </span>        <span class=
"org-keyword">if</span> (genSourceMap) {
<span class="linenr"> 84: </span>          map = s.generateMap({
<span class="linenr"> 85: </span>            source: filename,
<span class="linenr"> 86: </span>            hires: <span class=
"org-constant">true</span>,
<span class=
"linenr"> 87: </span>            includeContent: <span class=
"org-constant">true</span>
<span class="linenr"> 88: </span>          })
<span class="linenr"> 89: </span>        }
<span class="linenr"> 90: </span>      }
<span class="linenr"> 91: </span>      <span class=
"org-keyword">if</span> (cssVars.length) {
<span class=
"linenr"> 92: </span>        content = rewriteDefault(content, DEFAULT_VAR, plugins)
<span class=
"linenr"> 93: </span>        content += genNormalScriptCssVarsCode(
<span class="linenr"> 94: </span>          cssVars,
<span class="linenr"> 95: </span>          bindings,
<span class="linenr"> 96: </span>          scopeId,
<span class="linenr"> 97: </span>          isProd
<span class="linenr"> 98: </span>        )
<span class="linenr"> 99: </span>        content += <span class=
"org-string">`\nexport default ${DEFAULT_VAR}`</span>
<span class="linenr">100: </span>      }
<span class="linenr">101: </span>      <span class=
"org-keyword">return</span> {
<span class="linenr">102: </span>        ...script,
<span class="linenr">103: </span>        content,
<span class="linenr">104: </span>        map,
<span class="linenr">105: </span>        bindings,
<span class="linenr">106: </span>        scriptAst: scriptAst.body
<span class="linenr">107: </span>      }
<span class="linenr">108: </span>    } <span class=
"org-keyword">catch</span> (e) {
<span class="linenr">109: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">silently fallback if parse fails since user may be using custom</span>
<span class="linenr">110: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">babel syntax</span>
<span class="linenr">111: </span>      <span class=
"org-keyword">return</span> script
<span class="linenr">112: </span>    }
<span class="linenr">113: </span>  }
<span class="linenr">114: </span>
<span class="linenr">115: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">script 和 script setup 的语言必须一致</span>
<span class="linenr">116: </span>  <span class=
"org-keyword">if</span> (script &amp;& scriptLang !== scriptSetupLang) {
<span class="linenr">117: </span>    <span class=
"org-keyword">throw</span> <span class=
"org-keyword">new</span> <span class="org-type">Error</span>(
<span class="linenr">118: </span>      <span class=
"org-string">`[@vue/compiler-sfc] &lt;script&gt; and &lt;script setup&gt; must have the same `</span> +
<span class="linenr">119: </span>        <span class=
"org-string">`language type.`</span>
<span class="linenr">120: </span>    )
<span class="linenr">121: </span>  }
<span class="linenr">122: </span>
<span class="linenr">123: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">只处理 js/ts script</span>
<span class="linenr">124: </span>  <span class=
"org-keyword">if</span> (scriptSetupLang &amp;& !isTS &amp;& scriptSetupLang !== <span class="org-string">'jsx'</span>) {
<span class="linenr">125: </span>    <span class=
"org-keyword">return</span> scriptSetup
<span class="linenr">126: </span>  }
<span class="linenr">127: </span>
<span class="linenr">128: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">变量，imports 都需要导出</span>
<span class="linenr">129: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">bindingMetadata</span> = {}
<span class="linenr">130: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">helperImports</span> = <span class=
"org-keyword">new</span> <span class="org-type">Set</span>()
<span class="linenr">131: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">userImports</span> = Object.create(<span class=
"org-constant">null</span>)
<span class="linenr">132: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">userImportAlias</span> = Object.create(<span class="org-constant">null</span>)
<span class="linenr">133: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">scriptBindings</span> = Object.create(<span class="org-constant">null</span>)
<span class="linenr">134: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">setupBindings</span> = Object.create(<span class="org-constant">null</span>)
<span class="linenr">135: </span>
<span class="linenr">136: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">defaultExport</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">export default</span>
<span class="linenr">137: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">hasDefinePropsCall</span> = <span class=
"org-constant">false</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">defineProps()</span>
<span class="linenr">138: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">hasDefineEmitCall</span> = <span class=
"org-constant">false</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">defineEmits()</span>
<span class="linenr">139: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">hasDefineExposeCall</span> = <span class=
"org-constant">false</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">defineExpose()</span>
<span class="linenr">140: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">propsRuntimeDecl</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">属性声明</span>
<span class="linenr">141: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">propsRuntimeDefaults</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">属性默认值</span>
<span class="linenr">142: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">propsDestructureDecl</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">属性解构声明</span>
<span class="linenr">143: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">propsDestructureRestId</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">属性解构的 ... 符号</span>
<span class="linenr">144: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">propsTypeDecl</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">属性类型声明</span>
<span class="linenr">145: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">propsTypeDeclRaw</span>
<span class="linenr">146: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">propsIdentifier</span>
<span class="linenr">147: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">emitsRuntimeDecl</span>
<span class="linenr">148: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">emitsTypeDecl</span>
<span class="linenr">149: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">emitsTypeDeclRaw</span>
<span class="linenr">150: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">emitIdentifier</span>
<span class="linenr">151: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">hasAwait</span> = <span class=
"org-constant">false</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">有没 await 符号，如果有则会转成 async setup</span>
<span class="linenr">152: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">hasInlinedSsrRenderFn</span> = <span class=
"org-constant">false</span>
<span class="linenr">153: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">props/emits declared via types</span>
<span class="linenr">154: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">typeDeclaredProps</span> = {}
<span class="linenr">155: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">typeDeclaredEmits</span> = <span class=
"org-keyword">new</span> <span class="org-type">Set</span>()
<span class="linenr">156: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">record declared types for runtime props type generation</span>
<span class="linenr">157: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">declaredTypes</span> = {}
<span class="linenr">158: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">props destructure data</span>
<span class="linenr">159: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">propsDestructuredBindings</span> = Object.create(<span class="org-constant">null</span>)
<span class="linenr">160: </span>
<span class="linenr">161: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">magic-string state</span>
<span class="linenr">162: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">s</span> = <span class=
"org-keyword">new</span> <span class=
"org-type">MagicString</span>(source)
<span class="linenr">163: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">startOffset</span> = scriptSetup.loc.start.offset
<span class="linenr">164: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">endOffset</span> = scriptSetup.loc.end.offset
<span class="linenr">165: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">scriptStartOffset</span> = script &amp;& script.loc.start.offset
<span class="linenr">166: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">scriptEndOffset</span> = script &amp;& script.loc.end.offset
<span class="linenr">167: </span>
<span class=
"linenr">168: </span>  &lt;&lt;compileScript-utils&gt;&gt;
<span class=
"linenr">169: </span>  &lt;&lt;compileScript-steps&gt;&gt;
<span class="linenr">170: </span>
<span class="linenr">171: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">1. process normal &lt;script&gt; first if it exists</span>
<span class="linenr">172: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">scriptAst</span> = processNormalScript()
<span class="linenr">173: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">2. parse &lt;script setup&gt; and  walk over top level statements</span>
<span class="linenr">174: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">scriptSetupAst</span> = processSetupScript()
<span class="linenr">175: </span>
<span class="linenr">176: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">3. Apply reactivity transform</span>
<span class="linenr">177: </span>  applyReactivityTransform()
<span class="linenr">178: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">4. extract runtime props/emits code from setup context type</span>
<span class="linenr">179: </span>  extractRuntimePropsEmits()
<span class="linenr">180: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">5. check useOptions args to make sure it doesn't reference setup scope</span>
<span class="linenr">181: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">variables</span>
<span class="linenr">182: </span>  checkUseOptions()
<span class="linenr">183: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">6. remove non-script content</span>
<span class="linenr">184: </span>  removeNonScriptContent()
<span class="linenr">185: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">7. analyze binding metadata</span>
<span class="linenr">186: </span>  analyzeBindingMetadata()
<span class="linenr">187: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">8. inject `useCssVars` calls</span>
<span class="linenr">188: </span>  injectUseCssVarsCalls()
<span class="linenr">189: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">9. finalize setup() argument signature</span>
<span class="linenr">190: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">args</span> = <span class=
"org-string">`__props`</span>
<span class="linenr">191: </span>  finalizeSetupArgumentSignature()
<span class="linenr">192: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">10. generate return statement</span>
<span class="linenr">193: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">returned</span>
<span class="linenr">194: </span>  generateReturnStatement()
<span class="linenr">195: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">11. finalize default export</span>
<span class="linenr">196: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">runtimeOptions</span> = <span class=
"org-string">''</span>
<span class="linenr">197: </span>  finalizeDefaultExport()
<span class="linenr">198: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">12. finalize Vue helper imports</span>
<span class="linenr">199: </span>  finalizeVueHelperImports()
<span class="linenr">200: </span>
<span class="linenr">201: </span>  s.trim()
<span class="linenr">202: </span>
<span class="linenr">203: </span>  <span class=
"org-keyword">return</span> {
<span class="linenr">204: </span>    ...scriptSetup,
<span class="linenr">205: </span>    bindings: bindingMetadata,
<span class="linenr">206: </span>    imports: userImports,
<span class="linenr">207: </span>    content: s.toString(),
<span class="linenr">208: </span>    map: genSourceMap
<span class="linenr">209: </span>      ? (s.generateMap({
<span class="linenr">210: </span>          source: filename,
<span class="linenr">211: </span>          hires: <span class=
"org-constant">true</span>,
<span class=
"linenr">212: </span>          includeContent: <span class=
"org-constant">true</span>
<span class="linenr">213: </span>        }))
<span class="linenr">214: </span>      : <span class=
"org-constant">undefined</span>,
<span class="linenr">215: </span>    scriptAst: scriptAst?.body,
<span class=
"linenr">216: </span>    scriptSetupAst: scriptSetupAst?.body
<span class="linenr">217: </span>  }
<span class="linenr">218: </span>}
</pre>
          </div>
          <p>这个函数是用来编译 SFC 文件中 <code>&lt;script&gt;</code> 和
          <code>&lt;script setup&gt;</code> 中代码的，内容很多，主要 分为了 12
          个步聚完成，这里为了简化这个函数，会将这 12 步拆分成 12 个单独的函数。</p>
        </div>
      </div>
      <div id="outline-container-org7c93f4f" class="outline-3">
        <h3 id="org7c93f4f"><span class=
        "section-number-3">1.2.</span> utils</h3>
        <div class="outline-text-3" id="text-1-2">
          <div class="org-src-container">
            <pre class="src src-js" id="orgedfbc93"><span class=
            "linenr"> 1: </span>&lt;&lt;cs-u-helper&gt;&gt;
<span class="linenr"> 2: </span>&lt;&lt;cs-u-parse&gt;&gt;
<span class="linenr"> 3: </span>&lt;&lt;cs-u-error&gt;&gt;
<span class=
"linenr"> 4: </span>&lt;&lt;cs-u-registerUserImport&gt;&gt;
<span class=
"linenr"> 5: </span>&lt;&lt;cs-u-processDefineProps&gt;&gt;
<span class=
"linenr"> 6: </span>&lt;&lt;cs-u-processWithDefaults&gt;&gt;
<span class=
"linenr"> 7: </span>&lt;&lt;cs-u-processDefineEmits&gt;&gt;
<span class=
"linenr"> 8: </span>&lt;&lt;cs-u-resolveQualifiedType&gt;&gt;
<span class=
"linenr"> 9: </span>&lt;&lt;cs-u-processDefineExpose&gt;&gt;
<span class=
"linenr">10: </span>&lt;&lt;cs-u-checkInvalidScopeReference&gt;&gt;
<span class="linenr">11: </span>&lt;&lt;cs-u-processAwait&gt;&gt;
<span class=
"linenr">12: </span>&lt;&lt;cs-u-hasStaticWithDefaults&gt;&gt;
<span class=
"linenr">13: </span>&lt;&lt;cs-u-genRuntimeProps&gt;&gt;
<span class=
"linenr">14: </span>&lt;&lt;cs-u-genDestructuredDefaultValue&gt;&gt;
<span class=
"linenr">15: </span>&lt;&lt;cs-u-genSetupPropsType&gt;&gt;
</pre>
          </div>
        </div>
        <div id="outline-container-orgecdf7a7" class="outline-4">
          <h4 id="orgecdf7a7"><span class=
          "section-number-4">1.2.1.</span> helper()</h4>
          <div class="outline-text-4" id="text-1-2-1">
            <div class="org-src-container">
              <pre class="src src-js" id="orgcd70e83"><span class=
              "linenr">1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">helper</span>(<span class=
              "org-variable-name">key</span>) {
<span class="linenr">2: </span>  helperImports.add(key)
<span class="linenr">3: </span>  <span class=
"org-keyword">return</span> <span class=
"org-string">`_${key}`</span>
<span class="linenr">4: </span>}
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-org9b5560e" class="outline-4">
          <h4 id="org9b5560e"><span class=
          "section-number-4">1.2.2.</span> parse()</h4>
          <div class="outline-text-4" id="text-1-2-2">
            <div class="org-src-container">
              <pre class="src src-js" id="org022c896"><span class=
              "linenr"> 1: </span>  <span class=
              "org-keyword">function</span> <span class=
              "org-function-name">parse</span>(<span class=
              "org-variable-name">input</span>, <span class=
              "org-variable-name">options</span>, <span class=
              "org-variable-name">offset</span>) {
<span class="linenr"> 2: </span>    <span class=
"org-keyword">try</span> {
<span class="linenr"> 3: </span>      <span class=
"org-keyword">return</span> babelParser.parse(input, options).program
<span class="linenr"> 4: </span>    } <span class=
"org-keyword">catch</span> (e) {
<span class="linenr"> 5: </span>      e.message = <span class=
"org-string">`[@vue/compiler-sfc] ${e.message}\n\n${</span>
<span class="linenr"> 6: </span><span class=
"org-string">        sfc.filename</span>
<span class="linenr"> 7: </span><span class=
"org-string">      }\n${generateCodeFrame(source, e.pos + offset, e.pos + offset + 1)}`</span>
<span class="linenr"> 8: </span>      <span class=
"org-keyword">throw</span> e
<span class="linenr"> 9: </span>    }
<span class="linenr">10: </span>  }
<span class="linenr">11: </span>
<span class="linenr">12: </span>
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-org9e4efbb" class="outline-4">
          <h4 id="org9e4efbb"><span class=
          "section-number-4">1.2.3.</span> error()</h4>
          <div class="outline-text-4" id="text-1-2-3">
            <div class="org-src-container">
              <pre class="src src-js" id="org90122ec"><span class=
              "linenr">1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">error</span>(<span class=
              "org-variable-name">msg</span>, <span class=
              "org-variable-name">node</span>, <span class=
              "org-variable-name">end</span> = <span class=
              "org-variable-name">node</span>.<span class=
              "org-variable-name">end</span> + <span class=
              "org-variable-name">startOffset</span>) {
<span class="linenr">2: </span>  <span class=
"org-keyword">throw</span> <span class=
"org-keyword">new</span> <span class="org-type">Error</span>(
<span class="linenr">3: </span>    <span class=
"org-string">`[@vue/compiler-sfc] ${msg}\n\n${sfc.filename}\n${generateCodeFrame(</span>
<span class="linenr">4: </span><span class=
"org-string">    source,</span>
<span class="linenr">5: </span><span class=
"org-string">    node.start + startOffset,</span>
<span class="linenr">6: </span><span class=
"org-string">    end</span>
<span class="linenr">7: </span><span class=
"org-string">    )}`</span>
<span class="linenr">8: </span>  )
<span class="linenr">9: </span>}
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-org45020fa" class="outline-4">
          <h4 id="org45020fa"><span class=
          "section-number-4">1.2.4.</span>
          registerUserImport()</h4>
          <div class="outline-text-4" id="text-1-2-4">
            <div class="org-src-container">
              <pre class="src src-js" id="org6409e3b"><span class=
              "linenr"> 1: </span>  <span class=
              "org-keyword">function</span> <span class=
              "org-function-name">registerUserImport</span>(<span class=
              "org-variable-name">source</span>, <span class=
              "org-variable-name">local</span>, <span class=
              "org-variable-name">imported</span>, <span class=
              "org-variable-name">isType</span>, <span class=
              "org-variable-name">isFromSetup</span>) {
<span class="linenr"> 2: </span>    <span class=
"org-keyword">if</span> (source === <span class=
"org-string">'vue'</span> &amp;& imported) {
<span class=
"linenr"> 3: </span>      userImportAlias[imported] = local
<span class="linenr"> 4: </span>    }
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">isUsedInTemplate</span> = <span class=
"org-constant">true</span>
<span class="linenr"> 7: </span>    <span class=
"org-keyword">if</span> (isTS &amp;& sfc.template &amp;& !sfc.template.src &amp;& !sfc.template.lang) {
<span class=
"linenr"> 8: </span>      isUsedInTemplate = isImportUsed(local, sfc)
<span class="linenr"> 9: </span>    }
<span class="linenr">10: </span>
<span class="linenr">11: </span>    userImports[local] = {
<span class="linenr">12: </span>      isType,
<span class=
"linenr">13: </span>      imported: imported || <span class=
"org-string">'default'</span>,
<span class="linenr">14: </span>      source,
<span class="linenr">15: </span>      isFromSetup,
<span class="linenr">16: </span>      isUsedInTemplate
<span class="linenr">17: </span>    }
<span class="linenr">18: </span>  }
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-orga539d5f" class="outline-4">
          <h4 id="orga539d5f"><span class=
          "section-number-4">1.2.5.</span>
          processDefineProps()</h4>
          <div class="outline-text-4" id="text-1-2-5">
            <p>TODO 使用场景：</p>
            <ol class="org-ol">
              <li>不能重复调用 <code>defineProps()</code></li>
              <li>不能同时使用类型和非类型参数</li>
              <li>类型参数必须是字面量类型</li>
              <li>解构后的变量命名不能使用 <code>computed</code> 做为名字</li>
              <li>解构不支持嵌套使用</li>
            </ol>
            <div class="org-src-container">
              <pre class="src src-js" id="org7630928"><span class=
              "linenr"> 1: </span>
<span class="linenr"> 2: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">processDefineProps</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">declId</span>) {
<span class="linenr"> 3: </span>    <span class=
"org-keyword">if</span> (!isCallOf(node, DEFINE_PROPS)) {
<span class="linenr"> 4: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr"> 5: </span>    }
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>    <span class=
"org-keyword">if</span> (hasDefinePropsCall) {
<span class="linenr"> 8: </span>      error(<span class=
"org-string">`duplicate ${DEFINE_PROPS}() call`</span>, node)
<span class="linenr"> 9: </span>    }
<span class=
"linenr">10: </span>    hasDefinePropsCall = <span class=
"org-constant">true</span>
<span class="linenr">11: </span>
<span class=
"linenr">12: </span>    propsRuntimeDecl = node.<span class=
"org-constant">arguments</span>[<span class=
"org-highlight-numbers-number">0</span>]
<span class="linenr">13: </span>
<span class="linenr">14: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">call has type parameters - infer runtime types from it</span>
<span class="linenr">15: </span>    <span class=
"org-keyword">if</span> (node.typeParameters) {
<span class="linenr">16: </span>      <span class=
"org-keyword">if</span> (propsRuntimeDecl) {
<span class="linenr">17: </span>        error(
<span class="linenr">18: </span>          <span class=
"org-string">`${DEFINE_PROPS}() cannot accept both type and non-type arguments `</span> +
<span class="linenr">19: </span>            <span class=
"org-string">`at the same time. Use one or the other.`</span>,
<span class="linenr">20: </span>          node
<span class="linenr">21: </span>        )
<span class="linenr">22: </span>      }
<span class="linenr">23: </span>
<span class=
"linenr">24: </span>      propsTypeDeclRaw = node.typeParameters.params[<span class="org-highlight-numbers-number">0</span>]
<span class=
"linenr">25: </span>      propsTypeDecl = resolveQualifiedType(
<span class="linenr">26: </span>        propsTypeDeclRaw,
<span class=
"linenr">27: </span>        node =&gt; node.type === <span class=
"org-string">'TSTypeLiteral'</span>
<span class="linenr">28: </span>      )
<span class="linenr">29: </span>
<span class="linenr">30: </span>      <span class=
"org-keyword">if</span> (!propsTypeDecl) {
<span class="linenr">31: </span>        error(
<span class="linenr">32: </span>          <span class=
"org-string">`type argument passed to ${DEFINE_PROPS}() must be a literal type, `</span> +
<span class="linenr">33: </span>            <span class=
"org-string">`or a reference to an interface or literal type.`</span>,
<span class="linenr">34: </span>          propsTypeDeclRaw
<span class="linenr">35: </span>        )
<span class="linenr">36: </span>      }
<span class="linenr">37: </span>    }
<span class="linenr">38: </span>
<span class="linenr">39: </span>    <span class=
"org-keyword">if</span> (declId) {
<span class="linenr">40: </span>      <span class=
"org-keyword">if</span> (enablePropsTransform &amp;& declId.type === <span class="org-string">'ObjectPattern'</span>) {
<span class=
"linenr">41: </span>        propsDestructureDecl = declId
<span class="linenr">42: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">props destructure - handle compilation sugar</span>
<span class="linenr">43: </span>        <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">prop</span> <span class=
"org-keyword">of</span> declId.properties) {
<span class="linenr">44: </span>          <span class=
"org-keyword">if</span> (prop.type === <span class=
"org-string">'ObjectProperty'</span>) {
<span class="linenr">45: </span>            <span class=
"org-keyword">if</span> (prop.computed) {
<span class="linenr">46: </span>              error(
<span class="linenr">47: </span>                <span class=
"org-string">`${DEFINE_PROPS}() destructure cannot use computed key.`</span>,
<span class="linenr">48: </span>                prop.key
<span class="linenr">49: </span>              )
<span class="linenr">50: </span>            }
<span class="linenr">51: </span>            <span class=
"org-keyword">const</span> <span class=
"org-variable-name">propKey</span> = prop.key.name
<span class="linenr">52: </span>            <span class=
"org-keyword">if</span> (prop.value.type === <span class=
"org-string">'AssignmentPattern'</span>) {
<span class="linenr">53: </span>              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">default value { foo = 123 }</span>
<span class="linenr">54: </span>              <span class=
"org-keyword">const</span> { left, right } = prop.value
<span class="linenr">55: </span>              <span class=
"org-keyword">if</span> (left.type !== <span class=
"org-string">'Identifier'</span>) {
<span class="linenr">56: </span>                error(
<span class="linenr">57: </span>                  <span class=
"org-string">`${DEFINE_PROPS}() destructure does not support nested patterns.`</span>,
<span class="linenr">58: </span>                  left
<span class="linenr">59: </span>                )
<span class="linenr">60: </span>              }
<span class="linenr">61: </span>              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">store default value</span>
<span class=
"linenr">62: </span>              propsDestructuredBindings[propKey] = {
<span class="linenr">63: </span>                local: left.name,
<span class="linenr">64: </span>                <span class=
"org-keyword">default</span>: right
<span class="linenr">65: </span>              }
<span class="linenr">66: </span>            } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (prop.value.type === <span class=
"org-string">'Identifier'</span>) {
<span class="linenr">67: </span>              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">simple destructure</span>
<span class=
"linenr">68: </span>              propsDestructuredBindings[propKey] = {
<span class=
"linenr">69: </span>                local: prop.value.name
<span class="linenr">70: </span>              }
<span class="linenr">71: </span>            } <span class=
"org-keyword">else</span> {
<span class="linenr">72: </span>              error(
<span class="linenr">73: </span>                <span class=
"org-string">`${DEFINE_PROPS}() destructure does not support nested patterns.`</span>,
<span class="linenr">74: </span>                prop.value
<span class="linenr">75: </span>              )
<span class="linenr">76: </span>            }
<span class="linenr">77: </span>          } <span class=
"org-keyword">else</span> {
<span class="linenr">78: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">rest spread</span>
<span class=
"linenr">79: </span>            propsDestructureRestId = prop.argument.name
<span class="linenr">80: </span>          }
<span class="linenr">81: </span>        }
<span class="linenr">82: </span>      } <span class=
"org-keyword">else</span> {
<span class=
"linenr">83: </span>        propsIdentifier = scriptSetup.content.slice(declId.start, declId.end)
<span class="linenr">84: </span>      }
<span class="linenr">85: </span>    }
<span class="linenr">86: </span>
<span class="linenr">87: </span>    <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr">88: </span>  }
<span class="linenr">89: </span>
<span class="linenr">90: </span>
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-org21c5d19" class="outline-4">
          <h4 id="org21c5d19"><span class=
          "section-number-4">1.2.6.</span>
          processWithDefaults()</h4>
          <div class="outline-text-4" id="text-1-2-6">
            <p>处理带默认值的 props.</p>
            <div class="org-src-container">
              <pre class="src src-js" id="org1ae55b6"><span class=
              "linenr"> 1: </span>  <span class=
              "org-keyword">function</span> <span class=
              "org-function-name">processWithDefaults</span>(<span class=
              "org-variable-name">node</span>, <span class=
              "org-variable-name">declId</span>) {
<span class="linenr"> 2: </span>    <span class=
"org-keyword">if</span> (!isCallOf(node, WITH_DEFAULTS)) {
<span class="linenr"> 3: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr"> 4: </span>    }
<span class="linenr"> 5: </span>    <span class=
"org-keyword">if</span> (processDefineProps(node.<span class=
"org-constant">arguments</span>[<span class=
"org-highlight-numbers-number">0</span>], declId)) {
<span class="linenr"> 6: </span>      <span class=
"org-keyword">if</span> (propsRuntimeDecl) {
<span class="linenr"> 7: </span>        error(
<span class="linenr"> 8: </span>          <span class=
"org-string">`${WITH_DEFAULTS} can only be used with type-based `</span> +
<span class="linenr"> 9: </span>            <span class=
"org-string">`${DEFINE_PROPS} declaration.`</span>,
<span class="linenr">10: </span>          node
<span class="linenr">11: </span>        )
<span class="linenr">12: </span>      }
<span class="linenr">13: </span>      <span class=
"org-keyword">if</span> (propsDestructureDecl) {
<span class="linenr">14: </span>        error(
<span class="linenr">15: </span>          <span class=
"org-string">`${WITH_DEFAULTS}() is unnecessary when using destructure with ${DEFINE_PROPS}().\n`</span> +
<span class="linenr">16: </span>            <span class=
"org-string">`Prefer using destructure default values, e.g. const { foo = 1 } = defineProps(...).`</span>,
<span class="linenr">17: </span>          node.callee
<span class="linenr">18: </span>        )
<span class="linenr">19: </span>      }
<span class=
"linenr">20: </span>      propsRuntimeDefaults = node.<span class=
"org-constant">arguments</span>[<span class=
"org-highlight-numbers-number">1</span>]
<span class="linenr">21: </span>      <span class=
"org-keyword">if</span> (
<span class="linenr">22: </span>        !propsRuntimeDefaults ||
<span class=
"linenr">23: </span>        propsRuntimeDefaults.type !== <span class="org-string">'ObjectExpression'</span>
<span class="linenr">24: </span>      ) {
<span class="linenr">25: </span>        error(
<span class="linenr">26: </span>          <span class=
"org-string">`The 2nd argument of ${WITH_DEFAULTS} must be an object literal.`</span>,
<span class=
"linenr">27: </span>          propsRuntimeDefaults || node
<span class="linenr">28: </span>        )
<span class="linenr">29: </span>      }
<span class="linenr">30: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr">31: </span>      error(
<span class="linenr">32: </span>        <span class=
"org-string">`${WITH_DEFAULTS}' first argument must be a ${DEFINE_PROPS} call.`</span>,
<span class="linenr">33: </span>        node.<span class=
"org-constant">arguments</span>[<span class=
"org-highlight-numbers-number">0</span>] || node
<span class="linenr">34: </span>      )
<span class="linenr">35: </span>    }
<span class="linenr">36: </span>    <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr">37: </span>  }
<span class="linenr">38: </span>
<span class="linenr">39: </span>
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-orgfc31448" class="outline-4">
          <h4 id="orgfc31448"><span class=
          "section-number-4">1.2.7.</span>
          processDefineEmits()</h4>
          <div class="outline-text-4" id="text-1-2-7">
            <div class="org-src-container">
              <pre class="src src-js" id="org024f099"><span class=
              "linenr"> 1: </span>
<span class="linenr"> 2: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">processDefineEmits</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">declId</span>) {
<span class="linenr"> 3: </span>    <span class=
"org-keyword">if</span> (!isCallOf(node, DEFINE_EMITS)) {
<span class="linenr"> 4: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr"> 5: </span>    }
<span class="linenr"> 6: </span>    <span class=
"org-keyword">if</span> (hasDefineEmitCall) {
<span class="linenr"> 7: </span>      error(<span class=
"org-string">`duplicate ${DEFINE_EMITS}() call`</span>, node)
<span class="linenr"> 8: </span>    }
<span class=
"linenr"> 9: </span>    hasDefineEmitCall = <span class="org-constant">true</span>
<span class=
"linenr">10: </span>    emitsRuntimeDecl = node.<span class=
"org-constant">arguments</span>[<span class=
"org-highlight-numbers-number">0</span>]
<span class="linenr">11: </span>    <span class=
"org-keyword">if</span> (node.typeParameters) {
<span class="linenr">12: </span>      <span class=
"org-keyword">if</span> (emitsRuntimeDecl) {
<span class="linenr">13: </span>        error(
<span class="linenr">14: </span>          <span class=
"org-string">`${DEFINE_EMITS}() cannot accept both type and non-type arguments `</span> +
<span class="linenr">15: </span>            <span class=
"org-string">`at the same time. Use one or the other.`</span>,
<span class="linenr">16: </span>          node
<span class="linenr">17: </span>        )
<span class="linenr">18: </span>      }
<span class="linenr">19: </span>
<span class=
"linenr">20: </span>      emitsTypeDeclRaw = node.typeParameters.params[<span class="org-highlight-numbers-number">0</span>]
<span class=
"linenr">21: </span>      emitsTypeDecl = resolveQualifiedType(
<span class="linenr">22: </span>        emitsTypeDeclRaw,
<span class=
"linenr">23: </span>        node =&gt; node.type === <span class=
"org-string">'TSFunctionType'</span> || node.type === <span class=
"org-string">'TSTypeLiteral'</span>
<span class="linenr">24: </span>      )
<span class="linenr">25: </span>
<span class="linenr">26: </span>      <span class=
"org-keyword">if</span> (!emitsTypeDecl) {
<span class="linenr">27: </span>        error(
<span class="linenr">28: </span>          <span class=
"org-string">`type argument passed to ${DEFINE_EMITS}() must be a function type, `</span> +
<span class="linenr">29: </span>            <span class=
"org-string">`a literal type with call signatures, or a reference to the above types.`</span>,
<span class="linenr">30: </span>          emitsTypeDeclRaw
<span class="linenr">31: </span>        )
<span class="linenr">32: </span>      }
<span class="linenr">33: </span>    }
<span class="linenr">34: </span>
<span class="linenr">35: </span>    <span class=
"org-keyword">if</span> (declId) {
<span class=
"linenr">36: </span>      emitIdentifier = scriptSetup.content.slice(declId.start, declId.end)
<span class="linenr">37: </span>    }
<span class="linenr">38: </span>
<span class="linenr">39: </span>    <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr">40: </span>  }
<span class="linenr">41: </span>
<span class="linenr">42: </span>
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-org68971eb" class="outline-4">
          <h4 id="org68971eb"><span class=
          "section-number-4">1.2.8.</span>
          resolveQualifiedType()</h4>
          <div class="outline-text-4" id="text-1-2-8">
            <div class="org-src-container">
              <pre class="src src-js" id="org563e689"><span class=
              "linenr"> 1: </span>
<span class="linenr"> 2: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">resolveQualifiedType</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">qualifier</span>) {
<span class="linenr"> 3: </span>    <span class=
"org-keyword">if</span> (qualifier(node)) {
<span class="linenr"> 4: </span>      <span class=
"org-keyword">return</span> node
<span class="linenr"> 5: </span>    }
<span class="linenr"> 6: </span>    <span class=
"org-keyword">if</span> (
<span class="linenr"> 7: </span>      node.type === <span class=
"org-string">'TSTypeReference'</span> &amp;&
<span class=
"linenr"> 8: </span>      node.typeName.type === <span class=
"org-string">'Identifier'</span>
<span class="linenr"> 9: </span>    ) {
<span class="linenr">10: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">refName</span> = node.typeName.name
<span class="linenr">11: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isQualifiedType</span> = (node) =&gt; {
<span class="linenr">12: </span>        <span class=
"org-keyword">if</span> (
<span class=
"linenr">13: </span>          node.type === <span class="org-string">'TSInterfaceDeclaration'</span> &amp;&
<span class="linenr">14: </span>          node.id.name === refName
<span class="linenr">15: </span>        ) {
<span class="linenr">16: </span>          <span class=
"org-keyword">return</span> node.body
<span class="linenr">17: </span>        } <span class=
"org-keyword">else</span> <span class="org-keyword">if</span> (
<span class=
"linenr">18: </span>          node.type === <span class="org-string">'TSTypeAliasDeclaration'</span> &amp;&
<span class=
"linenr">19: </span>          node.id.name === refName &amp;&
<span class=
"linenr">20: </span>          qualifier(node.typeAnnotation)
<span class="linenr">21: </span>        ) {
<span class="linenr">22: </span>          <span class=
"org-keyword">return</span> node.typeAnnotation
<span class="linenr">23: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'ExportNamedDeclaration'</span> &amp;& node.declaration) {
<span class="linenr">24: </span>          <span class=
"org-keyword">return</span> isQualifiedType(node.declaration)
<span class="linenr">25: </span>        }
<span class="linenr">26: </span>      }
<span class="linenr">27: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">body</span> = scriptAst
<span class=
"linenr">28: </span>        ? [...scriptSetupAst.body, ...scriptAst.body]
<span class="linenr">29: </span>        : scriptSetupAst.body
<span class="linenr">30: </span>      <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">node</span> <span class=
"org-keyword">of</span> body) {
<span class="linenr">31: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">qualified</span> = isQualifiedType(node)
<span class="linenr">32: </span>        <span class=
"org-keyword">if</span> (qualified) {
<span class="linenr">33: </span>          <span class=
"org-keyword">return</span> qualified
<span class="linenr">34: </span>        }
<span class="linenr">35: </span>      }
<span class="linenr">36: </span>    }
<span class="linenr">37: </span>  }
<span class="linenr">38: </span>
<span class="linenr">39: </span>
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-org958a52f" class="outline-4">
          <h4 id="org958a52f"><span class=
          "section-number-4">1.2.9.</span>
          processDefineExpose()</h4>
          <div class="outline-text-4" id="text-1-2-9">
            <div class="org-src-container">
              <pre class="src src-js" id="orgf7c5c59"><span class=
              "linenr"> 1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">processDefineExpose</span>(<span class=
              "org-variable-name">node</span>) {
<span class="linenr"> 2: </span>    <span class=
"org-keyword">if</span> (isCallOf(node, DEFINE_EXPOSE)) {
<span class="linenr"> 3: </span>      <span class=
"org-keyword">if</span> (hasDefineExposeCall) {
<span class="linenr"> 4: </span>        error(<span class=
"org-string">`duplicate ${DEFINE_EXPOSE}() call`</span>, node)
<span class="linenr"> 5: </span>      }
<span class=
"linenr"> 6: </span>      hasDefineExposeCall = <span class=
"org-constant">true</span>
<span class="linenr"> 7: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr"> 8: </span>    }
<span class="linenr"> 9: </span>    <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">10: </span>  }
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-orgca8526f" class="outline-4">
          <h4 id="orgca8526f"><span class=
          "section-number-4">1.2.10.</span>
          checkInvalidScopeReference()</h4>
          <div class="outline-text-4" id="text-1-2-10">
            <div class="org-src-container">
              <pre class="src src-js" id="org3a5e025"><span class=
              "linenr"> 1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">checkInvalidScopeReference</span>(<span class=
              "org-variable-name">node</span>, <span class=
              "org-variable-name">method</span>) {
<span class="linenr"> 2: </span>    <span class=
"org-keyword">if</span> (!node) <span class=
"org-keyword">return</span>
<span class=
"linenr"> 3: </span>    walkIdentifiers(node, id =&gt; {
<span class="linenr"> 4: </span>      <span class=
"org-keyword">if</span> (setupBindings[id.name]) {
<span class="linenr"> 5: </span>        error(
<span class="linenr"> 6: </span>          <span class=
"org-string">`\`${method}()\` in &lt;script setup&gt; cannot reference locally `</span> +
<span class="linenr"> 7: </span>            <span class=
"org-string">`declared variables because it will be hoisted outside of the `</span> +
<span class="linenr"> 8: </span>            <span class=
"org-string">`setup() function. If your component options require initialization `</span> +
<span class="linenr"> 9: </span>            <span class=
"org-string">`in the module scope, use a separate normal &lt;script&gt; to export `</span> +
<span class="linenr">10: </span>            <span class=
"org-string">`the options instead.`</span>,
<span class="linenr">11: </span>          id
<span class="linenr">12: </span>        )
<span class="linenr">13: </span>      }
<span class="linenr">14: </span>    })
<span class="linenr">15: </span>  }
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-org14ae51e" class="outline-4">
          <h4 id="org14ae51e"><span class=
          "section-number-4">1.2.11.</span> processAwait()</h4>
          <div class="outline-text-4" id="text-1-2-11">
            <div class="org-src-container">
              <pre class="src src-js" id="org4aa780f"><span class=
              "linenr"> 1: </span><span class="org-doc">/**</span>
<span class="linenr"> 2: </span><span class=
"org-doc">   * await foo()</span>
<span class="linenr"> 3: </span><span class=
"org-doc">   * --&gt;</span>
<span class="linenr"> 4: </span><span class=
"org-doc">   * ;(</span>
<span class="linenr"> 5: </span><span class=
"org-doc">   *   ([__temp,__restore] = withAsyncContext(() =&gt; foo())),</span>
<span class="linenr"> 6: </span><span class=
"org-doc">   *   await __temp,</span>
<span class="linenr"> 7: </span><span class=
"org-doc">   *   __restore()</span>
<span class="linenr"> 8: </span><span class="org-doc">   * )</span>
<span class="linenr"> 9: </span><span class="org-doc">   *</span>
<span class="linenr">10: </span><span class=
"org-doc">   * const a = await foo()</span>
<span class="linenr">11: </span><span class=
"org-doc">   * --&gt;</span>
<span class="linenr">12: </span><span class=
"org-doc">   * const a = (</span>
<span class="linenr">13: </span><span class=
"org-doc">   *   ([__temp, __restore] = withAsyncContext(() =&gt; foo())),</span>
<span class="linenr">14: </span><span class=
"org-doc">   *   __temp = await __temp,</span>
<span class="linenr">15: </span><span class=
"org-doc">   *   __restore(),</span>
<span class="linenr">16: </span><span class=
"org-doc">   *   __temp</span>
<span class="linenr">17: </span><span class="org-doc">   * )</span>
<span class="linenr">18: </span><span class="org-doc">   */</span>
<span class="linenr">19: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">processAwait</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">needSemi</span>, <span class=
"org-variable-name">isStatement</span>) {
<span class="linenr">20: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">argumentStart</span> =
<span class=
"linenr">21: </span>      node.argument.extra &amp;& node.argument.extra.parenthesized
<span class=
"linenr">22: </span>        ? node.argument.extra.parenStart
<span class="linenr">23: </span>        : node.argument.start
<span class="linenr">24: </span>
<span class="linenr">25: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">argumentStr</span> = source.slice(
<span class="linenr">26: </span>      argumentStart + startOffset,
<span class=
"linenr">27: </span>      node.argument.end + startOffset
<span class="linenr">28: </span>    )
<span class="linenr">29: </span>
<span class="linenr">30: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">containsNestedAwait</span> = <span class=
"org-string">/\bawait\b/</span>.test(argumentStr)
<span class="linenr">31: </span>
<span class="linenr">32: </span>    s.overwrite(
<span class="linenr">33: </span>      node.start + startOffset,
<span class="linenr">34: </span>      argumentStart + startOffset,
<span class="linenr">35: </span>      <span class=
"org-string">`${needSemi ? `</span>;<span class=
"org-string">` : ``}(\n  ([__temp,__restore] = ${helper(</span>
<span class="linenr">36: </span><span class=
"org-string">        `</span>withAsyncContext<span class=
"org-string">`</span>
<span class="linenr">37: </span><span class=
"org-string">      )}(${containsNestedAwait ? `</span><span class=
"org-keyword">async</span> <span class=
"org-string">` : ``}() =&gt; `</span>
<span class="linenr">38: </span>    )
<span class="linenr">39: </span>    s.appendLeft(
<span class="linenr">40: </span>      node.end + startOffset,
<span class="linenr">41: </span>      <span class=
"org-string">`)),\n  ${isStatement ? `` : `</span>__temp = <span class="org-string">`}await __temp,\n  __restore()${</span>
<span class="linenr">42: </span><span class=
"org-string">        isStatement ? `` : `</span>,\n  __temp<span class="org-string">`</span>
<span class="linenr">43: </span><span class=
"org-string">      }\n)`</span>
<span class="linenr">44: </span>    )
<span class="linenr">45: </span>  }
<span class="linenr">46: </span>
<span class="linenr">47: </span>
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-org175ada4" class="outline-4">
          <h4 id="org175ada4"><span class=
          "section-number-4">1.2.12.</span>
          hasStaticWithDefaults()</h4>
          <div class="outline-text-4" id="text-1-2-12">
            <div class="org-src-container">
              <pre class="src src-js" id="org7a2868f"><span class=
              "linenr"> 1: </span><span class="org-doc">/**</span>
<span class="linenr"> 2: </span><span class=
"org-doc">   * check defaults. If the default object is an object literal with only</span>
<span class="linenr"> 3: </span><span class=
"org-doc">   * static properties, we can directly generate more optimized default</span>
<span class="linenr"> 4: </span><span class=
"org-doc">   * declarations. Otherwise we will have to fallback to runtime merging.</span>
<span class="linenr"> 5: </span><span class="org-doc">   */</span>
<span class="linenr"> 6: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">hasStaticWithDefaults</span>() {
<span class="linenr"> 7: </span>    <span class=
"org-keyword">return</span> (
<span class="linenr"> 8: </span>      propsRuntimeDefaults &amp;&
<span class=
"linenr"> 9: </span>      propsRuntimeDefaults.type === <span class="org-string">'ObjectExpression'</span> &amp;&
<span class=
"linenr">10: </span>      propsRuntimeDefaults.properties.every(
<span class="linenr">11: </span>        node =&gt;
<span class=
"linenr">12: </span>          (node.type === <span class=
"org-string">'ObjectProperty'</span> &amp;& !node.computed) ||
<span class=
"linenr">13: </span>          node.type === <span class="org-string">'ObjectMethod'</span>
<span class="linenr">14: </span>      )
<span class="linenr">15: </span>    )
<span class="linenr">16: </span>  }
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-org1a5b75b" class="outline-4">
          <h4 id="org1a5b75b"><span class=
          "section-number-4">1.2.13.</span> genRuntimeProps()</h4>
          <div class="outline-text-4" id="text-1-2-13">
            <div class="org-src-container">
              <pre class="src src-js" id="org217cb5c"><span class=
              "linenr"> 1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">genRuntimeProps</span>(<span class=
              "org-variable-name">props</span>) {
<span class="linenr"> 2: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">keys</span> = Object.keys(props)
<span class="linenr"> 3: </span>    <span class=
"org-keyword">if</span> (!keys.length) {
<span class="linenr"> 4: </span>      <span class=
"org-keyword">return</span> <span class="org-string">``</span>
<span class="linenr"> 5: </span>    }
<span class="linenr"> 6: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">hasStaticDefaults</span> = hasStaticWithDefaults()
<span class="linenr"> 7: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">scriptSetupSource</span> = scriptSetup.content
<span class="linenr"> 8: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">propsDecls</span> = <span class=
"org-string">`{</span>
<span class="linenr"> 9: </span><span class=
"org-string">    ${keys</span>
<span class="linenr">10: </span><span class=
"org-string">      .map(key =&gt; {</span>
<span class="linenr">11: </span><span class=
"org-string">        let defaultString</span>
<span class="linenr">12: </span><span class=
"org-string">        const destructured = genDestructuredDefaultValue(key)</span>
<span class="linenr">13: </span><span class=
"org-string">        if (destructured) {</span>
<span class="linenr">14: </span><span class=
"org-string">          defaultString = `</span><span class=
"org-keyword">default</span>: ${destructured}<span class=
"org-string">`</span>
<span class="linenr">15: </span><span class=
"org-string">        } else if (hasStaticDefaults) {</span>
<span class="linenr">16: </span><span class=
"org-string">          const prop = propsRuntimeDefaults.properties.find(</span>
<span class="linenr">17: </span><span class=
"org-string">            (node) =&gt; node.key.name === key</span>
<span class="linenr">18: </span><span class=
"org-string">          )</span>
<span class="linenr">19: </span><span class=
"org-string">          if (prop) {</span>
<span class="linenr">20: </span><span class=
"org-string">            if (prop.type === 'ObjectProperty') {</span>
<span class="linenr">21: </span><span class=
"org-string">              // prop has corresponding static default value</span>
<span class="linenr">22: </span><span class=
"org-string">              defaultString = `</span><span class=
"org-keyword">default</span>: ${scriptSetupSource.slice(
<span class="linenr">23: </span>                prop.value.start,
<span class="linenr">24: </span>                prop.value.end
<span class="linenr">25: </span>              )}<span class=
"org-string">`</span>
<span class="linenr">26: </span><span class=
"org-string">            } else {</span>
<span class="linenr">27: </span><span class=
"org-string">              defaultString = `</span><span class=
"org-keyword">default</span>() ${scriptSetupSource.slice(
<span class="linenr">28: </span>                prop.body.start,
<span class="linenr">29: </span>                prop.body.end
<span class="linenr">30: </span>              )}<span class=
"org-string">`</span>
<span class="linenr">31: </span><span class=
"org-string">            }</span>
<span class="linenr">32: </span><span class=
"org-string">          }</span>
<span class="linenr">33: </span><span class=
"org-string">        }</span>
<span class="linenr">34: </span>
<span class="linenr">35: </span><span class=
"org-string">        const { type, required } = props[key]</span>
<span class="linenr">36: </span><span class=
"org-string">        if (!isProd) {</span>
<span class="linenr">37: </span><span class=
"org-string">          return `</span>${key}: { type: ${toRuntimeTypeString(
<span class="linenr">38: </span>            type
<span class=
"linenr">39: </span>          )}, required: ${required}${
<span class=
"linenr">40: </span>            defaultString ? <span class=
"org-string">`, ${defaultString}`</span> : <span class=
"org-string">``</span>
<span class="linenr">41: </span>          } }<span class=
"org-string">`</span>
<span class="linenr">42: </span><span class=
"org-string">        } else if (</span>
<span class="linenr">43: </span><span class=
"org-string">          type.some(</span>
<span class="linenr">44: </span><span class=
"org-string">            el =&gt; el === 'Boolean' || (defaultString &amp;& el === 'Function')</span>
<span class="linenr">45: </span><span class=
"org-string">          )</span>
<span class="linenr">46: </span><span class=
"org-string">        ) {</span>
<span class="linenr">47: </span><span class=
"org-string">          // #4783 production: if boolean or defaultString and function exists, should keep the type.</span>
<span class="linenr">48: </span><span class=
"org-string">          return `</span>${key}: { type: ${toRuntimeTypeString(type)}${
<span class=
"linenr">49: </span>            defaultString ? <span class=
"org-string">`, ${defaultString}`</span> : <span class=
"org-string">``</span>
<span class="linenr">50: </span>          } }<span class=
"org-string">`</span>
<span class="linenr">51: </span><span class=
"org-string">        } else {</span>
<span class="linenr">52: </span><span class=
"org-string">          // production: checks are useless</span>
<span class="linenr">53: </span><span class=
"org-string">          return `</span>${key}: ${defaultString ? <span class="org-string">`{ ${defaultString} }`</span> : <span class="org-string">'null'</span>}<span class="org-string">`</span>
<span class="linenr">54: </span><span class=
"org-string">        }</span>
<span class="linenr">55: </span><span class=
"org-string">      })</span>
<span class="linenr">56: </span><span class=
"org-string">      .join(',\n    ')}\n  }`</span>
<span class="linenr">57: </span>
<span class="linenr">58: </span>    <span class=
"org-keyword">if</span> (propsRuntimeDefaults &amp;& !hasStaticDefaults) {
<span class="linenr">59: </span>      propsDecls = <span class=
"org-string">`${helper('mergeDefaults')}(${propsDecls}, ${source.slice(</span>
<span class="linenr">60: </span><span class=
"org-string">        propsRuntimeDefaults.start + startOffset,</span>
<span class="linenr">61: </span><span class=
"org-string">        propsRuntimeDefaults.end + startOffset</span>
<span class="linenr">62: </span><span class=
"org-string">      )})`</span>
<span class="linenr">63: </span>    }
<span class="linenr">64: </span>
<span class="linenr">65: </span>    <span class=
"org-keyword">return</span> <span class=
"org-string">`\n  props: ${propsDecls},`</span>
<span class="linenr">66: </span>  }
<span class="linenr">67: </span>
<span class="linenr">68: </span>
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-orgbcbfce1" class="outline-4">
          <h4 id="orgbcbfce1"><span class=
          "section-number-4">1.2.14.</span>
          genDestructuredDefaultValue()</h4>
          <div class="outline-text-4" id="text-1-2-14">
            <div class="org-src-container">
              <pre class="src src-js" id="orgbe2623d"><span class=
              "linenr"> 1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">genDestructuredDefaultValue</span>(<span class=
              "org-variable-name">key</span>) {
<span class="linenr"> 2: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">destructured</span> = propsDestructuredBindings[key]
<span class="linenr"> 3: </span>    <span class=
"org-keyword">if</span> (destructured &amp;& destructured.<span class="org-keyword">default</span>) {
<span class="linenr"> 4: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">value</span> = scriptSetup.content.slice(
<span class="linenr"> 5: </span>        destructured.<span class=
"org-keyword">default</span>.start,
<span class="linenr"> 6: </span>        destructured.<span class=
"org-keyword">default</span>.end
<span class="linenr"> 7: </span>      )
<span class="linenr"> 8: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isLiteral</span> = destructured.<span class=
"org-keyword">default</span>.type.endsWith(<span class=
"org-string">'Literal'</span>)
<span class="linenr"> 9: </span>      <span class=
"org-keyword">return</span> isLiteral ? value : <span class=
"org-string">`() =&gt; ${value}`</span>
<span class="linenr">10: </span>    }
<span class="linenr">11: </span>  }
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-org1bf22f6" class="outline-4">
          <h4 id="org1bf22f6"><span class=
          "section-number-4">1.2.15.</span>
          genSetupPropsType()</h4>
          <div class="outline-text-4" id="text-1-2-15">
            <div class="org-src-container">
              <pre class="src src-js" id="orgd8d0f5c"><span class=
              "linenr"> 1: </span>
<span class="linenr"> 2: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">genSetupPropsType</span>(<span class=
"org-variable-name">node</span>) {
<span class="linenr"> 3: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">scriptSetupSource</span> = scriptSetup.content
<span class="linenr"> 4: </span>    <span class=
"org-keyword">if</span> (hasStaticWithDefaults()) {
<span class="linenr"> 5: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">if withDefaults() is used, we need to remove the optional flags</span>
<span class="linenr"> 6: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">on props that have default values</span>
<span class="linenr"> 7: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">res</span> = <span class=
"org-string">`{ `</span>
<span class="linenr"> 8: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">members</span> = node.type === <span class=
"org-string">'TSTypeLiteral'</span> ? node.members : node.body
<span class="linenr"> 9: </span>      <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">m</span> <span class=
"org-keyword">of</span> members) {
<span class="linenr">10: </span>        <span class=
"org-keyword">if</span> (
<span class="linenr">11: </span>          (m.type === <span class=
"org-string">'TSPropertySignature'</span> ||
<span class="linenr">12: </span>            m.type === <span class=
"org-string">'TSMethodSignature'</span>) &amp;&
<span class="linenr">13: </span>          m.typeAnnotation &amp;&
<span class=
"linenr">14: </span>          m.key.type === <span class=
"org-string">'Identifier'</span>
<span class="linenr">15: </span>        ) {
<span class="linenr">16: </span>          <span class=
"org-keyword">if</span> (
<span class=
"linenr">17: </span>            propsRuntimeDefaults.properties.some(
<span class=
"linenr">18: </span>              (p) =&gt; p.key.name === m.key.name
<span class="linenr">19: </span>            )
<span class="linenr">20: </span>          ) {
<span class="linenr">21: </span>            res +=
<span class="linenr">22: </span>              m.key.name +
<span class=
"linenr">23: </span>              (m.type === <span class=
"org-string">'TSMethodSignature'</span> ? <span class=
"org-string">'()'</span> : <span class="org-string">''</span>) +
<span class=
"linenr">24: </span>              scriptSetupSource.slice(
<span class=
"linenr">25: </span>                m.typeAnnotation.start,
<span class=
"linenr">26: </span>                m.typeAnnotation.end
<span class="linenr">27: </span>              ) +
<span class="linenr">28: </span>              <span class=
"org-string">', '</span>
<span class="linenr">29: </span>          } <span class=
"org-keyword">else</span> {
<span class="linenr">30: </span>            res +=
<span class=
"linenr">31: </span>              scriptSetupSource.slice(m.start, m.typeAnnotation.end) + <span class="org-string">`, `</span>
<span class="linenr">32: </span>          }
<span class="linenr">33: </span>        }
<span class="linenr">34: </span>      }
<span class="linenr">35: </span>      <span class=
"org-keyword">return</span> (res.length ? res.slice(<span class=
"org-highlight-numbers-number">0</span>, -<span class=
"org-highlight-numbers-number">2</span>) : res) + <span class=
"org-string">` }`</span>
<span class="linenr">36: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr">37: </span>      <span class=
"org-keyword">return</span> scriptSetupSource.slice(node.start, node.end)
<span class="linenr">38: </span>    }
<span class="linenr">39: </span>  }
</pre>
            </div>
          </div>
        </div>
      </div>
      <div id="outline-container-org318e239" class="outline-3">
        <h3 id="org318e239"><span class=
        "section-number-3">1.3.</span> steps</h3>
        <div class="outline-text-3" id="text-1-3">
          <div class="org-src-container">
            <pre class="src src-js" id="org3242134"><span class=
            "linenr"> 1: </span>&lt;&lt;cs-s-processNormalScript&gt;&gt;
<span class=
"linenr"> 2: </span>&lt;&lt;cs-s-processSetupScript&gt;&gt;
<span class=
"linenr"> 3: </span>&lt;&lt;cs-s-applyReactivityTransform&gt;&gt;
<span class=
"linenr"> 4: </span>&lt;&lt;cs-s-extractRuntimePropsEmits&gt;&gt;
<span class=
"linenr"> 5: </span>&lt;&lt;cs-s-checkUseOptions&gt;&gt;
<span class=
"linenr"> 6: </span>&lt;&lt;cs-s-removeNonScriptContent&gt;&gt;
<span class=
"linenr"> 7: </span>&lt;&lt;cs-s-analyzeBindingMetadata&gt;&gt;
<span class=
"linenr"> 8: </span>&lt;&lt;cs-s-injectUseCssVarsCalls&gt;&gt;
<span class=
"linenr"> 9: </span>&lt;&lt;cs-s-finalizeSetupArgumentSignature&gt;&gt;
<span class=
"linenr">10: </span>&lt;&lt;cs-s-finalizeSetupArgumentSignature&gt;&gt;
<span class=
"linenr">11: </span>&lt;&lt;cs-s-generateReturnStatement&gt;&gt;
<span class=
"linenr">12: </span>&lt;&lt;cs-s-finalizeDefaultExport&gt;&gt;
<span class=
"linenr">13: </span>&lt;&lt;cs-s-finalizeVueHelperImports&gt;&gt;
</pre>
          </div>
        </div>
        <div id="outline-container-org302009a" class="outline-4">
          <h4 id="org302009a"><span class=
          "section-number-4">1.3.1.</span> process normal
          script</h4>
          <div class="outline-text-4" id="text-1-3-1">
            <div class="org-src-container">
              <pre class="src src-js" id="org839fd3c"><span class=
              "linenr">  1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">processNormalScript</span>() {
<span class="linenr">  2: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">scriptAst</span>
<span class="linenr">  3: </span>  <span class=
"org-keyword">if</span> (script) {
<span class="linenr">  4: </span>    scriptAst = parse(
<span class="linenr">  5: </span>      script.content,
<span class="linenr">  6: </span>      {
<span class="linenr">  7: </span>        plugins,
<span class="linenr">  8: </span>        sourceType: <span class=
"org-string">'module'</span>
<span class="linenr">  9: </span>      },
<span class="linenr"> 10: </span>      scriptStartOffset
<span class="linenr"> 11: </span>    )
<span class="linenr"> 12: </span>
<span class="linenr"> 13: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">node</span> <span class=
"org-keyword">of</span> scriptAst.body) {
<span class="linenr"> 14: </span>      <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'ImportDeclaration'</span>) {
<span class="linenr"> 15: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">record imports for dedupe</span>
<span class="linenr"> 16: </span>        <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">specifier</span> <span class=
"org-keyword">of</span> node.specifiers) {
<span class="linenr"> 17: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">imported</span> =
<span class=
"linenr"> 18: </span>            specifier.type === <span class=
"org-string">'ImportSpecifier'</span> &amp;&
<span class=
"linenr"> 19: </span>            specifier.imported.type === <span class="org-string">'Identifier'</span> &amp;&
<span class=
"linenr"> 20: </span>            specifier.imported.name
<span class="linenr"> 21: </span>          registerUserImport(
<span class="linenr"> 22: </span>            node.source.value,
<span class="linenr"> 23: </span>            specifier.local.name,
<span class="linenr"> 24: </span>            imported,
<span class=
"linenr"> 25: </span>            node.importKind === <span class=
"org-string">'type'</span> ||
<span class=
"linenr"> 26: </span>              (specifier.type === <span class=
"org-string">'ImportSpecifier'</span> &amp;&
<span class=
"linenr"> 27: </span>                specifier.importKind === <span class="org-string">'type'</span>),
<span class="linenr"> 28: </span>            <span class=
"org-constant">false</span>
<span class="linenr"> 29: </span>          )
<span class="linenr"> 30: </span>        }
<span class="linenr"> 31: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'ExportDefaultDeclaration'</span>) {
<span class="linenr"> 32: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">export default</span>
<span class="linenr"> 33: </span>        defaultExport = node
<span class="linenr"> 34: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">export default { ... } --&gt; const __default__ = { ... }</span>
<span class="linenr"> 35: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">start</span> = node.start + scriptStartOffset
<span class="linenr"> 36: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">end</span> = node.declaration.start + scriptStartOffset
<span class=
"linenr"> 37: </span>        s.overwrite(start, end, <span class=
"org-string">`const ${DEFAULT_VAR} = `</span>)
<span class="linenr"> 38: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'ExportNamedDeclaration'</span>) {
<span class="linenr"> 39: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">defaultSpecifier</span> = node.specifiers.find(
<span class=
"linenr"> 40: </span>          s =&gt; s.exported.type === <span class="org-string">'Identifier'</span> &amp;& s.exported.name === <span class="org-string">'default'</span>
<span class="linenr"> 41: </span>        )
<span class="linenr"> 42: </span>        <span class=
"org-keyword">if</span> (defaultSpecifier) {
<span class="linenr"> 43: </span>          defaultExport = node
<span class="linenr"> 44: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">1. remove specifier</span>
<span class="linenr"> 45: </span>          <span class=
"org-keyword">if</span> (node.specifiers.length &gt; <span class=
"org-highlight-numbers-number">1</span>) {
<span class="linenr"> 46: </span>            s.remove(
<span class=
"linenr"> 47: </span>              defaultSpecifier.start + scriptStartOffset,
<span class=
"linenr"> 48: </span>              defaultSpecifier.end + scriptStartOffset
<span class="linenr"> 49: </span>            )
<span class="linenr"> 50: </span>          } <span class=
"org-keyword">else</span> {
<span class="linenr"> 51: </span>            s.remove(
<span class=
"linenr"> 52: </span>              node.start + scriptStartOffset,
<span class=
"linenr"> 53: </span>              node.end + scriptStartOffset
<span class="linenr"> 54: </span>            )
<span class="linenr"> 55: </span>          }
<span class="linenr"> 56: </span>          <span class=
"org-keyword">if</span> (node.source) {
<span class="linenr"> 57: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">export { x as default } from './x'</span>
<span class="linenr"> 58: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">rewrite to `import { x as __default__ } from './x'` and</span>
<span class="linenr"> 59: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">add to top</span>
<span class="linenr"> 60: </span>            s.prepend(
<span class="linenr"> 61: </span>              <span class=
"org-string">`import { ${defaultSpecifier.local.name} as ${DEFAULT_VAR} } from '${node.source.value}'\n`</span>
<span class="linenr"> 62: </span>            )
<span class="linenr"> 63: </span>          } <span class=
"org-keyword">else</span> {
<span class="linenr"> 64: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">export { x as default }</span>
<span class="linenr"> 65: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">rewrite to `const __default__ = x` and move to end</span>
<span class="linenr"> 66: </span>            s.appendLeft(
<span class="linenr"> 67: </span>              scriptEndOffset,
<span class="linenr"> 68: </span>              <span class=
"org-string">`\nconst ${DEFAULT_VAR} = ${defaultSpecifier.local.name}\n`</span>
<span class="linenr"> 69: </span>            )
<span class="linenr"> 70: </span>          }
<span class="linenr"> 71: </span>        }
<span class="linenr"> 72: </span>        <span class=
"org-keyword">if</span> (node.declaration) {
<span class=
"linenr"> 73: </span>          walkDeclaration(node.declaration, scriptBindings, userImportAlias)
<span class="linenr"> 74: </span>        }
<span class="linenr"> 75: </span>      } <span class=
"org-keyword">else</span> <span class="org-keyword">if</span> (
<span class=
"linenr"> 76: </span>        (node.type === <span class="org-string">'VariableDeclaration'</span> ||
<span class=
"linenr"> 77: </span>          node.type === <span class=
"org-string">'FunctionDeclaration'</span> ||
<span class=
"linenr"> 78: </span>          node.type === <span class=
"org-string">'ClassDeclaration'</span> ||
<span class=
"linenr"> 79: </span>          node.type === <span class=
"org-string">'TSEnumDeclaration'</span>) &amp;&
<span class="linenr"> 80: </span>        !node.declare
<span class="linenr"> 81: </span>      ) {
<span class=
"linenr"> 82: </span>        walkDeclaration(node, scriptBindings, userImportAlias)
<span class="linenr"> 83: </span>      }
<span class="linenr"> 84: </span>    }
<span class="linenr"> 85: </span>
<span class="linenr"> 86: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">apply reactivity transform</span>
<span class="linenr"> 87: </span>    <span class=
"org-keyword">if</span> (enableReactivityTransform &amp;& RT.shouldTransform(script.content)) {
<span class="linenr"> 88: </span>      <span class=
"org-keyword">const</span> { rootRefs, importedHelpers } = transformAST(
<span class="linenr"> 89: </span>        scriptAst,
<span class="linenr"> 90: </span>        s,
<span class="linenr"> 91: </span>        scriptStartOffset
<span class="linenr"> 92: </span>      )
<span class="linenr"> 93: </span>      refBindings = rootRefs
<span class="linenr"> 94: </span>      <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">h</span> <span class=
"org-keyword">of</span> importedHelpers) {
<span class="linenr"> 95: </span>        helperImports.add(h)
<span class="linenr"> 96: </span>      }
<span class="linenr"> 97: </span>    }
<span class="linenr"> 98: </span>
<span class="linenr"> 99: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">&lt;script&gt; after &lt;script setup&gt;</span>
<span class="linenr">100: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">we need to move the block up so that `const __default__` is</span>
<span class="linenr">101: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">declared before being used in the actual component definition</span>
<span class="linenr">102: </span>    <span class=
"org-keyword">if</span> (scriptStartOffset &gt; startOffset) {
<span class=
"linenr">103: </span>      s.move(scriptStartOffset, scriptEndOffset, <span class="org-highlight-numbers-number">0</span>)
<span class="linenr">104: </span>    }
<span class="linenr">105: </span>  }
<span class="linenr">106: </span>
<span class="linenr">107: </span>  <span class=
"org-keyword">return</span> scriptAst
<span class="linenr">108: </span>}
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-orgbbdbf3f" class="outline-4">
          <h4 id="orgbbdbf3f"><span class=
          "section-number-4">1.3.2.</span> process setup
          script</h4>
          <div class="outline-text-4" id="text-1-3-2">
            <div class="org-src-container">
              <pre class="src src-js" id="orgaf888c9"><span class=
              "linenr">  1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">processSetupScript</span>() {
<span class="linenr">  2: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">scriptSetupAst</span> = babelParser.parse(
<span class="linenr">  3: </span>    scriptSetup.content,
<span class="linenr">  4: </span>    {
<span class="linenr">  5: </span>      plugins: [
<span class="linenr">  6: </span>        ...plugins,
<span class="linenr">  7: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">allow top level await but only inside &lt;script setup&gt;</span>
<span class="linenr">  8: </span>        <span class=
"org-string">'topLevelAwait'</span>
<span class="linenr">  9: </span>      ],
<span class="linenr"> 10: </span>      sourceType: <span class=
"org-string">'module'</span>
<span class="linenr"> 11: </span>    },
<span class="linenr"> 12: </span>    startOffset
<span class="linenr"> 13: </span>  )
<span class="linenr"> 14: </span>
<span class="linenr"> 15: </span>  <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">node</span> <span class=
"org-keyword">of</span> scriptSetupAst.body) {
<span class="linenr"> 16: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">start</span> = node.start + startOffset
<span class="linenr"> 17: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">end</span> = node.end + startOffset
<span class="linenr"> 18: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">locate comment</span>
<span class="linenr"> 19: </span>    <span class=
"org-keyword">if</span> (node.trailingComments &amp;& node.trailingComments.length &gt; <span class="org-highlight-numbers-number">0</span>) {
<span class="linenr"> 20: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">lastCommentNode</span> =
<span class=
"linenr"> 21: </span>        node.trailingComments[node.trailingComments.length - <span class="org-highlight-numbers-number">1</span>]
<span class=
"linenr"> 22: </span>      end = lastCommentNode.end + startOffset
<span class="linenr"> 23: </span>    }
<span class="linenr"> 24: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">locate the end of whitespace between this statement and the next</span>
<span class="linenr"> 25: </span>    <span class=
"org-keyword">while</span> (end &lt;= source.length) {
<span class="linenr"> 26: </span>      <span class=
"org-keyword">if</span> (!<span class=
"org-string">/\s/</span>.test(source.charAt(end))) {
<span class="linenr"> 27: </span>        <span class=
"org-keyword">break</span>
<span class="linenr"> 28: </span>      }
<span class="linenr"> 29: </span>      end++
<span class="linenr"> 30: </span>    }
<span class="linenr"> 31: </span>
<span class="linenr"> 32: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">(Dropped) `ref: x` bindings</span>
<span class="linenr"> 33: </span>    <span class=
"org-keyword">if</span> (
<span class="linenr"> 34: </span>      node.type === <span class=
"org-string">'LabeledStatement'</span> &amp;&
<span class=
"linenr"> 35: </span>      node.label.name === <span class=
"org-string">'ref'</span> &amp;&
<span class=
"linenr"> 36: </span>      node.body.type === <span class=
"org-string">'ExpressionStatement'</span>
<span class="linenr"> 37: </span>    ) {
<span class="linenr"> 38: </span>      error(
<span class="linenr"> 39: </span>        <span class=
"org-string">`ref sugar using the label syntax was an experimental proposal and `</span> +
<span class="linenr"> 40: </span>          <span class=
"org-string">`has been dropped based on community feedback. Please check out `</span> +
<span class="linenr"> 41: </span>          <span class=
"org-string">`the new proposal at https://github.com/vuejs/rfcs/discussions/369`</span>,
<span class="linenr"> 42: </span>        node
<span class="linenr"> 43: </span>      )
<span class="linenr"> 44: </span>    }
<span class="linenr"> 45: </span>
<span class="linenr"> 46: </span>    <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'ImportDeclaration'</span>) {
<span class="linenr"> 47: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">import declarations are moved to top</span>
<span class=
"linenr"> 48: </span>      s.move(start, end, <span class=
"org-highlight-numbers-number">0</span>)
<span class="linenr"> 49: </span>
<span class="linenr"> 50: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">dedupe imports</span>
<span class="linenr"> 51: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">removed</span> = <span class=
"org-highlight-numbers-number">0</span>
<span class="linenr"> 52: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">removeSpecifier</span> = (i) =&gt; {
<span class="linenr"> 53: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">removeLeft</span> = i &gt; removed
<span class="linenr"> 54: </span>        removed++
<span class="linenr"> 55: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">current</span> = node.specifiers[i]
<span class="linenr"> 56: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">next</span> = node.specifiers[i + <span class=
"org-highlight-numbers-number">1</span>]
<span class="linenr"> 57: </span>        s.remove(
<span class="linenr"> 58: </span>          removeLeft
<span class=
"linenr"> 59: </span>            ? node.specifiers[i - <span class=
"org-highlight-numbers-number">1</span>].end + startOffset
<span class=
"linenr"> 60: </span>            : current.start + startOffset,
<span class="linenr"> 61: </span>          next &amp;& !removeLeft
<span class=
"linenr"> 62: </span>            ? next.start + startOffset
<span class=
"linenr"> 63: </span>            : current.end + startOffset
<span class="linenr"> 64: </span>        )
<span class="linenr"> 65: </span>      }
<span class="linenr"> 66: </span>
<span class="linenr"> 67: </span>      <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; node.specifiers.length; i++) {
<span class="linenr"> 68: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">specifier</span> = node.specifiers[i]
<span class="linenr"> 69: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">local</span> = specifier.local.name
<span class="linenr"> 70: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">imported</span> =
<span class=
"linenr"> 71: </span>          specifier.type === <span class=
"org-string">'ImportSpecifier'</span> &amp;&
<span class=
"linenr"> 72: </span>          specifier.imported.type === <span class="org-string">'Identifier'</span> &amp;&
<span class="linenr"> 73: </span>          specifier.imported.name
<span class="linenr"> 74: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">source</span> = node.source.value
<span class="linenr"> 75: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">existing</span> = userImports[local]
<span class="linenr"> 76: </span>        <span class=
"org-keyword">if</span> (
<span class="linenr"> 77: </span>          source === <span class=
"org-string">'vue'</span> &amp;&
<span class=
"linenr"> 78: </span>          (imported === DEFINE_PROPS ||
<span class=
"linenr"> 79: </span>            imported === DEFINE_EMITS ||
<span class=
"linenr"> 80: </span>            imported === DEFINE_EXPOSE)
<span class="linenr"> 81: </span>        ) {
<span class="linenr"> 82: </span>          removeSpecifier(i)
<span class="linenr"> 83: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (existing) {
<span class="linenr"> 84: </span>          <span class=
"org-keyword">if</span> (existing.source === source &amp;& existing.imported === imported) {
<span class="linenr"> 85: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">already imported in &lt;script setup&gt;, dedupe</span>
<span class="linenr"> 86: </span>            removeSpecifier(i)
<span class="linenr"> 87: </span>          } <span class=
"org-keyword">else</span> {
<span class="linenr"> 88: </span>            error(<span class=
"org-string">`different imports aliased to same local name.`</span>, specifier)
<span class="linenr"> 89: </span>          }
<span class="linenr"> 90: </span>        } <span class=
"org-keyword">else</span> {
<span class="linenr"> 91: </span>          registerUserImport(
<span class="linenr"> 92: </span>            source,
<span class="linenr"> 93: </span>            local,
<span class="linenr"> 94: </span>            imported,
<span class=
"linenr"> 95: </span>            node.importKind === <span class=
"org-string">'type'</span> ||
<span class=
"linenr"> 96: </span>              (specifier.type === <span class=
"org-string">'ImportSpecifier'</span> &amp;&
<span class=
"linenr"> 97: </span>                specifier.importKind === <span class="org-string">'type'</span>),
<span class="linenr"> 98: </span>            <span class=
"org-constant">true</span>
<span class="linenr"> 99: </span>          )
<span class="linenr">100: </span>        }
<span class="linenr">101: </span>      }
<span class="linenr">102: </span>      <span class=
"org-keyword">if</span> (node.specifiers.length &amp;& removed === node.specifiers.length) {
<span class=
"linenr">103: </span>        s.remove(node.start + startOffset, node.end + startOffset)
<span class="linenr">104: </span>      }
<span class="linenr">105: </span>    }
<span class="linenr">106: </span>
<span class="linenr">107: </span>    <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'ExpressionStatement'</span>) {
<span class="linenr">108: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">process `defineProps` and `defineEmit(s)` calls</span>
<span class="linenr">109: </span>      <span class=
"org-keyword">if</span> (
<span class=
"linenr">110: </span>        processDefineProps(node.expression) ||
<span class=
"linenr">111: </span>        processDefineEmits(node.expression) ||
<span class=
"linenr">112: </span>        processWithDefaults(node.expression)
<span class="linenr">113: </span>      ) {
<span class=
"linenr">114: </span>        s.remove(node.start + startOffset, node.end + startOffset)
<span class="linenr">115: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (processDefineExpose(node.expression)) {
<span class="linenr">116: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">defineExpose({}) -&gt; expose({})</span>
<span class="linenr">117: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">callee</span> = node.expression.callee
<span class="linenr">118: </span>        s.overwrite(
<span class=
"linenr">119: </span>          callee.start + startOffset,
<span class=
"linenr">120: </span>          callee.end + startOffset,
<span class="linenr">121: </span>          <span class=
"org-string">'expose'</span>
<span class="linenr">122: </span>        )
<span class="linenr">123: </span>      }
<span class="linenr">124: </span>    }
<span class="linenr">125: </span>
<span class="linenr">126: </span>    <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'VariableDeclaration'</span> &amp;& !node.declare) {
<span class="linenr">127: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">total</span> = node.declarations.length
<span class="linenr">128: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">left</span> = total
<span class="linenr">129: </span>      <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; total; i++) {
<span class="linenr">130: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">decl</span> = node.declarations[i]
<span class="linenr">131: </span>        <span class=
"org-keyword">if</span> (decl.init) {
<span class="linenr">132: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">defineProps / defineEmits</span>
<span class="linenr">133: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isDefineProps</span> =
<span class=
"linenr">134: </span>            processDefineProps(decl.init, decl.id) ||
<span class=
"linenr">135: </span>            processWithDefaults(decl.init, decl.id)
<span class="linenr">136: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isDefineEmits</span> = processDefineEmits(decl.init, decl.id)
<span class="linenr">137: </span>          <span class=
"org-keyword">if</span> (isDefineProps || isDefineEmits) {
<span class="linenr">138: </span>            <span class=
"org-keyword">if</span> (left === <span class=
"org-highlight-numbers-number">1</span>) {
<span class=
"linenr">139: </span>              s.remove(node.start + startOffset, node.end + startOffset)
<span class="linenr">140: </span>            } <span class=
"org-keyword">else</span> {
<span class="linenr">141: </span>              <span class=
"org-keyword">let</span> <span class=
"org-variable-name">start</span> = decl.start + startOffset
<span class="linenr">142: </span>              <span class=
"org-keyword">let</span> <span class=
"org-variable-name">end</span> = decl.end + startOffset
<span class="linenr">143: </span>              <span class=
"org-keyword">if</span> (i &lt; total - <span class=
"org-highlight-numbers-number">1</span>) {
<span class="linenr">144: </span>                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">not the last one, locate the start of the next</span>
<span class=
"linenr">145: </span>                end = node.declarations[i + <span class="org-highlight-numbers-number">1</span>].start + startOffset
<span class="linenr">146: </span>              } <span class=
"org-keyword">else</span> {
<span class="linenr">147: </span>                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">last one, locate the end of the prev</span>
<span class=
"linenr">148: </span>                start = node.declarations[i - <span class="org-highlight-numbers-number">1</span>].end + startOffset
<span class="linenr">149: </span>              }
<span class="linenr">150: </span>              s.remove(start, end)
<span class="linenr">151: </span>              left--
<span class="linenr">152: </span>            }
<span class="linenr">153: </span>          }
<span class="linenr">154: </span>        }
<span class="linenr">155: </span>      }
<span class="linenr">156: </span>    }
<span class="linenr">157: </span>
<span class="linenr">158: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">walk declarations to record declared bindings</span>
<span class="linenr">159: </span>    <span class=
"org-keyword">if</span> (
<span class="linenr">160: </span>      (node.type === <span class=
"org-string">'VariableDeclaration'</span> ||
<span class="linenr">161: </span>        node.type === <span class=
"org-string">'FunctionDeclaration'</span> ||
<span class="linenr">162: </span>        node.type === <span class=
"org-string">'ClassDeclaration'</span>) &amp;&
<span class="linenr">163: </span>      !node.declare
<span class="linenr">164: </span>    ) {
<span class=
"linenr">165: </span>      walkDeclaration(node, setupBindings, userImportAlias)
<span class="linenr">166: </span>    }
<span class="linenr">167: </span>
<span class="linenr">168: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">walk statements & named exports / variable declarations for top level</span>
<span class="linenr">169: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">await</span>
<span class="linenr">170: </span>    <span class=
"org-keyword">if</span> (
<span class="linenr">171: </span>      (node.type === <span class=
"org-string">'VariableDeclaration'</span> &amp;& !node.declare) ||
<span class=
"linenr">172: </span>      node.type.endsWith(<span class=
"org-string">'Statement'</span>)
<span class="linenr">173: </span>    ) {
<span class="linenr">174: </span>      walk(node, {
<span class="linenr">175: </span>        enter(child, parent) {
<span class="linenr">176: </span>          <span class=
"org-keyword">if</span> (isFunctionType(child)) {
<span class="linenr">177: </span>            <span class=
"org-constant">this</span>.skip()
<span class="linenr">178: </span>          }
<span class="linenr">179: </span>          <span class=
"org-keyword">if</span> (child.type === <span class=
"org-string">'AwaitExpression'</span>) {
<span class=
"linenr">180: </span>            hasAwait = <span class="org-constant">true</span>
<span class="linenr">181: </span>            <span class=
"org-keyword">const</span> <span class=
"org-variable-name">needsSemi</span> = scriptSetupAst.body.some(n =&gt; {
<span class="linenr">182: </span>              <span class=
"org-keyword">return</span> n.type === <span class=
"org-string">'ExpressionStatement'</span> &amp;& n.start === child.start
<span class="linenr">183: </span>            })
<span class="linenr">184: </span>            processAwait(
<span class="linenr">185: </span>              child,
<span class="linenr">186: </span>              needsSemi,
<span class=
"linenr">187: </span>              parent.type === <span class=
"org-string">'ExpressionStatement'</span>
<span class="linenr">188: </span>            )
<span class="linenr">189: </span>          }
<span class="linenr">190: </span>        }
<span class="linenr">191: </span>      })
<span class="linenr">192: </span>    }
<span class="linenr">193: </span>
<span class="linenr">194: </span>    <span class=
"org-keyword">if</span> (
<span class="linenr">195: </span>      (node.type === <span class=
"org-string">'ExportNamedDeclaration'</span> &amp;& node.exportKind !== <span class="org-string">'type'</span>) ||
<span class="linenr">196: </span>      node.type === <span class=
"org-string">'ExportAllDeclaration'</span> ||
<span class="linenr">197: </span>      node.type === <span class=
"org-string">'ExportDefaultDeclaration'</span>
<span class="linenr">198: </span>    ) {
<span class="linenr">199: </span>      error(
<span class="linenr">200: </span>        <span class=
"org-string">`&lt;script setup&gt; cannot contain ES module exports. `</span> +
<span class="linenr">201: </span>          <span class=
"org-string">`If you are using a previous version of &lt;script setup&gt;, please `</span> +
<span class="linenr">202: </span>          <span class=
"org-string">`consult the updated RFC at https://github.com/vuejs/rfcs/pull/227.`</span>,
<span class="linenr">203: </span>        node
<span class="linenr">204: </span>      )
<span class="linenr">205: </span>    }
<span class="linenr">206: </span>
<span class="linenr">207: </span>    <span class=
"org-keyword">if</span> (isTS) {
<span class="linenr">208: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">runtime enum</span>
<span class="linenr">209: </span>      <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'TSEnumDeclaration'</span>) {
<span class=
"linenr">210: </span>        registerBinding(setupBindings, node.id, BindingTypes.SETUP_CONST)
<span class="linenr">211: </span>      }
<span class="linenr">212: </span>
<span class="linenr">213: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">move all Type declarations to outer scope</span>
<span class="linenr">214: </span>      <span class=
"org-keyword">if</span> (
<span class=
"linenr">215: </span>        node.type.startsWith(<span class=
"org-string">'TS'</span>) ||
<span class=
"linenr">216: </span>        (node.type === <span class="org-string">'ExportNamedDeclaration'</span> &amp;&
<span class=
"linenr">217: </span>          node.exportKind === <span class=
"org-string">'type'</span>) ||
<span class=
"linenr">218: </span>        (node.type === <span class="org-string">'VariableDeclaration'</span> &amp;& node.declare)
<span class="linenr">219: </span>      ) {
<span class=
"linenr">220: </span>        recordType(node, declaredTypes)
<span class=
"linenr">221: </span>        s.move(start, end, <span class=
"org-highlight-numbers-number">0</span>)
<span class="linenr">222: </span>      }
<span class="linenr">223: </span>    }
<span class="linenr">224: </span>  }
<span class="linenr">225: </span>
<span class="linenr">226: </span>  <span class=
"org-keyword">return</span> scriptSetupAst
<span class="linenr">227: </span>}
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-orge292ff1" class="outline-4">
          <h4 id="orge292ff1"><span class=
          "section-number-4">1.3.3.</span> apply reactivity
          transform</h4>
          <div class="outline-text-4" id="text-1-3-3">
            <div class="org-src-container">
              <pre class="src src-js" id="org5465996"><span class=
              "linenr"> 1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">applyReactivityTransform</span>() {
<span class="linenr"> 2: </span>  <span class=
"org-keyword">if</span> (
<span class=
"linenr"> 3: </span>    (enableReactivityTransform &amp;&
<span class="linenr"> 4: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">normal &lt;script&gt; had ref bindings that maybe used in &lt;script setup&gt;</span>
<span class=
"linenr"> 5: </span>      (refBindings || RT.shouldTransform(scriptSetup.content))) ||
<span class="linenr"> 6: </span>    propsDestructureDecl
<span class="linenr"> 7: </span>  ) {
<span class="linenr"> 8: </span>    <span class=
"org-keyword">const</span> { rootRefs, importedHelpers } = transformAST(
<span class="linenr"> 9: </span>      scriptSetupAst,
<span class="linenr">10: </span>      s,
<span class="linenr">11: </span>      startOffset,
<span class="linenr">12: </span>      refBindings,
<span class="linenr">13: </span>      propsDestructuredBindings
<span class="linenr">14: </span>    )
<span class=
"linenr">15: </span>    refBindings = refBindings ? [...refBindings, ...rootRefs] : rootRefs
<span class="linenr">16: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">h</span> <span class=
"org-keyword">of</span> importedHelpers) {
<span class="linenr">17: </span>      helperImports.add(h)
<span class="linenr">18: </span>    }
<span class="linenr">19: </span>  }
<span class="linenr">20: </span>}
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-org8fc7f68" class="outline-4">
          <h4 id="org8fc7f68"><span class=
          "section-number-4">1.3.4.</span> extract runtime
          props/emits</h4>
          <div class="outline-text-4" id="text-1-3-4">
            <div class="org-src-container">
              <pre class="src src-js" id="orgf1b4a17"><span class=
              "linenr">1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">extractRuntimePropsEmits</span>() {
<span class="linenr">2: </span>  <span class=
"org-keyword">if</span> (propsTypeDecl) {
<span class=
"linenr">3: </span>    extractRuntimeProps(propsTypeDecl, typeDeclaredProps, declaredTypes, isProd)
<span class="linenr">4: </span>  }
<span class="linenr">5: </span>  <span class=
"org-keyword">if</span> (emitsTypeDecl) {
<span class=
"linenr">6: </span>    extractRuntimeEmits(emitsTypeDecl, typeDeclaredEmits)
<span class="linenr">7: </span>  }
<span class="linenr">8: </span>}
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-org6ed735c" class="outline-4">
          <h4 id="org6ed735c"><span class=
          "section-number-4">1.3.5.</span> check useOptions dont
          ref setup scope variables</h4>
          <div class="outline-text-4" id="text-1-3-5">
            <div class="org-src-container">
              <pre class="src src-js" id="org96a3da0"><span class=
              "linenr">1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">checkUseOptions</span>() {
<span class=
"linenr">2: </span>  checkInvalidScopeReference(propsRuntimeDecl, DEFINE_PROPS)
<span class=
"linenr">3: </span>  checkInvalidScopeReference(propsRuntimeDefaults, DEFINE_PROPS)
<span class=
"linenr">4: </span>  checkInvalidScopeReference(propsDestructureDecl, DEFINE_PROPS)
<span class=
"linenr">5: </span>  checkInvalidScopeReference(emitsRuntimeDecl, DEFINE_PROPS)
<span class="linenr">6: </span>}
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-org893a633" class="outline-4">
          <h4 id="org893a633"><span class=
          "section-number-4">1.3.6.</span> remove non-script
          content</h4>
          <div class="outline-text-4" id="text-1-3-6">
            <div class="org-src-container">
              <pre class="src src-js" id="org7e4a8a3"><span class=
              "linenr"> 1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">removeNonScriptContent</span>() {
<span class="linenr"> 2: </span>  <span class=
"org-keyword">if</span> (script) {
<span class="linenr"> 3: </span>    <span class=
"org-keyword">if</span> (startOffset &lt; scriptStartOffset) {
<span class="linenr"> 4: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">&lt;script setup&gt; before &lt;script&gt;</span>
<span class="linenr"> 5: </span>      s.remove(<span class=
"org-highlight-numbers-number">0</span>, startOffset)
<span class=
"linenr"> 6: </span>      s.remove(endOffset, scriptStartOffset)
<span class=
"linenr"> 7: </span>      s.remove(scriptEndOffset, source.length)
<span class="linenr"> 8: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr"> 9: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">&lt;script&gt; before &lt;script setup&gt;</span>
<span class="linenr">10: </span>      s.remove(<span class=
"org-highlight-numbers-number">0</span>, scriptStartOffset)
<span class=
"linenr">11: </span>      s.remove(scriptEndOffset, startOffset)
<span class=
"linenr">12: </span>      s.remove(endOffset, source.length)
<span class="linenr">13: </span>    }
<span class="linenr">14: </span>  } <span class=
"org-keyword">else</span> {
<span class="linenr">15: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">only &lt;script setup&gt;</span>
<span class="linenr">16: </span>    s.remove(<span class=
"org-highlight-numbers-number">0</span>, startOffset)
<span class=
"linenr">17: </span>    s.remove(endOffset, source.length)
<span class="linenr">18: </span>  }
<span class="linenr">19: </span>}
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-org6b91885" class="outline-4">
          <h4 id="org6b91885"><span class=
          "section-number-4">1.3.7.</span> analyze binding
          metadata</h4>
          <div class="outline-text-4" id="text-1-3-7">
            <div class="org-src-container">
              <pre class="src src-js" id="orgf110277"><span class=
              "linenr"> 1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">analyzeBindingMetadata</span>() {
<span class="linenr"> 2: </span>  <span class=
"org-keyword">if</span> (scriptAst) {
<span class=
"linenr"> 3: </span>    Object.assign(bindingMetadata, analyzeScriptBindings(scriptAst.body))
<span class="linenr"> 4: </span>  }
<span class="linenr"> 5: </span>  <span class=
"org-keyword">if</span> (propsRuntimeDecl) {
<span class="linenr"> 6: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">of</span> getObjectOrArrayExpressionKeys(propsRuntimeDecl)) {
<span class=
"linenr"> 7: </span>      bindingMetadata[key] = BindingTypes.PROPS
<span class="linenr"> 8: </span>    }
<span class="linenr"> 9: </span>  }
<span class="linenr">10: </span>  <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">in</span> typeDeclaredProps) {
<span class=
"linenr">11: </span>    bindingMetadata[key] = BindingTypes.PROPS
<span class="linenr">12: </span>  }
<span class="linenr">13: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">props aliases</span>
<span class="linenr">14: </span>  <span class=
"org-keyword">if</span> (propsDestructureDecl) {
<span class="linenr">15: </span>    <span class=
"org-keyword">if</span> (propsDestructureRestId) {
<span class=
"linenr">16: </span>      bindingMetadata[propsDestructureRestId] = BindingTypes.SETUP_CONST
<span class="linenr">17: </span>    }
<span class="linenr">18: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">in</span> propsDestructuredBindings) {
<span class="linenr">19: </span>      <span class=
"org-keyword">const</span> { local } = propsDestructuredBindings[key]
<span class="linenr">20: </span>      <span class=
"org-keyword">if</span> (local !== key) {
<span class=
"linenr">21: </span>        bindingMetadata[local] = BindingTypes.PROPS_ALIASED
<span class=
"linenr">22: </span>        ;(bindingMetadata.__propsAliases ||
<span class=
"linenr">23: </span>          (bindingMetadata.__propsAliases = {}))[local] = key
<span class="linenr">24: </span>      }
<span class="linenr">25: </span>    }
<span class="linenr">26: </span>  }
<span class="linenr">27: </span>  <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> [key, { isType, imported, source }] <span class="org-keyword">of</span> Object.entries(
<span class="linenr">28: </span>    userImports
<span class="linenr">29: </span>  )) {
<span class="linenr">30: </span>    <span class=
"org-keyword">if</span> (isType) <span class=
"org-keyword">continue</span>
<span class="linenr">31: </span>    bindingMetadata[key] =
<span class="linenr">32: </span>      (imported === <span class=
"org-string">'default'</span> &amp;& source.endsWith(<span class=
"org-string">'.vue'</span>)) || source === <span class=
"org-string">'vue'</span>
<span class="linenr">33: </span>        ? BindingTypes.SETUP_CONST
<span class=
"linenr">34: </span>        : BindingTypes.SETUP_MAYBE_REF
<span class="linenr">35: </span>  }
<span class="linenr">36: </span>  <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">in</span> scriptBindings) {
<span class=
"linenr">37: </span>    bindingMetadata[key] = scriptBindings[key]
<span class="linenr">38: </span>  }
<span class="linenr">39: </span>  <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">in</span> setupBindings) {
<span class=
"linenr">40: </span>    bindingMetadata[key] = setupBindings[key]
<span class="linenr">41: </span>  }
<span class="linenr">42: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">known ref bindings</span>
<span class="linenr">43: </span>  <span class=
"org-keyword">if</span> (refBindings) {
<span class="linenr">44: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">of</span> refBindings) {
<span class=
"linenr">45: </span>      bindingMetadata[key] = BindingTypes.SETUP_REF
<span class="linenr">46: </span>    }
<span class="linenr">47: </span>  }
<span class="linenr">48: </span>}
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-org4ff3706" class="outline-4">
          <h4 id="org4ff3706"><span class=
          "section-number-4">1.3.8.</span> inject useCssVars
          calls</h4>
          <div class="outline-text-4" id="text-1-3-8">
            <div class="org-src-container">
              <pre class="src src-js" id="orgf17132f"><span class=
              "linenr"> 1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">injectUseCssVarsCalls</span>() {
<span class="linenr"> 2: </span>  <span class=
"org-keyword">if</span> (cssVars.length) {
<span class=
"linenr"> 3: </span>    helperImports.add(CSS_VARS_HELPER)
<span class="linenr"> 4: </span>    helperImports.add(<span class=
"org-string">'unref'</span>)
<span class="linenr"> 5: </span>    s.prependRight(
<span class="linenr"> 6: </span>      startOffset,
<span class="linenr"> 7: </span>      <span class=
"org-string">`\n${genCssVarsCode(cssVars, bindingMetadata, scopeId, isProd)}\n`</span>
<span class="linenr"> 8: </span>    )
<span class="linenr"> 9: </span>  }
<span class="linenr">10: </span>}
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-org06f1637" class="outline-4">
          <h4 id="org06f1637"><span class=
          "section-number-4">1.3.9.</span> finalize setup()
          argument signature</h4>
          <div class="outline-text-4" id="text-1-3-9">
            <div class="org-src-container">
              <pre class="src src-js" id="org3f9976d"><span class=
              "linenr"> 1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">finalizeSetupArgumentSignature</span>() {
<span class="linenr"> 2: </span>  <span class=
"org-keyword">if</span> (propsTypeDecl) {
<span class="linenr"> 3: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">mark as any and only cast on assignment</span>
<span class="linenr"> 4: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">since the user defined complex types may be incompatible with the</span>
<span class="linenr"> 5: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">inferred type from generated runtime declarations</span>
<span class="linenr"> 6: </span>    args += <span class=
"org-string">`: any`</span>
<span class="linenr"> 7: </span>  }
<span class="linenr"> 8: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">inject user assignment of props</span>
<span class="linenr"> 9: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">we use a default __props so that template expressions referencing props</span>
<span class="linenr">10: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">can use it directly</span>
<span class="linenr">11: </span>  <span class=
"org-keyword">if</span> (propsIdentifier) {
<span class="linenr">12: </span>    s.prependLeft(
<span class="linenr">13: </span>      startOffset,
<span class="linenr">14: </span>      <span class=
"org-string">`\nconst ${propsIdentifier} = __props${</span>
<span class="linenr">15: </span><span class=
"org-string">        propsTypeDecl ? `</span> as ${genSetupPropsType(propsTypeDecl)}<span class="org-string">` : ``</span>
<span class="linenr">16: </span><span class=
"org-string">      }\n`</span>
<span class="linenr">17: </span>    )
<span class="linenr">18: </span>  }
<span class="linenr">19: </span>  <span class=
"org-keyword">if</span> (propsDestructureRestId) {
<span class="linenr">20: </span>    s.prependLeft(
<span class="linenr">21: </span>      startOffset,
<span class="linenr">22: </span>      <span class=
"org-string">`\nconst ${propsDestructureRestId} = ${helper(</span>
<span class="linenr">23: </span><span class=
"org-string">        `</span>createPropsRestProxy<span class=
"org-string">`</span>
<span class="linenr">24: </span><span class=
"org-string">      )}(__props, ${JSON.stringify(Object.keys(propsDestructuredBindings))})\n`</span>
<span class="linenr">25: </span>    )
<span class="linenr">26: </span>  }
<span class="linenr">27: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">inject temp variables for async context preservation</span>
<span class="linenr">28: </span>  <span class=
"org-keyword">if</span> (hasAwait) {
<span class="linenr">29: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">any</span> = isTS ? <span class=
"org-string">`: any`</span> : <span class="org-string">``</span>
<span class=
"linenr">30: </span>    s.prependLeft(startOffset, <span class=
"org-string">`\nlet __temp${any}, __restore${any}\n`</span>)
<span class="linenr">31: </span>  }
<span class="linenr">32: </span>
<span class="linenr">33: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">destructureElements</span> =
<span class=
"linenr">34: </span>    hasDefineExposeCall || !options.inlineTemplate ? [<span class="org-string">`expose`</span>] : []
<span class="linenr">35: </span>  <span class=
"org-keyword">if</span> (emitIdentifier) {
<span class="linenr">36: </span>    destructureElements.push(
<span class=
"linenr">37: </span>      emitIdentifier === <span class=
"org-string">`emit`</span> ? <span class=
"org-string">`emit`</span> : <span class=
"org-string">`emit: ${emitIdentifier}`</span>
<span class="linenr">38: </span>    )
<span class="linenr">39: </span>  }
<span class="linenr">40: </span>  <span class=
"org-keyword">if</span> (destructureElements.length) {
<span class="linenr">41: </span>    args += <span class=
"org-string">`, { ${destructureElements.join(', ')} }`</span>
<span class="linenr">42: </span>    <span class=
"org-keyword">if</span> (emitsTypeDecl) {
<span class="linenr">43: </span>      args += <span class=
"org-string">`: { emit: (${scriptSetup.content.slice(</span>
<span class="linenr">44: </span><span class=
"org-string">        emitsTypeDecl.start,</span>
<span class="linenr">45: </span><span class=
"org-string">        emitsTypeDecl.end</span>
<span class="linenr">46: </span><span class=
"org-string">      )}), expose: any, slots: any, attrs: any }`</span>
<span class="linenr">47: </span>    }
<span class="linenr">48: </span>  }
<span class="linenr">49: </span>}
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-orgb18f8cb" class="outline-4">
          <h4 id="orgb18f8cb"><span class=
          "section-number-4">1.3.10.</span> generate return
          statement</h4>
          <div class="outline-text-4" id="text-1-3-10">
            <div class="org-src-container">
              <pre class="src src-js" id="orga9b916e"><span class=
              "linenr"> 1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">generateReturnStatement</span>() {
<span class="linenr"> 2: </span>  <span class=
"org-keyword">if</span> (options.inlineTemplate) {
<span class="linenr"> 3: </span>    <span class=
"org-keyword">if</span> (sfc.template &amp;& !sfc.template.src) {
<span class="linenr"> 4: </span>      <span class=
"org-keyword">if</span> (options.templateOptions &amp;& options.templateOptions.ssr) {
<span class=
"linenr"> 5: </span>        hasInlinedSsrRenderFn = <span class=
"org-constant">true</span>
<span class="linenr"> 6: </span>      }
<span class="linenr"> 7: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">inline render function mode - we are going to compile the template and</span>
<span class="linenr"> 8: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">inline it right here</span>
<span class="linenr"> 9: </span>      <span class=
"org-keyword">const</span> { code, ast, preamble, tips, errors } = compileTemplate({
<span class="linenr">10: </span>        filename,
<span class=
"linenr">11: </span>        source: sfc.template.content,
<span class="linenr">12: </span>        inMap: sfc.template.map,
<span class="linenr">13: </span>        ...options.templateOptions,
<span class="linenr">14: </span>        id: scopeId,
<span class=
"linenr">15: </span>        scoped: sfc.styles.some(s =&gt; s.scoped),
<span class="linenr">16: </span>        isProd: options.isProd,
<span class="linenr">17: </span>        ssrCssVars: sfc.cssVars,
<span class="linenr">18: </span>        compilerOptions: {
<span class=
"linenr">19: </span>          ...(options.templateOptions &amp;&
<span class=
"linenr">20: </span>            options.templateOptions.compilerOptions),
<span class="linenr">21: </span>          inline: <span class=
"org-constant">true</span>,
<span class="linenr">22: </span>          isTS,
<span class="linenr">23: </span>          bindingMetadata
<span class="linenr">24: </span>        }
<span class="linenr">25: </span>      })
<span class="linenr">26: </span>
<span class="linenr">27: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">err</span> = errors[<span class=
"org-highlight-numbers-number">0</span>]
<span class="linenr">28: </span>      <span class=
"org-keyword">if</span> (<span class=
"org-keyword">typeof</span> err === <span class=
"org-string">'string'</span>) {
<span class="linenr">29: </span>        <span class=
"org-keyword">throw</span> <span class=
"org-keyword">new</span> <span class="org-type">Error</span>(err)
<span class="linenr">30: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (err) {
<span class="linenr">31: </span>        <span class=
"org-keyword">if</span> (err.loc) {
<span class="linenr">32: </span>          err.message +=
<span class="linenr">33: </span>            <span class=
"org-string">`\n\n`</span> +
<span class="linenr">34: </span>            sfc.filename +
<span class="linenr">35: </span>            <span class=
"org-string">'\n'</span> +
<span class="linenr">36: </span>            generateCodeFrame(
<span class="linenr">37: </span>              source,
<span class="linenr">38: </span>              err.loc.start.offset,
<span class="linenr">39: </span>              err.loc.end.offset
<span class="linenr">40: </span>            ) +
<span class="linenr">41: </span>            <span class=
"org-string">`\n`</span>
<span class="linenr">42: </span>        }
<span class="linenr">43: </span>        <span class=
"org-keyword">throw</span> err
<span class="linenr">44: </span>      }
<span class="linenr">45: </span>      <span class=
"org-keyword">if</span> (preamble) {
<span class="linenr">46: </span>        s.prepend(preamble)
<span class="linenr">47: </span>      }
<span class="linenr">48: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">avoid duplicated unref import</span>
<span class="linenr">49: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">as this may get injected by the render function preamble OR the</span>
<span class="linenr">50: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">css vars codegen</span>
<span class="linenr">51: </span>      <span class=
"org-keyword">if</span> (ast &amp;& ast.helpers.includes(UNREF)) {
<span class="linenr">52: </span>        helperImports.<span class=
"org-keyword">delete</span>(<span class=
"org-string">'unref'</span>)
<span class="linenr">53: </span>      }
<span class="linenr">54: </span>      returned = code
<span class="linenr">55: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr">56: </span>      returned = <span class=
"org-string">`() =&gt; {}`</span>
<span class="linenr">57: </span>    }
<span class="linenr">58: </span>  } <span class=
"org-keyword">else</span> {
<span class="linenr">59: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">return bindings from script and script setup</span>
<span class="linenr">60: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">allBindings</span>= {
<span class="linenr">61: </span>      ...scriptBindings,
<span class="linenr">62: </span>      ...setupBindings
<span class="linenr">63: </span>    }
<span class="linenr">64: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">in</span> userImports) {
<span class="linenr">65: </span>      <span class=
"org-keyword">if</span> (!userImports[key].isType &amp;& userImports[key].isUsedInTemplate) {
<span class=
"linenr">66: </span>        allBindings[key] = <span class=
"org-constant">true</span>
<span class="linenr">67: </span>      }
<span class="linenr">68: </span>    }
<span class="linenr">69: </span>    returned = <span class=
"org-string">`{ ${Object.keys(allBindings).join(', ')} }`</span>
<span class="linenr">70: </span>  }
<span class="linenr">71: </span>
<span class="linenr">72: </span>  <span class=
"org-keyword">if</span> (!options.inlineTemplate) {
<span class="linenr">73: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">in non-inline mode, the `__isScriptSetup: true` flag is used by</span>
<span class="linenr">74: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">componentPublicInstance proxy to allow properties that start with $ or _</span>
<span class="linenr">75: </span>    s.appendRight(
<span class="linenr">76: </span>      endOffset,
<span class="linenr">77: </span>      <span class=
"org-string">`\nconst __returned__ = ${returned}\n`</span> +
<span class="linenr">78: </span>        <span class=
"org-string">`Object.defineProperty(__returned__, '__isScriptSetup', { enumerable: false, value: true })\n`</span> +
<span class="linenr">79: </span>        <span class=
"org-string">`return __returned__`</span> +
<span class="linenr">80: </span>        <span class=
"org-string">`\n}\n\n`</span>
<span class="linenr">81: </span>    )
<span class="linenr">82: </span>  } <span class=
"org-keyword">else</span> {
<span class=
"linenr">83: </span>    s.appendRight(endOffset, <span class=
"org-string">`\nreturn ${returned}\n}\n\n`</span>)
<span class="linenr">84: </span>  }
<span class="linenr">85: </span>}
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-org9a4824e" class="outline-4">
          <h4 id="org9a4824e"><span class=
          "section-number-4">1.3.11.</span> finalize default
          export</h4>
          <div class="outline-text-4" id="text-1-3-11">
            <div class="org-src-container">
              <pre class="src src-js" id="org711b955"><span class=
              "linenr"> 1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">finalizeDefaultExport</span>() {
<span class="linenr"> 2: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">runtimeOptions</span> = <span class=
"org-string">``</span>
<span class="linenr"> 3: </span>  <span class=
"org-keyword">if</span> (hasInlinedSsrRenderFn) {
<span class="linenr"> 4: </span>    runtimeOptions += <span class=
"org-string">`\n  __ssrInlineRender: true,`</span>
<span class="linenr"> 5: </span>  }
<span class="linenr"> 6: </span>  <span class=
"org-keyword">if</span> (propsRuntimeDecl) {
<span class="linenr"> 7: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">declCode</span> = scriptSetup.content
<span class=
"linenr"> 8: </span>      .slice(propsRuntimeDecl.start, propsRuntimeDecl.end)
<span class="linenr"> 9: </span>      .trim()
<span class="linenr">10: </span>    <span class=
"org-keyword">if</span> (propsDestructureDecl) {
<span class="linenr">11: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">defaults</span> = []
<span class="linenr">12: </span>      <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">in</span> propsDestructuredBindings) {
<span class="linenr">13: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">d</span> = genDestructuredDefaultValue(key)
<span class="linenr">14: </span>        <span class=
"org-keyword">if</span> (d) defaults.push(<span class=
"org-string">`${key}: ${d}`</span>)
<span class="linenr">15: </span>      }
<span class="linenr">16: </span>      <span class=
"org-keyword">if</span> (defaults.length) {
<span class="linenr">17: </span>        declCode = <span class=
"org-string">`${helper(</span>
<span class="linenr">18: </span><span class=
"org-string">          `</span>mergeDefaults<span class=
"org-string">`</span>
<span class="linenr">19: </span><span class=
"org-string">        )}(${declCode}, {\n  ${defaults.join(',\n  ')}\n})`</span>
<span class="linenr">20: </span>      }
<span class="linenr">21: </span>    }
<span class="linenr">22: </span>    runtimeOptions += <span class=
"org-string">`\n  props: ${declCode},`</span>
<span class="linenr">23: </span>  } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (propsTypeDecl) {
<span class=
"linenr">24: </span>    runtimeOptions += genRuntimeProps(typeDeclaredProps)
<span class="linenr">25: </span>  }
<span class="linenr">26: </span>  <span class=
"org-keyword">if</span> (emitsRuntimeDecl) {
<span class="linenr">27: </span>    runtimeOptions += <span class=
"org-string">`\n  emits: ${scriptSetup.content</span>
<span class="linenr">28: </span><span class=
"org-string">      .slice(emitsRuntimeDecl.start, emitsRuntimeDecl.end)</span>
<span class="linenr">29: </span><span class=
"org-string">      .trim()},`</span>
<span class="linenr">30: </span>  } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (emitsTypeDecl) {
<span class=
"linenr">31: </span>    runtimeOptions += genRuntimeEmits(typeDeclaredEmits)
<span class="linenr">32: </span>  }
<span class="linenr">33: </span>
<span class="linenr">34: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">&lt;script setup&gt; components are closed by default. If the user did not</span>
<span class="linenr">35: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">explicitly call `defineExpose`, call expose() with no args.</span>
<span class="linenr">36: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">exposeCall</span> =
<span class=
"linenr">37: </span>    hasDefineExposeCall || options.inlineTemplate ? <span class="org-string">``</span> : <span class="org-string">`  expose();\n`</span>
<span class="linenr">38: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">wrap setup code with function.</span>
<span class="linenr">39: </span>  <span class=
"org-keyword">if</span> (isTS) {
<span class="linenr">40: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">for TS, make sure the exported type is still valid type with</span>
<span class="linenr">41: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">correct props information</span>
<span class="linenr">42: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">we have to use object spread for types to be merged properly</span>
<span class="linenr">43: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">user's TS setting should compile it down to proper targets</span>
<span class="linenr">44: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">export default defineComponent({ ...__default__, ... })</span>
<span class="linenr">45: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">def</span> = defaultExport ? <span class=
"org-string">`\n  ...${DEFAULT_VAR},`</span> : <span class=
"org-string">``</span>
<span class="linenr">46: </span>    s.prependLeft(
<span class="linenr">47: </span>      startOffset,
<span class="linenr">48: </span>      <span class=
"org-string">`\nexport default /*#__PURE__*/${helper(</span>
<span class="linenr">49: </span><span class=
"org-string">        `</span>defineComponent<span class=
"org-string">`</span>
<span class="linenr">50: </span><span class=
"org-string">      )}({${def}${runtimeOptions}\n  ${</span>
<span class="linenr">51: </span><span class=
"org-string">        hasAwait ? `</span><span class=
"org-keyword">async</span> <span class="org-string">` : ``</span>
<span class="linenr">52: </span><span class=
"org-string">      }setup(${args}) {\n${exposeCall}`</span>
<span class="linenr">53: </span>    )
<span class=
"linenr">54: </span>    s.appendRight(endOffset, <span class=
"org-string">`})`</span>)
<span class="linenr">55: </span>  } <span class=
"org-keyword">else</span> {
<span class="linenr">56: </span>    <span class=
"org-keyword">if</span> (defaultExport) {
<span class="linenr">57: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">without TS, can't rely on rest spread, so we use Object.assign</span>
<span class="linenr">58: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">export default Object.assign(__default__, { ... })</span>
<span class="linenr">59: </span>      s.prependLeft(
<span class="linenr">60: </span>        startOffset,
<span class="linenr">61: </span>        <span class=
"org-string">`\nexport default /*#__PURE__*/Object.assign(${DEFAULT_VAR}, {${runtimeOptions}\n  `</span> +
<span class="linenr">62: </span>          <span class=
"org-string">`${hasAwait ? `</span><span class=
"org-keyword">async</span> <span class=
"org-string">` : ``}setup(${args}) {\n${exposeCall}`</span>
<span class="linenr">63: </span>      )
<span class=
"linenr">64: </span>      s.appendRight(endOffset, <span class=
"org-string">`})`</span>)
<span class="linenr">65: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr">66: </span>      s.prependLeft(
<span class="linenr">67: </span>        startOffset,
<span class="linenr">68: </span>        <span class=
"org-string">`\nexport default {${runtimeOptions}\n  `</span> +
<span class="linenr">69: </span>          <span class=
"org-string">`${hasAwait ? `</span><span class=
"org-keyword">async</span> <span class=
"org-string">` : ``}setup(${args}) {\n${exposeCall}`</span>
<span class="linenr">70: </span>      )
<span class=
"linenr">71: </span>      s.appendRight(endOffset, <span class=
"org-string">`}`</span>)
<span class="linenr">72: </span>    }
<span class="linenr">73: </span>  }
<span class="linenr">74: </span>}
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-orge172c72" class="outline-4">
          <h4 id="orge172c72"><span class=
          "section-number-4">1.3.12.</span> finalize Vue helper
          imports</h4>
          <div class="outline-text-4" id="text-1-3-12">
            <div class="org-src-container">
              <pre class="src src-js" id="orge050a6e"><span class=
              "linenr">1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">finalizeVueHelperImports</span>() {
<span class="linenr">2: </span>  <span class=
"org-keyword">if</span> (helperImports.size &gt; <span class=
"org-highlight-numbers-number">0</span>) {
<span class="linenr">3: </span>    s.prepend(
<span class="linenr">4: </span>      <span class=
"org-string">`import { ${[...helperImports]</span>
<span class="linenr">5: </span><span class=
"org-string">        .map(h =&gt; `</span>${h} as _${h}<span class=
"org-string">`)</span>
<span class="linenr">6: </span><span class=
"org-string">        .join(', ')} } from 'vue'\n`</span>
<span class="linenr">7: </span>    )
<span class="linenr">8: </span>  }
<span class="linenr">9: </span>}
</pre>
            </div>
          </div>
        </div>
      </div>
      <div id="outline-container-orgd09c3ba" class="outline-3">
        <h3 id="orgd09c3ba"><span class=
        "section-number-3">1.4.</span> functions</h3>
        <div class="outline-text-3" id="text-1-4">
          <div class="org-src-container">
            <pre class="src src-js" id="org5508090"><span class=
            "linenr"> 1: </span>&lt;&lt;registerBinding&gt;&gt;
<span class="linenr"> 2: </span>&lt;&lt;walkDeclaration&gt;&gt;
<span class="linenr"> 3: </span>&lt;&lt;walkObjectPattern&gt;&gt;
<span class="linenr"> 4: </span>&lt;&lt;walkArrayPattern&gt;&gt;
<span class="linenr"> 5: </span>&lt;&lt;walkPattern&gt;&gt;
<span class="linenr"> 6: </span>&lt;&lt;recordType&gt;&gt;
<span class="linenr"> 7: </span>&lt;&lt;extractRuntimeProps&gt;&gt;
<span class="linenr"> 8: </span>&lt;&lt;inferRuntimeType&gt;&gt;
<span class="linenr"> 9: </span>&lt;&lt;toRuntimeTypeString&gt;&gt;
<span class="linenr">10: </span>&lt;&lt;extractRuntimeEmits&gt;&gt;
<span class="linenr">11: </span>&lt;&lt;extractEventNames&gt;&gt;
<span class="linenr">12: </span>&lt;&lt;genRuntimeEmits&gt;&gt;
<span class="linenr">13: </span>&lt;&lt;isCallOf&gt;&gt;
<span class="linenr">14: </span>&lt;&lt;canNeverBeRef&gt;&gt;
<span class=
"linenr">15: </span>&lt;&lt;analyzeScriptBindings&gt;&gt;
<span class=
"linenr">16: </span>&lt;&lt;analyzeBindingsFromOptions&gt;&gt;
<span class=
"linenr">17: </span>&lt;&lt;getObjectExpressionKeys&gt;&gt;
<span class=
"linenr">18: </span>&lt;&lt;getArrayExpressionKeys&gt;&gt;
<span class=
"linenr">19: </span>&lt;&lt;getObjectOrArrayExpressionKeys&gt;&gt;
<span class=
"linenr">20: </span>&lt;&lt;resolveTemplateUsageCheckString&gt;&gt;
<span class="linenr">21: </span>&lt;&lt;stripStrings&gt;&gt;
<span class="linenr">22: </span>&lt;&lt;isImportUsed&gt;&gt;
<span class="linenr">23: </span>&lt;&lt;hmrShouldReload&gt;&gt;
</pre>
          </div>
        </div>
        <div id="outline-container-org1be5a97" class="outline-4">
          <h4 id="org1be5a97"><span class=
          "section-number-4">1.4.1.</span> registerBinding()</h4>
          <div class="outline-text-4" id="text-1-4-1">
            <div class="org-src-container">
              <pre class="src src-js" id="orgf466f0f"><span class=
              "linenr">1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">registerBinding</span>(<span class=
              "org-variable-name">bindings</span>, <span class=
              "org-variable-name">node</span>, <span class=
              "org-variable-name">type</span>) {
<span class="linenr">2: </span>  bindings[node.name] = type
<span class="linenr">3: </span>}
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-orgf70aac2" class="outline-4">
          <h4 id="orgf70aac2"><span class=
          "section-number-4">1.4.2.</span> walkDeclaration()</h4>
          <div class="outline-text-4" id="text-1-4-2">
            <div class="org-src-container">
              <pre class="src src-js" id="org8ca6df5"><span class=
              "linenr"> 1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">walkDeclaration</span>(<span class=
              "org-variable-name">node</span>, <span class=
              "org-variable-name">bindings</span>, <span class=
              "org-variable-name">userImportAlias</span>) {
<span class="linenr"> 2: </span>  <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'VariableDeclaration'</span>) {
<span class="linenr"> 3: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isConst</span> = node.kind === <span class=
"org-string">'const'</span>
<span class="linenr"> 4: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">export const foo = ...</span>
<span class="linenr"> 5: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> { id, init } <span class=
"org-keyword">of</span> node.declarations) {
<span class="linenr"> 6: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isDefineCall</span> = !!(
<span class="linenr"> 7: </span>        isConst &amp;&
<span class="linenr"> 8: </span>        isCallOf(
<span class="linenr"> 9: </span>          init,
<span class=
"linenr">10: </span>          c =&gt; c === DEFINE_PROPS || c === DEFINE_EMITS || c === WITH_DEFAULTS
<span class="linenr">11: </span>        )
<span class="linenr">12: </span>      )
<span class="linenr">13: </span>      <span class=
"org-keyword">if</span> (id.type === <span class=
"org-string">'Identifier'</span>) {
<span class="linenr">14: </span>        <span class=
"org-keyword">let</span> <span class=
"org-variable-name">bindingType</span>
<span class="linenr">15: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">userReactiveBinding</span> = userImportAlias[<span class="org-string">'reactive'</span>] || <span class="org-string">'reactive'</span>
<span class="linenr">16: </span>        <span class=
"org-keyword">if</span> (isCallOf(init, userReactiveBinding)) {
<span class="linenr">17: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">treat reactive() calls as let since it's meant to be mutable</span>
<span class=
"linenr">18: </span>          bindingType = BindingTypes.SETUP_LET
<span class="linenr">19: </span>        } <span class=
"org-keyword">else</span> <span class="org-keyword">if</span> (
<span class="linenr">20: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">if a declaration is a const literal, we can mark it so that</span>
<span class="linenr">21: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">the generated render fn code doesn't need to unref() it</span>
<span class="linenr">22: </span>          isDefineCall ||
<span class=
"linenr">23: </span>          (isConst &amp;& canNeverBeRef(init, userReactiveBinding))
<span class="linenr">24: </span>        ) {
<span class=
"linenr">25: </span>          bindingType = BindingTypes.SETUP_CONST
<span class="linenr">26: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (isConst) {
<span class="linenr">27: </span>          <span class=
"org-keyword">if</span> (isCallOf(init, userImportAlias[<span class="org-string">'ref'</span>] || <span class="org-string">'ref'</span>)) {
<span class=
"linenr">28: </span>            bindingType = BindingTypes.SETUP_REF
<span class="linenr">29: </span>          } <span class=
"org-keyword">else</span> {
<span class=
"linenr">30: </span>            bindingType = BindingTypes.SETUP_MAYBE_REF
<span class="linenr">31: </span>          }
<span class="linenr">32: </span>        } <span class=
"org-keyword">else</span> {
<span class=
"linenr">33: </span>          bindingType = BindingTypes.SETUP_LET
<span class="linenr">34: </span>        }
<span class=
"linenr">35: </span>        registerBinding(bindings, id, bindingType)
<span class="linenr">36: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr">37: </span>        <span class=
"org-keyword">if</span> (isCallOf(init, DEFINE_PROPS)) {
<span class="linenr">38: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">skip walking props destructure</span>
<span class="linenr">39: </span>          <span class=
"org-keyword">return</span>
<span class="linenr">40: </span>        }
<span class="linenr">41: </span>        <span class=
"org-keyword">if</span> (id.type === <span class=
"org-string">'ObjectPattern'</span>) {
<span class=
"linenr">42: </span>          walkObjectPattern(id, bindings, isConst, isDefineCall)
<span class="linenr">43: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (id.type === <span class=
"org-string">'ArrayPattern'</span>) {
<span class=
"linenr">44: </span>          walkArrayPattern(id, bindings, isConst, isDefineCall)
<span class="linenr">45: </span>        }
<span class="linenr">46: </span>      }
<span class="linenr">47: </span>    }
<span class="linenr">48: </span>  } <span class=
"org-keyword">else</span> <span class="org-keyword">if</span> (
<span class="linenr">49: </span>    node.type === <span class=
"org-string">'TSEnumDeclaration'</span> ||
<span class="linenr">50: </span>    node.type === <span class=
"org-string">'FunctionDeclaration'</span> ||
<span class="linenr">51: </span>    node.type === <span class=
"org-string">'ClassDeclaration'</span>
<span class="linenr">52: </span>  ) {
<span class="linenr">53: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">export function foo() {} / export class Foo {}</span>
<span class="linenr">54: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">export declarations must be named.</span>
<span class=
"linenr">55: </span>    bindings[node.id.name] = BindingTypes.SETUP_CONST
<span class="linenr">56: </span>  }
<span class="linenr">57: </span>}
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-org46aa7dd" class="outline-4">
          <h4 id="org46aa7dd"><span class=
          "section-number-4">1.4.3.</span> walkObjectPattern()</h4>
          <div class="outline-text-4" id="text-1-4-3">
            <div class="org-src-container">
              <pre class="src src-js" id="org163faf3"><span class=
              "linenr"> 1: </span>
<span class="linenr"> 2: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">walkObjectPattern</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">bindings</span>, <span class=
"org-variable-name">isConst</span>, <span class=
"org-variable-name">isDefineCall</span> = <span class=
"org-constant">false</span>) {
<span class="linenr"> 3: </span>  <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">p</span> <span class=
"org-keyword">of</span> node.properties) {
<span class="linenr"> 4: </span>    <span class=
"org-keyword">if</span> (p.type === <span class=
"org-string">'ObjectProperty'</span>) {
<span class="linenr"> 5: </span>      <span class=
"org-keyword">if</span> (p.key.type === <span class=
"org-string">'Identifier'</span> &amp;& p.key === p.value) {
<span class="linenr"> 6: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">shorthand: const { x } = ...</span>
<span class="linenr"> 7: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">type</span> = isDefineCall
<span class=
"linenr"> 8: </span>          ? BindingTypes.SETUP_CONST
<span class="linenr"> 9: </span>          : isConst
<span class=
"linenr">10: </span>          ? BindingTypes.SETUP_MAYBE_REF
<span class="linenr">11: </span>          : BindingTypes.SETUP_LET
<span class=
"linenr">12: </span>        registerBinding(bindings, p.key, type)
<span class="linenr">13: </span>      } <span class=
"org-keyword">else</span> {
<span class=
"linenr">14: </span>        walkPattern(p.value, bindings, isConst, isDefineCall)
<span class="linenr">15: </span>      }
<span class="linenr">16: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr">17: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">...rest</span>
<span class="linenr">18: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">argument can only be identifier when destructuring</span>
<span class="linenr">19: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">type</span> = isConst ? BindingTypes.SETUP_CONST : BindingTypes.SETUP_LET
<span class=
"linenr">20: </span>      registerBinding(bindings, p.argument, type)
<span class="linenr">21: </span>    }
<span class="linenr">22: </span>  }
<span class="linenr">23: </span>}
<span class="linenr">24: </span>
<span class="linenr">25: </span>
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-org6693c78" class="outline-4">
          <h4 id="org6693c78"><span class=
          "section-number-4">1.4.4.</span> walkArrayPattern()</h4>
          <div class="outline-text-4" id="text-1-4-4">
            <div class="org-src-container">
              <pre class="src src-js" id="org4ff1bf2"><span class=
              "linenr">1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">walkArrayPattern</span>(<span class=
              "org-variable-name">node</span>, <span class=
              "org-variable-name">bindings</span>, <span class=
              "org-variable-name">isConst</span>, <span class=
              "org-variable-name">isDefineCall</span> = <span class=
              "org-constant">false</span>) {
<span class="linenr">2: </span>  <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">e</span> <span class=
"org-keyword">of</span> node.elements) {
<span class=
"linenr">3: </span>    e &amp;& walkPattern(e, bindings, isConst, isDefineCall)
<span class="linenr">4: </span>  }
<span class="linenr">5: </span>}
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-org55e8e2a" class="outline-4">
          <h4 id="org55e8e2a"><span class=
          "section-number-4">1.4.5.</span> walkPattern()</h4>
          <div class="outline-text-4" id="text-1-4-5">
            <div class="org-src-container">
              <pre class="src src-js" id="org6e682f5"><span class=
              "linenr"> 1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">walkPattern</span>(<span class=
              "org-variable-name">node</span>, <span class=
              "org-variable-name">bindings</span>, <span class=
              "org-variable-name">isConst</span>, <span class=
              "org-variable-name">isDefineCall</span> = <span class=
              "org-constant">false</span>) {
<span class="linenr"> 2: </span>  <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'Identifier'</span>) {
<span class="linenr"> 3: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">type</span> = isDefineCall
<span class="linenr"> 4: </span>      ? BindingTypes.SETUP_CONST
<span class="linenr"> 5: </span>      : isConst
<span class=
"linenr"> 6: </span>      ? BindingTypes.SETUP_MAYBE_REF
<span class="linenr"> 7: </span>      : BindingTypes.SETUP_LET
<span class=
"linenr"> 8: </span>    registerBinding(bindings, node, type)
<span class="linenr"> 9: </span>  } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'RestElement'</span>) {
<span class="linenr">10: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">argument can only be identifier when destructuring</span>
<span class="linenr">11: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">type</span> = isConst ? BindingTypes.SETUP_CONST : BindingTypes.SETUP_LET
<span class=
"linenr">12: </span>    registerBinding(bindings, node.argument, type)
<span class="linenr">13: </span>  } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'ObjectPattern'</span>) {
<span class=
"linenr">14: </span>    walkObjectPattern(node, bindings, isConst)
<span class="linenr">15: </span>  } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'ArrayPattern'</span>) {
<span class=
"linenr">16: </span>    walkArrayPattern(node, bindings, isConst)
<span class="linenr">17: </span>  } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'AssignmentPattern'</span>) {
<span class="linenr">18: </span>    <span class=
"org-keyword">if</span> (node.left.type === <span class=
"org-string">'Identifier'</span>) {
<span class="linenr">19: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">type</span> = isDefineCall
<span class="linenr">20: </span>        ? BindingTypes.SETUP_CONST
<span class="linenr">21: </span>        : isConst
<span class=
"linenr">22: </span>        ? BindingTypes.SETUP_MAYBE_REF
<span class="linenr">23: </span>        : BindingTypes.SETUP_LET
<span class=
"linenr">24: </span>      registerBinding(bindings, node.left, type)
<span class="linenr">25: </span>    } <span class=
"org-keyword">else</span> {
<span class=
"linenr">26: </span>      walkPattern(node.left, bindings, isConst)
<span class="linenr">27: </span>    }
<span class="linenr">28: </span>  }
<span class="linenr">29: </span>}
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-org8597d17" class="outline-4">
          <h4 id="org8597d17"><span class=
          "section-number-4">1.4.6.</span> recordType()</h4>
          <div class="outline-text-4" id="text-1-4-6">
            <div class="org-src-container">
              <pre class="src src-js" id="orgd930987"><span class=
              "linenr"> 1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">recordType</span>(<span class=
              "org-variable-name">node</span>, <span class=
              "org-variable-name">declaredTypes</span>) {
<span class="linenr"> 2: </span>  <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'TSInterfaceDeclaration'</span>) {
<span class=
"linenr"> 3: </span>    declaredTypes[node.id.name] = [<span class=
"org-string">`Object`</span>]
<span class="linenr"> 4: </span>  } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'TSTypeAliasDeclaration'</span>) {
<span class=
"linenr"> 5: </span>    declaredTypes[node.id.name] = inferRuntimeType(
<span class="linenr"> 6: </span>      node.typeAnnotation,
<span class="linenr"> 7: </span>      declaredTypes
<span class="linenr"> 8: </span>    )
<span class="linenr"> 9: </span>  } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'ExportNamedDeclaration'</span> &amp;& node.declaration) {
<span class=
"linenr">10: </span>    recordType(node.declaration, declaredTypes)
<span class="linenr">11: </span>  }
<span class="linenr">12: </span>}
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-orgf917328" class="outline-4">
          <h4 id="orgf917328"><span class=
          "section-number-4">1.4.7.</span>
          extractRuntimeProps()</h4>
          <div class="outline-text-4" id="text-1-4-7">
            <div class="org-src-container">
              <pre class="src src-js" id="orge9042a3"><span class=
              "linenr"> 1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">extractRuntimeProps</span>(<span class=
              "org-variable-name">node</span>, <span class=
              "org-variable-name">props</span>, <span class=
              "org-variable-name">declaredTypes</span>, <span class=
              "org-variable-name">isProd</span>) {
<span class="linenr"> 2: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">members</span> = node.type === <span class=
"org-string">'TSTypeLiteral'</span> ? node.members : node.body
<span class="linenr"> 3: </span>  <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">m</span> <span class=
"org-keyword">of</span> members) {
<span class="linenr"> 4: </span>    <span class=
"org-keyword">if</span> (
<span class="linenr"> 5: </span>      (m.type === <span class=
"org-string">'TSPropertySignature'</span> || m.type === <span class="org-string">'TSMethodSignature'</span>) &amp;&
<span class="linenr"> 6: </span>      m.key.type === <span class=
"org-string">'Identifier'</span>
<span class="linenr"> 7: </span>    ) {
<span class="linenr"> 8: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">type</span>
<span class="linenr"> 9: </span>      <span class=
"org-keyword">if</span> (m.type === <span class=
"org-string">'TSMethodSignature'</span>) {
<span class="linenr">10: </span>        type = [<span class=
"org-string">'Function'</span>]
<span class="linenr">11: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (m.typeAnnotation) {
<span class=
"linenr">12: </span>        type = inferRuntimeType(m.typeAnnotation.typeAnnotation, declaredTypes)
<span class="linenr">13: </span>      }
<span class="linenr">14: </span>      props[m.key.name] = {
<span class="linenr">15: </span>        key: m.key.name,
<span class="linenr">16: </span>        required: !m.optional,
<span class="linenr">17: </span>        type: type || [<span class=
"org-string">`null`</span>]
<span class="linenr">18: </span>      }
<span class="linenr">19: </span>    }
<span class="linenr">20: </span>  }
<span class="linenr">21: </span>}
<span class="linenr">22: </span>
<span class="linenr">23: </span>
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-orgc812607" class="outline-4">
          <h4 id="orgc812607"><span class=
          "section-number-4">1.4.8.</span> inferRuntimeType()</h4>
          <div class="outline-text-4" id="text-1-4-8">
            <div class="org-src-container">
              <pre class="src src-js" id="org8a65dbe"><span class=
              "linenr"> 1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">inferRuntimeType</span>(<span class=
              "org-variable-name">node</span>, <span class=
              "org-variable-name">declaredTypes</span>) {
<span class="linenr"> 2: </span>  <span class=
"org-keyword">switch</span> (node.type) {
<span class="linenr"> 3: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'TSStringKeyword'</span>:
<span class="linenr"> 4: </span>      <span class=
"org-keyword">return</span> [<span class=
"org-string">'String'</span>]
<span class="linenr"> 5: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'TSNumberKeyword'</span>:
<span class="linenr"> 6: </span>      <span class=
"org-keyword">return</span> [<span class=
"org-string">'Number'</span>]
<span class="linenr"> 7: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'TSBooleanKeyword'</span>:
<span class="linenr"> 8: </span>      <span class=
"org-keyword">return</span> [<span class=
"org-string">'Boolean'</span>]
<span class="linenr"> 9: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'TSObjectKeyword'</span>:
<span class="linenr">10: </span>      <span class=
"org-keyword">return</span> [<span class=
"org-string">'Object'</span>]
<span class="linenr">11: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'TSTypeLiteral'</span>:
<span class="linenr">12: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment"><span class="org-bold"><span class=
"org-warning">TODO</span></span></span><span class=
"org-comment"> (nice to have) generate runtime property validation</span>
<span class="linenr">13: </span>      <span class=
"org-keyword">return</span> [<span class=
"org-string">'Object'</span>]
<span class="linenr">14: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'TSFunctionType'</span>:
<span class="linenr">15: </span>      <span class=
"org-keyword">return</span> [<span class=
"org-string">'Function'</span>]
<span class="linenr">16: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'TSArrayType'</span>:
<span class="linenr">17: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'TSTupleType'</span>:
<span class="linenr">18: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment"><span class="org-bold"><span class=
"org-warning">TODO</span></span></span><span class=
"org-comment"> (nice to have) generate runtime element type/length checks</span>
<span class="linenr">19: </span>      <span class=
"org-keyword">return</span> [<span class=
"org-string">'Array'</span>]
<span class="linenr">20: </span>
<span class="linenr">21: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'TSLiteralType'</span>:
<span class="linenr">22: </span>      <span class=
"org-keyword">switch</span> (node.literal.type) {
<span class="linenr">23: </span>        <span class=
"org-keyword">case</span> <span class=
"org-string">'StringLiteral'</span>:
<span class="linenr">24: </span>          <span class=
"org-keyword">return</span> [<span class=
"org-string">'String'</span>]
<span class="linenr">25: </span>        <span class=
"org-keyword">case</span> <span class=
"org-string">'BooleanLiteral'</span>:
<span class="linenr">26: </span>          <span class=
"org-keyword">return</span> [<span class=
"org-string">'Boolean'</span>]
<span class="linenr">27: </span>        <span class=
"org-keyword">case</span> <span class=
"org-string">'NumericLiteral'</span>:
<span class="linenr">28: </span>        <span class=
"org-keyword">case</span> <span class=
"org-string">'BigIntLiteral'</span>:
<span class="linenr">29: </span>          <span class=
"org-keyword">return</span> [<span class=
"org-string">'Number'</span>]
<span class="linenr">30: </span>        <span class=
"org-keyword">default</span>:
<span class="linenr">31: </span>          <span class=
"org-keyword">return</span> [<span class=
"org-string">`null`</span>]
<span class="linenr">32: </span>      }
<span class="linenr">33: </span>
<span class="linenr">34: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'TSTypeReference'</span>:
<span class="linenr">35: </span>      <span class=
"org-keyword">if</span> (node.typeName.type === <span class=
"org-string">'Identifier'</span>) {
<span class="linenr">36: </span>        <span class=
"org-keyword">if</span> (declaredTypes[node.typeName.name]) {
<span class="linenr">37: </span>          <span class=
"org-keyword">return</span> declaredTypes[node.typeName.name]
<span class="linenr">38: </span>        }
<span class="linenr">39: </span>        <span class=
"org-keyword">switch</span> (node.typeName.name) {
<span class="linenr">40: </span>          <span class=
"org-keyword">case</span> <span class="org-string">'Array'</span>:
<span class="linenr">41: </span>          <span class=
"org-keyword">case</span> <span class=
"org-string">'Function'</span>:
<span class="linenr">42: </span>          <span class=
"org-keyword">case</span> <span class="org-string">'Object'</span>:
<span class="linenr">43: </span>          <span class=
"org-keyword">case</span> <span class="org-string">'Set'</span>:
<span class="linenr">44: </span>          <span class=
"org-keyword">case</span> <span class="org-string">'Map'</span>:
<span class="linenr">45: </span>          <span class=
"org-keyword">case</span> <span class=
"org-string">'WeakSet'</span>:
<span class="linenr">46: </span>          <span class=
"org-keyword">case</span> <span class=
"org-string">'WeakMap'</span>:
<span class="linenr">47: </span>          <span class=
"org-keyword">case</span> <span class="org-string">'Date'</span>:
<span class="linenr">48: </span>            <span class=
"org-keyword">return</span> [node.typeName.name]
<span class="linenr">49: </span>          <span class=
"org-keyword">case</span> <span class="org-string">'Record'</span>:
<span class="linenr">50: </span>          <span class=
"org-keyword">case</span> <span class=
"org-string">'Partial'</span>:
<span class="linenr">51: </span>          <span class=
"org-keyword">case</span> <span class=
"org-string">'Readonly'</span>:
<span class="linenr">52: </span>          <span class=
"org-keyword">case</span> <span class="org-string">'Pick'</span>:
<span class="linenr">53: </span>          <span class=
"org-keyword">case</span> <span class="org-string">'Omit'</span>:
<span class="linenr">54: </span>          <span class=
"org-keyword">case</span> <span class=
"org-string">'Exclude'</span>:
<span class="linenr">55: </span>          <span class=
"org-keyword">case</span> <span class=
"org-string">'Extract'</span>:
<span class="linenr">56: </span>          <span class=
"org-keyword">case</span> <span class=
"org-string">'Required'</span>:
<span class="linenr">57: </span>          <span class=
"org-keyword">case</span> <span class=
"org-string">'InstanceType'</span>:
<span class="linenr">58: </span>            <span class=
"org-keyword">return</span> [<span class=
"org-string">'Object'</span>]
<span class="linenr">59: </span>        }
<span class="linenr">60: </span>      }
<span class="linenr">61: </span>      <span class=
"org-keyword">return</span> [<span class=
"org-string">`null`</span>]
<span class="linenr">62: </span>
<span class="linenr">63: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'TSParenthesizedType'</span>:
<span class="linenr">64: </span>      <span class=
"org-keyword">return</span> inferRuntimeType(node.typeAnnotation, declaredTypes)
<span class="linenr">65: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'TSUnionType'</span>:
<span class="linenr">66: </span>      <span class=
"org-keyword">return</span> [
<span class="linenr">67: </span>        ...<span class=
"org-keyword">new</span> <span class="org-type">Set</span>(
<span class="linenr">68: </span>          [].concat(
<span class=
"linenr">69: </span>            ...(node.types.map(t =&gt; inferRuntimeType(t, declaredTypes)))
<span class="linenr">70: </span>          )
<span class="linenr">71: </span>        )
<span class="linenr">72: </span>      ]
<span class="linenr">73: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'TSIntersectionType'</span>:
<span class="linenr">74: </span>      <span class=
"org-keyword">return</span> [<span class=
"org-string">'Object'</span>]
<span class="linenr">75: </span>
<span class="linenr">76: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'TSSymbolKeyword'</span>:
<span class="linenr">77: </span>      <span class=
"org-keyword">return</span> [<span class=
"org-string">'Symbol'</span>]
<span class="linenr">78: </span>
<span class="linenr">79: </span>    <span class=
"org-keyword">default</span>:
<span class="linenr">80: </span>      <span class=
"org-keyword">return</span> [<span class=
"org-string">`null`</span>] <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">no runtime check</span>
<span class="linenr">81: </span>  }
<span class="linenr">82: </span>}
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-org8ea11f2" class="outline-4">
          <h4 id="org8ea11f2"><span class=
          "section-number-4">1.4.9.</span>
          toRuntimeTypeString()</h4>
          <div class="outline-text-4" id="text-1-4-9">
            <div class="org-src-container">
              <pre class="src src-js" id="org0e56067"><span class=
              "linenr">1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">toRuntimeTypeString</span>(<span class=
              "org-variable-name">types</span>) {
<span class="linenr">2: </span>  <span class=
"org-keyword">return</span> types.length &gt; <span class=
"org-highlight-numbers-number">1</span> ? <span class=
"org-string">`[${types.join(', ')}]`</span> : types[<span class=
"org-highlight-numbers-number">0</span>]
<span class="linenr">3: </span>}
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-orgb74a603" class="outline-4">
          <h4 id="orgb74a603"><span class=
          "section-number-4">1.4.10.</span>
          extractRuntimeEmits()</h4>
          <div class="outline-text-4" id="text-1-4-10">
            <div class="org-src-container">
              <pre class="src src-js" id="orge2560bb"><span class=
              "linenr"> 1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">extractRuntimeEmits</span>(<span class=
              "org-variable-name">node</span>, <span class=
              "org-variable-name">emits</span>) {
<span class="linenr"> 2: </span>  <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'TSTypeLiteral'</span> || node.type === <span class=
"org-string">'TSInterfaceBody'</span>) {
<span class="linenr"> 3: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">members</span> = node.type === <span class=
"org-string">'TSTypeLiteral'</span> ? node.members : node.body
<span class="linenr"> 4: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">t</span> <span class=
"org-keyword">of</span> members) {
<span class="linenr"> 5: </span>      <span class=
"org-keyword">if</span> (t.type === <span class=
"org-string">'TSCallSignatureDeclaration'</span>) {
<span class=
"linenr"> 6: </span>        extractEventNames(t.parameters[<span class="org-highlight-numbers-number">0</span>], emits)
<span class="linenr"> 7: </span>      }
<span class="linenr"> 8: </span>    }
<span class="linenr"> 9: </span>    <span class=
"org-keyword">return</span>
<span class="linenr">10: </span>  } <span class=
"org-keyword">else</span> {
<span class=
"linenr">11: </span>    extractEventNames(node.parameters[<span class="org-highlight-numbers-number">0</span>], emits)
<span class="linenr">12: </span>  }
<span class="linenr">13: </span>}
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-orgfa2810d" class="outline-4">
          <h4 id="orgfa2810d"><span class=
          "section-number-4">1.4.11.</span>
          extractEventNames()</h4>
          <div class="outline-text-4" id="text-1-4-11">
            <div class="org-src-container">
              <pre class="src src-js" id="org83a95f4"><span class=
              "linenr"> 1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">extractEventNames</span>(<span class=
              "org-variable-name">eventName</span>, <span class=
              "org-variable-name">emits</span>) {
<span class="linenr"> 2: </span>  <span class=
"org-keyword">if</span> (
<span class="linenr"> 3: </span>    eventName.type === <span class=
"org-string">'Identifier'</span> &amp;&
<span class="linenr"> 4: </span>    eventName.typeAnnotation &amp;&
<span class=
"linenr"> 5: </span>    eventName.typeAnnotation.type === <span class="org-string">'TSTypeAnnotation'</span>
<span class="linenr"> 6: </span>  ) {
<span class="linenr"> 7: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">typeNode</span> = eventName.typeAnnotation.typeAnnotation
<span class="linenr"> 8: </span>    <span class=
"org-keyword">if</span> (typeNode.type === <span class=
"org-string">'TSLiteralType'</span>) {
<span class="linenr"> 9: </span>      <span class=
"org-keyword">if</span> (typeNode.literal.type !== <span class=
"org-string">'UnaryExpression'</span>) {
<span class=
"linenr">10: </span>        emits.add(String(typeNode.literal.value))
<span class="linenr">11: </span>      }
<span class="linenr">12: </span>    } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (typeNode.type === <span class=
"org-string">'TSUnionType'</span>) {
<span class="linenr">13: </span>      <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">t</span> <span class=
"org-keyword">of</span> typeNode.types) {
<span class="linenr">14: </span>        <span class=
"org-keyword">if</span> (
<span class="linenr">15: </span>          t.type === <span class=
"org-string">'TSLiteralType'</span> &amp;&
<span class=
"linenr">16: </span>          t.literal.type !== <span class=
"org-string">'UnaryExpression'</span>
<span class="linenr">17: </span>        ) {
<span class=
"linenr">18: </span>          emits.add(String(t.literal.value))
<span class="linenr">19: </span>        }
<span class="linenr">20: </span>      }
<span class="linenr">21: </span>    }
<span class="linenr">22: </span>  }
<span class="linenr">23: </span>}
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-org96c8032" class="outline-4">
          <h4 id="org96c8032"><span class=
          "section-number-4">1.4.12.</span> genRuntimeEmits()</h4>
          <div class="outline-text-4" id="text-1-4-12">
            <div class="org-src-container">
              <pre class="src src-js" id="orgba38830"><span class=
              "linenr">1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">genRuntimeEmits</span>(<span class=
              "org-variable-name">emits</span>) {
<span class="linenr">2: </span>  <span class=
"org-keyword">return</span> emits.size
<span class="linenr">3: </span>    ? <span class=
"org-string">`\n  emits: [${Array.from(emits)</span>
<span class="linenr">4: </span><span class=
"org-string">        .map(p =&gt; JSON.stringify(p))</span>
<span class="linenr">5: </span><span class=
"org-string">        .join(', ')}],`</span>
<span class="linenr">6: </span>    : <span class=
"org-string">``</span>
<span class="linenr">7: </span>}
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-orga5b8753" class="outline-4">
          <h4 id="orga5b8753"><span class=
          "section-number-4">1.4.13.</span> isCallOf()</h4>
          <div class="outline-text-4" id="text-1-4-13">
            <div class="org-src-container">
              <pre class="src src-js" id="org825b963"><span class=
              "linenr"> 1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">isCallOf</span>(<span class=
              "org-variable-name">node</span>, <span class=
              "org-variable-name">test</span>) {
<span class="linenr"> 2: </span>  <span class=
"org-keyword">return</span> !!(
<span class="linenr"> 3: </span>    node &amp;&
<span class="linenr"> 4: </span>    node.type === <span class=
"org-string">'CallExpression'</span> &amp;&
<span class=
"linenr"> 5: </span>    node.callee.type === <span class=
"org-string">'Identifier'</span> &amp;&
<span class="linenr"> 6: </span>    (<span class=
"org-keyword">typeof</span> test === <span class=
"org-string">'string'</span>
<span class="linenr"> 7: </span>      ? node.callee.name === test
<span class="linenr"> 8: </span>      : test(node.callee.name))
<span class="linenr"> 9: </span>  )
<span class="linenr">10: </span>}
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-org686f766" class="outline-4">
          <h4 id="org686f766"><span class=
          "section-number-4">1.4.14.</span> canNeverBeRef()</h4>
          <div class="outline-text-4" id="text-1-4-14">
            <div class="org-src-container">
              <pre class="src src-js" id="org1b21dbf"><span class=
              "linenr"> 1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">canNeverBeRef</span>(<span class=
              "org-variable-name">node</span>, <span class=
              "org-variable-name">userReactiveImport</span>) {
<span class="linenr"> 2: </span>  <span class=
"org-keyword">if</span> (isCallOf(node, userReactiveImport)) {
<span class="linenr"> 3: </span>    <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr"> 4: </span>  }
<span class="linenr"> 5: </span>  <span class=
"org-keyword">switch</span> (node.type) {
<span class="linenr"> 6: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'UnaryExpression'</span>:
<span class="linenr"> 7: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'BinaryExpression'</span>:
<span class="linenr"> 8: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'ArrayExpression'</span>:
<span class="linenr"> 9: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'ObjectExpression'</span>:
<span class="linenr">10: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'FunctionExpression'</span>:
<span class="linenr">11: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'ArrowFunctionExpression'</span>:
<span class="linenr">12: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'UpdateExpression'</span>:
<span class="linenr">13: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'ClassExpression'</span>:
<span class="linenr">14: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'TaggedTemplateExpression'</span>:
<span class="linenr">15: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr">16: </span>    <span class=
"org-keyword">case</span> <span class=
"org-string">'SequenceExpression'</span>:
<span class="linenr">17: </span>      <span class=
"org-keyword">return</span> canNeverBeRef(
<span class=
"linenr">18: </span>        node.expressions[node.expressions.length - <span class="org-highlight-numbers-number">1</span>],
<span class="linenr">19: </span>        userReactiveImport
<span class="linenr">20: </span>      )
<span class="linenr">21: </span>    <span class=
"org-keyword">default</span>:
<span class="linenr">22: </span>      <span class=
"org-keyword">if</span> (node.type.endsWith(<span class=
"org-string">'Literal'</span>)) {
<span class="linenr">23: </span>        <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr">24: </span>      }
<span class="linenr">25: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">26: </span>  }
<span class="linenr">27: </span>}
<span class="linenr">28: </span>
<span class="linenr">29: </span>
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-orgbcfccbc" class="outline-4">
          <h4 id="orgbcfccbc"><span class=
          "section-number-4">1.4.15.</span>
          analyzeScriptBindings()</h4>
          <div class="outline-text-4" id="text-1-4-15">
            <div class="org-src-container">
              <pre class="src src-js" id="org1935bd5"><span class=
              "linenr"> 1: </span><span class="org-doc">/**</span>
<span class="linenr"> 2: </span><span class=
"org-doc"> * Analyze bindings in normal `&lt;script&gt;`</span>
<span class="linenr"> 3: </span><span class=
"org-doc"> * Note that `compileScriptSetup` already analyzes bindings as part of its</span>
<span class="linenr"> 4: </span><span class=
"org-doc"> * compilation process so this should only be used on single `&lt;script&gt;` SFCs.</span>
<span class="linenr"> 5: </span><span class="org-doc"> */</span>
<span class="linenr"> 6: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">analyzeScriptBindings</span>(<span class=
"org-variable-name">ast</span>) {
<span class="linenr"> 7: </span>  <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">node</span> <span class=
"org-keyword">of</span> ast) {
<span class="linenr"> 8: </span>    <span class=
"org-keyword">if</span> (
<span class="linenr"> 9: </span>      node.type === <span class=
"org-string">'ExportDefaultDeclaration'</span> &amp;&
<span class=
"linenr">10: </span>      node.declaration.type === <span class=
"org-string">'ObjectExpression'</span>
<span class="linenr">11: </span>    ) {
<span class="linenr">12: </span>      <span class=
"org-keyword">return</span> analyzeBindingsFromOptions(node.declaration)
<span class="linenr">13: </span>    }
<span class="linenr">14: </span>  }
<span class="linenr">15: </span>  <span class=
"org-keyword">return</span> {}
<span class="linenr">16: </span>}
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-org65b62ae" class="outline-4">
          <h4 id="org65b62ae"><span class=
          "section-number-4">1.4.16.</span>
          analyzeBindingsFromOptions()</h4>
          <div class="outline-text-4" id="text-1-4-16">
            <div class="org-src-container">
              <pre class="src src-js" id="org843c755"><span class=
              "linenr"> 1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">analyzeBindingsFromOptions</span>(<span class=
              "org-variable-name">node</span>) {
<span class="linenr"> 2: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">bindings</span> = {}
<span class="linenr"> 3: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">#3270, #3275</span>
<span class="linenr"> 4: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">mark non-script-setup so we don't resolve components/directives from these</span>
<span class=
"linenr"> 5: </span>  Object.defineProperty(bindings, <span class=
"org-string">'__isScriptSetup'</span>, {
<span class="linenr"> 6: </span>    enumerable: <span class=
"org-constant">false</span>,
<span class="linenr"> 7: </span>    value: <span class=
"org-constant">false</span>
<span class="linenr"> 8: </span>  })
<span class="linenr"> 9: </span>  <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">property</span> <span class=
"org-keyword">of</span> node.properties) {
<span class="linenr">10: </span>    <span class=
"org-keyword">if</span> (
<span class=
"linenr">11: </span>      property.type === <span class="org-string">'ObjectProperty'</span> &amp;&
<span class="linenr">12: </span>      !property.computed &amp;&
<span class=
"linenr">13: </span>      property.key.type === <span class=
"org-string">'Identifier'</span>
<span class="linenr">14: </span>    ) {
<span class="linenr">15: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">props</span>
<span class="linenr">16: </span>      <span class=
"org-keyword">if</span> (property.key.name === <span class=
"org-string">'props'</span>) {
<span class="linenr">17: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">props: ['foo']</span>
<span class="linenr">18: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">props: { foo: ... }</span>
<span class="linenr">19: </span>        <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">of</span> getObjectOrArrayExpressionKeys(property.value)) {
<span class=
"linenr">20: </span>          bindings[key] = BindingTypes.PROPS
<span class="linenr">21: </span>        }
<span class="linenr">22: </span>      }
<span class="linenr">23: </span>
<span class="linenr">24: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">inject</span>
<span class="linenr">25: </span>      <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (property.key.name === <span class=
"org-string">'inject'</span>) {
<span class="linenr">26: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">inject: ['foo']</span>
<span class="linenr">27: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">inject: { foo: {} }</span>
<span class="linenr">28: </span>        <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">of</span> getObjectOrArrayExpressionKeys(property.value)) {
<span class=
"linenr">29: </span>          bindings[key] = BindingTypes.OPTIONS
<span class="linenr">30: </span>        }
<span class="linenr">31: </span>      }
<span class="linenr">32: </span>
<span class="linenr">33: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">computed & methods</span>
<span class="linenr">34: </span>      <span class=
"org-keyword">else</span> <span class="org-keyword">if</span> (
<span class=
"linenr">35: </span>        property.value.type === <span class=
"org-string">'ObjectExpression'</span> &amp;&
<span class=
"linenr">36: </span>        (property.key.name === <span class=
"org-string">'computed'</span> || property.key.name === <span class="org-string">'methods'</span>)
<span class="linenr">37: </span>      ) {
<span class="linenr">38: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">methods: { foo() {} }</span>
<span class="linenr">39: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">computed: { foo() {} }</span>
<span class="linenr">40: </span>        <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">of</span> getObjectExpressionKeys(property.value)) {
<span class=
"linenr">41: </span>          bindings[key] = BindingTypes.OPTIONS
<span class="linenr">42: </span>        }
<span class="linenr">43: </span>      }
<span class="linenr">44: </span>    }
<span class="linenr">45: </span>
<span class="linenr">46: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">setup & data</span>
<span class="linenr">47: </span>    <span class=
"org-keyword">else</span> <span class="org-keyword">if</span> (
<span class=
"linenr">48: </span>      property.type === <span class="org-string">'ObjectMethod'</span> &amp;&
<span class=
"linenr">49: </span>      property.key.type === <span class=
"org-string">'Identifier'</span> &amp;&
<span class=
"linenr">50: </span>      (property.key.name === <span class=
"org-string">'setup'</span> || property.key.name === <span class=
"org-string">'data'</span>)
<span class="linenr">51: </span>    ) {
<span class="linenr">52: </span>      <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">bodyItem</span> <span class=
"org-keyword">of</span> property.body.body) {
<span class="linenr">53: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">setup() {</span>
<span class="linenr">54: </span>        <span class=
"org-comment-delimiter">//   </span><span class=
"org-comment">return {</span>
<span class="linenr">55: </span>        <span class=
"org-comment-delimiter">//     </span><span class=
"org-comment">foo: null</span>
<span class="linenr">56: </span>        <span class=
"org-comment-delimiter">//   </span><span class=
"org-comment">}</span>
<span class="linenr">57: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">}</span>
<span class="linenr">58: </span>        <span class=
"org-keyword">if</span> (
<span class=
"linenr">59: </span>          bodyItem.type === <span class=
"org-string">'ReturnStatement'</span> &amp;&
<span class="linenr">60: </span>          bodyItem.argument &amp;&
<span class=
"linenr">61: </span>          bodyItem.argument.type === <span class="org-string">'ObjectExpression'</span>
<span class="linenr">62: </span>        ) {
<span class="linenr">63: </span>          <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">of</span> getObjectExpressionKeys(bodyItem.argument)) {
<span class="linenr">64: </span>            bindings[key] =
<span class=
"linenr">65: </span>              property.key.name === <span class="org-string">'setup'</span>
<span class=
"linenr">66: </span>                ? BindingTypes.SETUP_MAYBE_REF
<span class="linenr">67: </span>                : BindingTypes.DATA
<span class="linenr">68: </span>          }
<span class="linenr">69: </span>        }
<span class="linenr">70: </span>      }
<span class="linenr">71: </span>    }
<span class="linenr">72: </span>  }
<span class="linenr">73: </span>
<span class="linenr">74: </span>  <span class=
"org-keyword">return</span> bindings
<span class="linenr">75: </span>}
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-org3512a7c" class="outline-4">
          <h4 id="org3512a7c"><span class=
          "section-number-4">1.4.17.</span>
          getObjectExpressionKeys()</h4>
          <div class="outline-text-4" id="text-1-4-17">
            <div class="org-src-container">
              <pre class="src src-js" id="orgf6e701c"><span class=
              "linenr"> 1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">getObjectExpressionKeys</span>(<span class=
              "org-variable-name">node</span>) {
<span class="linenr"> 2: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">keys</span> = []
<span class="linenr"> 3: </span>  <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">prop</span> <span class=
"org-keyword">of</span> node.properties) {
<span class="linenr"> 4: </span>    <span class=
"org-keyword">if</span> (
<span class="linenr"> 5: </span>      (prop.type === <span class=
"org-string">'ObjectProperty'</span> || prop.type === <span class=
"org-string">'ObjectMethod'</span>) &amp;&
<span class="linenr"> 6: </span>      !prop.computed
<span class="linenr"> 7: </span>    ) {
<span class="linenr"> 8: </span>      <span class=
"org-keyword">if</span> (prop.key.type === <span class=
"org-string">'Identifier'</span>) {
<span class="linenr"> 9: </span>        keys.push(prop.key.name)
<span class="linenr">10: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (prop.key.type === <span class=
"org-string">'StringLiteral'</span>) {
<span class="linenr">11: </span>        keys.push(prop.key.value)
<span class="linenr">12: </span>      }
<span class="linenr">13: </span>    }
<span class="linenr">14: </span>  }
<span class="linenr">15: </span>  <span class=
"org-keyword">return</span> keys
<span class="linenr">16: </span>}
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-orgec7d4fd" class="outline-4">
          <h4 id="orgec7d4fd"><span class=
          "section-number-4">1.4.18.</span>
          getArrayExpressionKeys()</h4>
          <div class="outline-text-4" id="text-1-4-18">
            <div class="org-src-container">
              <pre class="src src-js" id="org44662d2"><span class=
              "linenr">1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">getArrayExpressionKeys</span>(<span class=
              "org-variable-name">node</span>) {
<span class="linenr">2: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">keys</span> = []
<span class="linenr">3: </span>  <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">element</span> <span class=
"org-keyword">of</span> node.elements) {
<span class="linenr">4: </span>    <span class=
"org-keyword">if</span> (element &amp;& element.type === <span class="org-string">'StringLiteral'</span>) {
<span class="linenr">5: </span>      keys.push(element.value)
<span class="linenr">6: </span>    }
<span class="linenr">7: </span>  }
<span class="linenr">8: </span>  <span class=
"org-keyword">return</span> keys
<span class="linenr">9: </span>}
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-org875116a" class="outline-4">
          <h4 id="org875116a"><span class=
          "section-number-4">1.4.19.</span>
          getObjectOrArrayExpressionKeys()</h4>
          <div class="outline-text-4" id="text-1-4-19">
            <div class="org-src-container">
              <pre class="src src-js" id="org3034669"><span class=
              "linenr">1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">getObjectOrArrayExpressionKeys</span>(<span class="org-variable-name">value</span>) {
<span class="linenr">2: </span>  <span class=
"org-keyword">if</span> (value.type === <span class=
"org-string">'ArrayExpression'</span>) {
<span class="linenr">3: </span>    <span class=
"org-keyword">return</span> getArrayExpressionKeys(value)
<span class="linenr">4: </span>  }
<span class="linenr">5: </span>  <span class=
"org-keyword">if</span> (value.type === <span class=
"org-string">'ObjectExpression'</span>) {
<span class="linenr">6: </span>    <span class=
"org-keyword">return</span> getObjectExpressionKeys(value)
<span class="linenr">7: </span>  }
<span class="linenr">8: </span>  <span class=
"org-keyword">return</span> []
<span class="linenr">9: </span>}
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-orga3a03a2" class="outline-4">
          <h4 id="orga3a03a2"><span class=
          "section-number-4">1.4.20.</span>
          resolveTemplateUsageCheckString()</h4>
          <div class="outline-text-4" id="text-1-4-20">
            <div class="org-src-container">
              <pre class="src src-js" id="orga8b118e"><span class=
              "linenr"> 1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">resolveTemplateUsageCheckString</span>(<span class="org-variable-name">sfc</span>) {
<span class="linenr"> 2: </span>  <span class=
"org-keyword">const</span> { content, ast } = sfc.template
<span class="linenr"> 3: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">cached</span> = templateUsageCheckCache.get(content)
<span class="linenr"> 4: </span>  <span class=
"org-keyword">if</span> (cached) {
<span class="linenr"> 5: </span>    <span class=
"org-keyword">return</span> cached
<span class="linenr"> 6: </span>  }
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">code</span> = <span class=
"org-string">''</span>
<span class="linenr"> 9: </span>  transform(createRoot([ast]), {
<span class="linenr">10: </span>    nodeTransforms: [
<span class="linenr">11: </span>      node =&gt; {
<span class="linenr">12: </span>        <span class=
"org-keyword">if</span> (node.type === NodeTypes.ELEMENT) {
<span class="linenr">13: </span>          <span class=
"org-keyword">if</span> (
<span class=
"linenr">14: </span>            !parserOptions.isNativeTag(node.tag) &amp;&
<span class=
"linenr">15: </span>            !parserOptions.isBuiltInComponent(node.tag)
<span class="linenr">16: </span>          ) {
<span class="linenr">17: </span>            code += <span class=
"org-string">`,${camelize(node.tag)},${capitalize(camelize(node.tag))}`</span>
<span class="linenr">18: </span>          }
<span class="linenr">19: </span>          <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; node.props.length; i++) {
<span class="linenr">20: </span>            <span class=
"org-keyword">const</span> <span class=
"org-variable-name">prop</span> = node.props[i]
<span class="linenr">21: </span>            <span class=
"org-keyword">if</span> (prop.type === NodeTypes.DIRECTIVE) {
<span class="linenr">22: </span>              <span class=
"org-keyword">if</span> (!isBuiltInDir(prop.name)) {
<span class=
"linenr">23: </span>                code += <span class="org-string">`,v${capitalize(camelize(prop.name))}`</span>
<span class="linenr">24: </span>              }
<span class="linenr">25: </span>              <span class=
"org-keyword">if</span> (prop.exp) {
<span class=
"linenr">26: </span>                code += <span class="org-string">`,${stripStrings(prop.exp.content)}`</span>
<span class="linenr">27: </span>              }
<span class="linenr">28: </span>            }
<span class="linenr">29: </span>          }
<span class="linenr">30: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (node.type === NodeTypes.INTERPOLATION) {
<span class="linenr">31: </span>          code += <span class=
"org-string">`,${stripStrings(node.content.content)}`</span>
<span class="linenr">32: </span>        }
<span class="linenr">33: </span>      }
<span class="linenr">34: </span>    ]
<span class="linenr">35: </span>  })
<span class="linenr">36: </span>
<span class="linenr">37: </span>  code += <span class=
"org-string">';'</span>
<span class=
"linenr">38: </span>  templateUsageCheckCache.set(content, code)
<span class="linenr">39: </span>  <span class=
"org-keyword">return</span> code
<span class="linenr">40: </span>}
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-orgf2017c3" class="outline-4">
          <h4 id="orgf2017c3"><span class=
          "section-number-4">1.4.21.</span> stripStrings()</h4>
          <div class="outline-text-4" id="text-1-4-21">
            <div class="org-src-container">
              <pre class="src src-js" id="orgfafa7db"><span class=
              "linenr">1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">stripStrings</span>(<span class=
              "org-variable-name">exp</span>) {
<span class="linenr">2: </span>  <span class=
"org-keyword">return</span> exp
<span class="linenr">3: </span>    .replace(<span class=
"org-string">/'[^']*'|"[^"]*"/</span>g, <span class=
"org-string">''</span>)
<span class="linenr">4: </span>    .replace(<span class=
"org-string">/`[^`]+`/</span>g, stripTemplateString)
<span class="linenr">5: </span>}
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-org34fd720" class="outline-4">
          <h4 id="org34fd720"><span class=
          "section-number-4">1.4.22.</span>
          stripTemplateString()</h4>
          <div class="outline-text-4" id="text-1-4-22">
            <div class="org-src-container">
              <pre class="src src-js" id="org9aa80d9"><span class=
              "linenr">1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">stripTemplateString</span>(<span class=
              "org-variable-name">str</span>) {
<span class="linenr">2: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">interpMatch</span> = str.match(<span class=
"org-string">/\${[^}]+}/</span>g)
<span class="linenr">3: </span>  <span class=
"org-keyword">if</span> (interpMatch) {
<span class="linenr">4: </span>    <span class=
"org-keyword">return</span> interpMatch.map(m =&gt; m.slice(<span class="org-highlight-numbers-number">2</span>, -<span class="org-highlight-numbers-number">1</span>)).join(<span class="org-string">','</span>)
<span class="linenr">5: </span>  }
<span class="linenr">6: </span>  <span class=
"org-keyword">return</span> <span class="org-string">''</span>
<span class="linenr">7: </span>}
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-org8e339e4" class="outline-4">
          <h4 id="org8e339e4"><span class=
          "section-number-4">1.4.23.</span> isImportUsed()</h4>
          <div class="outline-text-4" id="text-1-4-23">
            <div class="org-src-container">
              <pre class="src src-js" id="org7fa7df4"><span class=
              "linenr">1: </span><span class=
              "org-keyword">function</span> <span class=
              "org-function-name">isImportUsed</span>(<span class=
              "org-variable-name">local</span>, <span class=
              "org-variable-name">sfc</span>) {
<span class="linenr">2: </span>  <span class=
"org-keyword">return</span> <span class=
"org-keyword">new</span> <span class="org-type">RegExp</span>(
<span class="linenr">3: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">#4274 escape $ since it's a special char in regex</span>
<span class="linenr">4: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">(and is the only regex special char that is valid in identifiers)</span>
<span class="linenr">5: </span>    <span class=
"org-string">`[^\\w$_]${local.replace(/\$/g, '\\$')}[^\\w$_]`</span>
<span class=
"linenr">6: </span>  ).test(resolveTemplateUsageCheckString(sfc))
<span class="linenr">7: </span>}
</pre>
            </div>
          </div>
        </div>
        <div id="outline-container-org03ef6b1" class="outline-4">
          <h4 id="org03ef6b1"><span class=
          "section-number-4">1.4.24.</span> hmrShouldReload()</h4>
          <div class="outline-text-4" id="text-1-4-24">
            <div class="org-src-container">
              <pre class="src src-js" id="orgf78e37d"><span class=
              "linenr"> 1: </span><span class="org-doc">/**</span>
<span class="linenr"> 2: </span><span class=
"org-doc"> * Note: this comparison assumes the prev/next script are already identical,</span>
<span class="linenr"> 3: </span><span class=
"org-doc"> * and only checks the special case where &lt;script setup lang="ts"&gt; unused import</span>
<span class="linenr"> 4: </span><span class=
"org-doc"> * pruning result changes due to template changes.</span>
<span class="linenr"> 5: </span><span class="org-doc"> */</span>
<span class="linenr"> 6: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">hmrShouldReload</span>(<span class=
"org-variable-name">prevImports</span>, <span class=
"org-variable-name">next</span>) {
<span class="linenr"> 7: </span>  <span class=
"org-keyword">if</span> (
<span class="linenr"> 8: </span>    !next.scriptSetup ||
<span class=
"linenr"> 9: </span>    (next.scriptSetup.lang !== <span class=
"org-string">'ts'</span> &amp;& next.scriptSetup.lang !== <span class="org-string">'tsx'</span>)
<span class="linenr">10: </span>  ) {
<span class="linenr">11: </span>    <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">12: </span>  }
<span class="linenr">13: </span>
<span class="linenr">14: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">for each previous import, check if its used status remain the same based on</span>
<span class="linenr">15: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">the next descriptor's template</span>
<span class="linenr">16: </span>  <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">in</span> prevImports) {
<span class="linenr">17: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">if an import was previous unused, but now is used, we need to force</span>
<span class="linenr">18: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">reload so that the script now includes that import.</span>
<span class="linenr">19: </span>    <span class=
"org-keyword">if</span> (!prevImports[key].isUsedInTemplate &amp;& isImportUsed(key, next)) {
<span class="linenr">20: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr">21: </span>    }
<span class="linenr">22: </span>  }
<span class="linenr">23: </span>
<span class="linenr">24: </span>  <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">25: </span>}
</pre>
            </div>
          </div>
        </div>
      </div>
      <div id="outline-container-orga7e2b86" class="outline-3">
        <h3 id="orga7e2b86"><span class=
        "section-number-3">1.5.</span> rewriteDefault</h3>
        <div class="outline-text-3" id="text-1-5">
          <div class="org-src-container">
            <pre class="src src-js" id="org4fef711"><span class=
            "linenr"> 1: </span>
<span class="linenr"> 2: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">defaultExportRE</span> = <span class=
"org-string">/((?:^|\n|;)\s*)export(\s*)default/</span>
<span class="linenr"> 3: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">namedDefaultExportRE</span> = <span class=
"org-string">/((?:^|\n|;)\s*)export(.+)as(\s*)default/</span>s
<span class="linenr"> 4: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">exportDefaultClassRE</span> =
<span class="linenr"> 5: </span>  <span class=
"org-string">/((?:^|\n|;)\s*)export\s+default\s+class\s+([\w$]+)/</span>
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span class="org-doc">/**</span>
<span class="linenr"> 8: </span><span class=
"org-doc"> * Utility for rewriting `export default` in a script block into a variable</span>
<span class="linenr"> 9: </span><span class=
"org-doc"> * declaration so that we can inject things into it</span>
<span class="linenr">10: </span><span class="org-doc"> */</span>
<span class="linenr">11: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">rewriteDefault</span>(<span class=
"org-variable-name">input</span>, <span class=
"org-variable-name">as</span>, <span class=
"org-variable-name">parserPlugins</span>) {
<span class="linenr">12: </span>  <span class=
"org-keyword">if</span> (!hasDefaultExport(input)) {
<span class="linenr">13: </span>    <span class=
"org-keyword">return</span> input + <span class=
"org-string">`\nconst ${as} = {}`</span>
<span class="linenr">14: </span>  }
<span class="linenr">15: </span>
<span class="linenr">16: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">replaced</span>
<span class="linenr">17: </span>
<span class="linenr">18: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">classMatch</span> = input.match(exportDefaultClassRE)
<span class="linenr">19: </span>  <span class=
"org-keyword">if</span> (classMatch) {
<span class="linenr">20: </span>    replaced =
<span class=
"linenr">21: </span>      input.replace(exportDefaultClassRE, <span class="org-string">'$1class $2'</span>) +
<span class="linenr">22: </span>      <span class=
"org-string">`\nconst ${as} = ${classMatch[2]}`</span>
<span class="linenr">23: </span>  } <span class=
"org-keyword">else</span> {
<span class=
"linenr">24: </span>    replaced = input.replace(defaultExportRE, <span class="org-string">`$1const ${as} =`</span>)
<span class="linenr">25: </span>  }
<span class="linenr">26: </span>  <span class=
"org-keyword">if</span> (!hasDefaultExport(replaced)) {
<span class="linenr">27: </span>    <span class=
"org-keyword">return</span> replaced
<span class="linenr">28: </span>  }
<span class="linenr">29: </span>
<span class="linenr">30: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">if the script somehow still contains `default export`, it probably has</span>
<span class="linenr">31: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">multi-line comments or template strings. fallback to a full parse.</span>
<span class="linenr">32: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">s</span> = <span class=
"org-keyword">new</span> <span class=
"org-type">MagicString</span>(input)
<span class="linenr">33: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">ast</span> = babelParser.parse(input, {
<span class="linenr">34: </span>    sourceType: <span class=
"org-string">'module'</span>,
<span class="linenr">35: </span>    plugins: parserPlugins
<span class="linenr">36: </span>  }).program.body
<span class="linenr">37: </span>  ast.forEach(node =&gt; {
<span class="linenr">38: </span>    <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'ExportDefaultDeclaration'</span>) {
<span class=
"linenr">39: </span>      s.overwrite(node.start, node.declaration.start, <span class="org-string">`const ${as} = `</span>)
<span class="linenr">40: </span>    }
<span class="linenr">41: </span>    <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'ExportNamedDeclaration'</span>) {
<span class=
"linenr">42: </span>      node.specifiers.forEach(specifier =&gt; {
<span class="linenr">43: </span>        <span class=
"org-keyword">if</span> (
<span class=
"linenr">44: </span>          specifier.type === <span class=
"org-string">'ExportSpecifier'</span> &amp;&
<span class=
"linenr">45: </span>          specifier.exported.type === <span class="org-string">'Identifier'</span> &amp;&
<span class=
"linenr">46: </span>          specifier.exported.name === <span class="org-string">'default'</span>
<span class="linenr">47: </span>        ) {
<span class="linenr">48: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">end</span> = specifier.end
<span class="linenr">49: </span>          s.overwrite(
<span class="linenr">50: </span>            specifier.start,
<span class=
"linenr">51: </span>            input.charAt(end) === <span class=
"org-string">','</span> ? end + <span class=
"org-highlight-numbers-number">1</span> : end,
<span class="linenr">52: </span>            <span class=
"org-string">``</span>
<span class="linenr">53: </span>          )
<span class="linenr">54: </span>          s.append(<span class=
"org-string">`\nconst ${as} = ${specifier.local.name}`</span>)
<span class="linenr">55: </span>        }
<span class="linenr">56: </span>      })
<span class="linenr">57: </span>    }
<span class="linenr">58: </span>  })
<span class="linenr">59: </span>  <span class=
"org-keyword">return</span> s.toString()
<span class="linenr">60: </span>}
<span class="linenr">61: </span>
<span class="linenr">62: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">hasDefaultExport</span>(<span class=
"org-variable-name">input</span>) {
<span class="linenr">63: </span>  <span class=
"org-keyword">return</span> defaultExportRE.test(input) || namedDefaultExportRE.test(input)
<span class="linenr">64: </span>}
</pre>
          </div>
        </div>
      </div>
      <div id="outline-container-org08cd59c" class="outline-3">
        <h3 id="org08cd59c"><span class=
        "section-number-3">1.6.</span> cssVars</h3>
        <div class="outline-text-3" id="text-1-6">
          <div class="org-src-container">
            <pre class="src src-js" id="org3ffa535"><span class=
            "linenr">  1: </span><span class=
            "org-keyword">const</span> <span class=
            "org-variable-name">hash</span> = require(process.env.NODE_LIB + <span class="org-string">'/hash-sum'</span>)
<span class="linenr">  2: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">CSS_VARS_HELPER</span> = <span class=
"org-string">`useCssVars`</span>
<span class="linenr">  3: </span><span class=
"org-comment-delimiter">// </span><span class=
"org-comment">match v-bind() with max 2-levels of nested parens.</span>
<span class="linenr">  4: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">cssVarRE</span> = <span class=
"org-string">/v-bind\s*\(((?:[^)(]+|\((?:[^)(]+|\([^)(]*\))*\))*)\)/</span>g
<span class="linenr">  5: </span>
<span class="linenr">  6: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">genCssVarsFromList</span>(
<span class="linenr">  7: </span>  <span class=
"org-variable-name">vars</span>,
<span class="linenr">  8: </span>  <span class=
"org-variable-name">id</span>,
<span class="linenr">  9: </span>  isProd
<span class="linenr"> 10: </span>) {
<span class="linenr"> 11: </span>  <span class=
"org-keyword">return</span> <span class=
"org-string">`{\n  ${vars</span>
<span class="linenr"> 12: </span><span class=
"org-string">    .map(key =&gt; `"${genVarName(id, key, isProd)}"</span>: (${key})<span class="org-string">`)</span>
<span class="linenr"> 13: </span><span class=
"org-string">    .join(',\n  ')}\n}`</span>
<span class="linenr"> 14: </span>}
<span class="linenr"> 15: </span>
<span class="linenr"> 16: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">genVarName</span>(<span class=
"org-variable-name">id</span>, <span class=
"org-variable-name">raw</span>, <span class=
"org-variable-name">isProd</span>) {
<span class="linenr"> 17: </span>  <span class=
"org-keyword">if</span> (isProd) {
<span class="linenr"> 18: </span>    <span class=
"org-keyword">return</span> hash(id + raw)
<span class="linenr"> 19: </span>  } <span class=
"org-keyword">else</span> {
<span class="linenr"> 20: </span>    <span class=
"org-keyword">return</span> <span class=
"org-string">`${id}-${raw.replace(/([^\w-])/g, '_')}`</span>
<span class="linenr"> 21: </span>  }
<span class="linenr"> 22: </span>}
<span class="linenr"> 23: </span>
<span class="linenr"> 24: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">noramlizeExpression</span>(<span class=
"org-variable-name">exp</span>) {
<span class="linenr"> 25: </span>  exp = exp.trim()
<span class="linenr"> 26: </span>  <span class=
"org-keyword">if</span> (
<span class="linenr"> 27: </span>    (exp[<span class=
"org-highlight-numbers-number">0</span>] === <span class=
"org-string">`'`</span> &amp;& exp[exp.length - <span class=
"org-highlight-numbers-number">1</span>] === <span class=
"org-string">`'`</span>) ||
<span class="linenr"> 28: </span>    (exp[<span class=
"org-highlight-numbers-number">0</span>] === <span class=
"org-string">`"`</span> &amp;& exp[exp.length - <span class=
"org-highlight-numbers-number">1</span>] === <span class=
"org-string">`"`</span>)
<span class="linenr"> 29: </span>  ) {
<span class="linenr"> 30: </span>    <span class=
"org-keyword">return</span> exp.slice(<span class=
"org-highlight-numbers-number">1</span>, -<span class=
"org-highlight-numbers-number">1</span>)
<span class="linenr"> 31: </span>  }
<span class="linenr"> 32: </span>  <span class=
"org-keyword">return</span> exp
<span class="linenr"> 33: </span>}
<span class="linenr"> 34: </span>
<span class="linenr"> 35: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">parseCssVars</span>(<span class=
"org-variable-name">sfc</span>) {
<span class="linenr"> 36: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">vars</span> = []
<span class="linenr"> 37: </span>  sfc.styles.forEach(style =&gt; {
<span class="linenr"> 38: </span>    <span class=
"org-keyword">let</span> <span class=
"org-variable-name">match</span>
<span class="linenr"> 39: </span>    <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">ignore v-bind() in comments /* ... */</span>
<span class="linenr"> 40: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">content</span> = style.content.replace(<span class="org-string">/\/\*([\s\S]*?)\*\//</span>g, <span class="org-string">''</span>)
<span class="linenr"> 41: </span>    <span class=
"org-keyword">while</span> ((match = cssVarRE.exec(content))) {
<span class="linenr"> 42: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">variable</span> = noramlizeExpression(match[<span class="org-highlight-numbers-number">1</span>])
<span class="linenr"> 43: </span>      <span class=
"org-keyword">if</span> (!vars.includes(variable)) {
<span class="linenr"> 44: </span>        vars.push(variable)
<span class="linenr"> 45: </span>      }
<span class="linenr"> 46: </span>    }
<span class="linenr"> 47: </span>  })
<span class="linenr"> 48: </span>  <span class=
"org-keyword">return</span> vars
<span class="linenr"> 49: </span>}
<span class="linenr"> 50: </span>
<span class="linenr"> 51: </span><span class=
"org-comment-delimiter">// </span><span class=
"org-comment">for compileStyle</span>
<span class="linenr"> 52: </span>
<span class="linenr"> 53: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">cssVarsPlugin</span> = opts =&gt; {
<span class="linenr"> 54: </span>  <span class=
"org-keyword">const</span> { id, isProd } = opts
<span class="linenr"> 55: </span>  <span class=
"org-keyword">return</span> {
<span class="linenr"> 56: </span>    postcssPlugin: <span class=
"org-string">'vue-sfc-vars'</span>,
<span class="linenr"> 57: </span>    Declaration(decl) {
<span class="linenr"> 58: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">rewrite CSS variables</span>
<span class="linenr"> 59: </span>      <span class=
"org-keyword">if</span> (cssVarRE.test(decl.value)) {
<span class=
"linenr"> 60: </span>        decl.value = decl.value.replace(cssVarRE, (_, $1) =&gt; {
<span class="linenr"> 61: </span>          <span class=
"org-keyword">return</span> <span class=
"org-string">`var(--${genVarName(id, noramlizeExpression($1), isProd)})`</span>
<span class="linenr"> 62: </span>        })
<span class="linenr"> 63: </span>      }
<span class="linenr"> 64: </span>    }
<span class="linenr"> 65: </span>  }
<span class="linenr"> 66: </span>}
<span class=
"linenr"> 67: </span>cssVarsPlugin.postcss = <span class=
"org-constant">true</span>
<span class="linenr"> 68: </span>
<span class="linenr"> 69: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">genCssVarsCode</span>(
<span class="linenr"> 70: </span>  <span class=
"org-variable-name">vars</span>,
<span class="linenr"> 71: </span>  <span class=
"org-variable-name">bindings</span>,
<span class="linenr"> 72: </span>  <span class=
"org-variable-name">id</span>,
<span class="linenr"> 73: </span>  isProd
<span class="linenr"> 74: </span>) {
<span class="linenr"> 75: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">varsExp</span> = genCssVarsFromList(vars, id, isProd)
<span class="linenr"> 76: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">exp</span> = createSimpleExpression(varsExp, <span class="org-constant">false</span>)
<span class="linenr"> 77: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">context</span> = createTransformContext(createRoot([]), {
<span class=
"linenr"> 78: </span>    prefixIdentifiers: <span class="org-constant">true</span>,
<span class="linenr"> 79: </span>    inline: <span class=
"org-constant">true</span>,
<span class=
"linenr"> 80: </span>    bindingMetadata: bindings.__isScriptSetup === <span class="org-constant">false</span> ? <span class="org-constant">undefined</span> : bindings
<span class="linenr"> 81: </span>  })
<span class="linenr"> 82: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">transformed</span> = processExpression(exp, context)
<span class="linenr"> 83: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">transformedString</span> =
<span class=
"linenr"> 84: </span>    transformed.type === NodeTypes.SIMPLE_EXPRESSION
<span class="linenr"> 85: </span>      ? transformed.content
<span class="linenr"> 86: </span>      : transformed.children
<span class="linenr"> 87: </span>          .map(c =&gt; {
<span class="linenr"> 88: </span>            <span class=
"org-keyword">return</span> <span class=
"org-keyword">typeof</span> c === <span class=
"org-string">'string'</span>
<span class="linenr"> 89: </span>              ? c
<span class="linenr"> 90: </span>              : c.content
<span class="linenr"> 91: </span>          })
<span class="linenr"> 92: </span>          .join(<span class=
"org-string">''</span>)
<span class="linenr"> 93: </span>
<span class="linenr"> 94: </span>  <span class=
"org-keyword">return</span> <span class=
"org-string">`_${CSS_VARS_HELPER}(_ctx =&gt; (${transformedString}))`</span>
<span class="linenr"> 95: </span>}
<span class="linenr"> 96: </span>
<span class="linenr"> 97: </span><span class=
"org-comment-delimiter">// </span><span class=
"org-comment">&lt;script setup&gt; already gets the calls injected as part of the transform</span>
<span class="linenr"> 98: </span><span class=
"org-comment-delimiter">// </span><span class=
"org-comment">this is only for single normal &lt;script&gt;</span>
<span class="linenr"> 99: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">genNormalScriptCssVarsCode</span>(
<span class="linenr">100: </span>  <span class=
"org-variable-name">cssVars</span>,
<span class="linenr">101: </span>  <span class=
"org-variable-name">bindings</span>,
<span class="linenr">102: </span>  <span class=
"org-variable-name">id</span>,
<span class="linenr">103: </span>  isProd
<span class="linenr">104: </span>) {
<span class="linenr">105: </span>  <span class=
"org-keyword">return</span> (
<span class="linenr">106: </span>    <span class=
"org-string">`\nimport { ${CSS_VARS_HELPER} as _${CSS_VARS_HELPER} } from 'vue'\n`</span> +
<span class="linenr">107: </span>    <span class=
"org-string">`const __injectCSSVars__ = () =&gt; {\n${genCssVarsCode(</span>
<span class="linenr">108: </span><span class=
"org-string">      cssVars,</span>
<span class="linenr">109: </span><span class=
"org-string">      bindings,</span>
<span class="linenr">110: </span><span class=
"org-string">      id,</span>
<span class="linenr">111: </span><span class=
"org-string">      isProd</span>
<span class="linenr">112: </span><span class=
"org-string">    )}}\n`</span> +
<span class="linenr">113: </span>    <span class=
"org-string">`const __setup__ = __default__.setup\n`</span> +
<span class="linenr">114: </span>    <span class=
"org-string">`__default__.setup = __setup__\n`</span> +
<span class="linenr">115: </span>    <span class=
"org-string">`  ? (props, ctx) =&gt; { __injectCSSVars__();return __setup__(props, ctx) }\n`</span> +
<span class="linenr">116: </span>    <span class=
"org-string">`  : __injectCSSVars__\n`</span>
<span class="linenr">117: </span>  )
<span class="linenr">118: </span>}
<span class="linenr">119: </span>
</pre>
          </div>
        </div>
      </div>
      <div id="outline-container-org32c24c2" class="outline-3">
        <h3 id="org32c24c2"><span class=
        "section-number-3">1.7.</span> testing</h3>
        <div class="outline-text-3" id="text-1-7">
          <div class="org-src-container">
            <pre class="src src-js" id="org620633a"><span class=
            "linenr"> 1: </span>&lt;&lt;compiler-sfc&gt;&gt;
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">mockId</span> = <span class=
"org-string">'xxxxxxxx'</span>
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">compileSFCScript</span>(
<span class="linenr"> 6: </span>  <span class=
"org-variable-name">src</span>,
<span class="linenr"> 7: </span>  options
<span class="linenr"> 8: </span>) {
<span class="linenr"> 9: </span>  <span class=
"org-keyword">const</span> { descriptor } = parse(src)
<span class="linenr">10: </span>  <span class=
"org-keyword">return</span> compileScript(descriptor, {
<span class="linenr">11: </span>    ...options,
<span class="linenr">12: </span>    id: mockId
<span class="linenr">13: </span>  })
<span class="linenr">14: </span>}
</pre>
          </div>
          <div class="org-src-container">
            <pre class="src src-js"><span class=
            "linenr"> 1: </span>&lt;&lt;sfc-testing&gt;&gt;
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span class=
"org-keyword">const</span> { content, bindings } = compileSFCScript(<span class="org-string">`</span>
<span class="linenr"> 4: </span><span class=
"org-string">      &lt;script setup&gt;</span>
<span class="linenr"> 5: </span><span class=
"org-string">      import { x } from './x'</span>
<span class="linenr"> 6: </span><span class=
"org-string">      let a = 1</span>
<span class="linenr"> 7: </span><span class=
"org-string">      const b = 2</span>
<span class="linenr"> 8: </span><span class=
"org-string">      function c() {}</span>
<span class="linenr"> 9: </span><span class=
"org-string">      class d {}</span>
<span class="linenr">10: </span><span class=
"org-string">      &lt;/script&gt;</span>
<span class="linenr">11: </span>
<span class="linenr">12: </span><span class=
"org-string">      &lt;script&gt;</span>
<span class="linenr">13: </span><span class=
"org-string">      import { xx } from './x'</span>
<span class="linenr">14: </span><span class=
"org-string">      let aa = 1</span>
<span class="linenr">15: </span><span class=
"org-string">      const bb = 2</span>
<span class="linenr">16: </span><span class=
"org-string">      function cc() {}</span>
<span class="linenr">17: </span><span class=
"org-string">      class dd {}</span>
<span class="linenr">18: </span><span class=
"org-string">      &lt;/script&gt;</span>
<span class="linenr">19: </span><span class=
"org-string">      `</span>)
</pre>
          </div>
        </div>
      </div>
    </div>
    <div id="outline-container-org19b67a4" class="outline-2">
      <h2 id="org19b67a4"><span class="section-number-2">2.</span>
      template</h2>
      <div class="outline-text-2" id="text-2"></div>
      <div id="outline-container-orge791b0b" class="outline-3">
        <h3 id="orge791b0b"><span class=
        "section-number-3">2.1.</span> compileTemplate()</h3>
        <div class="outline-text-3" id="text-2-1">
          <div class="org-src-container">
            <pre class="src src-js" id="orga672af6"><span class=
            "linenr"> 1: </span><span class=
            "org-keyword">function</span> <span class=
            "org-function-name">compileTemplate</span>(<span class=
            "org-variable-name">options</span>) {
<span class="linenr"> 2: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">...省略直接使用现有的 compile</span>
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>  <span class=
"org-keyword">return</span> doCompileTemplate(options)
<span class="linenr"> 5: </span>}
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">doCompileTemplate</span>({
<span class="linenr"> 8: </span>  filename,
<span class="linenr"> 9: </span>  id,
<span class="linenr">10: </span>  scoped,
<span class="linenr">11: </span>  slotted,
<span class="linenr">12: </span>  inMap,
<span class="linenr">13: </span>  source,
<span class="linenr">14: </span>  ssr = <span class=
"org-constant">false</span>,
<span class="linenr">15: </span>  ssrCssVars,
<span class="linenr">16: </span>  isProd = <span class=
"org-constant">false</span>,
<span class="linenr">17: </span>  compiler,
<span class="linenr">18: </span>  compilerOptions = {},
<span class="linenr">19: </span>  transformAssetUrls
<span class="linenr">20: </span>}) {
<span class="linenr">21: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">errors</span> = []
<span class="linenr">22: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">warnings</span> = []
<span class="linenr">23: </span>
<span class="linenr">24: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">nodeTransforms</span> = []
<span class="linenr">25: </span>  <span class=
"org-keyword">if</span> (isObject(transformAssetUrls)) {
<span class="linenr">26: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">assetOptions</span> = normalizeOptions(transformAssetUrls)
<span class="linenr">27: </span>    nodeTransforms = [
<span class=
"linenr">28: </span>      createAssetUrlTransformWithOptions(assetOptions),
<span class=
"linenr">29: </span>      createSrcsetTransformWithOptions(assetOptions)
<span class="linenr">30: </span>    ]
<span class="linenr">31: </span>  } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (transformAssetUrls !== <span class=
"org-constant">false</span>) {
<span class=
"linenr">32: </span>    nodeTransforms = [transformAssetUrl, transformSrcset]
<span class="linenr">33: </span>  }
<span class="linenr">34: </span>
<span class="linenr">35: </span>  <span class=
"org-keyword">if</span> (!id) {
<span class="linenr">36: </span>    id = <span class=
"org-string">''</span>
<span class="linenr">37: </span>  }
<span class="linenr">38: </span>
<span class="linenr">39: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">shortId</span> = id.replace(<span class=
"org-string">/^data-v-/</span>, <span class="org-string">''</span>)
<span class="linenr">40: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">longId</span> = <span class=
"org-string">`data-v-${shortId}`</span>
<span class="linenr">41: </span>
<span class="linenr">42: </span>  <span class=
"org-keyword">let</span> { code, ast, preamble, map } = baseCompile(source, {
<span class="linenr">43: </span>    mode: <span class=
"org-string">'module'</span>,
<span class="linenr">44: </span>    prefixIdentifiers: <span class=
"org-constant">true</span>,
<span class="linenr">45: </span>    hoistStatic: <span class=
"org-constant">true</span>,
<span class="linenr">46: </span>    cacheHandlers: <span class=
"org-constant">true</span>,
<span class="linenr">47: </span>    ssrCssVars:
<span class=
"linenr">48: </span>      ssr &amp;& ssrCssVars &amp;& ssrCssVars.length
<span class=
"linenr">49: </span>        ? genCssVarsFromList(ssrCssVars, shortId, isProd)
<span class="linenr">50: </span>        : <span class=
"org-string">''</span>,
<span class=
"linenr">51: </span>    scopeId: scoped ? longId : <span class=
"org-constant">undefined</span>,
<span class="linenr">52: </span>    slotted,
<span class="linenr">53: </span>    sourceMap: <span class=
"org-constant">true</span>,
<span class="linenr">54: </span>    ...compilerOptions,
<span class=
"linenr">55: </span>    nodeTransforms: nodeTransforms.concat(compilerOptions.nodeTransforms || []),
<span class="linenr">56: </span>    filename,
<span class=
"linenr">57: </span>    onError: e =&gt; errors.push(e),
<span class=
"linenr">58: </span>    onWarn: w =&gt; warnings.push(w)
<span class="linenr">59: </span>  })
<span class="linenr">60: </span>
<span class="linenr">61: </span>  <span class=
"org-keyword">return</span> { code, ast, preamble, source, errors, tips, map }
<span class="linenr">62: </span>}
</pre>
          </div>
        </div>
      </div>
    </div>
    <div id="outline-container-org1835ca0" class="outline-2">
      <h2 id="org1835ca0"><span class="section-number-2">3.</span>
      mindmaps</h2>
      <div class="outline-text-2" id="text-3">
        <p><a href="#org1c3e7fb">compileScript()</a>:</p><a href=
        "../assets/img/vue3/compiler-sfc/vue-compiler-sfc-compile-script.svg"
        data-fancybox="gallery" data-caption="Preview"><img src=
        "../assets/img/vue3/compiler-sfc/vue-compiler-sfc-compile-script.svg"></a>
        <p>关键知识点：</p><a href=
        "../assets/img/vue3/compiler-sfc/vue-compiler-sfc-keypoints.svg"
        data-fancybox="gallery" data-caption="Preview"><img src=
        "../assets/img/vue3/compiler-sfc/vue-compiler-sfc-keypoints.svg"></a>
      </div>
    </div>
    <div id="outline-container-org06862ec" class="outline-2">
      <h2 id="org06862ec"><span class="section-number-2">4.</span>
      global variables</h2>
      <div class="outline-text-2" id="text-4">
        <br>
        <details class="code-details" style=
        "padding: 1em; background-color: #e5f5e5; /* background-color: pink; */ border-radius: 15px; color: hsl(157 75%); font-size: 0.9em; box-shadow: 0.05em 0.1em 5px 0.01em #00000057;">
          <summary>
            <strong><font face="Courier" size="3" color=
            "green">globalVars</font></strong>
          </summary>
          <div class="org-src-container">
            <pre class="src src-js" id="org94e9aa6"><span class=
            "linenr"> 1: </span><span class=
            "org-keyword">const</span> <span class=
            "org-variable-name">__ESM_BROWSER__</span> = <span class=
            "org-constant">false</span>, <span class=
            "org-variable-name">__GLOBAL__</span> = <span class=
            "org-constant">true</span>
<span class="linenr"> 2: </span><span class=
"org-keyword">let</span> <span class=
"org-variable-name">MagicString</span> = require(process.env.NODE_LIB + <span class="org-string">'/magic-string'</span>)
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">createCache</span>(<span class=
"org-variable-name">size</span> = <span class=
"org-highlight-numbers-number">500</span>) {
<span class="linenr"> 5: </span>  <span class=
"org-keyword">return</span> <span class=
"org-keyword">new</span> <span class="org-type">Map</span>()
<span class="linenr"> 6: </span>}
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>&lt;&lt;rewriteDefault&gt;&gt;
<span class=
"linenr"> 9: </span>&lt;&lt;reactivity-transform&gt;&gt;
<span class="linenr">10: </span>
<span class="linenr">11: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">range</span> = <span class=
"org-highlight-numbers-number">2</span>
<span class="linenr">12: </span>
<span class="linenr">13: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">generateCodeFrame</span>(
<span class="linenr">14: </span>  <span class=
"org-variable-name">source</span>,
<span class="linenr">15: </span>  start = <span class=
"org-highlight-numbers-number">0</span>,
<span class="linenr">16: </span>  end = source.length
<span class="linenr">17: </span>) {
<span class="linenr">18: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">Split the content into individual lines but capture the newline sequence</span>
<span class="linenr">19: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">that separated each line. This is important because the actual sequence is</span>
<span class="linenr">20: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">needed to properly take into account the full line length for offset</span>
<span class="linenr">21: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">comparison</span>
<span class="linenr">22: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">lines</span> = source.split(<span class=
"org-string">/(\r?\n)/</span>)
<span class="linenr">23: </span>
<span class="linenr">24: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">Separate the lines and newline sequences into separate arrays for easier referencing</span>
<span class="linenr">25: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">newlineSequences</span> = lines.filter((_, idx) =&gt; idx % <span class="org-highlight-numbers-number">2</span> === <span class="org-highlight-numbers-number">1</span>)
<span class=
"linenr">26: </span>  lines = lines.filter((_, idx) =&gt; idx % <span class="org-highlight-numbers-number">2</span> === <span class="org-highlight-numbers-number">0</span>)
<span class="linenr">27: </span>
<span class="linenr">28: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">count</span> = <span class=
"org-highlight-numbers-number">0</span>
<span class="linenr">29: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">res</span> = []
<span class="linenr">30: </span>  <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; lines.length; i++) {
<span class="linenr">31: </span>    count +=
<span class="linenr">32: </span>      lines[i].length +
<span class=
"linenr">33: </span>      ((newlineSequences[i] &amp;& newlineSequences[i].length) || <span class="org-highlight-numbers-number">0</span>)
<span class="linenr">34: </span>    <span class=
"org-keyword">if</span> (count &gt;= start) {
<span class="linenr">35: </span>      <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">j</span> = i - range; j &lt;= i + range || end &gt; count; j++) {
<span class="linenr">36: </span>        <span class=
"org-keyword">if</span> (j &lt; <span class=
"org-highlight-numbers-number">0</span> || j &gt;= lines.length) <span class="org-keyword">continue</span>
<span class="linenr">37: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">line</span> = j + <span class=
"org-highlight-numbers-number">1</span>
<span class="linenr">38: </span>        res.push(
<span class="linenr">39: </span>          <span class=
"org-string">`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${</span>
<span class="linenr">40: </span><span class=
"org-string">            lines[j]</span>
<span class="linenr">41: </span><span class=
"org-string">          }`</span>
<span class="linenr">42: </span>        )
<span class="linenr">43: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">lineLength</span> = lines[j].length
<span class="linenr">44: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">newLineSeqLength</span> =
<span class=
"linenr">45: </span>          (newlineSequences[j] &amp;& newlineSequences[j].length) || <span class="org-highlight-numbers-number">0</span>
<span class="linenr">46: </span>
<span class="linenr">47: </span>        <span class=
"org-keyword">if</span> (j === i) {
<span class="linenr">48: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">push underline</span>
<span class="linenr">49: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">pad</span> = start - (count - (lineLength + newLineSeqLength))
<span class="linenr">50: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">length</span> = Math.max(
<span class="linenr">51: </span>            <span class=
"org-highlight-numbers-number">1</span>,
<span class=
"linenr">52: </span>            end &gt; count ? lineLength - pad : end - start
<span class="linenr">53: </span>          )
<span class="linenr">54: </span>          res.push(<span class=
"org-string">`   |  `</span> + <span class=
"org-string">' '</span>.repeat(pad) + <span class=
"org-string">'^'</span>.repeat(length))
<span class="linenr">55: </span>        } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (j &gt; i) {
<span class="linenr">56: </span>          <span class=
"org-keyword">if</span> (end &gt; count) {
<span class="linenr">57: </span>            <span class=
"org-keyword">const</span> <span class=
"org-variable-name">length</span> = Math.max(Math.min(end - count, lineLength), <span class="org-highlight-numbers-number">1</span>)
<span class="linenr">58: </span>            res.push(<span class=
"org-string">`   |  `</span> + <span class=
"org-string">'^'</span>.repeat(length))
<span class="linenr">59: </span>          }
<span class="linenr">60: </span>
<span class=
"linenr">61: </span>          count += lineLength + newLineSeqLength
<span class="linenr">62: </span>        }
<span class="linenr">63: </span>      }
<span class="linenr">64: </span>      <span class=
"org-keyword">break</span>
<span class="linenr">65: </span>    }
<span class="linenr">66: </span>  }
<span class="linenr">67: </span>  <span class=
"org-keyword">return</span> res.join(<span class=
"org-string">'\n'</span>)
<span class="linenr">68: </span>}
<span class="linenr">69: </span>
</pre>
          </div>
        </details>
      </div>
      <div id="outline-container-org95e1794" class="outline-3">
        <h3 id="org95e1794"><span class=
        "section-number-3">4.1.</span> reactivity-transform</h3>
        <div class="outline-text-3" id="text-4-1">
          <p><a href=
          "https://github.com/vuejs/core/blob/main/packages/reactivity-transform/README.md">
          core/README.md at main · vuejs/core</a></p>
          <p>这个包的作用是转换一些 <code>script setup</code> 中自定义的一些新语法，如：
          <code>$ref()</code>, <code>$computed</code>,
          <code>$shallowRef()</code>, <code>$customRef()</code>,
          <code>$toRef()</code>, 语法糖，可以减少 <code>import ... from
          "vue"</code> 语法。</p>
          <div class="org-src-container">
            <pre class="src src-js" id="orge0eee94"><span class=
            "linenr">  1: </span><span class=
            "org-keyword">const</span> <span class=
            "org-variable-name">RT</span> = (<span class=
            "org-keyword">function</span>() {
<span class="linenr">  2: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">CONVERT_SYMBOL</span> = <span class=
"org-string">'$'</span>
<span class="linenr">  3: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">ESCAPE_SYMBOL</span> = <span class=
"org-string">'$$'</span>
<span class="linenr">  4: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">shorthands</span> = [<span class=
"org-string">'ref'</span>, <span class=
"org-string">'computed'</span>, <span class=
"org-string">'shallowRef'</span>, <span class=
"org-string">'toRef'</span>, <span class=
"org-string">'customRef'</span>]
<span class="linenr">  5: </span><span class=
"org-keyword">const</span> <span class=
"org-variable-name">transformCheckRE</span> = <span class=
"org-string">/[^\w]\$(?:\$|ref|computed|shallowRef)?\s*(\(|\&lt;)/</span>
<span class="linenr">  6: </span>
<span class="linenr">  7: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">shouldTransform</span>(<span class=
"org-variable-name">src</span>) {
<span class="linenr">  8: </span>  <span class=
"org-keyword">return</span> transformCheckRE.test(src)
<span class="linenr">  9: </span>}
<span class="linenr"> 10: </span>
<span class="linenr"> 11: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">transform</span>(
<span class="linenr"> 12: </span>  <span class=
"org-variable-name">src</span>,
<span class="linenr"> 13: </span>  {
<span class="linenr"> 14: </span>    filename,
<span class="linenr"> 15: </span>    sourceMap,
<span class="linenr"> 16: </span>    parserPlugins,
<span class=
"linenr"> 17: </span>    importHelpersFrom = <span class=
"org-string">'vue'</span>
<span class="linenr"> 18: </span>  } = {}
<span class="linenr"> 19: </span>) {
<span class="linenr"> 20: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">plugins</span> = parserPlugins || []
<span class="linenr"> 21: </span>  <span class=
"org-keyword">if</span> (filename) {
<span class="linenr"> 22: </span>    <span class=
"org-keyword">if</span> (<span class=
"org-string">/\.tsx?$/</span>.test(filename)) {
<span class="linenr"> 23: </span>      plugins.push(<span class=
"org-string">'typescript'</span>)
<span class="linenr"> 24: </span>    }
<span class="linenr"> 25: </span>    <span class=
"org-keyword">if</span> (filename.endsWith(<span class=
"org-string">'x'</span>)) {
<span class="linenr"> 26: </span>      plugins.push(<span class=
"org-string">'jsx'</span>)
<span class="linenr"> 27: </span>    }
<span class="linenr"> 28: </span>  }
<span class="linenr"> 29: </span>
<span class="linenr"> 30: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">ast</span> = babelParser.parse(src, {
<span class="linenr"> 31: </span>    sourceType: <span class=
"org-string">'module'</span>,
<span class="linenr"> 32: </span>    plugins
<span class="linenr"> 33: </span>  })
<span class="linenr"> 34: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">s</span> = <span class=
"org-keyword">new</span> <span class=
"org-type">MagicString</span>(src)
<span class="linenr"> 35: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">res</span> = transformAST(ast.program, s, <span class="org-highlight-numbers-number">0</span>)
<span class="linenr"> 36: </span>
<span class="linenr"> 37: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">inject helper imports</span>
<span class="linenr"> 38: </span>  <span class=
"org-keyword">if</span> (res.importedHelpers.length) {
<span class="linenr"> 39: </span>    s.prepend(
<span class="linenr"> 40: </span>      <span class=
"org-string">`import { ${res.importedHelpers</span>
<span class="linenr"> 41: </span><span class=
"org-string">        .map(h =&gt; `</span>${h} as _${h}<span class=
"org-string">`)</span>
<span class="linenr"> 42: </span><span class=
"org-string">        .join(', ')} } from '${importHelpersFrom}'\n`</span>
<span class="linenr"> 43: </span>    )
<span class="linenr"> 44: </span>  }
<span class="linenr"> 45: </span>
<span class="linenr"> 46: </span>  <span class=
"org-keyword">return</span> {
<span class="linenr"> 47: </span>    ...res,
<span class="linenr"> 48: </span>    code: s.toString(),
<span class="linenr"> 49: </span>    map: sourceMap
<span class="linenr"> 50: </span>      ? s.generateMap({
<span class="linenr"> 51: </span>          source: filename,
<span class="linenr"> 52: </span>          hires: <span class=
"org-constant">true</span>,
<span class=
"linenr"> 53: </span>          includeContent: <span class=
"org-constant">true</span>
<span class="linenr"> 54: </span>        })
<span class="linenr"> 55: </span>      : <span class=
"org-constant">null</span>
<span class="linenr"> 56: </span>  }
<span class="linenr"> 57: </span>}
<span class="linenr"> 58: </span>
<span class="linenr"> 59: </span><span class=
"org-keyword">function</span> <span class=
"org-function-name">transformAST</span>(
<span class="linenr"> 60: </span>  <span class=
"org-variable-name">ast</span>,
<span class="linenr"> 61: </span>  <span class=
"org-variable-name">s</span>,
<span class="linenr"> 62: </span>  offset = <span class=
"org-highlight-numbers-number">0</span>,
<span class="linenr"> 63: </span>  <span class=
"org-variable-name">knownRefs</span>,
<span class="linenr"> 64: </span>  knownProps
<span class="linenr"> 65: </span>) {
<span class="linenr"> 66: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">convertSymbol</span> = CONVERT_SYMBOL
<span class="linenr"> 67: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">escapeSymbol</span> = ESCAPE_SYMBOL
<span class="linenr"> 68: </span>
<span class="linenr"> 69: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">macro import handling</span>
<span class="linenr"> 70: </span>  <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">node</span> <span class=
"org-keyword">of</span> ast.body) {
<span class="linenr"> 71: </span>    <span class=
"org-keyword">if</span> (
<span class="linenr"> 72: </span>      node.type === <span class=
"org-string">'ImportDeclaration'</span> &amp;&
<span class=
"linenr"> 73: </span>      node.source.value === <span class=
"org-string">'vue/macros'</span>
<span class="linenr"> 74: </span>    ) {
<span class="linenr"> 75: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">remove macro imports</span>
<span class=
"linenr"> 76: </span>      s.remove(node.start + offset, node.end + offset)
<span class="linenr"> 77: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">check aliasing</span>
<span class="linenr"> 78: </span>      <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">specifier</span> <span class=
"org-keyword">of</span> node.specifiers) {
<span class="linenr"> 79: </span>        <span class=
"org-keyword">if</span> (specifier.type === <span class=
"org-string">'ImportSpecifier'</span>) {
<span class="linenr"> 80: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">imported</span> = specifier.imported.name
<span class="linenr"> 81: </span>          <span class=
"org-keyword">const</span> <span class=
"org-variable-name">local</span> = specifier.local.name
<span class="linenr"> 82: </span>          <span class=
"org-keyword">if</span> (local !== imported) {
<span class="linenr"> 83: </span>            <span class=
"org-keyword">if</span> (imported === ESCAPE_SYMBOL) {
<span class="linenr"> 84: </span>              escapeSymbol = local
<span class="linenr"> 85: </span>            } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (imported === CONVERT_SYMBOL) {
<span class=
"linenr"> 86: </span>              convertSymbol = local
<span class="linenr"> 87: </span>            } <span class=
"org-keyword">else</span> {
<span class="linenr"> 88: </span>              error(
<span class="linenr"> 89: </span>                <span class=
"org-string">`macro imports for ref-creating methods do not support aliasing.`</span>,
<span class="linenr"> 90: </span>                specifier
<span class="linenr"> 91: </span>              )
<span class="linenr"> 92: </span>            }
<span class="linenr"> 93: </span>          }
<span class="linenr"> 94: </span>        }
<span class="linenr"> 95: </span>      }
<span class="linenr"> 96: </span>    }
<span class="linenr"> 97: </span>  }
<span class="linenr"> 98: </span>
<span class="linenr"> 99: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">importedHelpers</span> = <span class=
"org-keyword">new</span> <span class="org-type">Set</span>()
<span class="linenr">100: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">rootScope</span> = {}
<span class="linenr">101: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">scopeStack</span> = [rootScope]
<span class="linenr">102: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">currentScope</span> = rootScope
<span class="linenr">103: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">escapeScope</span> <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">inside $$()</span>
<span class="linenr">104: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">excludedIds</span> = <span class=
"org-keyword">new</span> <span class="org-type">WeakSet</span>()
<span class="linenr">105: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">parentStack</span> = []
<span class="linenr">106: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">propsLocalToPublicMap</span> = Object.create(<span class="org-constant">null</span>)
<span class="linenr">107: </span>
<span class="linenr">108: </span>  <span class=
"org-keyword">if</span> (knownRefs) {
<span class="linenr">109: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">of</span> knownRefs) {
<span class=
"linenr">110: </span>      rootScope[key] = <span class="org-constant">true</span>
<span class="linenr">111: </span>    }
<span class="linenr">112: </span>  }
<span class="linenr">113: </span>  <span class=
"org-keyword">if</span> (knownProps) {
<span class="linenr">114: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">key</span> <span class=
"org-keyword">in</span> knownProps) {
<span class="linenr">115: </span>      <span class=
"org-keyword">const</span> { local } = knownProps[key]
<span class=
"linenr">116: </span>      rootScope[local] = <span class=
"org-string">'prop'</span>
<span class=
"linenr">117: </span>      propsLocalToPublicMap[local] = key
<span class="linenr">118: </span>    }
<span class="linenr">119: </span>  }
<span class="linenr">120: </span>
<span class="linenr">121: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">isRefCreationCall</span>(<span class=
"org-variable-name">callee</span>) {
<span class="linenr">122: </span>    <span class=
"org-keyword">if</span> (callee === convertSymbol) {
<span class="linenr">123: </span>      <span class=
"org-keyword">return</span> convertSymbol
<span class="linenr">124: </span>    }
<span class="linenr">125: </span>    <span class=
"org-keyword">if</span> (callee[<span class=
"org-highlight-numbers-number">0</span>] === <span class=
"org-string">'$'</span> &amp;& shorthands.includes(callee.slice(<span class="org-highlight-numbers-number">1</span>))) {
<span class="linenr">126: </span>      <span class=
"org-keyword">return</span> callee
<span class="linenr">127: </span>    }
<span class="linenr">128: </span>    <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">129: </span>  }
<span class="linenr">130: </span>
<span class="linenr">131: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">error</span>(<span class=
"org-variable-name">msg</span>, <span class=
"org-variable-name">node</span>) {
<span class="linenr">132: </span>    <span class=
"org-keyword">const</span> <span class=
"org-variable-name">e</span> = <span class=
"org-keyword">new</span> <span class="org-type">Error</span>(msg)
<span class="linenr">133: </span>    e.node = node
<span class="linenr">134: </span>    <span class=
"org-keyword">throw</span> e
<span class="linenr">135: </span>  }
<span class="linenr">136: </span>
<span class="linenr">137: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">helper</span>(<span class=
"org-variable-name">msg</span>) {
<span class="linenr">138: </span>    importedHelpers.add(msg)
<span class="linenr">139: </span>    <span class=
"org-keyword">return</span> <span class=
"org-string">`_${msg}`</span>
<span class="linenr">140: </span>  }
<span class="linenr">141: </span>
<span class="linenr">142: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">registerBinding</span>(<span class=
"org-variable-name">id</span>, <span class=
"org-variable-name">isRef</span> = <span class=
"org-constant">false</span>) {
<span class="linenr">143: </span>    excludedIds.add(id)
<span class="linenr">144: </span>    <span class=
"org-keyword">if</span> (currentScope) {
<span class=
"linenr">145: </span>      currentScope[id.name] = isRef
<span class="linenr">146: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr">147: </span>      error(
<span class="linenr">148: </span>        <span class=
"org-string">'registerBinding called without active scope, something is wrong.'</span>,
<span class="linenr">149: </span>        id
<span class="linenr">150: </span>      )
<span class="linenr">151: </span>    }
<span class="linenr">152: </span>  }
<span class="linenr">153: </span>
<span class="linenr">154: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">registerRefBinding</span> = (id) =&gt; registerBinding(id, <span class="org-constant">true</span>)
<span class="linenr">155: </span>
<span class="linenr">156: </span>  <span class=
"org-keyword">let</span> <span class=
"org-variable-name">tempVarCount</span> = <span class=
"org-highlight-numbers-number">0</span>
<span class="linenr">157: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">genTempVar</span>() {
<span class="linenr">158: </span>    <span class=
"org-keyword">return</span> <span class=
"org-string">`__$temp_${++tempVarCount}`</span>
<span class="linenr">159: </span>  }
<span class="linenr">160: </span>
<span class="linenr">161: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">snip</span>(<span class=
"org-variable-name">nod</span>) {
<span class="linenr">162: </span>    <span class=
"org-keyword">return</span> s.original.slice(node.start + offset, node.end + offset)
<span class="linenr">163: </span>  }
<span class="linenr">164: </span>
<span class="linenr">165: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">walkScope</span>(<span class=
"org-variable-name">node</span>, <span class=
"org-variable-name">isRoot</span> = <span class=
"org-constant">false</span>) {
<span class="linenr">166: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">stmt</span> <span class=
"org-keyword">of</span> node.body) {
<span class="linenr">167: </span>      <span class=
"org-keyword">if</span> (stmt.type === <span class=
"org-string">'VariableDeclaration'</span>) {
<span class=
"linenr">168: </span>        walkVariableDeclaration(stmt, isRoot)
<span class="linenr">169: </span>      } <span class=
"org-keyword">else</span> <span class="org-keyword">if</span> (
<span class="linenr">170: </span>        stmt.type === <span class=
"org-string">'FunctionDeclaration'</span> ||
<span class="linenr">171: </span>        stmt.type === <span class=
"org-string">'ClassDeclaration'</span>
<span class="linenr">172: </span>      ) {
<span class="linenr">173: </span>        <span class=
"org-keyword">if</span> (stmt.declare || !stmt.id) <span class=
"org-keyword">continue</span>
<span class="linenr">174: </span>        registerBinding(stmt.id)
<span class="linenr">175: </span>      } <span class=
"org-keyword">else</span> <span class="org-keyword">if</span> (
<span class=
"linenr">176: </span>        (stmt.type === <span class="org-string">'ForOfStatement'</span> || stmt.type === <span class="org-string">'ForInStatement'</span>) &amp;&
<span class=
"linenr">177: </span>        stmt.left.type === <span class=
"org-string">'VariableDeclaration'</span>
<span class="linenr">178: </span>      ) {
<span class=
"linenr">179: </span>        walkVariableDeclaration(stmt.left)
<span class="linenr">180: </span>      } <span class=
"org-keyword">else</span> <span class="org-keyword">if</span> (
<span class="linenr">181: </span>        stmt.type === <span class=
"org-string">'ExportNamedDeclaration'</span> &amp;&
<span class="linenr">182: </span>        stmt.declaration &amp;&
<span class=
"linenr">183: </span>        stmt.declaration.type === <span class=
"org-string">'VariableDeclaration'</span>
<span class="linenr">184: </span>      ) {
<span class=
"linenr">185: </span>        walkVariableDeclaration(stmt.declaration, isRoot)
<span class="linenr">186: </span>      } <span class=
"org-keyword">else</span> <span class="org-keyword">if</span> (
<span class="linenr">187: </span>        stmt.type === <span class=
"org-string">'LabeledStatement'</span> &amp;&
<span class=
"linenr">188: </span>        stmt.body.type === <span class=
"org-string">'VariableDeclaration'</span>
<span class="linenr">189: </span>      ) {
<span class=
"linenr">190: </span>        walkVariableDeclaration(stmt.body, isRoot)
<span class="linenr">191: </span>      }
<span class="linenr">192: </span>    }
<span class="linenr">193: </span>  }
<span class="linenr">194: </span>
<span class="linenr">195: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">walkVariableDeclaration</span>(<span class=
"org-variable-name">stmt</span>, <span class=
"org-variable-name">isRoot</span> = <span class=
"org-constant">false</span>) {
<span class="linenr">196: </span>    <span class=
"org-keyword">if</span> (stmt.declare) {
<span class="linenr">197: </span>      <span class=
"org-keyword">return</span>
<span class="linenr">198: </span>    }
<span class="linenr">199: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">decl</span> <span class=
"org-keyword">of</span> stmt.declarations) {
<span class="linenr">200: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">refCall</span>
<span class="linenr">201: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isCall</span> =
<span class="linenr">202: </span>        decl.init &amp;&
<span class=
"linenr">203: </span>        decl.init.type === <span class=
"org-string">'CallExpression'</span> &amp;&
<span class=
"linenr">204: </span>        decl.init.callee.type === <span class=
"org-string">'Identifier'</span>
<span class="linenr">205: </span>      <span class=
"org-keyword">if</span> (
<span class="linenr">206: </span>        isCall &amp;&
<span class=
"linenr">207: </span>        (refCall = isRefCreationCall(decl.init.callee.name))
<span class="linenr">208: </span>      ) {
<span class=
"linenr">209: </span>        processRefDeclaration(refCall, decl.id, decl.init)
<span class="linenr">210: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr">211: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isProps</span> =
<span class=
"linenr">212: </span>          isRoot &amp;& isCall &amp;& decl.init.callee.name === <span class="org-string">'defineProps'</span>
<span class="linenr">213: </span>        <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">id</span> <span class=
"org-keyword">of</span> extractIdentifiers(decl.id)) {
<span class="linenr">214: </span>          <span class=
"org-keyword">if</span> (isProps) {
<span class="linenr">215: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">for defineProps destructure, only exclude them since they</span>
<span class="linenr">216: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">are already passed in as knownProps</span>
<span class="linenr">217: </span>            excludedIds.add(id)
<span class="linenr">218: </span>          } <span class=
"org-keyword">else</span> {
<span class="linenr">219: </span>            registerBinding(id)
<span class="linenr">220: </span>          }
<span class="linenr">221: </span>        }
<span class="linenr">222: </span>      }
<span class="linenr">223: </span>    }
<span class="linenr">224: </span>  }
<span class="linenr">225: </span>
<span class="linenr">226: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">processRefDeclaration</span>(<span class=
"org-variable-name">method</span>, <span class=
"org-variable-name">id</span>, <span class=
"org-variable-name">call</span>) {
<span class="linenr">227: </span>    excludedIds.add(call.callee)
<span class="linenr">228: </span>    <span class=
"org-keyword">if</span> (method === convertSymbol) {
<span class="linenr">229: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">$</span>
<span class="linenr">230: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">remove macro</span>
<span class=
"linenr">231: </span>      s.remove(call.callee.start + offset, call.callee.end + offset)
<span class="linenr">232: </span>      <span class=
"org-keyword">if</span> (id.type === <span class=
"org-string">'Identifier'</span>) {
<span class="linenr">233: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">single variable</span>
<span class="linenr">234: </span>        registerRefBinding(id)
<span class="linenr">235: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (id.type === <span class=
"org-string">'ObjectPattern'</span>) {
<span class=
"linenr">236: </span>        processRefObjectPattern(id, call)
<span class="linenr">237: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (id.type === <span class=
"org-string">'ArrayPattern'</span>) {
<span class=
"linenr">238: </span>        processRefArrayPattern(id, call)
<span class="linenr">239: </span>      }
<span class="linenr">240: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr">241: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">shorthands</span>
<span class="linenr">242: </span>      <span class=
"org-keyword">if</span> (id.type === <span class=
"org-string">'Identifier'</span>) {
<span class="linenr">243: </span>        registerRefBinding(id)
<span class="linenr">244: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">replace call</span>
<span class="linenr">245: </span>        s.overwrite(
<span class="linenr">246: </span>          call.start + offset,
<span class=
"linenr">247: </span>          call.start + method.length + offset,
<span class=
"linenr">248: </span>          helper(method.slice(<span class=
"org-highlight-numbers-number">1</span>))
<span class="linenr">249: </span>        )
<span class="linenr">250: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr">251: </span>        error(<span class=
"org-string">`${method}() cannot be used with destructure patterns.`</span>, call)
<span class="linenr">252: </span>      }
<span class="linenr">253: </span>    }
<span class="linenr">254: </span>  }
<span class="linenr">255: </span>
<span class="linenr">256: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">processRefObjectPattern</span>(<span class=
"org-variable-name">pattern</span>, <span class=
"org-variable-name">call</span>, <span class=
"org-variable-name">tempVar</span>, <span class=
"org-variable-name">path</span> = []) {
<span class="linenr">257: </span>    <span class=
"org-keyword">if</span> (!tempVar) {
<span class="linenr">258: </span>      tempVar = genTempVar()
<span class="linenr">259: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">const { x } = $(useFoo()) --&gt; const __$temp_1 = useFoo()</span>
<span class=
"linenr">260: </span>      s.overwrite(pattern.start + offset, pattern.end + offset, tempVar)
<span class="linenr">261: </span>    }
<span class="linenr">262: </span>
<span class="linenr">263: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">p</span> <span class=
"org-keyword">of</span> pattern.properties) {
<span class="linenr">264: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">nameId</span>
<span class="linenr">265: </span>      <span class=
"org-keyword">let</span> <span class="org-variable-name">key</span>
<span class="linenr">266: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">defaultValue</span>
<span class="linenr">267: </span>      <span class=
"org-keyword">if</span> (p.type === <span class=
"org-string">'ObjectProperty'</span>) {
<span class="linenr">268: </span>        <span class=
"org-keyword">if</span> (p.key.start === p.value.start) {
<span class="linenr">269: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">shorthand { foo }</span>
<span class="linenr">270: </span>          nameId = p.key
<span class="linenr">271: </span>          <span class=
"org-keyword">if</span> (p.value.type === <span class=
"org-string">'Identifier'</span>) {
<span class="linenr">272: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">avoid shorthand value identifier from being processed</span>
<span class=
"linenr">273: </span>            excludedIds.add(p.value)
<span class="linenr">274: </span>          } <span class=
"org-keyword">else</span> <span class="org-keyword">if</span> (
<span class=
"linenr">275: </span>            p.value.type === <span class=
"org-string">'AssignmentPattern'</span> &amp;&
<span class=
"linenr">276: </span>            p.value.left.type === <span class=
"org-string">'Identifier'</span>
<span class="linenr">277: </span>          ) {
<span class="linenr">278: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">{ foo = 1 }</span>
<span class=
"linenr">279: </span>            excludedIds.add(p.value.left)
<span class=
"linenr">280: </span>            defaultValue = p.value.right
<span class="linenr">281: </span>          }
<span class="linenr">282: </span>        } <span class=
"org-keyword">else</span> {
<span class=
"linenr">283: </span>          key = p.computed ? p.key : p.key.name
<span class="linenr">284: </span>          <span class=
"org-keyword">if</span> (p.value.type === <span class=
"org-string">'Identifier'</span>) {
<span class="linenr">285: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">{ foo: bar }</span>
<span class="linenr">286: </span>            nameId = p.value
<span class="linenr">287: </span>          } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (p.value.type === <span class=
"org-string">'ObjectPattern'</span>) {
<span class=
"linenr">288: </span>            processRefObjectPattern(p.value, call, tempVar, [...path, key])
<span class="linenr">289: </span>          } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (p.value.type === <span class=
"org-string">'ArrayPattern'</span>) {
<span class=
"linenr">290: </span>            processRefArrayPattern(p.value, call, tempVar, [...path, key])
<span class="linenr">291: </span>          } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (p.value.type === <span class=
"org-string">'AssignmentPattern'</span>) {
<span class="linenr">292: </span>            <span class=
"org-keyword">if</span> (p.value.left.type === <span class=
"org-string">'Identifier'</span>) {
<span class="linenr">293: </span>              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">{ foo: bar = 1 }</span>
<span class=
"linenr">294: </span>              nameId = p.value.left
<span class=
"linenr">295: </span>              defaultValue = p.value.right
<span class="linenr">296: </span>            } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (p.value.left.type === <span class=
"org-string">'ObjectPattern'</span>) {
<span class=
"linenr">297: </span>              processRefObjectPattern(p.value.left, call, tempVar, [
<span class="linenr">298: </span>                ...path,
<span class=
"linenr">299: </span>                [key, p.value.right]
<span class="linenr">300: </span>              ])
<span class="linenr">301: </span>            } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (p.value.left.type === <span class=
"org-string">'ArrayPattern'</span>) {
<span class=
"linenr">302: </span>              processRefArrayPattern(p.value.left, call, tempVar, [
<span class="linenr">303: </span>                ...path,
<span class=
"linenr">304: </span>                [key, p.value.right]
<span class="linenr">305: </span>              ])
<span class="linenr">306: </span>            } <span class=
"org-keyword">else</span> {
<span class="linenr">307: </span>              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">MemberExpression case is not possible here, ignore</span>
<span class="linenr">308: </span>            }
<span class="linenr">309: </span>          }
<span class="linenr">310: </span>        }
<span class="linenr">311: </span>      } <span class=
"org-keyword">else</span> {
<span class="linenr">312: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">rest element { ...foo }</span>
<span class="linenr">313: </span>        error(<span class=
"org-string">`reactivity destructure does not support rest elements.`</span>, p)
<span class="linenr">314: </span>      }
<span class="linenr">315: </span>      <span class=
"org-keyword">if</span> (nameId) {
<span class="linenr">316: </span>        registerRefBinding(nameId)
<span class="linenr">317: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">inject toRef() after original replaced pattern</span>
<span class="linenr">318: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">source</span> = pathToString(tempVar, path)
<span class="linenr">319: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">keyStr</span> = isString(key)
<span class="linenr">320: </span>          ? <span class=
"org-string">`'${key}'`</span>
<span class="linenr">321: </span>          : key
<span class="linenr">322: </span>          ? snip(key)
<span class="linenr">323: </span>          : <span class=
"org-string">`'${nameId.name}'`</span>
<span class="linenr">324: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">defaultStr</span> = defaultValue ? <span class=
"org-string">`, ${snip(defaultValue)}`</span> : <span class=
"org-string">``</span>
<span class="linenr">325: </span>        s.appendLeft(
<span class="linenr">326: </span>          call.end + offset,
<span class="linenr">327: </span>          <span class=
"org-string">`,\n  ${nameId.name} = ${helper(</span>
<span class="linenr">328: </span><span class=
"org-string">            'toRef'</span>
<span class="linenr">329: </span><span class=
"org-string">          )}(${source}, ${keyStr}${defaultStr})`</span>
<span class="linenr">330: </span>        )
<span class="linenr">331: </span>      }
<span class="linenr">332: </span>    }
<span class="linenr">333: </span>  }
<span class="linenr">334: </span>
<span class="linenr">335: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">processRefArrayPattern</span>(<span class=
"org-variable-name">pattern</span>, <span class=
"org-variable-name">call</span>, <span class=
"org-variable-name">tempVar</span>, <span class=
"org-variable-name">path</span> = []) {
<span class="linenr">336: </span>    <span class=
"org-keyword">if</span> (!tempVar) {
<span class="linenr">337: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">const [x] = $(useFoo()) --&gt; const __$temp_1 = useFoo()</span>
<span class="linenr">338: </span>      tempVar = genTempVar()
<span class=
"linenr">339: </span>      s.overwrite(pattern.start + offset, pattern.end + offset, tempVar)
<span class="linenr">340: </span>    }
<span class="linenr">341: </span>
<span class="linenr">342: </span>    <span class=
"org-keyword">for</span> (<span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = <span class=
"org-highlight-numbers-number">0</span>; i &lt; pattern.elements.length; i++) {
<span class="linenr">343: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">e</span> = pattern.elements[i]
<span class="linenr">344: </span>      <span class=
"org-keyword">if</span> (!e) <span class=
"org-keyword">continue</span>
<span class="linenr">345: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">nameId</span>
<span class="linenr">346: </span>      <span class=
"org-keyword">let</span> <span class=
"org-variable-name">defaultValue</span>
<span class="linenr">347: </span>      <span class=
"org-keyword">if</span> (e.type === <span class=
"org-string">'Identifier'</span>) {
<span class="linenr">348: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">[a] --&gt; [__a]</span>
<span class="linenr">349: </span>        nameId = e
<span class="linenr">350: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (e.type === <span class=
"org-string">'AssignmentPattern'</span>) {
<span class="linenr">351: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">[a = 1]</span>
<span class="linenr">352: </span>        nameId = e.left
<span class="linenr">353: </span>        defaultValue = e.right
<span class="linenr">354: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (e.type === <span class=
"org-string">'RestElement'</span>) {
<span class="linenr">355: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">[...a]</span>
<span class="linenr">356: </span>        error(<span class=
"org-string">`reactivity destructure does not support rest elements.`</span>, e)
<span class="linenr">357: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (e.type === <span class=
"org-string">'ObjectPattern'</span>) {
<span class=
"linenr">358: </span>        processRefObjectPattern(e, call, tempVar, [...path, i])
<span class="linenr">359: </span>      } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (e.type === <span class=
"org-string">'ArrayPattern'</span>) {
<span class=
"linenr">360: </span>        processRefArrayPattern(e, call, tempVar, [...path, i])
<span class="linenr">361: </span>      }
<span class="linenr">362: </span>      <span class=
"org-keyword">if</span> (nameId) {
<span class="linenr">363: </span>        registerRefBinding(nameId)
<span class="linenr">364: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">inject toRef() after original replaced pattern</span>
<span class="linenr">365: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">source</span> = pathToString(tempVar, path)
<span class="linenr">366: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">defaultStr</span> = defaultValue ? <span class=
"org-string">`, ${snip(defaultValue)}`</span> : <span class=
"org-string">``</span>
<span class="linenr">367: </span>        s.appendLeft(
<span class="linenr">368: </span>          call.end + offset,
<span class="linenr">369: </span>          <span class=
"org-string">`,\n  ${nameId.name} = ${helper(</span>
<span class="linenr">370: </span><span class=
"org-string">            'toRef'</span>
<span class="linenr">371: </span><span class=
"org-string">          )}(${source}, ${i}${defaultStr})`</span>
<span class="linenr">372: </span>        )
<span class="linenr">373: </span>      }
<span class="linenr">374: </span>    }
<span class="linenr">375: </span>  }
<span class="linenr">376: </span>
<span class="linenr">377: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">pathToString</span>(<span class=
"org-variable-name">source</span>, <span class=
"org-variable-name">path</span>) {
<span class="linenr">378: </span>    <span class=
"org-keyword">if</span> (path.length) {
<span class="linenr">379: </span>      <span class=
"org-keyword">for</span> (<span class=
"org-keyword">const</span> <span class=
"org-variable-name">seg</span> <span class=
"org-keyword">of</span> path) {
<span class="linenr">380: </span>        <span class=
"org-keyword">if</span> (isArray(seg)) {
<span class="linenr">381: </span>          source = <span class=
"org-string">`(${source}${segToString(seg[0])} || ${snip(seg[1])})`</span>
<span class="linenr">382: </span>        } <span class=
"org-keyword">else</span> {
<span class=
"linenr">383: </span>          source += segToString(seg)
<span class="linenr">384: </span>        }
<span class="linenr">385: </span>      }
<span class="linenr">386: </span>    }
<span class="linenr">387: </span>    <span class=
"org-keyword">return</span> source
<span class="linenr">388: </span>  }
<span class="linenr">389: </span>
<span class="linenr">390: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">segToString</span>(<span class=
"org-variable-name">seg</span>) {
<span class="linenr">391: </span>    <span class=
"org-keyword">if</span> (<span class=
"org-keyword">typeof</span> seg === <span class=
"org-string">'number'</span>) {
<span class="linenr">392: </span>      <span class=
"org-keyword">return</span> <span class=
"org-string">`[${seg}]`</span>
<span class="linenr">393: </span>    } <span class=
"org-keyword">else</span> <span class=
"org-keyword">if</span> (<span class=
"org-keyword">typeof</span> seg === <span class=
"org-string">'string'</span>) {
<span class="linenr">394: </span>      <span class=
"org-keyword">return</span> <span class=
"org-string">`.${seg}`</span>
<span class="linenr">395: </span>    } <span class=
"org-keyword">else</span> {
<span class="linenr">396: </span>      <span class=
"org-keyword">return</span> snip(seg)
<span class="linenr">397: </span>    }
<span class="linenr">398: </span>  }
<span class="linenr">399: </span>
<span class="linenr">400: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">rewriteId</span>(<span class=
"org-variable-name">scope</span>, <span class=
"org-variable-name">id</span>, <span class=
"org-variable-name">parent</span>, <span class=
"org-variable-name">parentStack</span>) {
<span class="linenr">401: </span>    <span class=
"org-keyword">if</span> (hasOwn(scope, id.name)) {
<span class="linenr">402: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">bindingType</span> = scope[id.name]
<span class="linenr">403: </span>      <span class=
"org-keyword">if</span> (bindingType) {
<span class="linenr">404: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">isProp</span> = bindingType === <span class=
"org-string">'prop'</span>
<span class="linenr">405: </span>        <span class=
"org-keyword">if</span> (isStaticProperty(parent) &amp;& parent.shorthand) {
<span class="linenr">406: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">let binding used in a property shorthand</span>
<span class="linenr">407: </span>          <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">skip for destructure patterns</span>
<span class="linenr">408: </span>          <span class=
"org-keyword">if</span> (
<span class="linenr">409: </span>            !parent.inPattern ||
<span class=
"linenr">410: </span>            isInDestructureAssignment(parent, parentStack)
<span class="linenr">411: </span>          ) {
<span class="linenr">412: </span>            <span class=
"org-keyword">if</span> (isProp) {
<span class="linenr">413: </span>              <span class=
"org-keyword">if</span> (escapeScope) {
<span class="linenr">414: </span>                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">prop binding in $$()</span>
<span class="linenr">415: </span>                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">{ prop } -&gt; { prop: __prop_prop }</span>
<span class=
"linenr">416: </span>                registerEscapedPropBinding(id)
<span class="linenr">417: </span>                s.appendLeft(
<span class="linenr">418: </span>                  id.end + offset,
<span class="linenr">419: </span>                  <span class=
"org-string">`: __props_${propsLocalToPublicMap[id.name]}`</span>
<span class="linenr">420: </span>                )
<span class="linenr">421: </span>              } <span class=
"org-keyword">else</span> {
<span class="linenr">422: </span>                <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">{ prop } -&gt; { prop: __prop.prop }</span>
<span class="linenr">423: </span>                s.appendLeft(
<span class="linenr">424: </span>                  id.end + offset,
<span class="linenr">425: </span>                  <span class=
"org-string">`: __props.${propsLocalToPublicMap[id.name]}`</span>
<span class="linenr">426: </span>                )
<span class="linenr">427: </span>              }
<span class="linenr">428: </span>            } <span class=
"org-keyword">else</span> {
<span class="linenr">429: </span>              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">{ foo } -&gt; { foo: foo.value }</span>
<span class=
"linenr">430: </span>              s.appendLeft(id.end + offset, <span class="org-string">`: ${id.name}.value`</span>)
<span class="linenr">431: </span>            }
<span class="linenr">432: </span>          }
<span class="linenr">433: </span>        } <span class=
"org-keyword">else</span> {
<span class="linenr">434: </span>          <span class=
"org-keyword">if</span> (isProp) {
<span class="linenr">435: </span>            <span class=
"org-keyword">if</span> (escapeScope) {
<span class="linenr">436: </span>              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">x --&gt; __props_x</span>
<span class=
"linenr">437: </span>              registerEscapedPropBinding(id)
<span class="linenr">438: </span>              s.overwrite(
<span class="linenr">439: </span>                id.start + offset,
<span class="linenr">440: </span>                id.end + offset,
<span class="linenr">441: </span>                <span class=
"org-string">`__props_${propsLocalToPublicMap[id.name]}`</span>
<span class="linenr">442: </span>              )
<span class="linenr">443: </span>            } <span class=
"org-keyword">else</span> {
<span class="linenr">444: </span>              <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">x --&gt; __props.x</span>
<span class="linenr">445: </span>              s.overwrite(
<span class="linenr">446: </span>                id.start + offset,
<span class="linenr">447: </span>                id.end + offset,
<span class="linenr">448: </span>                <span class=
"org-string">`__props.${propsLocalToPublicMap[id.name]}`</span>
<span class="linenr">449: </span>              )
<span class="linenr">450: </span>            }
<span class="linenr">451: </span>          } <span class=
"org-keyword">else</span> {
<span class="linenr">452: </span>            <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">x --&gt; x.value</span>
<span class=
"linenr">453: </span>            s.appendLeft(id.end + offset, <span class="org-string">'.value'</span>)
<span class="linenr">454: </span>          }
<span class="linenr">455: </span>        }
<span class="linenr">456: </span>      }
<span class="linenr">457: </span>      <span class=
"org-keyword">return</span> <span class="org-constant">true</span>
<span class="linenr">458: </span>    }
<span class="linenr">459: </span>    <span class=
"org-keyword">return</span> <span class="org-constant">false</span>
<span class="linenr">460: </span>  }
<span class="linenr">461: </span>
<span class="linenr">462: </span>  <span class=
"org-keyword">const</span> <span class=
"org-variable-name">propBindingRefs</span> = {}
<span class="linenr">463: </span>  <span class=
"org-keyword">function</span> <span class=
"org-function-name">registerEscapedPropBinding</span>(<span class=
"org-variable-name">id</span>) {
<span class="linenr">464: </span>    <span class=
"org-keyword">if</span> (!propBindingRefs.hasOwnProperty(id.name)) {
<span class=
"linenr">465: </span>      propBindingRefs[id.name] = <span class=
"org-constant">true</span>
<span class="linenr">466: </span>      <span class=
"org-keyword">const</span> <span class=
"org-variable-name">publicKey</span> = propsLocalToPublicMap[id.name]
<span class="linenr">467: </span>      s.prependRight(
<span class="linenr">468: </span>        offset,
<span class="linenr">469: </span>        <span class=
"org-string">`const __props_${publicKey} = ${helper(</span>
<span class="linenr">470: </span><span class=
"org-string">          `</span>toRef<span class=
"org-string">`</span>
<span class="linenr">471: </span><span class=
"org-string">        )}(__props, '${publicKey}')\n`</span>
<span class="linenr">472: </span>      )
<span class="linenr">473: </span>    }
<span class="linenr">474: </span>  }
<span class="linenr">475: </span>
<span class="linenr">476: </span>  <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">check root scope first</span>
<span class="linenr">477: </span>  walkScope(ast, <span class=
"org-constant">true</span>)
<span class="linenr">478: </span>  walk(ast, {
<span class="linenr">479: </span>    enter(node, parent) {
<span class=
"linenr">480: </span>      parent &amp;& parentStack.push(parent)
<span class="linenr">481: </span>
<span class="linenr">482: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">function scopes</span>
<span class="linenr">483: </span>      <span class=
"org-keyword">if</span> (isFunctionType(node)) {
<span class=
"linenr">484: </span>        scopeStack.push((currentScope = {}))
<span class=
"linenr">485: </span>        walkFunctionParams(node, registerBinding)
<span class="linenr">486: </span>        <span class=
"org-keyword">if</span> (node.body.type === <span class=
"org-string">'BlockStatement'</span>) {
<span class="linenr">487: </span>          walkScope(node.body)
<span class="linenr">488: </span>        }
<span class="linenr">489: </span>        <span class=
"org-keyword">return</span>
<span class="linenr">490: </span>      }
<span class="linenr">491: </span>
<span class="linenr">492: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">catch param</span>
<span class="linenr">493: </span>      <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'CatchClause'</span>) {
<span class=
"linenr">494: </span>        scopeStack.push((currentScope = {}))
<span class="linenr">495: </span>        <span class=
"org-keyword">if</span> (node.param &amp;& node.param.type === <span class="org-string">'Identifier'</span>) {
<span class=
"linenr">496: </span>          registerBinding(node.param)
<span class="linenr">497: </span>        }
<span class="linenr">498: </span>        walkScope(node.body)
<span class="linenr">499: </span>        <span class=
"org-keyword">return</span>
<span class="linenr">500: </span>      }
<span class="linenr">501: </span>
<span class="linenr">502: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">non-function block scopes</span>
<span class="linenr">503: </span>      <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'BlockStatement'</span> &amp;& !isFunctionType(parent)) {
<span class=
"linenr">504: </span>        scopeStack.push((currentScope = {}))
<span class="linenr">505: </span>        walkScope(node)
<span class="linenr">506: </span>        <span class=
"org-keyword">return</span>
<span class="linenr">507: </span>      }
<span class="linenr">508: </span>
<span class="linenr">509: </span>      <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">skip type nodes</span>
<span class="linenr">510: </span>      <span class=
"org-keyword">if</span> (
<span class="linenr">511: </span>        parent &amp;&
<span class=
"linenr">512: </span>        parent.type.startsWith(<span class=
"org-string">'TS'</span>) &amp;&
<span class=
"linenr">513: </span>        parent.type !== <span class=
"org-string">'TSAsExpression'</span> &amp;&
<span class=
"linenr">514: </span>        parent.type !== <span class=
"org-string">'TSNonNullExpression'</span> &amp;&
<span class=
"linenr">515: </span>        parent.type !== <span class=
"org-string">'TSTypeAssertion'</span>
<span class="linenr">516: </span>      ) {
<span class="linenr">517: </span>        <span class=
"org-keyword">return</span> <span class=
"org-constant">this</span>.skip()
<span class="linenr">518: </span>      }
<span class="linenr">519: </span>
<span class="linenr">520: </span>      <span class=
"org-keyword">if</span> (
<span class="linenr">521: </span>        node.type === <span class=
"org-string">'Identifier'</span> &amp;&
<span class="linenr">522: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">if inside $$(), skip unless this is a destructured prop binding</span>
<span class=
"linenr">523: </span>        !(escapeScope &amp;& rootScope[node.name] !== <span class="org-string">'prop'</span>) &amp;&
<span class=
"linenr">524: </span>        isReferencedIdentifier(node, parent, parentStack) &amp;&
<span class="linenr">525: </span>        !excludedIds.has(node)
<span class="linenr">526: </span>      ) {
<span class="linenr">527: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment">walk up the scope chain to check if id should be appended .value</span>
<span class="linenr">528: </span>        <span class=
"org-keyword">let</span> <span class=
"org-variable-name">i</span> = scopeStack.length
<span class="linenr">529: </span>        <span class=
"org-keyword">while</span> (i--) {
<span class="linenr">530: </span>          <span class=
"org-keyword">if</span> (rewriteId(scopeStack[i], node, parent, parentStack)) {
<span class="linenr">531: </span>            <span class=
"org-keyword">return</span>
<span class="linenr">532: </span>          }
<span class="linenr">533: </span>        }
<span class="linenr">534: </span>      }
<span class="linenr">535: </span>
<span class="linenr">536: </span>      <span class=
"org-keyword">if</span> (node.type === <span class=
"org-string">'CallExpression'</span> &amp;& node.callee.type === <span class="org-string">'Identifier'</span>) {
<span class="linenr">537: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">callee</span> = node.callee.name
<span class="linenr">538: </span>
<span class="linenr">539: </span>        <span class=
"org-keyword">const</span> <span class=
"org-variable-name">refCall</span> = isRefCreationCall(callee)
<span class="linenr">540: </span>        <span class=
"org-keyword">if</span> (refCall &amp;& (!parent || parent.type !== <span class="org-string">'VariableDeclarator'</span>)) {
<span class="linenr">541: </span>          <span class=
"org-keyword">return</span> error(
<span class="linenr">542: </span>            <span class=
"org-string">`${refCall} can only be used as the initializer of `</span> +
<span class="linenr">543: </span>              <span class=
"org-string">`a variable declaration.`</span>,
<span class="linenr">544: </span>            node
<span class="linenr">545: </span>          )
<span class="linenr">546: </span>        }
<span class="linenr">547: </span>
<span class="linenr">548: </span>        <span class=
"org-keyword">if</span> (callee === escapeSymbol) {
<span class=
"linenr">549: </span>          s.remove(node.callee.start + offset, node.callee.end + offset)
<span class="linenr">550: </span>          escapeScope = node
<span class="linenr">551: </span>        }
<span class="linenr">552: </span>
<span class="linenr">553: </span>        <span class=
"org-comment-delimiter">// </span><span class=
"org-comment"><span class="org-bold"><span class=
"org-warning">TODO</span></span></span><span class=
"org-comment"> remove when out of experimental</span>
<span class="linenr">554: </span>        <span class=
"org-keyword">if</span> (callee === <span class=
"org-string">'$raw'</span>) {
<span class="linenr">555: </span>          error(
<span class="linenr">556: </span>            <span class=
"org-string">`$raw() has been replaced by $$(). `</span> +
<span class="linenr">557: </span>              <span class=
"org-string">`See ${RFC_LINK} for latest updates.`</span>,
<span class="linenr">558: </span>            node
<span class="linenr">559: </span>          )
<span class="linenr">560: </span>        }
<span class="linenr">561: </span>        <span class=
"org-keyword">if</span> (callee === <span class=
"org-string">'$fromRef'</span>) {
<span class="linenr">562: </span>          error(
<span class="linenr">563: </span>            <span class=
"org-string">`$fromRef() has been replaced by $(). `</span> +
<span class="linenr">564: </span>              <span class=
"org-string">`See ${RFC_LINK} for latest updates.`</span>,
<span class="linenr">565: </span>            node
<span class="linenr">566: </span>          )
<span class="linenr">567: </span>        }
<span class="linenr">568: </span>      }
<span class="linenr">569: </span>    },
<span class="linenr">570: </span>    leave(node, parent) {
<span class=
"linenr">571: </span>      parent &amp;& parentStack.pop()
<span class="linenr">572: </span>      <span class=
"org-keyword">if</span> (
<span class=
"linenr">573: </span>        (node.type === <span class="org-string">'BlockStatement'</span> &amp;& !isFunctionType(parent)) ||
<span class="linenr">574: </span>        isFunctionType(node)
<span class="linenr">575: </span>      ) {
<span class="linenr">576: </span>        scopeStack.pop()
<span class=
"linenr">577: </span>        currentScope = scopeStack[scopeStack.length - <span class="org-highlight-numbers-number">1</span>] || <span class="org-constant">null</span>
<span class="linenr">578: </span>      }
<span class="linenr">579: </span>      <span class=
"org-keyword">if</span> (node === escapeScope) {
<span class="linenr">580: </span>        escapeScope = <span class=
"org-constant">undefined</span>
<span class="linenr">581: </span>      }
<span class="linenr">582: </span>    }
<span class="linenr">583: </span>  })
<span class="linenr">584: </span>
<span class="linenr">585: </span>  <span class=
"org-keyword">return</span> {
<span class=
"linenr">586: </span>    rootRefs: Object.keys(rootScope).filter(key =&gt; rootScope[key] === <span class="org-constant">true</span>),
<span class=
"linenr">587: </span>    importedHelpers: [...importedHelpers]
<span class="linenr">588: </span>  }
<span class="linenr">589: </span>}
<span class="linenr">590: </span>
<span class="linenr">591: </span>  <span class=
"org-keyword">return</span> { transformAST, transform, shouldTransform }
<span class="linenr">592: </span>}())
</pre>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div id="postamble" class="status">
    <p class="author">Author: Zhicheng Lee</p>
    <p class="date">Created: 2022-05-05 Thu 16:39</p>
  </div>
</body>
</html>
