:PROPERTIES:
:ID:       f17d718c-0d00-4c10-b3f9-e9e0d8295193
:END:
#+SETUPFILE:~/.gclrc/org/hugo_setup.org
#+HUGO_SLUG: build_your_own_vue_compiler_dom
#+HTML_HEAD: <meta name="category" content="vue"/>
#+HTML_HEAD: <meta name="tags" content="compiler-dom"/>
#+HTML_HEAD: <meta name="createdAt" content="2022-04-27 14:49:00"/>
#+PROPERTY: header-args :noweb no-export
#+TITLE: build your own vue compiler-dom
<badge: GCCLL | Homepage | green | / | gnu-emacs | tinder>

#+begin_box Vue3 compiler-dom :background-color green

[[https://www.cheng92.com/vue/vue-mind-map-compiler-dom/][Vue3 源码头脑风暴之 4 ☞compiler-dom - 若叶知秋]]

文章最后有交互式的[[testing][测试方法]]，可输入想看的模板得到对应的 render 函数和 AST 。
#+end_box

#+html: <br>
#+begin_details compiler-core 代码 :title-color green
[[https://blog.cheng92.com/posts/build_your_own_vue_compiler_core.html][build your own vue compiler-core]]

#+name: globalVars
#+include ../assets/tests/globalVars.js src js -n -r

#+name: compiler-core
#+include: ../assets/tests/compiler-core.js src js -n -r
#+end_details

* APIs

compiler-dom 包包含以下 APIs 这个包主要是针对一些指令进行加工处理，如： ~v-html~,
~v-text~ 等等。

| name             | description                                      |
|------------------+--------------------------------------------------|
| [[transformStyleCD][transformStyle()]] | combine & normalize, result to object ~{a:b, c:d}~ |
| [[transformVHtml][transformVHtml()]] | v-html                                           |
| [[transformVText][transformVText()]] | v-text                                           |
| [[transformModel][transformModel()]] | v-model, transform bind value and event handler  |
| [[transformOn][transformOn()]]    | v-on, handle the event modifiers                 |
| [[transformShow][transformShow()]]  | v-show                                           |

code:

#+name: compiler-dom-export
#+begin_src js -n -r
const compilerDom = (function() {
  <<transformStyle>>
  <<transformVHtml>>
  <<transformVText>>
  <<transformModel>>
  <<transformOn>>
  <<transformShow>>
  <<stringifyStatic>>
  <<DOMDirectiveTransforms>>
  <<DOMNodeTransforms>>
  <<compile>>
  <<parse>>

  return {
    DOMNodeTransforms,
    DOMDirectiveTransforms,
    compile,
    parse,
    transformStyle,
  }
}())
#+end_src

#+name: compiler-dom
#+begin_src js -n -r
<<globalVars>>
<<compiler-core>>
<<compiler-dom-export>>
#+end_src

export to file:
#+html: <br>
#+begin_details compiler-dom :title-color red
#+begin_src js -n -r :noweb yes :tangle "~/github/mine/blog.cheng92.com/assets/tests/compiler-dom.js"
<<compiler-dom-export>>
#+end_src
#+end_details

* transforms

#+name: DOMDirectiveTransforms
#+begin_src js -n -r
const DOMDirectiveTransforms = {
  cloak: noopDirectiveTransform,
  html: transformVHtml,
  text: transformVText,
  model: transformModel, // override compiler-core
  on: transformOn, // override compiler-core
  show: transformShow
}
#+end_src

#+name: DOMNodeTransforms
#+begin_src js -n -r
const DOMNodeTransforms = [
  transformStyle,
  ...(__DEV__ ? [warnTransitionChildren] : [])
]
#+end_src

** style

compiler-dom 之前：

#+name: test-before-cd
#+begin_src js -n -r :exports both
<<compiler-core>>

const { baseCompile } = compilerCore
logOff()
const { code } = baseCompile('<div style="width:200px" :style="{height: `200px`}" />', { filename: 'foo.vue' })
logOn()
logg('<div style="width:200px" />', code)
#+end_src

对 style 属性进行加工处理，字符串拆成对象，然后合并到，同时支持多种使用方式

1. ~<div style="width:100px">~ => ~{width:'100px'}~
2. ~<div :style="{width:'100px'}">~ => ~{width:'100px'}~
3. ~<div :style="{width:'100px'} style="height:100px">~ => ~{width:'100px',height:'100px'}~

#+name: transformStyle
#+begin_src js -n -r

// Parse inline CSS strings for static style attributes into an object.
// This is a NodeTransform since it works on the static `style` attribute and
// converts it into a dynamic equivalent:
// style="color: red" -> :style='{ "color": "red" }'
// It is then processed by `transformElement` and included in the generated
// props.
const transformStyle = node => {
  if (node.type === NodeTypes.ELEMENT) {
    node.props.forEach((p, i) => {
      if (p.type === NodeTypes.ATTRIBUTE && p.name === 'style' && p.value) {
        // replace p with an expression node
        node.props[i] = {
          type: NodeTypes.DIRECTIVE,
          name: `bind`,
          arg: createSimpleExpression(`style`, true, p.loc),
          exp: parseInlineCSS(p.value.content, p.loc),
          modifiers: [],
          loc: p.loc
        }
      }
    })
  }
}

const parseInlineCSS = (cssText, loc) => {
  const normalized = parseStringStyle(cssText)
  return createSimpleExpression(
    JSON.stringify(normalized),
    false,
    loc,
    ConstantTypes.CAN_STRINGIFY
  )
}
#+end_src

[[(parseStringStyle)][parseStringStyle]] 将字符串解析成对象 ~"width:100px"~ => ~{ width: '100px' }~

[[(stringifyStyle)][stringifyStyle]] 将对象转成字符串 ~{ width: '100px' }~ => ~"width:100px"~

[[(normalizeStyle)][normalizeStyle]] 解析 style 的值，可能是 ~"width:100px"~ 或 ~{width:'100px'}~ 也可以是
~['width:100px', {height:'100px'}]~ 的混合方式，最终都会被解析成对象
~{width:'100px', height: '100px'}~ 。

#+begin_src js -n -r :exports both
<<compiler-dom>>

const { parseStringStyle, stringifyStyle, normalizeStyle } = compilerDom
const { logg } = compilerCore
const pss = s => parseStringStyle(s)
let r = pss('width:100px;height:100px')
logg('parseStringStyle', r)
const sfs = s => stringifyStyle(s)
const s = sfs(r)
logg('stringifyStyle', s)
logg('normalizeStyle', normalizeStyle([r, s, 'font-size:12px', { 'line-height': 1.2 }]))
#+end_src

red:Testing

#+begin_src js -n -r :exports both
<<compiler-dom>>

const { compile } = compilerDom
logOff()
const { code } = compile('<div style="width:200px" :style="{height: `200px`}" />', { filename: 'foo.vue' })
logOn()
logg('<div style="width:200px" />', code)
#+end_src

注意与 [[test-before-cd][实现 compiler-dom 之前测试结果]] 对比结果，会发现后者的 ~style~ 都会被转成对
象形式。

之前：
#+begin_src js
 style: _normalizeStyle([
   "width:200px",
   {height: `200px`}
 ])
#+end_src

之后：

#+begin_src js
style: _normalizeStyle([
  {"width":"200px"},
  {height: `200px`}
])
#+end_src

** v-html

#+name: transformVHtml
#+begin_src js -n -r
const transformVHtml = (dir, node, context) => {
  const { exp, loc } = dir
  if (!exp) {
    logg("v-html no exp")
  }
  if (node.children.length) {
    logg('v-html can not has children')
    node.children.length = 0
  }
  return {
    props: [
      createObjectProperty(
        createSimpleExpression(`innerHTML`, true, loc),
        exp || createSimpleExpression('', true)
      )
    ]
  }
}
#+end_src

red:Testing

before: 不会被处理
#+begin_src js -n -r :exports both
<<compiler-core>>
logOff()
const { code } = baseCompile("<div v-html='foo'><span/></div>", { filename: 'foo.vue' })
logOn()
logg('v-html', code)
#+end_src

after:

#+begin_src js -n -r :exports both
<<compiler-dom>>
logOff()
const { code } = compile("<div v-html='foo'><span/></div>", { filename: 'foo.vue' })
logOn()
logg('v-html', code)
#+end_src

注意看前后的结果， compile-core 阶段是没有对 v-html 进行处理的，且 after 结果中
的 ~<span/>~ 已经没有了，且增加了 ~{ innerHTML }~ 属性。

** v-text

#+name: transformVText
#+begin_src js -n -r
const transformVText = (dir, node, context) => {
  const { exp, loc } = dir
  if (!exp) {
    logg('v-text no exp')
  }
  if (node.children.length) {
    logg('v-text can not have children')
    node.children.length = 0
  }
  return {
    props: [
      createObjectProperty(
        createSimpleExpression(`textContent`, true),
        exp
          ? createCallExpression(
              context.helperString(TO_DISPLAY_STRING),
              [exp],
              loc
            )
          : createSimpleExpression('', true)
      )
    ]
  }
}
#+end_src

red:Testing

before: compiler-core 中也没有对 v-text 指令的处理

#+begin_src js -n -r :exports both
<<compiler-core>>
logOff()
const { code } = baseCompile("<div v-text='foo'><span/></div>", { filename: 'foo.vue' })
logOn()
logg('v-text', code)
#+end_src

after: ~<span/>~ 所有子节点都会被删除，增加 ~{ textContent }~ 属性。
#+begin_src js -n -r :exports both
<<compiler-dom>>
logOff()
const { code } = compile("<div v-text='foo'><span/></div>", { filename: 'foo.vue' })
logOn()
logg('v-text', code)
#+end_src

** v-model

#+name: transformModel
#+begin_src js -n -r
const transformModel = (dir, node, context) => {
  const baseResult = transformModel(dir, node, context)
  // base transform has errors OR component v-model (only need props)
  if (!baseResult.props.length || node.tagType === ElementTypes.COMPONENT) {
    return baseResult
  }

  if (dir.arg) {
    logg("transfromModel - X_V_MODEL_ARG_ON_ELEMENT")
  }

  function checkDuplicatedValue() {
    const value = findProp(node, 'value')
    if (value) {
      logg("transfromModel - X_V_MODEL_UNNECESSARY_VALUE")
    }
  }

  const { tag } = node
  const isCustomElement = context.isCustomElement(tag)
  if (
    tag === 'input' ||
    tag === 'textarea' ||
    tag === 'select' ||
    isCustomElement
  ) {
    let directiveToUse = V_MODEL_TEXT
    let isInvalidType = false
    if (tag === 'input' || isCustomElement) {
      const type = findProp(node, `type`)
      if (type) {
        if (type.type === NodeTypes.DIRECTIVE) {
          // :type="foo"
          directiveToUse = V_MODEL_DYNAMIC
        } else if (type.value) {
          switch (type.value.content) {
            case 'radio':
              directiveToUse = V_MODEL_RADIO
              break
            case 'checkbox':
              directiveToUse = V_MODEL_CHECKBOX
              break
            case 'file':
              isInvalidType = true
              logg("[DOM]transformModel - X_V_MODEL_ON_FILE_INPUT_ELEMENT")
              break
            default:
              // text type
              __DEV__ && checkDuplicatedValue()
              break
          }
        }
      } else if (hasDynamicKeyVBind(node)) {
        // element has bindings with dynamic keys, which can possibly contain
        // "type".
        directiveToUse = V_MODEL_DYNAMIC
      } else {
        // text type
        __DEV__ && checkDuplicatedValue()
      }
    } else if (tag === 'select') {
      directiveToUse = V_MODEL_SELECT
    } else {
      // textarea
      __DEV__ && checkDuplicatedValue()
    }
    // inject runtime directive
    // by returning the helper symbol via needRuntime
    // the import will replaced a resolveDirective call.
    if (!isInvalidType) {
      baseResult.needRuntime = context.helper(directiveToUse)
    }
  } else {
    logg("[DOM]transformModel - X_V_MODEL_ON_INVALID_ELEMENT")
  }

  // native vmodel doesn't need the `modelValue` props since they are also
  // passed to the runtime as `binding.value`. removing it reduces code size.
  baseResult.props = baseResult.props.filter(
    p =>
      !(
        p.key.type === NodeTypes.SIMPLE_EXPRESSION &&
        p.key.content === 'modelValue'
      )
  )

  return baseResult
}
#+end_src

1. 只处理 input, textarea, select 文本框标签，或自定义的标签

2. <input> 标签类型分为 radio 和 checkbox 单复选项框处理，不能使用 type='file' 类型

3. <select> 下拉选项框的处理

4. 过滤掉 transform 之后的 ~{modelValue: value, 'onUpdate:value': $event => value
   = $event}~ 里面的 ~modelValue：value~ 属性，因为在 runtime-core 时期的
   [[withDirectives][withDirectives(]]) 处理里面会被绑定到 value 属性上

red:Testing

before:

#+begin_src js -n -r :exports both
<<compiler-core>>

logOff()
const { code } = baseCompile("<input type='text' v-model='value' />", { filename: 'foo.vue' })
logOn()
log('v-model', code)
#+end_src

after: 多了一层包装 ~_withDirectives()~
#+begin_src js -n -r :exports both
<<compiler-dom>>

logOff()
const { code } = compile("<input type='text' v-model='value' />", { filename: 'foo.vue' })
logOn()
log('v-model', code)
#+end_src

那来看下 ~_withDirectives()~ 里面做了什么？

#+name: withDirectives
#+begin_src js -n -r
function withDirectives(vnode, directives) {
  const internalInstance = currentRenderingInstance
  if (internalInstance === null) {
    return vnode
  }
  // 取当前应用实例
  const instance = getExposeProxy(internalInstance) || internalInstance.proxy
  const bindings = vnode.dirs || (vnode.dirs = [])
  for (let i = 0; i < directives.length; i++) {

    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i]
    if (isFunction(dir)) {
      dir = {
        mounted: dir,
        updated: dir
      }
    }
    if (dir.deep) {
      traverse(value)
    }
    bindings.push({
      dir,
      instance,
      value,
      oldValue: void 0,
      arg,
      modifiers
    })
  }
  return vnode
}
#+end_src
** v-on

#+name: transformOn
#+begin_src js -n -r
const isEventOptionModifier = /*#__PURE__*/ makeMap(`passive,once,capture`)
const isNonKeyModifier = /*#__PURE__*/ makeMap(
  // event propagation management
  `stop,prevent,self,` +
    // system modifiers + exact
    `ctrl,shift,alt,meta,exact,` +
    // mouse
    `middle`
)
// left & right could be mouse or key modifiers based on event type
const maybeKeyModifier = /*#__PURE__*/ makeMap('left,right')
const isKeyboardEvent = /*#__PURE__*/ makeMap(
  `onkeyup,onkeydown,onkeypress`,
  true
)

// 将修饰符分类
const resolveModifiers = (key, modifiers, context, loc) => {
  const keyModifiers = []
  const nonKeyModifiers = []
  const eventOptionModifiers = []

  for (let i = 0; i < modifiers.length; i++) {
    const modifier = modifiers[i]

    if (isEventOptionModifier(modifier)) {
      // eventOptionModifiers: modifiers for addEventListener() options,
      // e.g. .passive & .capture
      eventOptionModifiers.push(modifier)
    } else {
      // runtimeModifiers: modifiers that needs runtime guards
      if (maybeKeyModifier(modifier)) {
        if (isStaticExp(key)) {
          if (isKeyboardEvent(key.content)) {
            keyModifiers.push(modifier)
          } else {
            nonKeyModifiers.push(modifier)
          }
        } else {
          keyModifiers.push(modifier)
          nonKeyModifiers.push(modifier)
        }
      } else {
        if (isNonKeyModifier(modifier)) {
          nonKeyModifiers.push(modifier)
        } else {
          keyModifiers.push(modifier)
        }
      }
    }
  }

  return {
    keyModifiers,
    nonKeyModifiers,
    eventOptionModifiers
  }
}

// 原生 click 事件
const transformClick = (key, event) => {
  const isStaticClick =
    isStaticExp(key) && key.content.toLowerCase() === 'onclick'
  return isStaticClick
    ? createSimpleExpression(event, true)
    : key.type !== NodeTypes.SIMPLE_EXPRESSION
    ? createCompoundExpression([
        `(`,
        key,
        `) === "onClick" ? "${event}" : (`,
        key,
        `)`
      ])
    : key
}

const transformOn = (dir, node, context) => {
  return transformOn(dir, node, context, baseResult => {
    const { modifiers } = dir
    if (!modifiers.length) return baseResult

    let { key, value: handlerExp } = baseResult.props[0]
    const { keyModifiers, nonKeyModifiers, eventOptionModifiers } =
      resolveModifiers(key, modifiers, context, dir.loc)

    // normalize click.right and click.middle since they don't actually fire
    if (nonKeyModifiers.includes('right')) { (ref:transformOn-right)
      key = transformClick(key, `onContextmenu`)
    }
    if (nonKeyModifiers.includes('middle')) {
      key = transformClick(key, `onMouseup`)
    }

    if (nonKeyModifiers.length) {
      handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
        handlerExp,
        JSON.stringify(nonKeyModifiers)
      ])
    }

    if (
      keyModifiers.length &&
      // if event name is dynamic, always wrap with keys guard
      (!isStaticExp(key) || isKeyboardEvent(key.content))
    ) {
      handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [
        handlerExp,
        JSON.stringify(keyModifiers)
      ])
    }

    if (eventOptionModifiers.length) {
      const modifierPostfix = eventOptionModifiers.map(capitalize).join('')
      key = isStaticExp(key)
        ? createSimpleExpression(`${key.content}${modifierPostfix}`, true)
        : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`])
    }

    return {
      props: [createObjectProperty(key, handlerExp)]
    }
  })
}
#+end_src

red:Testing

before: 注意看结果会发现修饰符并没有出现在 render 函数中
#+begin_src js -n -r :exports both
<<compiler-core>>

logOff()
const { code } = baseCompile(`<div @click.enter.passive="handleClick" />`, { filename: 'foo.vue' })
logOn()
log('onclick', code)
#+end_src

after:
#+begin_src js -n -r :exports both
<<compiler-dom>>

logOff()
const { code } = compile(`<div @click.right.passive="handleClick" />`, { filename: 'foo.vue' })
logOn()
log('onclick', code)
#+end_src

1. right 修饰符下的 click 事件被转成了 ~onContextmenu~ 右键点击事件
2. passive 修饰符直接被追加到了事件 key 后面 ~onContextmenuPassive~, 这也是 vue 中
   对修饰符的处理方式(如： ~@click.right.once~ => ~onContextmenuOnce~)


当有修饰符的时候会使用到 withModifiers, 每个修饰符都有自己对应的一个函数，只有当
满足条件的才会让事件继续，也就是最后的 ~fn(event, ...args)~ 执行:

#+begin_src typescript -n -r
const modifierGuards: Record<
  string,
  (e: Event, modifiers: string[]) => void | boolean
> = {
  stop: e => e.stopPropagation(),
  prevent: e => e.preventDefault(),
  self: e => e.target !== e.currentTarget,
  ctrl: e => !(e as KeyedEvent).ctrlKey,
  shift: e => !(e as KeyedEvent).shiftKey,
  alt: e => !(e as KeyedEvent).altKey,
  meta: e => !(e as KeyedEvent).metaKey,
  left: e => 'button' in e && (e as MouseEvent).button !== 0,
  middle: e => 'button' in e && (e as MouseEvent).button !== 1,
  right: e => 'button' in e && (e as MouseEvent).button !== 2,
  exact: (e, modifiers) =>
    systemModifiers.some(m => (e as any)[`${m}Key`] && !modifiers.includes(m))
}

const withModifiers = (fn: Function, modifiers: string[]) => {
  return (event: Event, ...args: unknown[]) => {
    for (let i = 0; i < modifiers.length; i++) {
      const guard = modifierGuards[modifiers[i]]
      if (guard && guard(event, modifiers)) return
    }
    return fn(event, ...args)
  }
}
#+end_src

#+begin_box 小结
compiler-dom 对 v-on 指令的处理就是对修饰符的处理，将事件函数进行转换，使用
~withModifiers()~ 进行封装。

修饰符有三类：

1. 事件选项kbd:passive,once,capture

   [[https://segmentfault.com/a/1190000017247263][passive的作用和原理 - SegmentFault 思否]]

   [[https://blog.techbridge.cc/2017/07/15/javascript-event-propagation/][DOM 的事件傳遞機制：捕獲與冒泡]]

2. 冒泡相关 kbd:stop,prevent,self, 系统组合键 kbd:ctrl,shift,alt,meta,exact, 鼠
   标按键 kbd:middle
3. <kbd:left, right> 可能是鼠标也可以是键盘上的左右键


修饰符影响事件类型：

1. click.right 转成右键菜单键 ~onContextmenu~
2. click.middle 转成鼠标中键 ~onMouseUp~
#+end_box

** v-show

v-show 在这里并没有真正的被处理到，而在 runtime 运行时才会被处理，也就是后面会完
成的 ~runtime-dom~ 包里，实现原理其实就是控制元素 ~display~ 属性，这里只是将其标识了
下需要运行时去处理。

旧博客中有相关分析：[[https://www.cheng92.com/vue/vue-mind-map-runtime-dom/#v-show][Vue3 源码头脑风暴之 8 ☞ runtime-dom - 若叶知秋]]

#+name: transformShow
#+begin_src js -n -r
const transformShow = (dir, node, context) => {
  const { exp, loc } = dir
  if (!exp) {
    logg('transformShow no exp.')
  }

  return {
    props: [],
    needRuntime: context.helper(V_SHOW)
  }
}
#+end_src

** stringifyStatic

在处理静态提升代码时需要用到 ~stringifyStatic~, 它会将静态提升的节点直接字符串化，
然后创建一个 off-dom 节点来保存它，等到需要使用的时候直接使用这个 off-dom 节点。

#+name: stringifyStatic
#+begin_src js -n -r
 const StringifyThresholds = {
   ELEMENT_WITH_BINDING_COUNT: 5,
   NODE_COUNT: 20
}

/**
 ,* Regex for replacing placeholders for embedded constant variables
 ,* (e.g. import URL string constants generated by compiler-sfc)
 ,*/
const expReplaceRE = /__VUE_EXP_START__(.*?)__VUE_EXP_END__/g

/**
 ,* Turn eligible hoisted static trees into stringified static nodes, e.g.
 ,*
 ,* ```js
 ,* const _hoisted_1 = createStaticVNode(`<div class="foo">bar</div>`)
 ,* ```
 ,*
 ,* A single static vnode can contain stringified content for **multiple**
 ,* consecutive nodes (element and plain text), called a "chunk".
 ,* `@vue/runtime-dom` will create the content via innerHTML in a hidden
 ,* container element and insert all the nodes in place. The call must also
 ,* provide the number of nodes contained in the chunk so that during hydration
 ,* we can know how many nodes the static vnode should adopt.
 ,*
 ,* The optimization scans a children list that contains hoisted nodes, and
 ,* tries to find the largest chunk of consecutive hoisted nodes before running
 ,* into a non-hoisted node or the end of the list. A chunk is then converted
 ,* into a single static vnode and replaces the hoisted expression of the first
 ,* node in the chunk. Other nodes in the chunk are considered "merged" and
 ,* therefore removed from both the hoist list and the children array.
 ,*
 ,* This optimization is only performed in Node.js.
 ,*/
const stringifyStatic = (children, context, parent) => {
  // bail stringification for slot content
  if (context.scopes.vSlot > 0) {
    return
  }

  let nc = 0 // current node count
  let ec = 0 // current element with binding count
  const currentChunk = []

  logg(`stringifyStatic - children.length = ${children.length}`)
  const stringifyCurrentChunk = (currentIndex) => {
    if (
      nc >= StringifyThresholds.NODE_COUNT ||
      ec >= StringifyThresholds.ELEMENT_WITH_BINDING_COUNT
    ) {
      logg(`stringifyCurrentChunk - index = ${currentIndex}`)
      // combine all currently eligible nodes into a single static vnode call
      const staticCall = createCallExpression(context.helper(CREATE_STATIC), [
        JSON.stringify(
          currentChunk.map(node => stringifyNode(node, context)).join('')
        ).replace(expReplaceRE, `" + $1 + "`),
        // the 2nd argument indicates the number of DOM nodes this static vnode
        // will insert / hydrate
        String(currentChunk.length)
      ])
      // replace the first node's hoisted expression with the static vnode call
      replaceHoist(currentChunk[0], staticCall, context)

      if (currentChunk.length > 1) {
        for (let i = 1; i < currentChunk.length; i++) {
          // for the merged nodes, set their hoisted expression to null
          replaceHoist(currentChunk[i], null, context)
        }

        // also remove merged nodes from children
        const deleteCount = currentChunk.length - 1
        children.splice(currentIndex - currentChunk.length + 1, deleteCount)
        return deleteCount
      }
    }
    return 0
  }

  let i = 0
  for (; i < children.length; i++) {
    const child = children[i]
    const hoisted = getHoistedNode(child)
    if (hoisted) {
      // presence of hoisted means child must be a stringifiable node
      const node = child
      const result = analyzeNode(node)
      if (result) {
        // node is stringifiable, record state
        nc += result[0]
        ec += result[1]
        currentChunk.push(node)
        continue
      }
    }
    // we only reach here if we ran into a node that is not stringifiable
    // check if currently analyzed nodes meet criteria for stringification.
    // adjust iteration index
    i -= stringifyCurrentChunk(i)
    // reset state
    nc = 0
    ec = 0
    currentChunk.length = 0
  }
  // in case the last node was also stringifiable
  stringifyCurrentChunk(i)
}

const getHoistedNode = (node) =>
  ((node.type === NodeTypes.ELEMENT && node.tagType === ElementTypes.ELEMENT) ||
    node.type == NodeTypes.TEXT_CALL) &&
  node.codegenNode &&
  node.codegenNode.type === NodeTypes.SIMPLE_EXPRESSION &&
  node.codegenNode.hoisted

const dataAriaRE = /^(data|aria)-/
const isStringifiableAttr = (name, ns) => {
  return (
    (ns === DOMNamespaces.HTML
      ? isKnownHtmlAttr(name)
      : ns === DOMNamespaces.SVG
      ? isKnownSvgAttr(name)
      : false) || dataAriaRE.test(name)
  )
}

const replaceHoist = (node,replacement,context) => {
  const hoistToReplace = node.codegenNode.hoisted
  context.hoists[context.hoists.indexOf(hoistToReplace)] = replacement
}

const isNonStringifiable = /*#__PURE__*/ makeMap(
  `caption,thead,tr,th,tbody,td,tfoot,colgroup,col`
)

/**
 ,* for a hoisted node, analyze it and return:
 ,* - false: bailed (contains non-stringifiable props or runtime constant)
 ,* - [nc, ec] where
 ,*   - nc is the number of nodes inside
 ,*   - ec is the number of element with bindings inside
 ,*/
function analyzeNode(node) {
  if (node.type === NodeTypes.ELEMENT && isNonStringifiable(node.tag)) {
    return false
  }

  if (node.type === NodeTypes.TEXT_CALL) {
    return [1, 0]
  }

  let nc = 1 // node count
  let ec = node.props.length > 0 ? 1 : 0 // element w/ binding count
  let bailed = false
  const bail = () => {
    bailed = true
    return false
  }

  // TODO: check for cases where using innerHTML will result in different
  // output compared to imperative node insertions.
  // probably only need to check for most common case
  // i.e. non-phrasing-content tags inside `<p>`
  function walk(node) {
    for (let i = 0; i < node.props.length; i++) {
      const p = node.props[i]
      // bail on non-attr bindings
      if (
        p.type === NodeTypes.ATTRIBUTE &&
        !isStringifiableAttr(p.name, node.ns)
      ) {
        return bail()
      }
      if (p.type === NodeTypes.DIRECTIVE && p.name === 'bind') {
        // bail on non-attr bindings
        if (
          p.arg &&
          (p.arg.type === NodeTypes.COMPOUND_EXPRESSION ||
            (p.arg.isStatic && !isStringifiableAttr(p.arg.content, node.ns)))
        ) {
          return bail()
        }
        if (
          p.exp &&
          (p.exp.type === NodeTypes.COMPOUND_EXPRESSION ||
            p.exp.constType < ConstantTypes.CAN_STRINGIFY)
        ) {
          return bail()
        }
      }
    }
    for (let i = 0; i < node.children.length; i++) {
      nc++
      const child = node.children[i]
      if (child.type === NodeTypes.ELEMENT) {
        if (child.props.length > 0) {
          ec++
        }
        walk(child)
        if (bailed) {
          return false
        }
      }
    }
    return true
  }

  return walk(node) ? [nc, ec] : false
}

function stringifyNode(node, context) {
  if (isString(node)) {
    return node
  }
  if (isSymbol(node)) {
    return ``
  }
  switch (node.type) {
    case NodeTypes.ELEMENT:
      return stringifyElement(node, context)
    case NodeTypes.TEXT:
      return escapeHtml(node.content)
    case NodeTypes.COMMENT:
      return `<!--${escapeHtml(node.content)}-->`
    case NodeTypes.INTERPOLATION:
      return escapeHtml(toDisplayString(evaluateConstant(node.content)))
    case NodeTypes.COMPOUND_EXPRESSION:
      return escapeHtml(evaluateConstant(node))
    case NodeTypes.TEXT_CALL:
      return stringifyNode(node.content, context)
    default:
      // static trees will not contain if/for nodes
      return ''
  }
}

function stringifyElement(node, context) {
  let res = `<${node.tag}`
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i]
    if (p.type === NodeTypes.ATTRIBUTE) {
      res += ` ${p.name}`
      if (p.value) {
        res += `="${escapeHtml(p.value.content)}"`
      }
    } else if (p.type === NodeTypes.DIRECTIVE && p.name === 'bind') {
      const exp = p.exp
      if (exp.content[0] === '_') {
        // internally generated string constant references
        // e.g. imported URL strings via compiler-sfc transformAssetUrl plugin
        res += ` ${p.arg.content}="__VUE_EXP_START__${
          exp.content
        }__VUE_EXP_END__"`
        continue
      }
      // constant v-bind, e.g. :foo="1"
      let evaluated = evaluateConstant(exp)
      if (evaluated != null) {
        const arg = p.arg && p.arg.content
        if (arg === 'class') {
          evaluated = normalizeClass(evaluated)
        } else if (arg === 'style') {
          evaluated = stringifyStyle(normalizeStyle(evaluated))
        }
        res += ` ${p.arg.content}="${escapeHtml(evaluated)}"`
      }
    }
  }
  if (context.scopeId) {
    res += ` ${context.scopeId}`
  }
  res += `>`
  for (let i = 0; i < node.children.length; i++) {
    res += stringifyNode(node.children[i], context)
  }
  if (!isVoidTag(node.tag)) {
    res += `</${node.tag}>`
  }
  return res
}

// __UNSAFE__
// Reason: eval.
// It's technically safe to eval because only constant expressions are possible
// here, e.g. `{{ 1 }}` or `{{ 'foo' }}`
// in addition, constant exps bail on presence of parens so you can't even
// run JSFuck in here. But we mark it unsafe for security review purposes.
// (see compiler-core/src/transformExpressions)
function evaluateConstant(exp) {
  if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {
    return new Function(`return ${exp.content}`)()
  } else {
    // compound
    let res = ``
    exp.children.forEach(c => {
      if (isString(c) || isSymbol(c)) {
        return
      }
      if (c.type === NodeTypes.TEXT) {
        res += c.content
      } else if (c.type === NodeTypes.INTERPOLATION) {
        res += toDisplayString(evaluateConstant(c.content))
      } else {
        res += evaluateConstant(c)
      }
    })
    return res
  }
}

#+end_src

red:Testing

#+name: stringifyStatic-test-utils
#+begin_src js -n -r
<<compiler-dom>>

function compileWithStringify(template) {
    return compile(template, {
      hoistStatic: true,
      prefixIdentifiers: true,
      transformHoist: stringifyStatic
    })
  }

  function repeat(code, n) {
    return new Array(n)
      .fill(0)
      .map(() => code)
      .join('')
  }
#+end_src

#+html: <br>
#+begin_details should bail on non-eligible static trees :title-color red
#+begin_src js -n -r :exports both
<<stringifyStatic-test-utils>>

logOff()
const { ast, code } = compileWithStringify(
  `<div><div><div>hello</div><div>hello</div></div></div>`
)
logOn()
logg('ast hoists', ast.hoists)
logg('code', code)
#+end_src
#+end_details

#+html: <br>
#+begin_details should work on eligible content (elements with binding > 5) :title-color red
#+begin_src js -n -r :exports both
<<stringifyStatic-test-utils>>

logOff()
const { ast, code } = compileWithStringify(
  `<div><div>${repeat(
        `<span class="foo"/>`,
        StringifyThresholds.ELEMENT_WITH_BINDING_COUNT
      )}</div></div><div></div>`
  //`<div><div><div>hello</div><div>hello</div></div></div>`
)
logOn()
logg('ast hoists', ast.hoists)
logg('code', code)
#+end_src
#+end_details

#+html: <br>
#+begin_details should work on eligible content (elements > 20) :title-color red
#+begin_src js -n -r :exports both
<<stringifyStatic-test-utils>>

logOff()
const { ast, code } = compileWithStringify(
  `<div><div>${repeat(
        `<span/>`,
        StringifyThresholds.NODE_COUNT
      )}</div></div>`
)
logOn()
logg('ast hoists', ast.hoists)
logg('code', code)
#+end_src
#+end_details

#+html: <br>
#+begin_details serializing constant bindings :title-color red
#+begin_src js -n -r :exports both
<<stringifyStatic-test-utils>>

logOff()
const { ast, code } = compileWithStringify(
  `<div><div :style="{ color: 'red' }">${repeat(
        `<span :class="[{ foo: true }, { bar: true }]">{{ 1 }} + {{ false }}</span>`,
        StringifyThresholds.ELEMENT_WITH_BINDING_COUNT
      )}</div></div>`
)
logOn()
logg('ast hoists', ast.hoists)
logg('code', code)
#+end_src
#+end_details

createStaticVNode:

#+begin_src typescript -n -r
function createStaticVNode(
  content: string,
  numberOfNodes: number
): VNode {
  // A static vnode can contain multiple stringified elements, and the number
  // of elements is necessary for hydration.
  const vnode = createVNode(Static, null, content)
  vnode.staticCount = numberOfNodes
  return vnode
}
#+end_src

* compile()

#+name: compile
#+begin_src js -n -r
function compile(template, options = {}) {
  return baseCompile(
    template,
    extend({}, parserOptions, options, {
      nodeTransforms: [
        // ignore <script> and <tag>
        // this is not put inside DOMNodeTransforms because that list is used
        // by compiler-ssr to generate vnode fallback branches
        ignoreSideEffectTags,
        ...DOMNodeTransforms,
        ...(options.nodeTransforms || [])
      ],
      directiveTransforms: extend(
        {},
        DOMDirectiveTransforms,
        options.directiveTransforms || {}
      ),
      transformHoist: __BROWSER__ ? null : stringifyStatic
    })
  )
}
#+end_src
* parse

#+name: parse
#+begin_src js -n -r
function parse(template, options = {}) {
  return baseParse(template, extend({}, parserOptions, options))
}
#+end_src
* testing

更多测试([[https://github.com/vuejs/core/blob/main/packages/compiler-dom/__tests__/transforms/stringifyStatic.spec.ts][core/stringifyStatic.spec.ts at main · vuejs/core]])：

#+name: testing
#+begin_export html
<script src="/assets/tests/compiler-core.js"></script>
<script src="/assets/tests/compiler-dom.js"></script>
<div id="h1Mvr33k"></div>
<script src="/assets/js/vue-json-viewer/index.js"></script>
<script src="/assets/tests/h1Mvr33k.js"></script>
#+end_export

* Global Variables

#+html: <br>
#+begin_details global variables :title-color green
#+name: globalVars
#+begin_src js -n -r
<<namedChars>>
<<helpers-cd>>
<<dom-attrs>>
<<html-tags>>
<<normalizeProp>>
<<escapeHtml>>
<<toDisplayString>>

const noopDirectiveTransform = () => ({ props: [] })

const isRawTextContainer = /*#__PURE__*/ makeMap(
  'style,iframe,script,noscript',
  true
)

const DOMNamespaces = {
  HTML: Namespaces.HTML,
  SVG: 1,
  MATH_ML: 2
}

const parserOptions = {
  isVoidTag,
  isNativeTag: tag => isHTMLTag(tag) || isSVGTag(tag),
  isPreTag: tag => tag === 'pre',
  decodeEntities: __BROWSER__ ? decodeHtmlBrowser : decodeHtml,

  isBuiltInComponent: tag => {
    if (isBuiltInType(tag, `Transition`)) {
      return TRANSITION
    } else if (isBuiltInType(tag, `TransitionGroup`)) {
      return TRANSITION_GROUP
    }
  },

  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
  getNamespace(tag, parent) {
    let ns = parent ? parent.ns : DOMNamespaces.HTML

    if (parent && ns === DOMNamespaces.MATH_ML) {
      if (parent.tag === 'annotation-xml') {
        if (tag === 'svg') {
          return DOMNamespaces.SVG
        }
        if (
          parent.props.some(
            a =>
              a.type === NodeTypes.ATTRIBUTE &&
              a.name === 'encoding' &&
              a.value != null &&
              (a.value.content === 'text/html' ||
                a.value.content === 'application/xhtml+xml')
          )
        ) {
          ns = DOMNamespaces.HTML
        }
      } else if (
        /^m(?:[ions]|text)$/.test(parent.tag) &&
        tag !== 'mglyph' &&
        tag !== 'malignmark'
      ) {
        ns = DOMNamespaces.HTML
      }
    } else if (parent && ns === DOMNamespaces.SVG) {
      if (
        parent.tag === 'foreignObject' ||
        parent.tag === 'desc' ||
        parent.tag === 'title'
      ) {
        ns = DOMNamespaces.HTML
      }
    }

    if (ns === DOMNamespaces.HTML) {
      if (tag === 'svg') {
        return DOMNamespaces.SVG
      }
      if (tag === 'math') {
        return DOMNamespaces.MATH_ML
      }
    }
    return ns
  },

  // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
  getTextMode({ tag, ns }) {
    if (ns === DOMNamespaces.HTML) {
      if (tag === 'textarea' || tag === 'title') {
        return TextModes.RCDATA
      }
      if (isRawTextContainer(tag)) {
        return TextModes.RAWTEXT
      }
    }
    return TextModes.DATA
  }
}

function hasDynamicKeyVBind(node) {
  return node.props.some(
    p =>
      p.type === NodeTypes.DIRECTIVE &&
      p.name === 'bind' &&
      (!p.arg || // v-bind="obj"
        p.arg.type !== NodeTypes.SIMPLE_EXPRESSION || // v-bind:[_ctx.foo]
        !p.arg.isStatic) // v-bind:[foo]
  )
}


function hasMultipleChildren(node) {
  // #1352 filter out potential comment nodes.
  const children = (node.children = node.children.filter(
    c =>
      c.type !== NodeTypes.COMMENT &&
      !(c.type === NodeTypes.TEXT && !c.content.trim())
  ))
  const child = children[0]
  return (
    children.length !== 1 ||
    child.type === NodeTypes.FOR ||
    (child.type === NodeTypes.IF && child.branches.some(hasMultipleChildren))
  )
}

const warnTransitionChildren = (node, context) => {
  if (
    node.type === NodeTypes.ELEMENT &&
    node.tagType === ElementTypes.COMPONENT
  ) {
    const component = context.isBuiltInComponent(node.tag)
    if (component === TRANSITION) {
      return () => {
        if (node.children.length && hasMultipleChildren(node)) {
          console.warn(`X_TRANSITION_INVALID_CHILDREN`, node)
        }
      }
    }
  }
}


const ignoreSideEffectTags = (node, context) => {
  if (
    node.type === NodeTypes.ELEMENT &&
    node.tagType === ElementTypes.ELEMENT &&
    (node.tag === 'script' || node.tag === 'style')
  ) {
    console.warn(`X_IGNORED_SIDE_EFFECT_TAG`)
    context.removeNode()
  }
}
#+end_src
#+end_details

#+html: <br>
#+begin_details html-tags :title-color green
#+name: html-tags
#+begin_src js -n -r
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element
const HTML_TAGS =
  'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +
  'header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +
  'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +
  'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +
  'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +
  'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +
  'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +
  'option,output,progress,select,textarea,details,dialog,menu,' +
  'summary,template,blockquote,iframe,tfoot'

// https://developer.mozilla.org/en-US/docs/Web/SVG/Element
const SVG_TAGS =
  'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +
  'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +
  'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +
  'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +
  'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +
  'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +
  'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +
  'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +
  'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +
  'text,textPath,title,tspan,unknown,use,view'

const VOID_TAGS =
  'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr'

const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS)
/**
 ,* Compiler only.
 ,* Do NOT use in runtime code paths unless behind `__DEV__` flag.
 ,*/
const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS)
const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS)

#+end_src
#+end_details

#+html: <br>
#+begin_details helpers-cd :title-color  green
#+name: helpers-cd
#+begin_src js -n -r

const V_MODEL_RADIO = Symbol(__DEV__ ? `vModelRadio` : ``)
const V_MODEL_CHECKBOX = Symbol(__DEV__ ? `vModelCheckbox` : ``)
const V_MODEL_TEXT = Symbol(__DEV__ ? `vModelText` : ``)
const V_MODEL_SELECT = Symbol(__DEV__ ? `vModelSelect` : ``)
const V_MODEL_DYNAMIC = Symbol(__DEV__ ? `vModelDynamic` : ``)

const V_ON_WITH_MODIFIERS = Symbol(__DEV__ ? `vOnModifiersGuard` : ``)
const V_ON_WITH_KEYS = Symbol(__DEV__ ? `vOnKeysGuard` : ``)

const V_SHOW = Symbol(__DEV__ ? `vShow` : ``)

const TRANSITION = Symbol(__DEV__ ? `Transition` : ``)
const TRANSITION_GROUP = Symbol(__DEV__ ? `TransitionGroup` : ``)

registerRuntimeHelpers({
  [V_MODEL_RADIO]: `vModelRadio`,
  [V_MODEL_CHECKBOX]: `vModelCheckbox`,
  [V_MODEL_TEXT]: `vModelText`,
  [V_MODEL_SELECT]: `vModelSelect`,
  [V_MODEL_DYNAMIC]: `vModelDynamic`,
  [V_ON_WITH_MODIFIERS]: `withModifiers`,
  [V_ON_WITH_KEYS]: `withKeys`,
  [V_SHOW]: `vShow`,
  [TRANSITION]: `Transition`,
  [TRANSITION_GROUP]: `TransitionGroup`
})
#+end_src
#+end_details

#+html: <br>
#+begin_details namedChars :title-color green
#+name: namedChars
#+begin_src js -n -r
const namedCharacterReferences = {
  "GT": ">",
  "gt": ">",
  "LT": "<",
  "lt": "<",
  "ac;": "∾",
  "af;": "⁡",
  "AMP": "&",
  "amp": "&",
  "ap;": "≈",
  "DD;": "ⅅ",
  "dd;": "ⅆ",
  "deg": "°",
  "ee;": "ⅇ",
  "eg;": "⪚",
  "el;": "⪙",
  "ETH": "Ð",
  "eth": "ð",
  "gE;": "≧",
  "ge;": "≥",
  "Gg;": "⋙",
  "gg;": "≫",
  "gl;": "≷",
  "GT;": ">",
  "Gt;": "≫",
  "gt;": ">",
  "ic;": "⁣",
  "ii;": "ⅈ",
  "Im;": "ℑ",
  "in;": "∈",
  "it;": "⁢",
  "lE;": "≦",
  "le;": "≤",
  "lg;": "≶",
  "Ll;": "⋘",
  "ll;": "≪",
  "LT;": "<",
  "Lt;": "≪",
  "lt;": "<",
  "mp;": "∓",
  "Mu;": "Μ",
  "mu;": "μ",
  "ne;": "≠",
  "ni;": "∋",
  "not": "¬",
  "Nu;": "Ν",
  "nu;": "ν",
  "Or;": "⩔",
  "or;": "∨",
  "oS;": "Ⓢ",
  "Pi;": "Π",
  "pi;": "π",
  "pm;": "±",
  "Pr;": "⪻",
  "pr;": "≺",
  "Re;": "ℜ",
  "REG": "®",
  "reg": "®",
  "rx;": "℞",
  "Sc;": "⪼",
  "sc;": "≻",
  "shy": "­",
  "uml": "¨",
  "wp;": "℘",
  "wr;": "≀",
  "Xi;": "Ξ",
  "xi;": "ξ",
  "yen": "¥",
  "acd;": "∿",
  "acE;": "∾̳",
  "Acy;": "А",
  "acy;": "а",
  "Afr;": "𝔄",
  "afr;": "𝔞",
  "AMP;": "&",
  "amp;": "&",
  "And;": "⩓",
  "and;": "∧",
  "ang;": "∠",
  "apE;": "⩰",
  "ape;": "≊",
  "ast;": "*",
  "Auml": "Ä",
  "auml": "ä",
  "Bcy;": "Б",
  "bcy;": "б",
  "Bfr;": "𝔅",
  "bfr;": "𝔟",
  "bne;": "=⃥",
  "bot;": "⊥",
  "Cap;": "⋒",
  "cap;": "∩",
  "cent": "¢",
  "Cfr;": "ℭ",
  "cfr;": "𝔠",
  "Chi;": "Χ",
  "chi;": "χ",
  "cir;": "○",
  "COPY": "©",
  "copy": "©",
  "Cup;": "⋓",
  "cup;": "∪",
  "Dcy;": "Д",
  "dcy;": "д",
  "deg;": "°",
  "Del;": "∇",
  "Dfr;": "𝔇",
  "dfr;": "𝔡",
  "die;": "¨",
  "div;": "÷",
  "Dot;": "¨",
  "dot;": "˙",
  "Ecy;": "Э",
  "ecy;": "э",
  "Efr;": "𝔈",
  "efr;": "𝔢",
  "egs;": "⪖",
  "ell;": "ℓ",
  "els;": "⪕",
  "ENG;": "Ŋ",
  "eng;": "ŋ",
  "Eta;": "Η",
  "eta;": "η",
  "ETH;": "Ð",
  "eth;": "ð",
  "Euml": "Ë",
  "euml": "ë",
  "Fcy;": "Ф",
  "fcy;": "ф",
  "Ffr;": "𝔉",
  "ffr;": "𝔣",
  "gap;": "⪆",
  "Gcy;": "Г",
  "gcy;": "г",
  "gEl;": "⪌",
  "gel;": "⋛",
  "geq;": "≥",
  "ges;": "⩾",
  "Gfr;": "𝔊",
  "gfr;": "𝔤",
  "ggg;": "⋙",
  "gla;": "⪥",
  "glE;": "⪒",
  "glj;": "⪤",
  "gnE;": "≩",
  "gne;": "⪈",
  "Hat;": "^",
  "Hfr;": "ℌ",
  "hfr;": "𝔥",
  "Icy;": "И",
  "icy;": "и",
  "iff;": "⇔",
  "Ifr;": "ℑ",
  "ifr;": "𝔦",
  "Int;": "∬",
  "int;": "∫",
  "Iuml": "Ï",
  "iuml": "ï",
  "Jcy;": "Й",
  "jcy;": "й",
  "Jfr;": "𝔍",
  "jfr;": "𝔧",
  "Kcy;": "К",
  "kcy;": "к",
  "Kfr;": "𝔎",
  "kfr;": "𝔨",
  "lap;": "⪅",
  "lat;": "⪫",
  "Lcy;": "Л",
  "lcy;": "л",
  "lEg;": "⪋",
  "leg;": "⋚",
  "leq;": "≤",
  "les;": "⩽",
  "Lfr;": "𝔏",
  "lfr;": "𝔩",
  "lgE;": "⪑",
  "lnE;": "≨",
  "lne;": "⪇",
  "loz;": "◊",
  "lrm;": "‎",
  "Lsh;": "↰",
  "lsh;": "↰",
  "macr": "¯",
  "Map;": "⤅",
  "map;": "↦",
  "Mcy;": "М",
  "mcy;": "м",
  "Mfr;": "𝔐",
  "mfr;": "𝔪",
  "mho;": "℧",
  "mid;": "∣",
  "nap;": "≉",
  "nbsp": " ",
  "Ncy;": "Н",
  "ncy;": "н",
  "Nfr;": "𝔑",
  "nfr;": "𝔫",
  "ngE;": "≧̸",
  "nge;": "≱",
  "nGg;": "⋙̸",
  "nGt;": "≫⃒",
  "ngt;": "≯",
  "nis;": "⋼",
  "niv;": "∋",
  "nlE;": "≦̸",
  "nle;": "≰",
  "nLl;": "⋘̸",
  "nLt;": "≪⃒",
  "nlt;": "≮",
  "Not;": "⫬",
  "not;": "¬",
  "npr;": "⊀",
  "nsc;": "⊁",
  "num;": "#",
  "Ocy;": "О",
  "ocy;": "о",
  "Ofr;": "𝔒",
  "ofr;": "𝔬",
  "ogt;": "⧁",
  "ohm;": "Ω",
  "olt;": "⧀",
  "ord;": "⩝",
  "ordf": "ª",
  "ordm": "º",
  "orv;": "⩛",
  "Ouml": "Ö",
  "ouml": "ö",
  "par;": "∥",
  "para": "¶",
  "Pcy;": "П",
  "pcy;": "п",
  "Pfr;": "𝔓",
  "pfr;": "𝔭",
  "Phi;": "Φ",
  "phi;": "φ",
  "piv;": "ϖ",
  "prE;": "⪳",
  "pre;": "⪯",
  "Psi;": "Ψ",
  "psi;": "ψ",
  "Qfr;": "𝔔",
  "qfr;": "𝔮",
  "QUOT": "\"",
  "quot": "\"",
  "Rcy;": "Р",
  "rcy;": "р",
  "REG;": "®",
  "reg;": "®",
  "Rfr;": "ℜ",
  "rfr;": "𝔯",
  "Rho;": "Ρ",
  "rho;": "ρ",
  "rlm;": "‏",
  "Rsh;": "↱",
  "rsh;": "↱",
  "scE;": "⪴",
  "sce;": "⪰",
  "Scy;": "С",
  "scy;": "с",
  "sect": "§",
  "Sfr;": "𝔖",
  "sfr;": "𝔰",
  "shy;": "­",
  "sim;": "∼",
  "smt;": "⪪",
  "sol;": "/",
  "squ;": "□",
  "Sub;": "⋐",
  "sub;": "⊂",
  "Sum;": "∑",
  "sum;": "∑",
  "Sup;": "⋑",
  "sup;": "⊃",
  "sup1": "¹",
  "sup2": "²",
  "sup3": "³",
  "Tab;": "\t",
  "Tau;": "Τ",
  "tau;": "τ",
  "Tcy;": "Т",
  "tcy;": "т",
  "Tfr;": "𝔗",
  "tfr;": "𝔱",
  "top;": "⊤",
  "Ucy;": "У",
  "ucy;": "у",
  "Ufr;": "𝔘",
  "ufr;": "𝔲",
  "uml;": "¨",
  "Uuml": "Ü",
  "uuml": "ü",
  "Vcy;": "В",
  "vcy;": "в",
  "Vee;": "⋁",
  "vee;": "∨",
  "Vfr;": "𝔙",
  "vfr;": "𝔳",
  "Wfr;": "𝔚",
  "wfr;": "𝔴",
  "Xfr;": "𝔛",
  "xfr;": "𝔵",
  "Ycy;": "Ы",
  "ycy;": "ы",
  "yen;": "¥",
  "Yfr;": "𝔜",
  "yfr;": "𝔶",
  "yuml": "ÿ",
  "Zcy;": "З",
  "zcy;": "з",
  "Zfr;": "ℨ",
  "zfr;": "𝔷",
  "zwj;": "‍",
  "Acirc": "Â",
  "acirc": "â",
  "acute": "´",
  "AElig": "Æ",
  "aelig": "æ",
  "andd;": "⩜",
  "andv;": "⩚",
  "ange;": "⦤",
  "Aopf;": "𝔸",
  "aopf;": "𝕒",
  "apid;": "≋",
  "apos;": "'",
  "Aring": "Å",
  "aring": "å",
  "Ascr;": "𝒜",
  "ascr;": "𝒶",
  "Auml;": "Ä",
  "auml;": "ä",
  "Barv;": "⫧",
  "bbrk;": "⎵",
  "Beta;": "Β",
  "beta;": "β",
  "beth;": "ℶ",
  "bNot;": "⫭",
  "bnot;": "⌐",
  "Bopf;": "𝔹",
  "bopf;": "𝕓",
  "boxH;": "═",
  "boxh;": "─",
  "boxV;": "║",
  "boxv;": "│",
  "Bscr;": "ℬ",
  "bscr;": "𝒷",
  "bsim;": "∽",
  "bsol;": "\\",
  "bull;": "•",
  "bump;": "≎",
  "caps;": "∩︀",
  "Cdot;": "Ċ",
  "cdot;": "ċ",
  "cedil": "¸",
  "cent;": "¢",
  "CHcy;": "Ч",
  "chcy;": "ч",
  "circ;": "ˆ",
  "cirE;": "⧃",
  "cire;": "≗",
  "comp;": "∁",
  "cong;": "≅",
  "Copf;": "ℂ",
  "copf;": "𝕔",
  "COPY;": "©",
  "copy;": "©",
  "Cscr;": "𝒞",
  "cscr;": "𝒸",
  "csub;": "⫏",
  "csup;": "⫐",
  "cups;": "∪︀",
  "Darr;": "↡",
  "dArr;": "⇓",
  "darr;": "↓",
  "dash;": "‐",
  "dHar;": "⥥",
  "diam;": "⋄",
  "DJcy;": "Ђ",
  "djcy;": "ђ",
  "Dopf;": "𝔻",
  "dopf;": "𝕕",
  "Dscr;": "𝒟",
  "dscr;": "𝒹",
  "DScy;": "Ѕ",
  "dscy;": "ѕ",
  "dsol;": "⧶",
  "dtri;": "▿",
  "DZcy;": "Џ",
  "dzcy;": "џ",
  "ecir;": "≖",
  "Ecirc": "Ê",
  "ecirc": "ê",
  "Edot;": "Ė",
  "eDot;": "≑",
  "edot;": "ė",
  "emsp;": " ",
  "ensp;": " ",
  "Eopf;": "𝔼",
  "eopf;": "𝕖",
  "epar;": "⋕",
  "epsi;": "ε",
  "Escr;": "ℰ",
  "escr;": "ℯ",
  "Esim;": "⩳",
  "esim;": "≂",
  "Euml;": "Ë",
  "euml;": "ë",
  "euro;": "€",
  "excl;": "!",
  "flat;": "♭",
  "fnof;": "ƒ",
  "Fopf;": "𝔽",
  "fopf;": "𝕗",
  "fork;": "⋔",
  "Fscr;": "ℱ",
  "fscr;": "𝒻",
  "Gdot;": "Ġ",
  "gdot;": "ġ",
  "geqq;": "≧",
  "gesl;": "⋛︀",
  "GJcy;": "Ѓ",
  "gjcy;": "ѓ",
  "gnap;": "⪊",
  "gneq;": "⪈",
  "Gopf;": "𝔾",
  "gopf;": "𝕘",
  "Gscr;": "𝒢",
  "gscr;": "ℊ",
  "gsim;": "≳",
  "gtcc;": "⪧",
  "gvnE;": "≩︀",
  "half;": "½",
  "hArr;": "⇔",
  "harr;": "↔",
  "hbar;": "ℏ",
  "Hopf;": "ℍ",
  "hopf;": "𝕙",
  "Hscr;": "ℋ",
  "hscr;": "𝒽",
  "Icirc": "Î",
  "icirc": "î",
  "Idot;": "İ",
  "IEcy;": "Е",
  "iecy;": "е",
  "iexcl": "¡",
  "imof;": "⊷",
  "IOcy;": "Ё",
  "iocy;": "ё",
  "Iopf;": "𝕀",
  "iopf;": "𝕚",
  "Iota;": "Ι",
  "iota;": "ι",
  "Iscr;": "ℐ",
  "iscr;": "𝒾",
  "isin;": "∈",
  "Iuml;": "Ï",
  "iuml;": "ï",
  "Jopf;": "𝕁",
  "jopf;": "𝕛",
  "Jscr;": "𝒥",
  "jscr;": "𝒿",
  "KHcy;": "Х",
  "khcy;": "х",
  "KJcy;": "Ќ",
  "kjcy;": "ќ",
  "Kopf;": "𝕂",
  "kopf;": "𝕜",
  "Kscr;": "𝒦",
  "kscr;": "𝓀",
  "Lang;": "⟪",
  "lang;": "⟨",
  "laquo": "«",
  "Larr;": "↞",
  "lArr;": "⇐",
  "larr;": "←",
  "late;": "⪭",
  "lcub;": "{",
  "ldca;": "⤶",
  "ldsh;": "↲",
  "leqq;": "≦",
  "lesg;": "⋚︀",
  "lHar;": "⥢",
  "LJcy;": "Љ",
  "ljcy;": "љ",
  "lnap;": "⪉",
  "lneq;": "⪇",
  "Lopf;": "𝕃",
  "lopf;": "𝕝",
  "lozf;": "⧫",
  "lpar;": "(",
  "Lscr;": "ℒ",
  "lscr;": "𝓁",
  "lsim;": "≲",
  "lsqb;": "[",
  "ltcc;": "⪦",
  "ltri;": "◃",
  "lvnE;": "≨︀",
  "macr;": "¯",
  "male;": "♂",
  "malt;": "✠",
  "micro": "µ",
  "mlcp;": "⫛",
  "mldr;": "…",
  "Mopf;": "𝕄",
  "mopf;": "𝕞",
  "Mscr;": "ℳ",
  "mscr;": "𝓂",
  "nang;": "∠⃒",
  "napE;": "⩰̸",
  "nbsp;": " ",
  "ncap;": "⩃",
  "ncup;": "⩂",
  "ngeq;": "≱",
  "nges;": "⩾̸",
  "ngtr;": "≯",
  "nGtv;": "≫̸",
  "nisd;": "⋺",
  "NJcy;": "Њ",
  "njcy;": "њ",
  "nldr;": "‥",
  "nleq;": "≰",
  "nles;": "⩽̸",
  "nLtv;": "≪̸",
  "nmid;": "∤",
  "Nopf;": "ℕ",
  "nopf;": "𝕟",
  "npar;": "∦",
  "npre;": "⪯̸",
  "nsce;": "⪰̸",
  "Nscr;": "𝒩",
  "nscr;": "𝓃",
  "nsim;": "≁",
  "nsub;": "⊄",
  "nsup;": "⊅",
  "ntgl;": "≹",
  "ntlg;": "≸",
  "nvap;": "≍⃒",
  "nvge;": "≥⃒",
  "nvgt;": ">⃒",
  "nvle;": "≤⃒",
  "nvlt;": "<⃒",
  "oast;": "⊛",
  "ocir;": "⊚",
  "Ocirc": "Ô",
  "ocirc": "ô",
  "odiv;": "⨸",
  "odot;": "⊙",
  "ogon;": "˛",
  "oint;": "∮",
  "omid;": "⦶",
  "Oopf;": "𝕆",
  "oopf;": "𝕠",
  "opar;": "⦷",
  "ordf;": "ª",
  "ordm;": "º",
  "oror;": "⩖",
  "Oscr;": "𝒪",
  "oscr;": "ℴ",
  "osol;": "⊘",
  "Ouml;": "Ö",
  "ouml;": "ö",
  "para;": "¶",
  "part;": "∂",
  "perp;": "⊥",
  "phiv;": "ϕ",
  "plus;": "+",
  "Popf;": "ℙ",
  "popf;": "𝕡",
  "pound": "£",
  "prap;": "⪷",
  "prec;": "≺",
  "prnE;": "⪵",
  "prod;": "∏",
  "prop;": "∝",
  "Pscr;": "𝒫",
  "pscr;": "𝓅",
  "qint;": "⨌",
  "Qopf;": "ℚ",
  "qopf;": "𝕢",
  "Qscr;": "𝒬",
  "qscr;": "𝓆",
  "QUOT;": "\"",
  "quot;": "\"",
  "race;": "∽̱",
  "Rang;": "⟫",
  "rang;": "⟩",
  "raquo": "»",
  "Rarr;": "↠",
  "rArr;": "⇒",
  "rarr;": "→",
  "rcub;": "}",
  "rdca;": "⤷",
  "rdsh;": "↳",
  "real;": "ℜ",
  "rect;": "▭",
  "rHar;": "⥤",
  "rhov;": "ϱ",
  "ring;": "˚",
  "Ropf;": "ℝ",
  "ropf;": "𝕣",
  "rpar;": ")",
  "Rscr;": "ℛ",
  "rscr;": "𝓇",
  "rsqb;": "]",
  "rtri;": "▹",
  "scap;": "⪸",
  "scnE;": "⪶",
  "sdot;": "⋅",
  "sect;": "§",
  "semi;": ";",
  "sext;": "✶",
  "SHcy;": "Ш",
  "shcy;": "ш",
  "sime;": "≃",
  "simg;": "⪞",
  "siml;": "⪝",
  "smid;": "∣",
  "smte;": "⪬",
  "solb;": "⧄",
  "Sopf;": "𝕊",
  "sopf;": "𝕤",
  "spar;": "∥",
  "Sqrt;": "√",
  "squf;": "▪",
  "Sscr;": "𝒮",
  "sscr;": "𝓈",
  "Star;": "⋆",
  "star;": "☆",
  "subE;": "⫅",
  "sube;": "⊆",
  "succ;": "≻",
  "sung;": "♪",
  "sup1;": "¹",
  "sup2;": "²",
  "sup3;": "³",
  "supE;": "⫆",
  "supe;": "⊇",
  "szlig": "ß",
  "tbrk;": "⎴",
  "tdot;": "⃛",
  "THORN": "Þ",
  "thorn": "þ",
  "times": "×",
  "tint;": "∭",
  "toea;": "⤨",
  "Topf;": "𝕋",
  "topf;": "𝕥",
  "tosa;": "⤩",
  "trie;": "≜",
  "Tscr;": "𝒯",
  "tscr;": "𝓉",
  "TScy;": "Ц",
  "tscy;": "ц",
  "Uarr;": "↟",
  "uArr;": "⇑",
  "uarr;": "↑",
  "Ucirc": "Û",
  "ucirc": "û",
  "uHar;": "⥣",
  "Uopf;": "𝕌",
  "uopf;": "𝕦",
  "Upsi;": "ϒ",
  "upsi;": "υ",
  "Uscr;": "𝒰",
  "uscr;": "𝓊",
  "utri;": "▵",
  "Uuml;": "Ü",
  "uuml;": "ü",
  "vArr;": "⇕",
  "varr;": "↕",
  "Vbar;": "⫫",
  "vBar;": "⫨",
  "Vert;": "‖",
  "vert;": "|",
  "Vopf;": "𝕍",
  "vopf;": "𝕧",
  "Vscr;": "𝒱",
  "vscr;": "𝓋",
  "Wopf;": "𝕎",
  "wopf;": "𝕨",
  "Wscr;": "𝒲",
  "wscr;": "𝓌",
  "xcap;": "⋂",
  "xcup;": "⋃",
  "xmap;": "⟼",
  "xnis;": "⋻",
  "Xopf;": "𝕏",
  "xopf;": "𝕩",
  "Xscr;": "𝒳",
  "xscr;": "𝓍",
  "xvee;": "⋁",
  "YAcy;": "Я",
  "yacy;": "я",
  "YIcy;": "Ї",
  "yicy;": "ї",
  "Yopf;": "𝕐",
  "yopf;": "𝕪",
  "Yscr;": "𝒴",
  "yscr;": "𝓎",
  "YUcy;": "Ю",
  "yucy;": "ю",
  "Yuml;": "Ÿ",
  "yuml;": "ÿ",
  "Zdot;": "Ż",
  "zdot;": "ż",
  "Zeta;": "Ζ",
  "zeta;": "ζ",
  "ZHcy;": "Ж",
  "zhcy;": "ж",
  "Zopf;": "ℤ",
  "zopf;": "𝕫",
  "Zscr;": "𝒵",
  "zscr;": "𝓏",
  "zwnj;": "‌",
  "Aacute": "Á",
  "aacute": "á",
  "Acirc;": "Â",
  "acirc;": "â",
  "acute;": "´",
  "AElig;": "Æ",
  "aelig;": "æ",
  "Agrave": "À",
  "agrave": "à",
  "aleph;": "ℵ",
  "Alpha;": "Α",
  "alpha;": "α",
  "Amacr;": "Ā",
  "amacr;": "ā",
  "amalg;": "⨿",
  "angle;": "∠",
  "angrt;": "∟",
  "angst;": "Å",
  "Aogon;": "Ą",
  "aogon;": "ą",
  "Aring;": "Å",
  "aring;": "å",
  "asymp;": "≈",
  "Atilde": "Ã",
  "atilde": "ã",
  "awint;": "⨑",
  "bcong;": "≌",
  "bdquo;": "„",
  "bepsi;": "϶",
  "blank;": "␣",
  "blk12;": "▒",
  "blk14;": "░",
  "blk34;": "▓",
  "block;": "█",
  "boxDL;": "╗",
  "boxDl;": "╖",
  "boxdL;": "╕",
  "boxdl;": "┐",
  "boxDR;": "╔",
  "boxDr;": "╓",
  "boxdR;": "╒",
  "boxdr;": "┌",
  "boxHD;": "╦",
  "boxHd;": "╤",
  "boxhD;": "╥",
  "boxhd;": "┬",
  "boxHU;": "╩",
  "boxHu;": "╧",
  "boxhU;": "╨",
  "boxhu;": "┴",
  "boxUL;": "╝",
  "boxUl;": "╜",
  "boxuL;": "╛",
  "boxul;": "┘",
  "boxUR;": "╚",
  "boxUr;": "╙",
  "boxuR;": "╘",
  "boxur;": "└",
  "boxVH;": "╬",
  "boxVh;": "╫",
  "boxvH;": "╪",
  "boxvh;": "┼",
  "boxVL;": "╣",
  "boxVl;": "╢",
  "boxvL;": "╡",
  "boxvl;": "┤",
  "boxVR;": "╠",
  "boxVr;": "╟",
  "boxvR;": "╞",
  "boxvr;": "├",
  "Breve;": "˘",
  "breve;": "˘",
  "brvbar": "¦",
  "bsemi;": "⁏",
  "bsime;": "⋍",
  "bsolb;": "⧅",
  "bumpE;": "⪮",
  "bumpe;": "≏",
  "caret;": "⁁",
  "caron;": "ˇ",
  "ccaps;": "⩍",
  "Ccedil": "Ç",
  "ccedil": "ç",
  "Ccirc;": "Ĉ",
  "ccirc;": "ĉ",
  "ccups;": "⩌",
  "cedil;": "¸",
  "check;": "✓",
  "clubs;": "♣",
  "Colon;": "∷",
  "colon;": ":",
  "comma;": ",",
  "crarr;": "↵",
  "Cross;": "⨯",
  "cross;": "✗",
  "csube;": "⫑",
  "csupe;": "⫒",
  "ctdot;": "⋯",
  "cuepr;": "⋞",
  "cuesc;": "⋟",
  "cupor;": "⩅",
  "curren": "¤",
  "cuvee;": "⋎",
  "cuwed;": "⋏",
  "cwint;": "∱",
  "Dashv;": "⫤",
  "dashv;": "⊣",
  "dblac;": "˝",
  "ddarr;": "⇊",
  "Delta;": "Δ",
  "delta;": "δ",
  "dharl;": "⇃",
  "dharr;": "⇂",
  "diams;": "♦",
  "disin;": "⋲",
  "divide": "÷",
  "doteq;": "≐",
  "dtdot;": "⋱",
  "dtrif;": "▾",
  "duarr;": "⇵",
  "duhar;": "⥯",
  "Eacute": "É",
  "eacute": "é",
  "Ecirc;": "Ê",
  "ecirc;": "ê",
  "eDDot;": "⩷",
  "efDot;": "≒",
  "Egrave": "È",
  "egrave": "è",
  "Emacr;": "Ē",
  "emacr;": "ē",
  "empty;": "∅",
  "Eogon;": "Ę",
  "eogon;": "ę",
  "eplus;": "⩱",
  "epsiv;": "ϵ",
  "eqsim;": "≂",
  "Equal;": "⩵",
  "equiv;": "≡",
  "erarr;": "⥱",
  "erDot;": "≓",
  "esdot;": "≐",
  "exist;": "∃",
  "fflig;": "ﬀ",
  "filig;": "ﬁ",
  "fjlig;": "fj",
  "fllig;": "ﬂ",
  "fltns;": "▱",
  "forkv;": "⫙",
  "frac12": "½",
  "frac14": "¼",
  "frac34": "¾",
  "frasl;": "⁄",
  "frown;": "⌢",
  "Gamma;": "Γ",
  "gamma;": "γ",
  "Gcirc;": "Ĝ",
  "gcirc;": "ĝ",
  "gescc;": "⪩",
  "gimel;": "ℷ",
  "gneqq;": "≩",
  "gnsim;": "⋧",
  "grave;": "`",
  "gsime;": "⪎",
  "gsiml;": "⪐",
  "gtcir;": "⩺",
  "gtdot;": "⋗",
  "Hacek;": "ˇ",
  "harrw;": "↭",
  "Hcirc;": "Ĥ",
  "hcirc;": "ĥ",
  "hoarr;": "⇿",
  "Iacute": "Í",
  "iacute": "í",
  "Icirc;": "Î",
  "icirc;": "î",
  "iexcl;": "¡",
  "Igrave": "Ì",
  "igrave": "ì",
  "iiint;": "∭",
  "iiota;": "℩",
  "IJlig;": "Ĳ",
  "ijlig;": "ĳ",
  "Imacr;": "Ī",
  "imacr;": "ī",
  "image;": "ℑ",
  "imath;": "ı",
  "imped;": "Ƶ",
  "infin;": "∞",
  "Iogon;": "Į",
  "iogon;": "į",
  "iprod;": "⨼",
  "iquest": "¿",
  "isinE;": "⋹",
  "isins;": "⋴",
  "isinv;": "∈",
  "Iukcy;": "І",
  "iukcy;": "і",
  "Jcirc;": "Ĵ",
  "jcirc;": "ĵ",
  "jmath;": "ȷ",
  "Jukcy;": "Є",
  "jukcy;": "є",
  "Kappa;": "Κ",
  "kappa;": "κ",
  "lAarr;": "⇚",
  "langd;": "⦑",
  "laquo;": "«",
  "larrb;": "⇤",
  "lates;": "⪭︀",
  "lBarr;": "⤎",
  "lbarr;": "⤌",
  "lbbrk;": "❲",
  "lbrke;": "⦋",
  "lceil;": "⌈",
  "ldquo;": "“",
  "lescc;": "⪨",
  "lhard;": "↽",
  "lharu;": "↼",
  "lhblk;": "▄",
  "llarr;": "⇇",
  "lltri;": "◺",
  "lneqq;": "≨",
  "lnsim;": "⋦",
  "loang;": "⟬",
  "loarr;": "⇽",
  "lobrk;": "⟦",
  "lopar;": "⦅",
  "lrarr;": "⇆",
  "lrhar;": "⇋",
  "lrtri;": "⊿",
  "lsime;": "⪍",
  "lsimg;": "⪏",
  "lsquo;": "‘",
  "ltcir;": "⩹",
  "ltdot;": "⋖",
  "ltrie;": "⊴",
  "ltrif;": "◂",
  "mdash;": "—",
  "mDDot;": "∺",
  "micro;": "µ",
  "middot": "·",
  "minus;": "−",
  "mumap;": "⊸",
  "nabla;": "∇",
  "napid;": "≋̸",
  "napos;": "ŉ",
  "natur;": "♮",
  "nbump;": "≎̸",
  "ncong;": "≇",
  "ndash;": "–",
  "neArr;": "⇗",
  "nearr;": "↗",
  "nedot;": "≐̸",
  "nesim;": "≂̸",
  "ngeqq;": "≧̸",
  "ngsim;": "≵",
  "nhArr;": "⇎",
  "nharr;": "↮",
  "nhpar;": "⫲",
  "nlArr;": "⇍",
  "nlarr;": "↚",
  "nleqq;": "≦̸",
  "nless;": "≮",
  "nlsim;": "≴",
  "nltri;": "⋪",
  "notin;": "∉",
  "notni;": "∌",
  "npart;": "∂̸",
  "nprec;": "⊀",
  "nrArr;": "⇏",
  "nrarr;": "↛",
  "nrtri;": "⋫",
  "nsime;": "≄",
  "nsmid;": "∤",
  "nspar;": "∦",
  "nsubE;": "⫅̸",
  "nsube;": "⊈",
  "nsucc;": "⊁",
  "nsupE;": "⫆̸",
  "nsupe;": "⊉",
  "Ntilde": "Ñ",
  "ntilde": "ñ",
  "numsp;": " ",
  "nvsim;": "∼⃒",
  "nwArr;": "⇖",
  "nwarr;": "↖",
  "Oacute": "Ó",
  "oacute": "ó",
  "Ocirc;": "Ô",
  "ocirc;": "ô",
  "odash;": "⊝",
  "OElig;": "Œ",
  "oelig;": "œ",
  "ofcir;": "⦿",
  "Ograve": "Ò",
  "ograve": "ò",
  "ohbar;": "⦵",
  "olarr;": "↺",
  "olcir;": "⦾",
  "oline;": "‾",
  "Omacr;": "Ō",
  "omacr;": "ō",
  "Omega;": "Ω",
  "omega;": "ω",
  "operp;": "⦹",
  "oplus;": "⊕",
  "orarr;": "↻",
  "order;": "ℴ",
  "Oslash": "Ø",
  "oslash": "ø",
  "Otilde": "Õ",
  "otilde": "õ",
  "ovbar;": "⌽",
  "parsl;": "⫽",
  "phone;": "☎",
  "plusb;": "⊞",
  "pluse;": "⩲",
  "plusmn": "±",
  "pound;": "£",
  "prcue;": "≼",
  "Prime;": "″",
  "prime;": "′",
  "prnap;": "⪹",
  "prsim;": "≾",
  "quest;": "?",
  "rAarr;": "⇛",
  "radic;": "√",
  "rangd;": "⦒",
  "range;": "⦥",
  "raquo;": "»",
  "rarrb;": "⇥",
  "rarrc;": "⤳",
  "rarrw;": "↝",
  "ratio;": "∶",
  "RBarr;": "⤐",
  "rBarr;": "⤏",
  "rbarr;": "⤍",
  "rbbrk;": "❳",
  "rbrke;": "⦌",
  "rceil;": "⌉",
  "rdquo;": "”",
  "reals;": "ℝ",
  "rhard;": "⇁",
  "rharu;": "⇀",
  "rlarr;": "⇄",
  "rlhar;": "⇌",
  "rnmid;": "⫮",
  "roang;": "⟭",
  "roarr;": "⇾",
  "robrk;": "⟧",
  "ropar;": "⦆",
  "rrarr;": "⇉",
  "rsquo;": "’",
  "rtrie;": "⊵",
  "rtrif;": "▸",
  "sbquo;": "‚",
  "sccue;": "≽",
  "Scirc;": "Ŝ",
  "scirc;": "ŝ",
  "scnap;": "⪺",
  "scsim;": "≿",
  "sdotb;": "⊡",
  "sdote;": "⩦",
  "seArr;": "⇘",
  "searr;": "↘",
  "setmn;": "∖",
  "sharp;": "♯",
  "Sigma;": "Σ",
  "sigma;": "σ",
  "simeq;": "≃",
  "simgE;": "⪠",
  "simlE;": "⪟",
  "simne;": "≆",
  "slarr;": "←",
  "smile;": "⌣",
  "smtes;": "⪬︀",
  "sqcap;": "⊓",
  "sqcup;": "⊔",
  "sqsub;": "⊏",
  "sqsup;": "⊐",
  "srarr;": "→",
  "starf;": "★",
  "strns;": "¯",
  "subnE;": "⫋",
  "subne;": "⊊",
  "supnE;": "⫌",
  "supne;": "⊋",
  "swArr;": "⇙",
  "swarr;": "↙",
  "szlig;": "ß",
  "Theta;": "Θ",
  "theta;": "θ",
  "thkap;": "≈",
  "THORN;": "Þ",
  "thorn;": "þ",
  "Tilde;": "∼",
  "tilde;": "˜",
  "times;": "×",
  "TRADE;": "™",
  "trade;": "™",
  "trisb;": "⧍",
  "TSHcy;": "Ћ",
  "tshcy;": "ћ",
  "twixt;": "≬",
  "Uacute": "Ú",
  "uacute": "ú",
  "Ubrcy;": "Ў",
  "ubrcy;": "ў",
  "Ucirc;": "Û",
  "ucirc;": "û",
  "udarr;": "⇅",
  "udhar;": "⥮",
  "Ugrave": "Ù",
  "ugrave": "ù",
  "uharl;": "↿",
  "uharr;": "↾",
  "uhblk;": "▀",
  "ultri;": "◸",
  "Umacr;": "Ū",
  "umacr;": "ū",
  "Union;": "⋃",
  "Uogon;": "Ų",
  "uogon;": "ų",
  "uplus;": "⊎",
  "upsih;": "ϒ",
  "UpTee;": "⊥",
  "Uring;": "Ů",
  "uring;": "ů",
  "urtri;": "◹",
  "utdot;": "⋰",
  "utrif;": "▴",
  "uuarr;": "⇈",
  "varpi;": "ϖ",
  "vBarv;": "⫩",
  "VDash;": "⊫",
  "Vdash;": "⊩",
  "vDash;": "⊨",
  "vdash;": "⊢",
  "veeeq;": "≚",
  "vltri;": "⊲",
  "vnsub;": "⊂⃒",
  "vnsup;": "⊃⃒",
  "vprop;": "∝",
  "vrtri;": "⊳",
  "Wcirc;": "Ŵ",
  "wcirc;": "ŵ",
  "Wedge;": "⋀",
  "wedge;": "∧",
  "xcirc;": "◯",
  "xdtri;": "▽",
  "xhArr;": "⟺",
  "xharr;": "⟷",
  "xlArr;": "⟸",
  "xlarr;": "⟵",
  "xodot;": "⨀",
  "xrArr;": "⟹",
  "xrarr;": "⟶",
  "xutri;": "△",
  "Yacute": "Ý",
  "yacute": "ý",
  "Ycirc;": "Ŷ",
  "ycirc;": "ŷ",
  "Aacute;": "Á",
  "aacute;": "á",
  "Abreve;": "Ă",
  "abreve;": "ă",
  "Agrave;": "À",
  "agrave;": "à",
  "andand;": "⩕",
  "angmsd;": "∡",
  "angsph;": "∢",
  "apacir;": "⩯",
  "approx;": "≈",
  "Assign;": "≔",
  "Atilde;": "Ã",
  "atilde;": "ã",
  "barvee;": "⊽",
  "Barwed;": "⌆",
  "barwed;": "⌅",
  "becaus;": "∵",
  "bernou;": "ℬ",
  "bigcap;": "⋂",
  "bigcup;": "⋃",
  "bigvee;": "⋁",
  "bkarow;": "⤍",
  "bottom;": "⊥",
  "bowtie;": "⋈",
  "boxbox;": "⧉",
  "bprime;": "‵",
  "brvbar;": "¦",
  "bullet;": "•",
  "Bumpeq;": "≎",
  "bumpeq;": "≏",
  "Cacute;": "Ć",
  "cacute;": "ć",
  "capand;": "⩄",
  "capcap;": "⩋",
  "capcup;": "⩇",
  "capdot;": "⩀",
  "Ccaron;": "Č",
  "ccaron;": "č",
  "Ccedil;": "Ç",
  "ccedil;": "ç",
  "circeq;": "≗",
  "cirmid;": "⫯",
  "Colone;": "⩴",
  "colone;": "≔",
  "commat;": "@",
  "compfn;": "∘",
  "Conint;": "∯",
  "conint;": "∮",
  "coprod;": "∐",
  "copysr;": "℗",
  "cularr;": "↶",
  "CupCap;": "≍",
  "cupcap;": "⩆",
  "cupcup;": "⩊",
  "cupdot;": "⊍",
  "curarr;": "↷",
  "curren;": "¤",
  "cylcty;": "⌭",
  "Dagger;": "‡",
  "dagger;": "†",
  "daleth;": "ℸ",
  "Dcaron;": "Ď",
  "dcaron;": "ď",
  "dfisht;": "⥿",
  "divide;": "÷",
  "divonx;": "⋇",
  "dlcorn;": "⌞",
  "dlcrop;": "⌍",
  "dollar;": "$",
  "DotDot;": "⃜",
  "drcorn;": "⌟",
  "drcrop;": "⌌",
  "Dstrok;": "Đ",
  "dstrok;": "đ",
  "Eacute;": "É",
  "eacute;": "é",
  "easter;": "⩮",
  "Ecaron;": "Ě",
  "ecaron;": "ě",
  "ecolon;": "≕",
  "Egrave;": "È",
  "egrave;": "è",
  "egsdot;": "⪘",
  "elsdot;": "⪗",
  "emptyv;": "∅",
  "emsp13;": " ",
  "emsp14;": " ",
  "eparsl;": "⧣",
  "eqcirc;": "≖",
  "equals;": "=",
  "equest;": "≟",
  "Exists;": "∃",
  "female;": "♀",
  "ffilig;": "ﬃ",
  "ffllig;": "ﬄ",
  "ForAll;": "∀",
  "forall;": "∀",
  "frac12;": "½",
  "frac13;": "⅓",
  "frac14;": "¼",
  "frac15;": "⅕",
  "frac16;": "⅙",
  "frac18;": "⅛",
  "frac23;": "⅔",
  "frac25;": "⅖",
  "frac34;": "¾",
  "frac35;": "⅗",
  "frac38;": "⅜",
  "frac45;": "⅘",
  "frac56;": "⅚",
  "frac58;": "⅝",
  "frac78;": "⅞",
  "gacute;": "ǵ",
  "Gammad;": "Ϝ",
  "gammad;": "ϝ",
  "Gbreve;": "Ğ",
  "gbreve;": "ğ",
  "Gcedil;": "Ģ",
  "gesdot;": "⪀",
  "gesles;": "⪔",
  "gtlPar;": "⦕",
  "gtrarr;": "⥸",
  "gtrdot;": "⋗",
  "gtrsim;": "≳",
  "hairsp;": " ",
  "hamilt;": "ℋ",
  "HARDcy;": "Ъ",
  "hardcy;": "ъ",
  "hearts;": "♥",
  "hellip;": "…",
  "hercon;": "⊹",
  "homtht;": "∻",
  "horbar;": "―",
  "hslash;": "ℏ",
  "Hstrok;": "Ħ",
  "hstrok;": "ħ",
  "hybull;": "⁃",
  "hyphen;": "‐",
  "Iacute;": "Í",
  "iacute;": "í",
  "Igrave;": "Ì",
  "igrave;": "ì",
  "iiiint;": "⨌",
  "iinfin;": "⧜",
  "incare;": "℅",
  "inodot;": "ı",
  "intcal;": "⊺",
  "iquest;": "¿",
  "isinsv;": "⋳",
  "Itilde;": "Ĩ",
  "itilde;": "ĩ",
  "Jsercy;": "Ј",
  "jsercy;": "ј",
  "kappav;": "ϰ",
  "Kcedil;": "Ķ",
  "kcedil;": "ķ",
  "kgreen;": "ĸ",
  "Lacute;": "Ĺ",
  "lacute;": "ĺ",
  "lagran;": "ℒ",
  "Lambda;": "Λ",
  "lambda;": "λ",
  "langle;": "⟨",
  "larrfs;": "⤝",
  "larrhk;": "↩",
  "larrlp;": "↫",
  "larrpl;": "⤹",
  "larrtl;": "↢",
  "lAtail;": "⤛",
  "latail;": "⤙",
  "lbrace;": "{",
  "lbrack;": "[",
  "Lcaron;": "Ľ",
  "lcaron;": "ľ",
  "Lcedil;": "Ļ",
  "lcedil;": "ļ",
  "ldquor;": "„",
  "lesdot;": "⩿",
  "lesges;": "⪓",
  "lfisht;": "⥼",
  "lfloor;": "⌊",
  "lharul;": "⥪",
  "llhard;": "⥫",
  "Lmidot;": "Ŀ",
  "lmidot;": "ŀ",
  "lmoust;": "⎰",
  "loplus;": "⨭",
  "lowast;": "∗",
  "lowbar;": "_",
  "lparlt;": "⦓",
  "lrhard;": "⥭",
  "lsaquo;": "‹",
  "lsquor;": "‚",
  "Lstrok;": "Ł",
  "lstrok;": "ł",
  "lthree;": "⋋",
  "ltimes;": "⋉",
  "ltlarr;": "⥶",
  "ltrPar;": "⦖",
  "mapsto;": "↦",
  "marker;": "▮",
  "mcomma;": "⨩",
  "midast;": "*",
  "midcir;": "⫰",
  "middot;": "·",
  "minusb;": "⊟",
  "minusd;": "∸",
  "mnplus;": "∓",
  "models;": "⊧",
  "mstpos;": "∾",
  "Nacute;": "Ń",
  "nacute;": "ń",
  "nbumpe;": "≏̸",
  "Ncaron;": "Ň",
  "ncaron;": "ň",
  "Ncedil;": "Ņ",
  "ncedil;": "ņ",
  "nearhk;": "⤤",
  "nequiv;": "≢",
  "nesear;": "⤨",
  "nexist;": "∄",
  "nltrie;": "⋬",
  "notinE;": "⋹̸",
  "nparsl;": "⫽⃥",
  "nprcue;": "⋠",
  "nrarrc;": "⤳̸",
  "nrarrw;": "↝̸",
  "nrtrie;": "⋭",
  "nsccue;": "⋡",
  "nsimeq;": "≄",
  "Ntilde;": "Ñ",
  "ntilde;": "ñ",
  "numero;": "№",
  "nVDash;": "⊯",
  "nVdash;": "⊮",
  "nvDash;": "⊭",
  "nvdash;": "⊬",
  "nvHarr;": "⤄",
  "nvlArr;": "⤂",
  "nvrArr;": "⤃",
  "nwarhk;": "⤣",
  "nwnear;": "⤧",
  "Oacute;": "Ó",
  "oacute;": "ó",
  "Odblac;": "Ő",
  "odblac;": "ő",
  "odsold;": "⦼",
  "Ograve;": "Ò",
  "ograve;": "ò",
  "ominus;": "⊖",
  "origof;": "⊶",
  "Oslash;": "Ø",
  "oslash;": "ø",
  "Otilde;": "Õ",
  "otilde;": "õ",
  "Otimes;": "⨷",
  "otimes;": "⊗",
  "parsim;": "⫳",
  "percnt;": "%",
  "period;": ".",
  "permil;": "‰",
  "phmmat;": "ℳ",
  "planck;": "ℏ",
  "plankv;": "ℏ",
  "plusdo;": "∔",
  "plusdu;": "⨥",
  "plusmn;": "±",
  "preceq;": "⪯",
  "primes;": "ℙ",
  "prnsim;": "⋨",
  "propto;": "∝",
  "prurel;": "⊰",
  "puncsp;": " ",
  "qprime;": "⁗",
  "Racute;": "Ŕ",
  "racute;": "ŕ",
  "rangle;": "⟩",
  "rarrap;": "⥵",
  "rarrfs;": "⤞",
  "rarrhk;": "↪",
  "rarrlp;": "↬",
  "rarrpl;": "⥅",
  "Rarrtl;": "⤖",
  "rarrtl;": "↣",
  "rAtail;": "⤜",
  "ratail;": "⤚",
  "rbrace;": "}",
  "rbrack;": "]",
  "Rcaron;": "Ř",
  "rcaron;": "ř",
  "Rcedil;": "Ŗ",
  "rcedil;": "ŗ",
  "rdquor;": "”",
  "rfisht;": "⥽",
  "rfloor;": "⌋",
  "rharul;": "⥬",
  "rmoust;": "⎱",
  "roplus;": "⨮",
  "rpargt;": "⦔",
  "rsaquo;": "›",
  "rsquor;": "’",
  "rthree;": "⋌",
  "rtimes;": "⋊",
  "Sacute;": "Ś",
  "sacute;": "ś",
  "Scaron;": "Š",
  "scaron;": "š",
  "Scedil;": "Ş",
  "scedil;": "ş",
  "scnsim;": "⋩",
  "searhk;": "⤥",
  "seswar;": "⤩",
  "sfrown;": "⌢",
  "SHCHcy;": "Щ",
  "shchcy;": "щ",
  "sigmaf;": "ς",
  "sigmav;": "ς",
  "simdot;": "⩪",
  "smashp;": "⨳",
  "SOFTcy;": "Ь",
  "softcy;": "ь",
  "solbar;": "⌿",
  "spades;": "♠",
  "sqcaps;": "⊓︀",
  "sqcups;": "⊔︀",
  "sqsube;": "⊑",
  "sqsupe;": "⊒",
  "Square;": "□",
  "square;": "□",
  "squarf;": "▪",
  "ssetmn;": "∖",
  "ssmile;": "⌣",
  "sstarf;": "⋆",
  "subdot;": "⪽",
  "Subset;": "⋐",
  "subset;": "⊂",
  "subsim;": "⫇",
  "subsub;": "⫕",
  "subsup;": "⫓",
  "succeq;": "⪰",
  "supdot;": "⪾",
  "Supset;": "⋑",
  "supset;": "⊃",
  "supsim;": "⫈",
  "supsub;": "⫔",
  "supsup;": "⫖",
  "swarhk;": "⤦",
  "swnwar;": "⤪",
  "target;": "⌖",
  "Tcaron;": "Ť",
  "tcaron;": "ť",
  "Tcedil;": "Ţ",
  "tcedil;": "ţ",
  "telrec;": "⌕",
  "there4;": "∴",
  "thetav;": "ϑ",
  "thinsp;": " ",
  "thksim;": "∼",
  "timesb;": "⊠",
  "timesd;": "⨰",
  "topbot;": "⌶",
  "topcir;": "⫱",
  "tprime;": "‴",
  "tridot;": "◬",
  "Tstrok;": "Ŧ",
  "tstrok;": "ŧ",
  "Uacute;": "Ú",
  "uacute;": "ú",
  "Ubreve;": "Ŭ",
  "ubreve;": "ŭ",
  "Udblac;": "Ű",
  "udblac;": "ű",
  "ufisht;": "⥾",
  "Ugrave;": "Ù",
  "ugrave;": "ù",
  "ulcorn;": "⌜",
  "ulcrop;": "⌏",
  "urcorn;": "⌝",
  "urcrop;": "⌎",
  "Utilde;": "Ũ",
  "utilde;": "ũ",
  "vangrt;": "⦜",
  "varphi;": "ϕ",
  "varrho;": "ϱ",
  "Vdashl;": "⫦",
  "veebar;": "⊻",
  "vellip;": "⋮",
  "Verbar;": "‖",
  "verbar;": "|",
  "vsubnE;": "⫋︀",
  "vsubne;": "⊊︀",
  "vsupnE;": "⫌︀",
  "vsupne;": "⊋︀",
  "Vvdash;": "⊪",
  "wedbar;": "⩟",
  "wedgeq;": "≙",
  "weierp;": "℘",
  "wreath;": "≀",
  "xoplus;": "⨁",
  "xotime;": "⨂",
  "xsqcup;": "⨆",
  "xuplus;": "⨄",
  "xwedge;": "⋀",
  "Yacute;": "Ý",
  "yacute;": "ý",
  "Zacute;": "Ź",
  "zacute;": "ź",
  "Zcaron;": "Ž",
  "zcaron;": "ž",
  "zeetrf;": "ℨ",
  "alefsym;": "ℵ",
  "angrtvb;": "⊾",
  "angzarr;": "⍼",
  "asympeq;": "≍",
  "backsim;": "∽",
  "Because;": "∵",
  "because;": "∵",
  "bemptyv;": "⦰",
  "between;": "≬",
  "bigcirc;": "◯",
  "bigodot;": "⨀",
  "bigstar;": "★",
  "bnequiv;": "≡⃥",
  "boxplus;": "⊞",
  "Cayleys;": "ℭ",
  "Cconint;": "∰",
  "ccupssm;": "⩐",
  "Cedilla;": "¸",
  "cemptyv;": "⦲",
  "cirscir;": "⧂",
  "coloneq;": "≔",
  "congdot;": "⩭",
  "cudarrl;": "⤸",
  "cudarrr;": "⤵",
  "cularrp;": "⤽",
  "curarrm;": "⤼",
  "dbkarow;": "⤏",
  "ddagger;": "‡",
  "ddotseq;": "⩷",
  "demptyv;": "⦱",
  "Diamond;": "⋄",
  "diamond;": "⋄",
  "digamma;": "ϝ",
  "dotplus;": "∔",
  "DownTee;": "⊤",
  "dwangle;": "⦦",
  "Element;": "∈",
  "Epsilon;": "Ε",
  "epsilon;": "ε",
  "eqcolon;": "≕",
  "equivDD;": "⩸",
  "gesdoto;": "⪂",
  "gtquest;": "⩼",
  "gtrless;": "≷",
  "harrcir;": "⥈",
  "Implies;": "⇒",
  "intprod;": "⨼",
  "isindot;": "⋵",
  "larrbfs;": "⤟",
  "larrsim;": "⥳",
  "lbrksld;": "⦏",
  "lbrkslu;": "⦍",
  "ldrdhar;": "⥧",
  "LeftTee;": "⊣",
  "lesdoto;": "⪁",
  "lessdot;": "⋖",
  "lessgtr;": "≶",
  "lesssim;": "≲",
  "lotimes;": "⨴",
  "lozenge;": "◊",
  "ltquest;": "⩻",
  "luruhar;": "⥦",
  "maltese;": "✠",
  "minusdu;": "⨪",
  "napprox;": "≉",
  "natural;": "♮",
  "nearrow;": "↗",
  "NewLine;": "\n",
  "nexists;": "∄",
  "NoBreak;": "⁠",
  "notinva;": "∉",
  "notinvb;": "⋷",
  "notinvc;": "⋶",
  "NotLess;": "≮",
  "notniva;": "∌",
  "notnivb;": "⋾",
  "notnivc;": "⋽",
  "npolint;": "⨔",
  "npreceq;": "⪯̸",
  "nsqsube;": "⋢",
  "nsqsupe;": "⋣",
  "nsubset;": "⊂⃒",
  "nsucceq;": "⪰̸",
  "nsupset;": "⊃⃒",
  "nvinfin;": "⧞",
  "nvltrie;": "⊴⃒",
  "nvrtrie;": "⊵⃒",
  "nwarrow;": "↖",
  "olcross;": "⦻",
  "Omicron;": "Ο",
  "omicron;": "ο",
  "orderof;": "ℴ",
  "orslope;": "⩗",
  "OverBar;": "‾",
  "pertenk;": "‱",
  "planckh;": "ℎ",
  "pluscir;": "⨢",
  "plussim;": "⨦",
  "plustwo;": "⨧",
  "precsim;": "≾",
  "Product;": "∏",
  "quatint;": "⨖",
  "questeq;": "≟",
  "rarrbfs;": "⤠",
  "rarrsim;": "⥴",
  "rbrksld;": "⦎",
  "rbrkslu;": "⦐",
  "rdldhar;": "⥩",
  "realine;": "ℛ",
  "rotimes;": "⨵",
  "ruluhar;": "⥨",
  "searrow;": "↘",
  "simplus;": "⨤",
  "simrarr;": "⥲",
  "subedot;": "⫃",
  "submult;": "⫁",
  "subplus;": "⪿",
  "subrarr;": "⥹",
  "succsim;": "≿",
  "supdsub;": "⫘",
  "supedot;": "⫄",
  "suphsol;": "⟉",
  "suphsub;": "⫗",
  "suplarr;": "⥻",
  "supmult;": "⫂",
  "supplus;": "⫀",
  "swarrow;": "↙",
  "topfork;": "⫚",
  "triplus;": "⨹",
  "tritime;": "⨻",
  "UpArrow;": "↑",
  "Uparrow;": "⇑",
  "uparrow;": "↑",
  "Upsilon;": "Υ",
  "upsilon;": "υ",
  "uwangle;": "⦧",
  "vzigzag;": "⦚",
  "zigrarr;": "⇝",
  "andslope;": "⩘",
  "angmsdaa;": "⦨",
  "angmsdab;": "⦩",
  "angmsdac;": "⦪",
  "angmsdad;": "⦫",
  "angmsdae;": "⦬",
  "angmsdaf;": "⦭",
  "angmsdag;": "⦮",
  "angmsdah;": "⦯",
  "angrtvbd;": "⦝",
  "approxeq;": "≊",
  "awconint;": "∳",
  "backcong;": "≌",
  "barwedge;": "⌅",
  "bbrktbrk;": "⎶",
  "bigoplus;": "⨁",
  "bigsqcup;": "⨆",
  "biguplus;": "⨄",
  "bigwedge;": "⋀",
  "boxminus;": "⊟",
  "boxtimes;": "⊠",
  "bsolhsub;": "⟈",
  "capbrcup;": "⩉",
  "circledR;": "®",
  "circledS;": "Ⓢ",
  "cirfnint;": "⨐",
  "clubsuit;": "♣",
  "cupbrcap;": "⩈",
  "curlyvee;": "⋎",
  "cwconint;": "∲",
  "DDotrahd;": "⤑",
  "doteqdot;": "≑",
  "DotEqual;": "≐",
  "dotminus;": "∸",
  "drbkarow;": "⤐",
  "dzigrarr;": "⟿",
  "elinters;": "⏧",
  "emptyset;": "∅",
  "eqvparsl;": "⧥",
  "fpartint;": "⨍",
  "geqslant;": "⩾",
  "gesdotol;": "⪄",
  "gnapprox;": "⪊",
  "hksearow;": "⤥",
  "hkswarow;": "⤦",
  "imagline;": "ℐ",
  "imagpart;": "ℑ",
  "infintie;": "⧝",
  "integers;": "ℤ",
  "Integral;": "∫",
  "intercal;": "⊺",
  "intlarhk;": "⨗",
  "laemptyv;": "⦴",
  "ldrushar;": "⥋",
  "leqslant;": "⩽",
  "lesdotor;": "⪃",
  "LessLess;": "⪡",
  "llcorner;": "⌞",
  "lnapprox;": "⪉",
  "lrcorner;": "⌟",
  "lurdshar;": "⥊",
  "mapstoup;": "↥",
  "multimap;": "⊸",
  "naturals;": "ℕ",
  "ncongdot;": "⩭̸",
  "NotEqual;": "≠",
  "notindot;": "⋵̸",
  "NotTilde;": "≁",
  "otimesas;": "⨶",
  "parallel;": "∥",
  "PartialD;": "∂",
  "plusacir;": "⨣",
  "pointint;": "⨕",
  "Precedes;": "≺",
  "precneqq;": "⪵",
  "precnsim;": "⋨",
  "profalar;": "⌮",
  "profline;": "⌒",
  "profsurf;": "⌓",
  "raemptyv;": "⦳",
  "realpart;": "ℜ",
  "RightTee;": "⊢",
  "rppolint;": "⨒",
  "rtriltri;": "⧎",
  "scpolint;": "⨓",
  "setminus;": "∖",
  "shortmid;": "∣",
  "smeparsl;": "⧤",
  "sqsubset;": "⊏",
  "sqsupset;": "⊐",
  "subseteq;": "⊆",
  "Succeeds;": "≻",
  "succneqq;": "⪶",
  "succnsim;": "⋩",
  "SuchThat;": "∋",
  "Superset;": "⊃",
  "supseteq;": "⊇",
  "thetasym;": "ϑ",
  "thicksim;": "∼",
  "timesbar;": "⨱",
  "triangle;": "▵",
  "triminus;": "⨺",
  "trpezium;": "⏢",
  "Uarrocir;": "⥉",
  "ulcorner;": "⌜",
  "UnderBar;": "_",
  "urcorner;": "⌝",
  "varkappa;": "ϰ",
  "varsigma;": "ς",
  "vartheta;": "ϑ",
  "backprime;": "‵",
  "backsimeq;": "⋍",
  "Backslash;": "∖",
  "bigotimes;": "⨂",
  "CenterDot;": "·",
  "centerdot;": "·",
  "checkmark;": "✓",
  "CircleDot;": "⊙",
  "complexes;": "ℂ",
  "Congruent;": "≡",
  "Coproduct;": "∐",
  "dotsquare;": "⊡",
  "DoubleDot;": "¨",
  "DownArrow;": "↓",
  "Downarrow;": "⇓",
  "downarrow;": "↓",
  "DownBreve;": "̑",
  "gtrapprox;": "⪆",
  "gtreqless;": "⋛",
  "gvertneqq;": "≩︀",
  "heartsuit;": "♥",
  "HumpEqual;": "≏",
  "LeftArrow;": "←",
  "Leftarrow;": "⇐",
  "leftarrow;": "←",
  "LeftFloor;": "⌊",
  "lesseqgtr;": "⋚",
  "LessTilde;": "≲",
  "lvertneqq;": "≨︀",
  "Mellintrf;": "ℳ",
  "MinusPlus;": "∓",
  "ngeqslant;": "⩾̸",
  "nleqslant;": "⩽̸",
  "NotCupCap;": "≭",
  "NotExists;": "∄",
  "NotSubset;": "⊂⃒",
  "nparallel;": "∦",
  "nshortmid;": "∤",
  "nsubseteq;": "⊈",
  "nsupseteq;": "⊉",
  "OverBrace;": "⏞",
  "pitchfork;": "⋔",
  "PlusMinus;": "±",
  "rationals;": "ℚ",
  "spadesuit;": "♠",
  "subseteqq;": "⫅",
  "subsetneq;": "⊊",
  "supseteqq;": "⫆",
  "supsetneq;": "⊋",
  "Therefore;": "∴",
  "therefore;": "∴",
  "ThinSpace;": " ",
  "triangleq;": "≜",
  "TripleDot;": "⃛",
  "UnionPlus;": "⊎",
  "varpropto;": "∝",
  "Bernoullis;": "ℬ",
  "circledast;": "⊛",
  "CirclePlus;": "⊕",
  "complement;": "∁",
  "curlywedge;": "⋏",
  "eqslantgtr;": "⪖",
  "EqualTilde;": "≂",
  "Fouriertrf;": "ℱ",
  "gtreqqless;": "⪌",
  "ImaginaryI;": "ⅈ",
  "Laplacetrf;": "ℒ",
  "LeftVector;": "↼",
  "lessapprox;": "⪅",
  "lesseqqgtr;": "⪋",
  "Lleftarrow;": "⇚",
  "lmoustache;": "⎰",
  "longmapsto;": "⟼",
  "mapstodown;": "↧",
  "mapstoleft;": "↤",
  "nLeftarrow;": "⇍",
  "nleftarrow;": "↚",
  "NotElement;": "∉",
  "NotGreater;": "≯",
  "nsubseteqq;": "⫅̸",
  "nsupseteqq;": "⫆̸",
  "precapprox;": "⪷",
  "Proportion;": "∷",
  "RightArrow;": "→",
  "Rightarrow;": "⇒",
  "rightarrow;": "→",
  "RightFloor;": "⌋",
  "rmoustache;": "⎱",
  "sqsubseteq;": "⊑",
  "sqsupseteq;": "⊒",
  "subsetneqq;": "⫋",
  "succapprox;": "⪸",
  "supsetneqq;": "⫌",
  "ThickSpace;": "  ",
  "TildeEqual;": "≃",
  "TildeTilde;": "≈",
  "UnderBrace;": "⏟",
  "UpArrowBar;": "⤒",
  "UpTeeArrow;": "↥",
  "upuparrows;": "⇈",
  "varepsilon;": "ϵ",
  "varnothing;": "∅",
  "backepsilon;": "϶",
  "blacksquare;": "▪",
  "circledcirc;": "⊚",
  "circleddash;": "⊝",
  "CircleMinus;": "⊖",
  "CircleTimes;": "⊗",
  "curlyeqprec;": "⋞",
  "curlyeqsucc;": "⋟",
  "diamondsuit;": "♦",
  "eqslantless;": "⪕",
  "Equilibrium;": "⇌",
  "expectation;": "ℰ",
  "GreaterLess;": "≷",
  "LeftCeiling;": "⌈",
  "LessGreater;": "≶",
  "MediumSpace;": " ",
  "NotLessLess;": "≪̸",
  "NotPrecedes;": "⊀",
  "NotSucceeds;": "⊁",
  "NotSuperset;": "⊃⃒",
  "nRightarrow;": "⇏",
  "nrightarrow;": "↛",
  "OverBracket;": "⎴",
  "preccurlyeq;": "≼",
  "precnapprox;": "⪹",
  "quaternions;": "ℍ",
  "RightVector;": "⇀",
  "Rrightarrow;": "⇛",
  "RuleDelayed;": "⧴",
  "SmallCircle;": "∘",
  "SquareUnion;": "⊔",
  "straightphi;": "ϕ",
  "SubsetEqual;": "⊆",
  "succcurlyeq;": "≽",
  "succnapprox;": "⪺",
  "thickapprox;": "≈",
  "UpDownArrow;": "↕",
  "Updownarrow;": "⇕",
  "updownarrow;": "↕",
  "VerticalBar;": "∣",
  "blacklozenge;": "⧫",
  "DownArrowBar;": "⤓",
  "DownTeeArrow;": "↧",
  "ExponentialE;": "ⅇ",
  "exponentiale;": "ⅇ",
  "GreaterEqual;": "≥",
  "GreaterTilde;": "≳",
  "HilbertSpace;": "ℋ",
  "HumpDownHump;": "≎",
  "Intersection;": "⋂",
  "LeftArrowBar;": "⇤",
  "LeftTeeArrow;": "↤",
  "LeftTriangle;": "⊲",
  "LeftUpVector;": "↿",
  "NotCongruent;": "≢",
  "NotHumpEqual;": "≏̸",
  "NotLessEqual;": "≰",
  "NotLessTilde;": "≴",
  "Proportional;": "∝",
  "RightCeiling;": "⌉",
  "risingdotseq;": "≓",
  "RoundImplies;": "⥰",
  "ShortUpArrow;": "↑",
  "SquareSubset;": "⊏",
  "triangledown;": "▿",
  "triangleleft;": "◃",
  "UnderBracket;": "⎵",
  "varsubsetneq;": "⊊︀",
  "varsupsetneq;": "⊋︀",
  "VerticalLine;": "|",
  "ApplyFunction;": "⁡",
  "bigtriangleup;": "△",
  "blacktriangle;": "▴",
  "DifferentialD;": "ⅆ",
  "divideontimes;": "⋇",
  "DoubleLeftTee;": "⫤",
  "DoubleUpArrow;": "⇑",
  "fallingdotseq;": "≒",
  "hookleftarrow;": "↩",
  "leftarrowtail;": "↢",
  "leftharpoonup;": "↼",
  "LeftTeeVector;": "⥚",
  "LeftVectorBar;": "⥒",
  "LessFullEqual;": "≦",
  "LongLeftArrow;": "⟵",
  "Longleftarrow;": "⟸",
  "longleftarrow;": "⟵",
  "looparrowleft;": "↫",
  "measuredangle;": "∡",
  "NotEqualTilde;": "≂̸",
  "NotTildeEqual;": "≄",
  "NotTildeTilde;": "≉",
  "ntriangleleft;": "⋪",
  "Poincareplane;": "ℌ",
  "PrecedesEqual;": "⪯",
  "PrecedesTilde;": "≾",
  "RightArrowBar;": "⇥",
  "RightTeeArrow;": "↦",
  "RightTriangle;": "⊳",
  "RightUpVector;": "↾",
  "shortparallel;": "∥",
  "smallsetminus;": "∖",
  "SucceedsEqual;": "⪰",
  "SucceedsTilde;": "≿",
  "SupersetEqual;": "⊇",
  "triangleright;": "▹",
  "UpEquilibrium;": "⥮",
  "upharpoonleft;": "↿",
  "varsubsetneqq;": "⫋︀",
  "varsupsetneqq;": "⫌︀",
  "VerticalTilde;": "≀",
  "VeryThinSpace;": " ",
  "curvearrowleft;": "↶",
  "DiacriticalDot;": "˙",
  "doublebarwedge;": "⌆",
  "DoubleRightTee;": "⊨",
  "downdownarrows;": "⇊",
  "DownLeftVector;": "↽",
  "GreaterGreater;": "⪢",
  "hookrightarrow;": "↪",
  "HorizontalLine;": "─",
  "InvisibleComma;": "⁣",
  "InvisibleTimes;": "⁢",
  "LeftDownVector;": "⇃",
  "leftleftarrows;": "⇇",
  "LeftRightArrow;": "↔",
  "Leftrightarrow;": "⇔",
  "leftrightarrow;": "↔",
  "leftthreetimes;": "⋋",
  "LessSlantEqual;": "⩽",
  "LongRightArrow;": "⟶",
  "Longrightarrow;": "⟹",
  "longrightarrow;": "⟶",
  "looparrowright;": "↬",
  "LowerLeftArrow;": "↙",
  "NestedLessLess;": "≪",
  "NotGreaterLess;": "≹",
  "NotLessGreater;": "≸",
  "NotSubsetEqual;": "⊈",
  "NotVerticalBar;": "∤",
  "nshortparallel;": "∦",
  "ntriangleright;": "⋫",
  "OpenCurlyQuote;": "‘",
  "ReverseElement;": "∋",
  "rightarrowtail;": "↣",
  "rightharpoonup;": "⇀",
  "RightTeeVector;": "⥛",
  "RightVectorBar;": "⥓",
  "ShortDownArrow;": "↓",
  "ShortLeftArrow;": "←",
  "SquareSuperset;": "⊐",
  "TildeFullEqual;": "≅",
  "trianglelefteq;": "⊴",
  "upharpoonright;": "↾",
  "UpperLeftArrow;": "↖",
  "ZeroWidthSpace;": "​",
  "bigtriangledown;": "▽",
  "circlearrowleft;": "↺",
  "CloseCurlyQuote;": "’",
  "ContourIntegral;": "∮",
  "curvearrowright;": "↷",
  "DoubleDownArrow;": "⇓",
  "DoubleLeftArrow;": "⇐",
  "downharpoonleft;": "⇃",
  "DownRightVector;": "⇁",
  "leftharpoondown;": "↽",
  "leftrightarrows;": "⇆",
  "LeftRightVector;": "⥎",
  "LeftTriangleBar;": "⧏",
  "LeftUpTeeVector;": "⥠",
  "LeftUpVectorBar;": "⥘",
  "LowerRightArrow;": "↘",
  "nLeftrightarrow;": "⇎",
  "nleftrightarrow;": "↮",
  "NotGreaterEqual;": "≱",
  "NotGreaterTilde;": "≵",
  "NotHumpDownHump;": "≎̸",
  "NotLeftTriangle;": "⋪",
  "NotSquareSubset;": "⊏̸",
  "ntrianglelefteq;": "⋬",
  "OverParenthesis;": "⏜",
  "RightDownVector;": "⇂",
  "rightleftarrows;": "⇄",
  "rightsquigarrow;": "↝",
  "rightthreetimes;": "⋌",
  "ShortRightArrow;": "→",
  "straightepsilon;": "ϵ",
  "trianglerighteq;": "⊵",
  "UpperRightArrow;": "↗",
  "vartriangleleft;": "⊲",
  "circlearrowright;": "↻",
  "DiacriticalAcute;": "´",
  "DiacriticalGrave;": "`",
  "DiacriticalTilde;": "˜",
  "DoubleRightArrow;": "⇒",
  "DownArrowUpArrow;": "⇵",
  "downharpoonright;": "⇂",
  "EmptySmallSquare;": "◻",
  "GreaterEqualLess;": "⋛",
  "GreaterFullEqual;": "≧",
  "LeftAngleBracket;": "⟨",
  "LeftUpDownVector;": "⥑",
  "LessEqualGreater;": "⋚",
  "NonBreakingSpace;": " ",
  "NotPrecedesEqual;": "⪯̸",
  "NotRightTriangle;": "⋫",
  "NotSucceedsEqual;": "⪰̸",
  "NotSucceedsTilde;": "≿̸",
  "NotSupersetEqual;": "⊉",
  "ntrianglerighteq;": "⋭",
  "rightharpoondown;": "⇁",
  "rightrightarrows;": "⇉",
  "RightTriangleBar;": "⧐",
  "RightUpTeeVector;": "⥜",
  "RightUpVectorBar;": "⥔",
  "twoheadleftarrow;": "↞",
  "UnderParenthesis;": "⏝",
  "UpArrowDownArrow;": "⇅",
  "vartriangleright;": "⊳",
  "blacktriangledown;": "▾",
  "blacktriangleleft;": "◂",
  "DoubleUpDownArrow;": "⇕",
  "DoubleVerticalBar;": "∥",
  "DownLeftTeeVector;": "⥞",
  "DownLeftVectorBar;": "⥖",
  "FilledSmallSquare;": "◼",
  "GreaterSlantEqual;": "⩾",
  "LeftDoubleBracket;": "⟦",
  "LeftDownTeeVector;": "⥡",
  "LeftDownVectorBar;": "⥙",
  "leftrightharpoons;": "⇋",
  "LeftTriangleEqual;": "⊴",
  "NegativeThinSpace;": "​",
  "NotGreaterGreater;": "≫̸",
  "NotLessSlantEqual;": "⩽̸",
  "NotNestedLessLess;": "⪡̸",
  "NotReverseElement;": "∌",
  "NotSquareSuperset;": "⊐̸",
  "NotTildeFullEqual;": "≇",
  "RightAngleBracket;": "⟩",
  "rightleftharpoons;": "⇌",
  "RightUpDownVector;": "⥏",
  "SquareSubsetEqual;": "⊑",
  "twoheadrightarrow;": "↠",
  "VerticalSeparator;": "❘",
  "blacktriangleright;": "▸",
  "DownRightTeeVector;": "⥟",
  "DownRightVectorBar;": "⥗",
  "LongLeftRightArrow;": "⟷",
  "Longleftrightarrow;": "⟺",
  "longleftrightarrow;": "⟷",
  "NegativeThickSpace;": "​",
  "NotLeftTriangleBar;": "⧏̸",
  "PrecedesSlantEqual;": "≼",
  "ReverseEquilibrium;": "⇋",
  "RightDoubleBracket;": "⟧",
  "RightDownTeeVector;": "⥝",
  "RightDownVectorBar;": "⥕",
  "RightTriangleEqual;": "⊵",
  "SquareIntersection;": "⊓",
  "SucceedsSlantEqual;": "≽",
  "DoubleLongLeftArrow;": "⟸",
  "DownLeftRightVector;": "⥐",
  "LeftArrowRightArrow;": "⇆",
  "leftrightsquigarrow;": "↭",
  "NegativeMediumSpace;": "​",
  "NotGreaterFullEqual;": "≧̸",
  "NotRightTriangleBar;": "⧐̸",
  "RightArrowLeftArrow;": "⇄",
  "SquareSupersetEqual;": "⊒",
  "CapitalDifferentialD;": "ⅅ",
  "DoubleLeftRightArrow;": "⇔",
  "DoubleLongRightArrow;": "⟹",
  "EmptyVerySmallSquare;": "▫",
  "NestedGreaterGreater;": "≫",
  "NotDoubleVerticalBar;": "∦",
  "NotGreaterSlantEqual;": "⩾̸",
  "NotLeftTriangleEqual;": "⋬",
  "NotSquareSubsetEqual;": "⋢",
  "OpenCurlyDoubleQuote;": "“",
  "ReverseUpEquilibrium;": "⥯",
  "CloseCurlyDoubleQuote;": "”",
  "DoubleContourIntegral;": "∯",
  "FilledVerySmallSquare;": "▪",
  "NegativeVeryThinSpace;": "​",
  "NotPrecedesSlantEqual;": "⋠",
  "NotRightTriangleEqual;": "⋭",
  "NotSucceedsSlantEqual;": "⋡",
  "DiacriticalDoubleAcute;": "˝",
  "NotSquareSupersetEqual;": "⋣",
  "NotNestedGreaterGreater;": "⪢̸",
  "ClockwiseContourIntegral;": "∲",
  "DoubleLongLeftRightArrow;": "⟺",
  "CounterClockwiseContourIntegral;": "∳"
}

const decodeHtml = (rawText, asAttr) => {
  let offset = 0
  const end = rawText.length
  let decodedText = ''

  function advance(length) {
    offset += length
    rawText = rawText.slice(length)
  }

  while (offset < end) {
    const head = /&(?:#x?)?/i.exec(rawText)
    if (!head || offset + head.index >= end) {
      const remaining = end - offset
      decodedText += rawText.slice(0, remaining)
      advance(remaining)
      break
    }

    // Advance to the "&".
    decodedText += rawText.slice(0, head.index)
    advance(head.index)

    if (head[0] === '&') {
      // Named character reference.
      let name = ''
      let value = undefined
      if (/[0-9a-z]/i.test(rawText[1])) {
        if (!maxCRNameLength) {
          maxCRNameLength = Object.keys(namedCharacterReferences).reduce(
            (max, name) => Math.max(max, name.length),
            0
          )
        }
        for (let length = maxCRNameLength; !value && length > 0; --length) {
          name = rawText.slice(1, 1 + length)
          value = namedCharacterReferences[name]
        }
        if (value) {
          const semi = name.endsWith(';')
          if (
            asAttr &&
            !semi &&
            /[=a-z0-9]/i.test(rawText[name.length + 1] || '')
          ) {
            decodedText += '&' + name
            advance(1 + name.length)
          } else {
            decodedText += value
            advance(1 + name.length)
          }
        } else {
          decodedText += '&' + name
          advance(1 + name.length)
        }
      } else {
        decodedText += '&'
        advance(1)
      }
    } else {
      // Numeric character reference.
      const hex = head[0] === '&#x'
      const pattern = hex ? /^&#x([0-9a-f]+);?/i : /^&#([0-9]+);?/
      const body = pattern.exec(rawText)
      if (!body) {
        decodedText += head[0]
        advance(head[0].length)
      } else {
        // https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state
        let cp = Number.parseInt(body[1], hex ? 16 : 10)
        if (cp === 0) {
          cp = 0xfffd
        } else if (cp > 0x10ffff) {
          cp = 0xfffd
        } else if (cp >= 0xd800 && cp <= 0xdfff) {
          cp = 0xfffd
        } else if ((cp >= 0xfdd0 && cp <= 0xfdef) || (cp & 0xfffe) === 0xfffe) {
          // noop
        } else if (
          (cp >= 0x01 && cp <= 0x08) ||
          cp === 0x0b ||
          (cp >= 0x0d && cp <= 0x1f) ||
          (cp >= 0x7f && cp <= 0x9f)
        ) {
          cp = CCR_REPLACEMENTS[cp] || cp
        }
        decodedText += String.fromCodePoint(cp)
        advance(body[0].length)
      }
    }
  }
  return decodedText
}

// https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state
const CCR_REPLACEMENTS = {
  0x80: 0x20ac,
  0x82: 0x201a,
  0x83: 0x0192,
  0x84: 0x201e,
  0x85: 0x2026,
  0x86: 0x2020,
  0x87: 0x2021,
  0x88: 0x02c6,
  0x89: 0x2030,
  0x8a: 0x0160,
  0x8b: 0x2039,
  0x8c: 0x0152,
  0x8e: 0x017d,
  0x91: 0x2018,
  0x92: 0x2019,
  0x93: 0x201c,
  0x94: 0x201d,
  0x95: 0x2022,
  0x96: 0x2013,
  0x97: 0x2014,
  0x98: 0x02dc,
  0x99: 0x2122,
  0x9a: 0x0161,
  0x9b: 0x203a,
  0x9c: 0x0153,
  0x9e: 0x017e,
  0x9f: 0x0178
}

let decoder

function decodeHtmlBrowser(raw, asAttr = false) {
  if (!decoder) {
    decoder = document.createElement('div')
  }
  if (asAttr) {
    decoder.innerHTML = `<div foo="${raw.replace(/"/g, '&quot;')}">`
    return decoder.children[0].getAttribute('foo')
  } else {
    decoder.innerHTML = raw
    return decoder.textContent
  }
}
#+end_src
#+end_details

#+html: <br>
#+begin_details dom-attrs :title-color green
#+name: dom-attrs
#+begin_src js -n -r

/**
 ,* On the client we only need to offer special cases for boolean attributes that
 ,* have different names from their corresponding dom properties:
 ,* - itemscope -> N/A
 ,* - allowfullscreen -> allowFullscreen
 ,* - formnovalidate -> formNoValidate
 ,* - ismap -> isMap
 ,* - nomodule -> noModule
 ,* - novalidate -> noValidate
 ,* - readonly -> readOnly
 ,*/
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`
const isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs)

/**
 ,* The full list is needed during SSR to produce the correct initial markup.
 ,*/
const isBooleanAttr = /*#__PURE__*/ makeMap(
  specialBooleanAttrs +
    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +
    `loop,open,required,reversed,scoped,seamless,` +
    `checked,muted,multiple,selected`
)

/**
 ,* Boolean attributes should be included if the value is truthy or ''.
 ,* e.g. `<select multiple>` compiles to `{ multiple: '' }`
 ,*/
function includeBooleanAttr(value) {
  return !!value || value === ''
}

const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/
const attrValidationCache = {}

function isSSRSafeAttrName(name) {
  if (attrValidationCache.hasOwnProperty(name)) {
    return attrValidationCache[name]
  }
  const isUnsafe = unsafeAttrCharRE.test(name)
  if (isUnsafe) {
    console.error(`unsafe attribute name: ${name}`)
  }
  return (attrValidationCache[name] = !isUnsafe)
}

const propsToAttrMap = {
  acceptCharset: 'accept-charset',
  className: 'class',
  htmlFor: 'for',
  httpEquiv: 'http-equiv'
}

/**
 ,* CSS properties that accept plain numbers
 ,*/
const isNoUnitNumericStyleProp = /*#__PURE__*/ makeMap(
  `animation-iteration-count,border-image-outset,border-image-slice,` +
    `border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,` +
    `columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,` +
    `grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,` +
    `grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,` +
    `line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,` +
    // SVG
    `fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,` +
    `stroke-miterlimit,stroke-opacity,stroke-width`
)

/**
 ,* Known attributes, this is used for stringification of runtime static nodes
 ,* so that we don't stringify bindings that cannot be set from HTML.
 ,* Don't also forget to allow `data-*` and `aria-*`!
 ,* Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes
 ,*/
const isKnownHtmlAttr = /*#__PURE__*/ makeMap(
  `accept,accept-charset,accesskey,action,align,allow,alt,async,` +
    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +
    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +
    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +
    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +
    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +
    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +
    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +
    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +
    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +
    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +
    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +
    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +
    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +
    `value,width,wrap`
)

/**
 ,* Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute
 ,*/
const isKnownSvgAttr = /*#__PURE__*/ makeMap(
  `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,` +
    `arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,` +
    `baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,` +
    `clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,` +
    `color-interpolation-filters,color-profile,color-rendering,` +
    `contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,` +
    `descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,` +
    `dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,` +
    `fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,` +
    `font-family,font-size,font-size-adjust,font-stretch,font-style,` +
    `font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,` +
    `glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,` +
    `gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,` +
    `horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,` +
    `k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,` +
    `lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,` +
    `marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,` +
    `mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,` +
    `name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,` +
    `overflow,overline-position,overline-thickness,panose-1,paint-order,path,` +
    `pathLength,patternContentUnits,patternTransform,patternUnits,ping,` +
    `pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,` +
    `preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,` +
    `rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,` +
    `restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,` +
    `specularConstant,specularExponent,speed,spreadMethod,startOffset,` +
    `stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,` +
    `strikethrough-position,strikethrough-thickness,string,stroke,` +
    `stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,` +
    `stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,` +
    `systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,` +
    `text-decoration,text-rendering,textLength,to,transform,transform-origin,` +
    `type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,` +
    `unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,` +
    `v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,` +
    `vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,` +
    `writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,` +
    `xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,` +
    `xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`
)

#+end_src
#+end_details

#+html: <br>
#+begin_details normalizeProp :title-color green
#+name: normalizeProp
#+begin_src js -n -r

function normalizeStyle(value) { (ref:normalizeStyle)
  if (isArray(value)) {
    const res = {}
    for (let i = 0; i < value.length; i++) {
      const item = value[i]
      const normalized = isString(item)
        ? parseStringStyle(item)
        : normalizeStyle(item)
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key]
        }
      }
    }
    return res
  } else if (isString(value)) {
    return value
  } else if (isObject(value)) {
    return value
  }
}

const listDelimiterRE = /;(?![^(]*\))/g
const propertyDelimiterRE = /:(.+)/

function parseStringStyle(cssText) { (ref:parseStringStyle)
  const ret = {}
  cssText.split(listDelimiterRE).forEach(item => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE)
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim())
    }
  })
  return ret
}

function stringifyStyle(styles) { (ref:stringifyStyle)
  let ret = ''
  if (!styles || isString(styles)) {
    return ret
  }
  for (const key in styles) {
    const value = styles[key]
    const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key)
    if (
      isString(value) ||
      (typeof value === 'number' && isNoUnitNumericStyleProp(normalizedKey))
    ) {
      // only render valid values
      ret += `${normalizedKey}:${value};`
    }
  }
  return ret
}

function normalizeClass(value) { (ref:normalizeClass)
  let res = ''
  if (isString(value)) {
    res = value
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i])
      if (normalized) {
        res += normalized + ' '
      }
    }
  } else if (isObject(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + ' '
      }
    }
  }
  return res.trim()
}

function normalizeProps(props) { (ref:normalizeProps)
  if (!props) return null
  let { class: klass, style } = props
  if (klass && !isString(klass)) {
    props.class = normalizeClass(klass)
  }
  if (style) {
    props.style = normalizeStyle(style)
  }
  return props
}

#+end_src
#+end_details

#+html: <br>
#+begin_details escapeHtml :title-color green
#+name: escapeHtml
#+begin_src js -n -r
const escapeRE = /["'&<>]/

function escapeHtml(string) {
  const str = '' + string
  const match = escapeRE.exec(str)

  if (!match) {
    return str
  }

  let html = ''
  let escaped
  let index
  let lastIndex = 0
  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34: // "
        escaped = '&quot;'
        break
      case 38: // &
        escaped = '&amp;'
        break
      case 39: // '
        escaped = '&#39;'
        break
      case 60: // <
        escaped = '&lt;'
        break
      case 62: // >
        escaped = '&gt;'
        break
      default:
        continue
    }

    if (lastIndex !== index) {
      html += str.slice(lastIndex, index)
    }

    lastIndex = index + 1
    html += escaped
  }

  return lastIndex !== index ? html + str.slice(lastIndex, index) : html
}

// https://www.w3.org/TR/html52/syntax.html#comments
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g

function escapeHtmlComment(src) {
  return src.replace(commentStripRE, '')
}

#+end_src
#+end_details

#+html: <br>
#+begin_details toDisplayString :title-color green
#+name: toDisplayString
#+begin_src js -n -r
const toDisplayString = (val) => {
  return isString(val)
    ? val
    : val == null
    ? ''
    : isArray(val) ||
      (isObject(val) &&
        (val.toString === objectToString || !isFunction(val.toString)))
    ? JSON.stringify(val, replacer, 2)
    : String(val)
}

const replacer = (_key, val) => {
  // can't use isRef here since @vue/shared has no deps
  if (val && val.__v_isRef) {
    return replacer(_key, val.value)
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {
        ;entries[`${key} =>`] = val
        return entries
      }, {})
    }
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    }
  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
    return String(val)
  }
  return val
}

#+end_src
#+end_details
* COMMENT Local Variables       :ARCHIVE:
# Local Variables:
# after-save-hook: gcl/org-html-export-to-html
# End:
