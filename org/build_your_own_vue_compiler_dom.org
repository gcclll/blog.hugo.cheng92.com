:PROPERTIES:
:ID:       f17d718c-0d00-4c10-b3f9-e9e0d8295193
:END:
#+SETUPFILE:~/.gclrc/org/hugo_setup.org
#+HUGO_SLUG: build_your_own_vue_compiler_dom
#+HTML_HEAD: <meta name="category" content="vue"/>
#+HTML_HEAD: <meta name="tags" content="compiler-dom"/>
#+HTML_HEAD: <meta name="createdAt" content="2022-04-27 14:49:00"/>
#+PROPERTY: header-args :noweb no-export
#+TITLE: build your own vue compiler-dom
<badge: GCCLL | Homepage | green | / | gnu-emacs | tinder>

#+begin_box Vue3 compiler-dom :background-color green

[[https://www.cheng92.com/vue/vue-mind-map-compiler-dom/][Vue3 æºç å¤´è„‘é£æš´ä¹‹ 4 â˜compiler-dom - è‹¥å¶çŸ¥ç§‹]]

æ–‡ç« æœ€åæœ‰äº¤äº’å¼çš„[[testing][æµ‹è¯•æ–¹æ³•]]ï¼Œå¯è¾“å…¥æƒ³çœ‹çš„æ¨¡æ¿å¾—åˆ°å¯¹åº”çš„ render å‡½æ•°å’Œ AST ã€‚
#+end_box

#+html: <br>
#+begin_details compiler-core ä»£ç  :title-color green
[[https://blog.cheng92.com/posts/build_your_own_vue_compiler_core.html][build your own vue compiler-core]]

#+name: globalVars
#+include ../assets/tests/globalVars.js src js -n -r

#+name: compiler-core
#+include: ../assets/tests/compiler-core.js src js -n -r
#+end_details

* APIs

compiler-dom åŒ…åŒ…å«ä»¥ä¸‹ APIs è¿™ä¸ªåŒ…ä¸»è¦æ˜¯é’ˆå¯¹ä¸€äº›æŒ‡ä»¤è¿›è¡ŒåŠ å·¥å¤„ç†ï¼Œå¦‚ï¼š ~v-html~,
~v-text~ ç­‰ç­‰ã€‚

| name             | description                                      |
|------------------+--------------------------------------------------|
| [[transformStyleCD][transformStyle()]] | combine & normalize, result to object ~{a:b, c:d}~ |
| [[transformVHtml][transformVHtml()]] | v-html                                           |
| [[transformVText][transformVText()]] | v-text                                           |
| [[transformModel][transformModel()]] | v-model, transform bind value and event handler  |
| [[transformOn][transformOn()]]    | v-on, handle the event modifiers                 |
| [[transformShow][transformShow()]]  | v-show                                           |

code:

#+name: compiler-dom-export
#+begin_src js -n -r
const compilerDom = (function() {
  <<transformStyle>>
  <<transformVHtml>>
  <<transformVText>>
  <<transformModel>>
  <<transformOn>>
  <<transformShow>>
  <<stringifyStatic>>
  <<DOMDirectiveTransforms>>
  <<DOMNodeTransforms>>
  <<compile>>
  <<parse>>

  return {
    DOMNodeTransforms,
    DOMDirectiveTransforms,
    compile,
    parse,
    transformStyle,
  }
}())
#+end_src

#+name: compiler-dom
#+begin_src js -n -r
<<globalVars>>
<<compiler-core>>
<<compiler-dom-export>>
#+end_src

export to file:
#+html: <br>
#+begin_details compiler-dom :title-color red
#+begin_src js -n -r :noweb yes :tangle "~/github/mine/blog.cheng92.com/assets/tests/compiler-dom.js"
<<compiler-dom-export>>
#+end_src
#+end_details

* transforms

#+name: DOMDirectiveTransforms
#+begin_src js -n -r
const DOMDirectiveTransforms = {
  cloak: noopDirectiveTransform,
  html: transformVHtml,
  text: transformVText,
  model: transformModel, // override compiler-core
  on: transformOn, // override compiler-core
  show: transformShow
}
#+end_src

#+name: DOMNodeTransforms
#+begin_src js -n -r
const DOMNodeTransforms = [
  transformStyle,
  ...(__DEV__ ? [warnTransitionChildren] : [])
]
#+end_src

** style

compiler-dom ä¹‹å‰ï¼š

#+name: test-before-cd
#+begin_src js -n -r :exports both
<<compiler-core>>

const { baseCompile } = compilerCore
logOff()
const { code } = baseCompile('<div style="width:200px" :style="{height: `200px`}" />', { filename: 'foo.vue' })
logOn()
logg('<div style="width:200px" />', code)
#+end_src

å¯¹ style å±æ€§è¿›è¡ŒåŠ å·¥å¤„ç†ï¼Œå­—ç¬¦ä¸²æ‹†æˆå¯¹è±¡ï¼Œç„¶ååˆå¹¶åˆ°ï¼ŒåŒæ—¶æ”¯æŒå¤šç§ä½¿ç”¨æ–¹å¼

1. ~<div style="width:100px">~ => ~{width:'100px'}~
2. ~<div :style="{width:'100px'}">~ => ~{width:'100px'}~
3. ~<div :style="{width:'100px'} style="height:100px">~ => ~{width:'100px',height:'100px'}~

#+name: transformStyle
#+begin_src js -n -r

// Parse inline CSS strings for static style attributes into an object.
// This is a NodeTransform since it works on the static `style` attribute and
// converts it into a dynamic equivalent:
// style="color: red" -> :style='{ "color": "red" }'
// It is then processed by `transformElement` and included in the generated
// props.
const transformStyle = node => {
  if (node.type === NodeTypes.ELEMENT) {
    node.props.forEach((p, i) => {
      if (p.type === NodeTypes.ATTRIBUTE && p.name === 'style' && p.value) {
        // replace p with an expression node
        node.props[i] = {
          type: NodeTypes.DIRECTIVE,
          name: `bind`,
          arg: createSimpleExpression(`style`, true, p.loc),
          exp: parseInlineCSS(p.value.content, p.loc),
          modifiers: [],
          loc: p.loc
        }
      }
    })
  }
}

const parseInlineCSS = (cssText, loc) => {
  const normalized = parseStringStyle(cssText)
  return createSimpleExpression(
    JSON.stringify(normalized),
    false,
    loc,
    ConstantTypes.CAN_STRINGIFY
  )
}
#+end_src

[[(parseStringStyle)][parseStringStyle]] å°†å­—ç¬¦ä¸²è§£ææˆå¯¹è±¡ ~"width:100px"~ => ~{ width: '100px' }~

[[(stringifyStyle)][stringifyStyle]] å°†å¯¹è±¡è½¬æˆå­—ç¬¦ä¸² ~{ width: '100px' }~ => ~"width:100px"~

[[(normalizeStyle)][normalizeStyle]] è§£æ style çš„å€¼ï¼Œå¯èƒ½æ˜¯ ~"width:100px"~ æˆ– ~{width:'100px'}~ ä¹Ÿå¯ä»¥æ˜¯
~['width:100px', {height:'100px'}]~ çš„æ··åˆæ–¹å¼ï¼Œæœ€ç»ˆéƒ½ä¼šè¢«è§£ææˆå¯¹è±¡
~{width:'100px', height: '100px'}~ ã€‚

#+begin_src js -n -r :exports both
<<compiler-dom>>

const { parseStringStyle, stringifyStyle, normalizeStyle } = compilerDom
const { logg } = compilerCore
const pss = s => parseStringStyle(s)
let r = pss('width:100px;height:100px')
logg('parseStringStyle', r)
const sfs = s => stringifyStyle(s)
const s = sfs(r)
logg('stringifyStyle', s)
logg('normalizeStyle', normalizeStyle([r, s, 'font-size:12px', { 'line-height': 1.2 }]))
#+end_src

red:Testing

#+begin_src js -n -r :exports both
<<compiler-dom>>

const { compile } = compilerDom
logOff()
const { code } = compile('<div style="width:200px" :style="{height: `200px`}" />', { filename: 'foo.vue' })
logOn()
logg('<div style="width:200px" />', code)
#+end_src

æ³¨æ„ä¸ [[test-before-cd][å®ç° compiler-dom ä¹‹å‰æµ‹è¯•ç»“æœ]] å¯¹æ¯”ç»“æœï¼Œä¼šå‘ç°åè€…çš„ ~style~ éƒ½ä¼šè¢«è½¬æˆå¯¹
è±¡å½¢å¼ã€‚

ä¹‹å‰ï¼š
#+begin_src js
 style: _normalizeStyle([
   "width:200px",
   {height: `200px`}
 ])
#+end_src

ä¹‹åï¼š

#+begin_src js
style: _normalizeStyle([
  {"width":"200px"},
  {height: `200px`}
])
#+end_src

** v-html

#+name: transformVHtml
#+begin_src js -n -r
const transformVHtml = (dir, node, context) => {
  const { exp, loc } = dir
  if (!exp) {
    logg("v-html no exp")
  }
  if (node.children.length) {
    logg('v-html can not has children')
    node.children.length = 0
  }
  return {
    props: [
      createObjectProperty(
        createSimpleExpression(`innerHTML`, true, loc),
        exp || createSimpleExpression('', true)
      )
    ]
  }
}
#+end_src

red:Testing

before: ä¸ä¼šè¢«å¤„ç†
#+begin_src js -n -r :exports both
<<compiler-core>>
logOff()
const { code } = baseCompile("<div v-html='foo'><span/></div>", { filename: 'foo.vue' })
logOn()
logg('v-html', code)
#+end_src

after:

#+begin_src js -n -r :exports both
<<compiler-dom>>
logOff()
const { code } = compile("<div v-html='foo'><span/></div>", { filename: 'foo.vue' })
logOn()
logg('v-html', code)
#+end_src

æ³¨æ„çœ‹å‰åçš„ç»“æœï¼Œ compile-core é˜¶æ®µæ˜¯æ²¡æœ‰å¯¹ v-html è¿›è¡Œå¤„ç†çš„ï¼Œä¸” after ç»“æœä¸­
çš„ ~<span/>~ å·²ç»æ²¡æœ‰äº†ï¼Œä¸”å¢åŠ äº† ~{ innerHTML }~ å±æ€§ã€‚

** v-text

#+name: transformVText
#+begin_src js -n -r
const transformVText = (dir, node, context) => {
  const { exp, loc } = dir
  if (!exp) {
    logg('v-text no exp')
  }
  if (node.children.length) {
    logg('v-text can not have children')
    node.children.length = 0
  }
  return {
    props: [
      createObjectProperty(
        createSimpleExpression(`textContent`, true),
        exp
          ? createCallExpression(
              context.helperString(TO_DISPLAY_STRING),
              [exp],
              loc
            )
          : createSimpleExpression('', true)
      )
    ]
  }
}
#+end_src

red:Testing

before: compiler-core ä¸­ä¹Ÿæ²¡æœ‰å¯¹ v-text æŒ‡ä»¤çš„å¤„ç†

#+begin_src js -n -r :exports both
<<compiler-core>>
logOff()
const { code } = baseCompile("<div v-text='foo'><span/></div>", { filename: 'foo.vue' })
logOn()
logg('v-text', code)
#+end_src

after: ~<span/>~ æ‰€æœ‰å­èŠ‚ç‚¹éƒ½ä¼šè¢«åˆ é™¤ï¼Œå¢åŠ  ~{ textContent }~ å±æ€§ã€‚
#+begin_src js -n -r :exports both
<<compiler-dom>>
logOff()
const { code } = compile("<div v-text='foo'><span/></div>", { filename: 'foo.vue' })
logOn()
logg('v-text', code)
#+end_src

** v-model

#+name: transformModel
#+begin_src js -n -r
const transformModel = (dir, node, context) => {
  const baseResult = transformModel(dir, node, context)
  // base transform has errors OR component v-model (only need props)
  if (!baseResult.props.length || node.tagType === ElementTypes.COMPONENT) {
    return baseResult
  }

  if (dir.arg) {
    logg("transfromModel - X_V_MODEL_ARG_ON_ELEMENT")
  }

  function checkDuplicatedValue() {
    const value = findProp(node, 'value')
    if (value) {
      logg("transfromModel - X_V_MODEL_UNNECESSARY_VALUE")
    }
  }

  const { tag } = node
  const isCustomElement = context.isCustomElement(tag)
  if (
    tag === 'input' ||
    tag === 'textarea' ||
    tag === 'select' ||
    isCustomElement
  ) {
    let directiveToUse = V_MODEL_TEXT
    let isInvalidType = false
    if (tag === 'input' || isCustomElement) {
      const type = findProp(node, `type`)
      if (type) {
        if (type.type === NodeTypes.DIRECTIVE) {
          // :type="foo"
          directiveToUse = V_MODEL_DYNAMIC
        } else if (type.value) {
          switch (type.value.content) {
            case 'radio':
              directiveToUse = V_MODEL_RADIO
              break
            case 'checkbox':
              directiveToUse = V_MODEL_CHECKBOX
              break
            case 'file':
              isInvalidType = true
              logg("[DOM]transformModel - X_V_MODEL_ON_FILE_INPUT_ELEMENT")
              break
            default:
              // text type
              __DEV__ && checkDuplicatedValue()
              break
          }
        }
      } else if (hasDynamicKeyVBind(node)) {
        // element has bindings with dynamic keys, which can possibly contain
        // "type".
        directiveToUse = V_MODEL_DYNAMIC
      } else {
        // text type
        __DEV__ && checkDuplicatedValue()
      }
    } else if (tag === 'select') {
      directiveToUse = V_MODEL_SELECT
    } else {
      // textarea
      __DEV__ && checkDuplicatedValue()
    }
    // inject runtime directive
    // by returning the helper symbol via needRuntime
    // the import will replaced a resolveDirective call.
    if (!isInvalidType) {
      baseResult.needRuntime = context.helper(directiveToUse)
    }
  } else {
    logg("[DOM]transformModel - X_V_MODEL_ON_INVALID_ELEMENT")
  }

  // native vmodel doesn't need the `modelValue` props since they are also
  // passed to the runtime as `binding.value`. removing it reduces code size.
  baseResult.props = baseResult.props.filter(
    p =>
      !(
        p.key.type === NodeTypes.SIMPLE_EXPRESSION &&
        p.key.content === 'modelValue'
      )
  )

  return baseResult
}
#+end_src

1. åªå¤„ç† input, textarea, select æ–‡æœ¬æ¡†æ ‡ç­¾ï¼Œæˆ–è‡ªå®šä¹‰çš„æ ‡ç­¾

2. <input> æ ‡ç­¾ç±»å‹åˆ†ä¸º radio å’Œ checkbox å•å¤é€‰é¡¹æ¡†å¤„ç†ï¼Œä¸èƒ½ä½¿ç”¨ type='file' ç±»å‹

3. <select> ä¸‹æ‹‰é€‰é¡¹æ¡†çš„å¤„ç†

4. è¿‡æ»¤æ‰ transform ä¹‹åçš„ ~{modelValue: value, 'onUpdate:value': $event => value
   = $event}~ é‡Œé¢çš„ ~modelValueï¼švalue~ å±æ€§ï¼Œå› ä¸ºåœ¨ runtime-core æ—¶æœŸçš„
   [[withDirectives][withDirectives(]]) å¤„ç†é‡Œé¢ä¼šè¢«ç»‘å®šåˆ° value å±æ€§ä¸Š

red:Testing

before:

#+begin_src js -n -r :exports both
<<compiler-core>>

logOff()
const { code } = baseCompile("<input type='text' v-model='value' />", { filename: 'foo.vue' })
logOn()
log('v-model', code)
#+end_src

after: å¤šäº†ä¸€å±‚åŒ…è£… ~_withDirectives()~
#+begin_src js -n -r :exports both
<<compiler-dom>>

logOff()
const { code } = compile("<input type='text' v-model='value' />", { filename: 'foo.vue' })
logOn()
log('v-model', code)
#+end_src

é‚£æ¥çœ‹ä¸‹ ~_withDirectives()~ é‡Œé¢åšäº†ä»€ä¹ˆï¼Ÿ

#+name: withDirectives
#+begin_src js -n -r
function withDirectives(vnode, directives) {
  const internalInstance = currentRenderingInstance
  if (internalInstance === null) {
    return vnode
  }
  // å–å½“å‰åº”ç”¨å®ä¾‹
  const instance = getExposeProxy(internalInstance) || internalInstance.proxy
  const bindings = vnode.dirs || (vnode.dirs = [])
  for (let i = 0; i < directives.length; i++) {

    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i]
    if (isFunction(dir)) {
      dir = {
        mounted: dir,
        updated: dir
      }
    }
    if (dir.deep) {
      traverse(value)
    }
    bindings.push({
      dir,
      instance,
      value,
      oldValue: void 0,
      arg,
      modifiers
    })
  }
  return vnode
}
#+end_src
** v-on

#+name: transformOn
#+begin_src js -n -r
const isEventOptionModifier = /*#__PURE__*/ makeMap(`passive,once,capture`)
const isNonKeyModifier = /*#__PURE__*/ makeMap(
  // event propagation management
  `stop,prevent,self,` +
    // system modifiers + exact
    `ctrl,shift,alt,meta,exact,` +
    // mouse
    `middle`
)
// left & right could be mouse or key modifiers based on event type
const maybeKeyModifier = /*#__PURE__*/ makeMap('left,right')
const isKeyboardEvent = /*#__PURE__*/ makeMap(
  `onkeyup,onkeydown,onkeypress`,
  true
)

// å°†ä¿®é¥°ç¬¦åˆ†ç±»
const resolveModifiers = (key, modifiers, context, loc) => {
  const keyModifiers = []
  const nonKeyModifiers = []
  const eventOptionModifiers = []

  for (let i = 0; i < modifiers.length; i++) {
    const modifier = modifiers[i]

    if (isEventOptionModifier(modifier)) {
      // eventOptionModifiers: modifiers for addEventListener() options,
      // e.g. .passive & .capture
      eventOptionModifiers.push(modifier)
    } else {
      // runtimeModifiers: modifiers that needs runtime guards
      if (maybeKeyModifier(modifier)) {
        if (isStaticExp(key)) {
          if (isKeyboardEvent(key.content)) {
            keyModifiers.push(modifier)
          } else {
            nonKeyModifiers.push(modifier)
          }
        } else {
          keyModifiers.push(modifier)
          nonKeyModifiers.push(modifier)
        }
      } else {
        if (isNonKeyModifier(modifier)) {
          nonKeyModifiers.push(modifier)
        } else {
          keyModifiers.push(modifier)
        }
      }
    }
  }

  return {
    keyModifiers,
    nonKeyModifiers,
    eventOptionModifiers
  }
}

// åŸç”Ÿ click äº‹ä»¶
const transformClick = (key, event) => {
  const isStaticClick =
    isStaticExp(key) && key.content.toLowerCase() === 'onclick'
  return isStaticClick
    ? createSimpleExpression(event, true)
    : key.type !== NodeTypes.SIMPLE_EXPRESSION
    ? createCompoundExpression([
        `(`,
        key,
        `) === "onClick" ? "${event}" : (`,
        key,
        `)`
      ])
    : key
}

const transformOn = (dir, node, context) => {
  return transformOn(dir, node, context, baseResult => {
    const { modifiers } = dir
    if (!modifiers.length) return baseResult

    let { key, value: handlerExp } = baseResult.props[0]
    const { keyModifiers, nonKeyModifiers, eventOptionModifiers } =
      resolveModifiers(key, modifiers, context, dir.loc)

    // normalize click.right and click.middle since they don't actually fire
    if (nonKeyModifiers.includes('right')) { (ref:transformOn-right)
      key = transformClick(key, `onContextmenu`)
    }
    if (nonKeyModifiers.includes('middle')) {
      key = transformClick(key, `onMouseup`)
    }

    if (nonKeyModifiers.length) {
      handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
        handlerExp,
        JSON.stringify(nonKeyModifiers)
      ])
    }

    if (
      keyModifiers.length &&
      // if event name is dynamic, always wrap with keys guard
      (!isStaticExp(key) || isKeyboardEvent(key.content))
    ) {
      handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [
        handlerExp,
        JSON.stringify(keyModifiers)
      ])
    }

    if (eventOptionModifiers.length) {
      const modifierPostfix = eventOptionModifiers.map(capitalize).join('')
      key = isStaticExp(key)
        ? createSimpleExpression(`${key.content}${modifierPostfix}`, true)
        : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`])
    }

    return {
      props: [createObjectProperty(key, handlerExp)]
    }
  })
}
#+end_src

red:Testing

before: æ³¨æ„çœ‹ç»“æœä¼šå‘ç°ä¿®é¥°ç¬¦å¹¶æ²¡æœ‰å‡ºç°åœ¨ render å‡½æ•°ä¸­
#+begin_src js -n -r :exports both
<<compiler-core>>

logOff()
const { code } = baseCompile(`<div @click.enter.passive="handleClick" />`, { filename: 'foo.vue' })
logOn()
log('onclick', code)
#+end_src

after:
#+begin_src js -n -r :exports both
<<compiler-dom>>

logOff()
const { code } = compile(`<div @click.right.passive="handleClick" />`, { filename: 'foo.vue' })
logOn()
log('onclick', code)
#+end_src

1. right ä¿®é¥°ç¬¦ä¸‹çš„ click äº‹ä»¶è¢«è½¬æˆäº† ~onContextmenu~ å³é”®ç‚¹å‡»äº‹ä»¶
2. passive ä¿®é¥°ç¬¦ç›´æ¥è¢«è¿½åŠ åˆ°äº†äº‹ä»¶ key åé¢ ~onContextmenuPassive~, è¿™ä¹Ÿæ˜¯ vue ä¸­
   å¯¹ä¿®é¥°ç¬¦çš„å¤„ç†æ–¹å¼(å¦‚ï¼š ~@click.right.once~ => ~onContextmenuOnce~)


å½“æœ‰ä¿®é¥°ç¬¦çš„æ—¶å€™ä¼šä½¿ç”¨åˆ° withModifiers, æ¯ä¸ªä¿®é¥°ç¬¦éƒ½æœ‰è‡ªå·±å¯¹åº”çš„ä¸€ä¸ªå‡½æ•°ï¼Œåªæœ‰å½“
æ»¡è¶³æ¡ä»¶çš„æ‰ä¼šè®©äº‹ä»¶ç»§ç»­ï¼Œä¹Ÿå°±æ˜¯æœ€åçš„ ~fn(event, ...args)~ æ‰§è¡Œ:

#+begin_src typescript -n -r
const modifierGuards: Record<
  string,
  (e: Event, modifiers: string[]) => void | boolean
> = {
  stop: e => e.stopPropagation(),
  prevent: e => e.preventDefault(),
  self: e => e.target !== e.currentTarget,
  ctrl: e => !(e as KeyedEvent).ctrlKey,
  shift: e => !(e as KeyedEvent).shiftKey,
  alt: e => !(e as KeyedEvent).altKey,
  meta: e => !(e as KeyedEvent).metaKey,
  left: e => 'button' in e && (e as MouseEvent).button !== 0,
  middle: e => 'button' in e && (e as MouseEvent).button !== 1,
  right: e => 'button' in e && (e as MouseEvent).button !== 2,
  exact: (e, modifiers) =>
    systemModifiers.some(m => (e as any)[`${m}Key`] && !modifiers.includes(m))
}

const withModifiers = (fn: Function, modifiers: string[]) => {
  return (event: Event, ...args: unknown[]) => {
    for (let i = 0; i < modifiers.length; i++) {
      const guard = modifierGuards[modifiers[i]]
      if (guard && guard(event, modifiers)) return
    }
    return fn(event, ...args)
  }
}
#+end_src

#+begin_box å°ç»“
compiler-dom å¯¹ v-on æŒ‡ä»¤çš„å¤„ç†å°±æ˜¯å¯¹ä¿®é¥°ç¬¦çš„å¤„ç†ï¼Œå°†äº‹ä»¶å‡½æ•°è¿›è¡Œè½¬æ¢ï¼Œä½¿ç”¨
~withModifiers()~ è¿›è¡Œå°è£…ã€‚

ä¿®é¥°ç¬¦æœ‰ä¸‰ç±»ï¼š

1. äº‹ä»¶é€‰é¡¹kbd:passive,once,capture

   [[https://segmentfault.com/a/1190000017247263][passiveçš„ä½œç”¨å’ŒåŸç† - SegmentFault æ€å¦]]

   [[https://blog.techbridge.cc/2017/07/15/javascript-event-propagation/][DOM çš„äº‹ä»¶å‚³éæ©Ÿåˆ¶ï¼šæ•ç²èˆ‡å†’æ³¡]]

2. å†’æ³¡ç›¸å…³ kbd:stop,prevent,self, ç³»ç»Ÿç»„åˆé”® kbd:ctrl,shift,alt,meta,exact, é¼ 
   æ ‡æŒ‰é”® kbd:middle
3. <kbd:left, right> å¯èƒ½æ˜¯é¼ æ ‡ä¹Ÿå¯ä»¥æ˜¯é”®ç›˜ä¸Šçš„å·¦å³é”®


ä¿®é¥°ç¬¦å½±å“äº‹ä»¶ç±»å‹ï¼š

1. click.right è½¬æˆå³é”®èœå•é”® ~onContextmenu~
2. click.middle è½¬æˆé¼ æ ‡ä¸­é”® ~onMouseUp~
#+end_box

** v-show

v-show åœ¨è¿™é‡Œå¹¶æ²¡æœ‰çœŸæ­£çš„è¢«å¤„ç†åˆ°ï¼Œè€Œåœ¨ runtime è¿è¡Œæ—¶æ‰ä¼šè¢«å¤„ç†ï¼Œä¹Ÿå°±æ˜¯åé¢ä¼šå®Œ
æˆçš„ ~runtime-dom~ åŒ…é‡Œï¼Œå®ç°åŸç†å…¶å®å°±æ˜¯æ§åˆ¶å…ƒç´  ~display~ å±æ€§ï¼Œè¿™é‡Œåªæ˜¯å°†å…¶æ ‡è¯†äº†
ä¸‹éœ€è¦è¿è¡Œæ—¶å»å¤„ç†ã€‚

æ—§åšå®¢ä¸­æœ‰ç›¸å…³åˆ†æï¼š[[https://www.cheng92.com/vue/vue-mind-map-runtime-dom/#v-show][Vue3 æºç å¤´è„‘é£æš´ä¹‹ 8 â˜ runtime-dom - è‹¥å¶çŸ¥ç§‹]]

#+name: transformShow
#+begin_src js -n -r
const transformShow = (dir, node, context) => {
  const { exp, loc } = dir
  if (!exp) {
    logg('transformShow no exp.')
  }

  return {
    props: [],
    needRuntime: context.helper(V_SHOW)
  }
}
#+end_src

** stringifyStatic

åœ¨å¤„ç†é™æ€æå‡ä»£ç æ—¶éœ€è¦ç”¨åˆ° ~stringifyStatic~, å®ƒä¼šå°†é™æ€æå‡çš„èŠ‚ç‚¹ç›´æ¥å­—ç¬¦ä¸²åŒ–ï¼Œ
ç„¶ååˆ›å»ºä¸€ä¸ª off-dom èŠ‚ç‚¹æ¥ä¿å­˜å®ƒï¼Œç­‰åˆ°éœ€è¦ä½¿ç”¨çš„æ—¶å€™ç›´æ¥ä½¿ç”¨è¿™ä¸ª off-dom èŠ‚ç‚¹ã€‚

#+name: stringifyStatic
#+begin_src js -n -r
 const StringifyThresholds = {
   ELEMENT_WITH_BINDING_COUNT: 5,
   NODE_COUNT: 20
}

/**
 ,* Regex for replacing placeholders for embedded constant variables
 ,* (e.g. import URL string constants generated by compiler-sfc)
 ,*/
const expReplaceRE = /__VUE_EXP_START__(.*?)__VUE_EXP_END__/g

/**
 ,* Turn eligible hoisted static trees into stringified static nodes, e.g.
 ,*
 ,* ```js
 ,* const _hoisted_1 = createStaticVNode(`<div class="foo">bar</div>`)
 ,* ```
 ,*
 ,* A single static vnode can contain stringified content for **multiple**
 ,* consecutive nodes (element and plain text), called a "chunk".
 ,* `@vue/runtime-dom` will create the content via innerHTML in a hidden
 ,* container element and insert all the nodes in place. The call must also
 ,* provide the number of nodes contained in the chunk so that during hydration
 ,* we can know how many nodes the static vnode should adopt.
 ,*
 ,* The optimization scans a children list that contains hoisted nodes, and
 ,* tries to find the largest chunk of consecutive hoisted nodes before running
 ,* into a non-hoisted node or the end of the list. A chunk is then converted
 ,* into a single static vnode and replaces the hoisted expression of the first
 ,* node in the chunk. Other nodes in the chunk are considered "merged" and
 ,* therefore removed from both the hoist list and the children array.
 ,*
 ,* This optimization is only performed in Node.js.
 ,*/
const stringifyStatic = (children, context, parent) => {
  // bail stringification for slot content
  if (context.scopes.vSlot > 0) {
    return
  }

  let nc = 0 // current node count
  let ec = 0 // current element with binding count
  const currentChunk = []

  logg(`stringifyStatic - children.length = ${children.length}`)
  const stringifyCurrentChunk = (currentIndex) => {
    if (
      nc >= StringifyThresholds.NODE_COUNT ||
      ec >= StringifyThresholds.ELEMENT_WITH_BINDING_COUNT
    ) {
      logg(`stringifyCurrentChunk - index = ${currentIndex}`)
      // combine all currently eligible nodes into a single static vnode call
      const staticCall = createCallExpression(context.helper(CREATE_STATIC), [
        JSON.stringify(
          currentChunk.map(node => stringifyNode(node, context)).join('')
        ).replace(expReplaceRE, `" + $1 + "`),
        // the 2nd argument indicates the number of DOM nodes this static vnode
        // will insert / hydrate
        String(currentChunk.length)
      ])
      // replace the first node's hoisted expression with the static vnode call
      replaceHoist(currentChunk[0], staticCall, context)

      if (currentChunk.length > 1) {
        for (let i = 1; i < currentChunk.length; i++) {
          // for the merged nodes, set their hoisted expression to null
          replaceHoist(currentChunk[i], null, context)
        }

        // also remove merged nodes from children
        const deleteCount = currentChunk.length - 1
        children.splice(currentIndex - currentChunk.length + 1, deleteCount)
        return deleteCount
      }
    }
    return 0
  }

  let i = 0
  for (; i < children.length; i++) {
    const child = children[i]
    const hoisted = getHoistedNode(child)
    if (hoisted) {
      // presence of hoisted means child must be a stringifiable node
      const node = child
      const result = analyzeNode(node)
      if (result) {
        // node is stringifiable, record state
        nc += result[0]
        ec += result[1]
        currentChunk.push(node)
        continue
      }
    }
    // we only reach here if we ran into a node that is not stringifiable
    // check if currently analyzed nodes meet criteria for stringification.
    // adjust iteration index
    i -= stringifyCurrentChunk(i)
    // reset state
    nc = 0
    ec = 0
    currentChunk.length = 0
  }
  // in case the last node was also stringifiable
  stringifyCurrentChunk(i)
}

const getHoistedNode = (node) =>
  ((node.type === NodeTypes.ELEMENT && node.tagType === ElementTypes.ELEMENT) ||
    node.type == NodeTypes.TEXT_CALL) &&
  node.codegenNode &&
  node.codegenNode.type === NodeTypes.SIMPLE_EXPRESSION &&
  node.codegenNode.hoisted

const dataAriaRE = /^(data|aria)-/
const isStringifiableAttr = (name, ns) => {
  return (
    (ns === DOMNamespaces.HTML
      ? isKnownHtmlAttr(name)
      : ns === DOMNamespaces.SVG
      ? isKnownSvgAttr(name)
      : false) || dataAriaRE.test(name)
  )
}

const replaceHoist = (node,replacement,context) => {
  const hoistToReplace = node.codegenNode.hoisted
  context.hoists[context.hoists.indexOf(hoistToReplace)] = replacement
}

const isNonStringifiable = /*#__PURE__*/ makeMap(
  `caption,thead,tr,th,tbody,td,tfoot,colgroup,col`
)

/**
 ,* for a hoisted node, analyze it and return:
 ,* - false: bailed (contains non-stringifiable props or runtime constant)
 ,* - [nc, ec] where
 ,*   - nc is the number of nodes inside
 ,*   - ec is the number of element with bindings inside
 ,*/
function analyzeNode(node) {
  if (node.type === NodeTypes.ELEMENT && isNonStringifiable(node.tag)) {
    return false
  }

  if (node.type === NodeTypes.TEXT_CALL) {
    return [1, 0]
  }

  let nc = 1 // node count
  let ec = node.props.length > 0 ? 1 : 0 // element w/ binding count
  let bailed = false
  const bail = () => {
    bailed = true
    return false
  }

  // TODO: check for cases where using innerHTML will result in different
  // output compared to imperative node insertions.
  // probably only need to check for most common case
  // i.e. non-phrasing-content tags inside `<p>`
  function walk(node) {
    for (let i = 0; i < node.props.length; i++) {
      const p = node.props[i]
      // bail on non-attr bindings
      if (
        p.type === NodeTypes.ATTRIBUTE &&
        !isStringifiableAttr(p.name, node.ns)
      ) {
        return bail()
      }
      if (p.type === NodeTypes.DIRECTIVE && p.name === 'bind') {
        // bail on non-attr bindings
        if (
          p.arg &&
          (p.arg.type === NodeTypes.COMPOUND_EXPRESSION ||
            (p.arg.isStatic && !isStringifiableAttr(p.arg.content, node.ns)))
        ) {
          return bail()
        }
        if (
          p.exp &&
          (p.exp.type === NodeTypes.COMPOUND_EXPRESSION ||
            p.exp.constType < ConstantTypes.CAN_STRINGIFY)
        ) {
          return bail()
        }
      }
    }
    for (let i = 0; i < node.children.length; i++) {
      nc++
      const child = node.children[i]
      if (child.type === NodeTypes.ELEMENT) {
        if (child.props.length > 0) {
          ec++
        }
        walk(child)
        if (bailed) {
          return false
        }
      }
    }
    return true
  }

  return walk(node) ? [nc, ec] : false
}

function stringifyNode(node, context) {
  if (isString(node)) {
    return node
  }
  if (isSymbol(node)) {
    return ``
  }
  switch (node.type) {
    case NodeTypes.ELEMENT:
      return stringifyElement(node, context)
    case NodeTypes.TEXT:
      return escapeHtml(node.content)
    case NodeTypes.COMMENT:
      return `<!--${escapeHtml(node.content)}-->`
    case NodeTypes.INTERPOLATION:
      return escapeHtml(toDisplayString(evaluateConstant(node.content)))
    case NodeTypes.COMPOUND_EXPRESSION:
      return escapeHtml(evaluateConstant(node))
    case NodeTypes.TEXT_CALL:
      return stringifyNode(node.content, context)
    default:
      // static trees will not contain if/for nodes
      return ''
  }
}

function stringifyElement(node, context) {
  let res = `<${node.tag}`
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i]
    if (p.type === NodeTypes.ATTRIBUTE) {
      res += ` ${p.name}`
      if (p.value) {
        res += `="${escapeHtml(p.value.content)}"`
      }
    } else if (p.type === NodeTypes.DIRECTIVE && p.name === 'bind') {
      const exp = p.exp
      if (exp.content[0] === '_') {
        // internally generated string constant references
        // e.g. imported URL strings via compiler-sfc transformAssetUrl plugin
        res += ` ${p.arg.content}="__VUE_EXP_START__${
          exp.content
        }__VUE_EXP_END__"`
        continue
      }
      // constant v-bind, e.g. :foo="1"
      let evaluated = evaluateConstant(exp)
      if (evaluated != null) {
        const arg = p.arg && p.arg.content
        if (arg === 'class') {
          evaluated = normalizeClass(evaluated)
        } else if (arg === 'style') {
          evaluated = stringifyStyle(normalizeStyle(evaluated))
        }
        res += ` ${p.arg.content}="${escapeHtml(evaluated)}"`
      }
    }
  }
  if (context.scopeId) {
    res += ` ${context.scopeId}`
  }
  res += `>`
  for (let i = 0; i < node.children.length; i++) {
    res += stringifyNode(node.children[i], context)
  }
  if (!isVoidTag(node.tag)) {
    res += `</${node.tag}>`
  }
  return res
}

// __UNSAFE__
// Reason: eval.
// It's technically safe to eval because only constant expressions are possible
// here, e.g. `{{ 1 }}` or `{{ 'foo' }}`
// in addition, constant exps bail on presence of parens so you can't even
// run JSFuck in here. But we mark it unsafe for security review purposes.
// (see compiler-core/src/transformExpressions)
function evaluateConstant(exp) {
  if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {
    return new Function(`return ${exp.content}`)()
  } else {
    // compound
    let res = ``
    exp.children.forEach(c => {
      if (isString(c) || isSymbol(c)) {
        return
      }
      if (c.type === NodeTypes.TEXT) {
        res += c.content
      } else if (c.type === NodeTypes.INTERPOLATION) {
        res += toDisplayString(evaluateConstant(c.content))
      } else {
        res += evaluateConstant(c)
      }
    })
    return res
  }
}

#+end_src

red:Testing

#+name: stringifyStatic-test-utils
#+begin_src js -n -r
<<compiler-dom>>

function compileWithStringify(template) {
    return compile(template, {
      hoistStatic: true,
      prefixIdentifiers: true,
      transformHoist: stringifyStatic
    })
  }

  function repeat(code, n) {
    return new Array(n)
      .fill(0)
      .map(() => code)
      .join('')
  }
#+end_src

#+html: <br>
#+begin_details should bail on non-eligible static trees :title-color red
#+begin_src js -n -r :exports both
<<stringifyStatic-test-utils>>

logOff()
const { ast, code } = compileWithStringify(
  `<div><div><div>hello</div><div>hello</div></div></div>`
)
logOn()
logg('ast hoists', ast.hoists)
logg('code', code)
#+end_src
#+end_details

#+html: <br>
#+begin_details should work on eligible content (elements with binding > 5) :title-color red
#+begin_src js -n -r :exports both
<<stringifyStatic-test-utils>>

logOff()
const { ast, code } = compileWithStringify(
  `<div><div>${repeat(
        `<span class="foo"/>`,
        StringifyThresholds.ELEMENT_WITH_BINDING_COUNT
      )}</div></div><div></div>`
  //`<div><div><div>hello</div><div>hello</div></div></div>`
)
logOn()
logg('ast hoists', ast.hoists)
logg('code', code)
#+end_src
#+end_details

#+html: <br>
#+begin_details should work on eligible content (elements > 20) :title-color red
#+begin_src js -n -r :exports both
<<stringifyStatic-test-utils>>

logOff()
const { ast, code } = compileWithStringify(
  `<div><div>${repeat(
        `<span/>`,
        StringifyThresholds.NODE_COUNT
      )}</div></div>`
)
logOn()
logg('ast hoists', ast.hoists)
logg('code', code)
#+end_src
#+end_details

#+html: <br>
#+begin_details serializing constant bindings :title-color red
#+begin_src js -n -r :exports both
<<stringifyStatic-test-utils>>

logOff()
const { ast, code } = compileWithStringify(
  `<div><div :style="{ color: 'red' }">${repeat(
        `<span :class="[{ foo: true }, { bar: true }]">{{ 1 }} + {{ false }}</span>`,
        StringifyThresholds.ELEMENT_WITH_BINDING_COUNT
      )}</div></div>`
)
logOn()
logg('ast hoists', ast.hoists)
logg('code', code)
#+end_src
#+end_details

createStaticVNode:

#+begin_src typescript -n -r
function createStaticVNode(
  content: string,
  numberOfNodes: number
): VNode {
  // A static vnode can contain multiple stringified elements, and the number
  // of elements is necessary for hydration.
  const vnode = createVNode(Static, null, content)
  vnode.staticCount = numberOfNodes
  return vnode
}
#+end_src

* compile()

#+name: compile
#+begin_src js -n -r
function compile(template, options = {}) {
  return baseCompile(
    template,
    extend({}, parserOptions, options, {
      nodeTransforms: [
        // ignore <script> and <tag>
        // this is not put inside DOMNodeTransforms because that list is used
        // by compiler-ssr to generate vnode fallback branches
        ignoreSideEffectTags,
        ...DOMNodeTransforms,
        ...(options.nodeTransforms || [])
      ],
      directiveTransforms: extend(
        {},
        DOMDirectiveTransforms,
        options.directiveTransforms || {}
      ),
      transformHoist: __BROWSER__ ? null : stringifyStatic
    })
  )
}
#+end_src
* parse

#+name: parse
#+begin_src js -n -r
function parse(template, options = {}) {
  return baseParse(template, extend({}, parserOptions, options))
}
#+end_src
* testing

æ›´å¤šæµ‹è¯•([[https://github.com/vuejs/core/blob/main/packages/compiler-dom/__tests__/transforms/stringifyStatic.spec.ts][core/stringifyStatic.spec.ts at main Â· vuejs/core]])ï¼š

#+name: testing
#+begin_export html
<script src="/assets/tests/compiler-core.js"></script>
<script src="/assets/tests/compiler-dom.js"></script>
<div id="h1Mvr33k"></div>
<script src="/assets/js/vue-json-viewer/index.js"></script>
<script src="/assets/tests/h1Mvr33k.js"></script>
#+end_export

* Global Variables

#+html: <br>
#+begin_details global variables :title-color green
#+name: globalVars
#+begin_src js -n -r
<<namedChars>>
<<helpers-cd>>
<<dom-attrs>>
<<html-tags>>
<<normalizeProp>>
<<escapeHtml>>
<<toDisplayString>>

const noopDirectiveTransform = () => ({ props: [] })

const isRawTextContainer = /*#__PURE__*/ makeMap(
  'style,iframe,script,noscript',
  true
)

const DOMNamespaces = {
  HTML: Namespaces.HTML,
  SVG: 1,
  MATH_ML: 2
}

const parserOptions = {
  isVoidTag,
  isNativeTag: tag => isHTMLTag(tag) || isSVGTag(tag),
  isPreTag: tag => tag === 'pre',
  decodeEntities: __BROWSER__ ? decodeHtmlBrowser : decodeHtml,

  isBuiltInComponent: tag => {
    if (isBuiltInType(tag, `Transition`)) {
      return TRANSITION
    } else if (isBuiltInType(tag, `TransitionGroup`)) {
      return TRANSITION_GROUP
    }
  },

  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
  getNamespace(tag, parent) {
    let ns = parent ? parent.ns : DOMNamespaces.HTML

    if (parent && ns === DOMNamespaces.MATH_ML) {
      if (parent.tag === 'annotation-xml') {
        if (tag === 'svg') {
          return DOMNamespaces.SVG
        }
        if (
          parent.props.some(
            a =>
              a.type === NodeTypes.ATTRIBUTE &&
              a.name === 'encoding' &&
              a.value != null &&
              (a.value.content === 'text/html' ||
                a.value.content === 'application/xhtml+xml')
          )
        ) {
          ns = DOMNamespaces.HTML
        }
      } else if (
        /^m(?:[ions]|text)$/.test(parent.tag) &&
        tag !== 'mglyph' &&
        tag !== 'malignmark'
      ) {
        ns = DOMNamespaces.HTML
      }
    } else if (parent && ns === DOMNamespaces.SVG) {
      if (
        parent.tag === 'foreignObject' ||
        parent.tag === 'desc' ||
        parent.tag === 'title'
      ) {
        ns = DOMNamespaces.HTML
      }
    }

    if (ns === DOMNamespaces.HTML) {
      if (tag === 'svg') {
        return DOMNamespaces.SVG
      }
      if (tag === 'math') {
        return DOMNamespaces.MATH_ML
      }
    }
    return ns
  },

  // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
  getTextMode({ tag, ns }) {
    if (ns === DOMNamespaces.HTML) {
      if (tag === 'textarea' || tag === 'title') {
        return TextModes.RCDATA
      }
      if (isRawTextContainer(tag)) {
        return TextModes.RAWTEXT
      }
    }
    return TextModes.DATA
  }
}

function hasDynamicKeyVBind(node) {
  return node.props.some(
    p =>
      p.type === NodeTypes.DIRECTIVE &&
      p.name === 'bind' &&
      (!p.arg || // v-bind="obj"
        p.arg.type !== NodeTypes.SIMPLE_EXPRESSION || // v-bind:[_ctx.foo]
        !p.arg.isStatic) // v-bind:[foo]
  )
}


function hasMultipleChildren(node) {
  // #1352 filter out potential comment nodes.
  const children = (node.children = node.children.filter(
    c =>
      c.type !== NodeTypes.COMMENT &&
      !(c.type === NodeTypes.TEXT && !c.content.trim())
  ))
  const child = children[0]
  return (
    children.length !== 1 ||
    child.type === NodeTypes.FOR ||
    (child.type === NodeTypes.IF && child.branches.some(hasMultipleChildren))
  )
}

const warnTransitionChildren = (node, context) => {
  if (
    node.type === NodeTypes.ELEMENT &&
    node.tagType === ElementTypes.COMPONENT
  ) {
    const component = context.isBuiltInComponent(node.tag)
    if (component === TRANSITION) {
      return () => {
        if (node.children.length && hasMultipleChildren(node)) {
          console.warn(`X_TRANSITION_INVALID_CHILDREN`, node)
        }
      }
    }
  }
}


const ignoreSideEffectTags = (node, context) => {
  if (
    node.type === NodeTypes.ELEMENT &&
    node.tagType === ElementTypes.ELEMENT &&
    (node.tag === 'script' || node.tag === 'style')
  ) {
    console.warn(`X_IGNORED_SIDE_EFFECT_TAG`)
    context.removeNode()
  }
}
#+end_src
#+end_details

#+html: <br>
#+begin_details html-tags :title-color green
#+name: html-tags
#+begin_src js -n -r
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element
const HTML_TAGS =
  'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +
  'header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +
  'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +
  'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +
  'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +
  'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +
  'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +
  'option,output,progress,select,textarea,details,dialog,menu,' +
  'summary,template,blockquote,iframe,tfoot'

// https://developer.mozilla.org/en-US/docs/Web/SVG/Element
const SVG_TAGS =
  'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +
  'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +
  'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +
  'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +
  'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +
  'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +
  'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +
  'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +
  'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +
  'text,textPath,title,tspan,unknown,use,view'

const VOID_TAGS =
  'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr'

const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS)
/**
 ,* Compiler only.
 ,* Do NOT use in runtime code paths unless behind `__DEV__` flag.
 ,*/
const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS)
const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS)

#+end_src
#+end_details

#+html: <br>
#+begin_details helpers-cd :title-color  green
#+name: helpers-cd
#+begin_src js -n -r

const V_MODEL_RADIO = Symbol(__DEV__ ? `vModelRadio` : ``)
const V_MODEL_CHECKBOX = Symbol(__DEV__ ? `vModelCheckbox` : ``)
const V_MODEL_TEXT = Symbol(__DEV__ ? `vModelText` : ``)
const V_MODEL_SELECT = Symbol(__DEV__ ? `vModelSelect` : ``)
const V_MODEL_DYNAMIC = Symbol(__DEV__ ? `vModelDynamic` : ``)

const V_ON_WITH_MODIFIERS = Symbol(__DEV__ ? `vOnModifiersGuard` : ``)
const V_ON_WITH_KEYS = Symbol(__DEV__ ? `vOnKeysGuard` : ``)

const V_SHOW = Symbol(__DEV__ ? `vShow` : ``)

const TRANSITION = Symbol(__DEV__ ? `Transition` : ``)
const TRANSITION_GROUP = Symbol(__DEV__ ? `TransitionGroup` : ``)

registerRuntimeHelpers({
  [V_MODEL_RADIO]: `vModelRadio`,
  [V_MODEL_CHECKBOX]: `vModelCheckbox`,
  [V_MODEL_TEXT]: `vModelText`,
  [V_MODEL_SELECT]: `vModelSelect`,
  [V_MODEL_DYNAMIC]: `vModelDynamic`,
  [V_ON_WITH_MODIFIERS]: `withModifiers`,
  [V_ON_WITH_KEYS]: `withKeys`,
  [V_SHOW]: `vShow`,
  [TRANSITION]: `Transition`,
  [TRANSITION_GROUP]: `TransitionGroup`
})
#+end_src
#+end_details

#+html: <br>
#+begin_details namedChars :title-color green
#+name: namedChars
#+begin_src js -n -r
const namedCharacterReferences = {
  "GT": ">",
  "gt": ">",
  "LT": "<",
  "lt": "<",
  "ac;": "âˆ¾",
  "af;": "â¡",
  "AMP": "&",
  "amp": "&",
  "ap;": "â‰ˆ",
  "DD;": "â……",
  "dd;": "â…†",
  "deg": "Â°",
  "ee;": "â…‡",
  "eg;": "âªš",
  "el;": "âª™",
  "ETH": "Ã",
  "eth": "Ã°",
  "gE;": "â‰§",
  "ge;": "â‰¥",
  "Gg;": "â‹™",
  "gg;": "â‰«",
  "gl;": "â‰·",
  "GT;": ">",
  "Gt;": "â‰«",
  "gt;": ">",
  "ic;": "â£",
  "ii;": "â…ˆ",
  "Im;": "â„‘",
  "in;": "âˆˆ",
  "it;": "â¢",
  "lE;": "â‰¦",
  "le;": "â‰¤",
  "lg;": "â‰¶",
  "Ll;": "â‹˜",
  "ll;": "â‰ª",
  "LT;": "<",
  "Lt;": "â‰ª",
  "lt;": "<",
  "mp;": "âˆ“",
  "Mu;": "Îœ",
  "mu;": "Î¼",
  "ne;": "â‰ ",
  "ni;": "âˆ‹",
  "not": "Â¬",
  "Nu;": "Î",
  "nu;": "Î½",
  "Or;": "â©”",
  "or;": "âˆ¨",
  "oS;": "â“ˆ",
  "Pi;": "Î ",
  "pi;": "Ï€",
  "pm;": "Â±",
  "Pr;": "âª»",
  "pr;": "â‰º",
  "Re;": "â„œ",
  "REG": "Â®",
  "reg": "Â®",
  "rx;": "â„",
  "Sc;": "âª¼",
  "sc;": "â‰»",
  "shy": "Â­",
  "uml": "Â¨",
  "wp;": "â„˜",
  "wr;": "â‰€",
  "Xi;": "Î",
  "xi;": "Î¾",
  "yen": "Â¥",
  "acd;": "âˆ¿",
  "acE;": "âˆ¾Ì³",
  "Acy;": "Ğ",
  "acy;": "Ğ°",
  "Afr;": "ğ”„",
  "afr;": "ğ”",
  "AMP;": "&",
  "amp;": "&",
  "And;": "â©“",
  "and;": "âˆ§",
  "ang;": "âˆ ",
  "apE;": "â©°",
  "ape;": "â‰Š",
  "ast;": "*",
  "Auml": "Ã„",
  "auml": "Ã¤",
  "Bcy;": "Ğ‘",
  "bcy;": "Ğ±",
  "Bfr;": "ğ”…",
  "bfr;": "ğ”Ÿ",
  "bne;": "=âƒ¥",
  "bot;": "âŠ¥",
  "Cap;": "â‹’",
  "cap;": "âˆ©",
  "cent": "Â¢",
  "Cfr;": "â„­",
  "cfr;": "ğ” ",
  "Chi;": "Î§",
  "chi;": "Ï‡",
  "cir;": "â—‹",
  "COPY": "Â©",
  "copy": "Â©",
  "Cup;": "â‹“",
  "cup;": "âˆª",
  "Dcy;": "Ğ”",
  "dcy;": "Ğ´",
  "deg;": "Â°",
  "Del;": "âˆ‡",
  "Dfr;": "ğ”‡",
  "dfr;": "ğ”¡",
  "die;": "Â¨",
  "div;": "Ã·",
  "Dot;": "Â¨",
  "dot;": "Ë™",
  "Ecy;": "Ğ­",
  "ecy;": "Ñ",
  "Efr;": "ğ”ˆ",
  "efr;": "ğ”¢",
  "egs;": "âª–",
  "ell;": "â„“",
  "els;": "âª•",
  "ENG;": "ÅŠ",
  "eng;": "Å‹",
  "Eta;": "Î—",
  "eta;": "Î·",
  "ETH;": "Ã",
  "eth;": "Ã°",
  "Euml": "Ã‹",
  "euml": "Ã«",
  "Fcy;": "Ğ¤",
  "fcy;": "Ñ„",
  "Ffr;": "ğ”‰",
  "ffr;": "ğ”£",
  "gap;": "âª†",
  "Gcy;": "Ğ“",
  "gcy;": "Ğ³",
  "gEl;": "âªŒ",
  "gel;": "â‹›",
  "geq;": "â‰¥",
  "ges;": "â©¾",
  "Gfr;": "ğ”Š",
  "gfr;": "ğ”¤",
  "ggg;": "â‹™",
  "gla;": "âª¥",
  "glE;": "âª’",
  "glj;": "âª¤",
  "gnE;": "â‰©",
  "gne;": "âªˆ",
  "Hat;": "^",
  "Hfr;": "â„Œ",
  "hfr;": "ğ”¥",
  "Icy;": "Ğ˜",
  "icy;": "Ğ¸",
  "iff;": "â‡”",
  "Ifr;": "â„‘",
  "ifr;": "ğ”¦",
  "Int;": "âˆ¬",
  "int;": "âˆ«",
  "Iuml": "Ã",
  "iuml": "Ã¯",
  "Jcy;": "Ğ™",
  "jcy;": "Ğ¹",
  "Jfr;": "ğ”",
  "jfr;": "ğ”§",
  "Kcy;": "Ğš",
  "kcy;": "Ğº",
  "Kfr;": "ğ”",
  "kfr;": "ğ”¨",
  "lap;": "âª…",
  "lat;": "âª«",
  "Lcy;": "Ğ›",
  "lcy;": "Ğ»",
  "lEg;": "âª‹",
  "leg;": "â‹š",
  "leq;": "â‰¤",
  "les;": "â©½",
  "Lfr;": "ğ”",
  "lfr;": "ğ”©",
  "lgE;": "âª‘",
  "lnE;": "â‰¨",
  "lne;": "âª‡",
  "loz;": "â—Š",
  "lrm;": "â€",
  "Lsh;": "â†°",
  "lsh;": "â†°",
  "macr": "Â¯",
  "Map;": "â¤…",
  "map;": "â†¦",
  "Mcy;": "Ğœ",
  "mcy;": "Ğ¼",
  "Mfr;": "ğ”",
  "mfr;": "ğ”ª",
  "mho;": "â„§",
  "mid;": "âˆ£",
  "nap;": "â‰‰",
  "nbsp": "Â ",
  "Ncy;": "Ğ",
  "ncy;": "Ğ½",
  "Nfr;": "ğ”‘",
  "nfr;": "ğ”«",
  "ngE;": "â‰§Ì¸",
  "nge;": "â‰±",
  "nGg;": "â‹™Ì¸",
  "nGt;": "â‰«âƒ’",
  "ngt;": "â‰¯",
  "nis;": "â‹¼",
  "niv;": "âˆ‹",
  "nlE;": "â‰¦Ì¸",
  "nle;": "â‰°",
  "nLl;": "â‹˜Ì¸",
  "nLt;": "â‰ªâƒ’",
  "nlt;": "â‰®",
  "Not;": "â«¬",
  "not;": "Â¬",
  "npr;": "âŠ€",
  "nsc;": "âŠ",
  "num;": "#",
  "Ocy;": "Ğ",
  "ocy;": "Ğ¾",
  "Ofr;": "ğ”’",
  "ofr;": "ğ”¬",
  "ogt;": "â§",
  "ohm;": "Î©",
  "olt;": "â§€",
  "ord;": "â©",
  "ordf": "Âª",
  "ordm": "Âº",
  "orv;": "â©›",
  "Ouml": "Ã–",
  "ouml": "Ã¶",
  "par;": "âˆ¥",
  "para": "Â¶",
  "Pcy;": "ĞŸ",
  "pcy;": "Ğ¿",
  "Pfr;": "ğ”“",
  "pfr;": "ğ”­",
  "Phi;": "Î¦",
  "phi;": "Ï†",
  "piv;": "Ï–",
  "prE;": "âª³",
  "pre;": "âª¯",
  "Psi;": "Î¨",
  "psi;": "Ïˆ",
  "Qfr;": "ğ””",
  "qfr;": "ğ”®",
  "QUOT": "\"",
  "quot": "\"",
  "Rcy;": "Ğ ",
  "rcy;": "Ñ€",
  "REG;": "Â®",
  "reg;": "Â®",
  "Rfr;": "â„œ",
  "rfr;": "ğ”¯",
  "Rho;": "Î¡",
  "rho;": "Ï",
  "rlm;": "â€",
  "Rsh;": "â†±",
  "rsh;": "â†±",
  "scE;": "âª´",
  "sce;": "âª°",
  "Scy;": "Ğ¡",
  "scy;": "Ñ",
  "sect": "Â§",
  "Sfr;": "ğ”–",
  "sfr;": "ğ”°",
  "shy;": "Â­",
  "sim;": "âˆ¼",
  "smt;": "âªª",
  "sol;": "/",
  "squ;": "â–¡",
  "Sub;": "â‹",
  "sub;": "âŠ‚",
  "Sum;": "âˆ‘",
  "sum;": "âˆ‘",
  "Sup;": "â‹‘",
  "sup;": "âŠƒ",
  "sup1": "Â¹",
  "sup2": "Â²",
  "sup3": "Â³",
  "Tab;": "\t",
  "Tau;": "Î¤",
  "tau;": "Ï„",
  "Tcy;": "Ğ¢",
  "tcy;": "Ñ‚",
  "Tfr;": "ğ”—",
  "tfr;": "ğ”±",
  "top;": "âŠ¤",
  "Ucy;": "Ğ£",
  "ucy;": "Ñƒ",
  "Ufr;": "ğ”˜",
  "ufr;": "ğ”²",
  "uml;": "Â¨",
  "Uuml": "Ãœ",
  "uuml": "Ã¼",
  "Vcy;": "Ğ’",
  "vcy;": "Ğ²",
  "Vee;": "â‹",
  "vee;": "âˆ¨",
  "Vfr;": "ğ”™",
  "vfr;": "ğ”³",
  "Wfr;": "ğ”š",
  "wfr;": "ğ”´",
  "Xfr;": "ğ”›",
  "xfr;": "ğ”µ",
  "Ycy;": "Ğ«",
  "ycy;": "Ñ‹",
  "yen;": "Â¥",
  "Yfr;": "ğ”œ",
  "yfr;": "ğ”¶",
  "yuml": "Ã¿",
  "Zcy;": "Ğ—",
  "zcy;": "Ğ·",
  "Zfr;": "â„¨",
  "zfr;": "ğ”·",
  "zwj;": "â€",
  "Acirc": "Ã‚",
  "acirc": "Ã¢",
  "acute": "Â´",
  "AElig": "Ã†",
  "aelig": "Ã¦",
  "andd;": "â©œ",
  "andv;": "â©š",
  "ange;": "â¦¤",
  "Aopf;": "ğ”¸",
  "aopf;": "ğ•’",
  "apid;": "â‰‹",
  "apos;": "'",
  "Aring": "Ã…",
  "aring": "Ã¥",
  "Ascr;": "ğ’œ",
  "ascr;": "ğ’¶",
  "Auml;": "Ã„",
  "auml;": "Ã¤",
  "Barv;": "â«§",
  "bbrk;": "âµ",
  "Beta;": "Î’",
  "beta;": "Î²",
  "beth;": "â„¶",
  "bNot;": "â«­",
  "bnot;": "âŒ",
  "Bopf;": "ğ”¹",
  "bopf;": "ğ•“",
  "boxH;": "â•",
  "boxh;": "â”€",
  "boxV;": "â•‘",
  "boxv;": "â”‚",
  "Bscr;": "â„¬",
  "bscr;": "ğ’·",
  "bsim;": "âˆ½",
  "bsol;": "\\",
  "bull;": "â€¢",
  "bump;": "â‰",
  "caps;": "âˆ©ï¸€",
  "Cdot;": "ÄŠ",
  "cdot;": "Ä‹",
  "cedil": "Â¸",
  "cent;": "Â¢",
  "CHcy;": "Ğ§",
  "chcy;": "Ñ‡",
  "circ;": "Ë†",
  "cirE;": "â§ƒ",
  "cire;": "â‰—",
  "comp;": "âˆ",
  "cong;": "â‰…",
  "Copf;": "â„‚",
  "copf;": "ğ•”",
  "COPY;": "Â©",
  "copy;": "Â©",
  "Cscr;": "ğ’",
  "cscr;": "ğ’¸",
  "csub;": "â«",
  "csup;": "â«",
  "cups;": "âˆªï¸€",
  "Darr;": "â†¡",
  "dArr;": "â‡“",
  "darr;": "â†“",
  "dash;": "â€",
  "dHar;": "â¥¥",
  "diam;": "â‹„",
  "DJcy;": "Ğ‚",
  "djcy;": "Ñ’",
  "Dopf;": "ğ”»",
  "dopf;": "ğ••",
  "Dscr;": "ğ’Ÿ",
  "dscr;": "ğ’¹",
  "DScy;": "Ğ…",
  "dscy;": "Ñ•",
  "dsol;": "â§¶",
  "dtri;": "â–¿",
  "DZcy;": "Ğ",
  "dzcy;": "ÑŸ",
  "ecir;": "â‰–",
  "Ecirc": "ÃŠ",
  "ecirc": "Ãª",
  "Edot;": "Ä–",
  "eDot;": "â‰‘",
  "edot;": "Ä—",
  "emsp;": "â€ƒ",
  "ensp;": "â€‚",
  "Eopf;": "ğ”¼",
  "eopf;": "ğ•–",
  "epar;": "â‹•",
  "epsi;": "Îµ",
  "Escr;": "â„°",
  "escr;": "â„¯",
  "Esim;": "â©³",
  "esim;": "â‰‚",
  "Euml;": "Ã‹",
  "euml;": "Ã«",
  "euro;": "â‚¬",
  "excl;": "!",
  "flat;": "â™­",
  "fnof;": "Æ’",
  "Fopf;": "ğ”½",
  "fopf;": "ğ•—",
  "fork;": "â‹”",
  "Fscr;": "â„±",
  "fscr;": "ğ’»",
  "Gdot;": "Ä ",
  "gdot;": "Ä¡",
  "geqq;": "â‰§",
  "gesl;": "â‹›ï¸€",
  "GJcy;": "Ğƒ",
  "gjcy;": "Ñ“",
  "gnap;": "âªŠ",
  "gneq;": "âªˆ",
  "Gopf;": "ğ”¾",
  "gopf;": "ğ•˜",
  "Gscr;": "ğ’¢",
  "gscr;": "â„Š",
  "gsim;": "â‰³",
  "gtcc;": "âª§",
  "gvnE;": "â‰©ï¸€",
  "half;": "Â½",
  "hArr;": "â‡”",
  "harr;": "â†”",
  "hbar;": "â„",
  "Hopf;": "â„",
  "hopf;": "ğ•™",
  "Hscr;": "â„‹",
  "hscr;": "ğ’½",
  "Icirc": "Ã",
  "icirc": "Ã®",
  "Idot;": "Ä°",
  "IEcy;": "Ğ•",
  "iecy;": "Ğµ",
  "iexcl": "Â¡",
  "imof;": "âŠ·",
  "IOcy;": "Ğ",
  "iocy;": "Ñ‘",
  "Iopf;": "ğ•€",
  "iopf;": "ğ•š",
  "Iota;": "Î™",
  "iota;": "Î¹",
  "Iscr;": "â„",
  "iscr;": "ğ’¾",
  "isin;": "âˆˆ",
  "Iuml;": "Ã",
  "iuml;": "Ã¯",
  "Jopf;": "ğ•",
  "jopf;": "ğ•›",
  "Jscr;": "ğ’¥",
  "jscr;": "ğ’¿",
  "KHcy;": "Ğ¥",
  "khcy;": "Ñ…",
  "KJcy;": "ĞŒ",
  "kjcy;": "Ñœ",
  "Kopf;": "ğ•‚",
  "kopf;": "ğ•œ",
  "Kscr;": "ğ’¦",
  "kscr;": "ğ“€",
  "Lang;": "âŸª",
  "lang;": "âŸ¨",
  "laquo": "Â«",
  "Larr;": "â†",
  "lArr;": "â‡",
  "larr;": "â†",
  "late;": "âª­",
  "lcub;": "{",
  "ldca;": "â¤¶",
  "ldsh;": "â†²",
  "leqq;": "â‰¦",
  "lesg;": "â‹šï¸€",
  "lHar;": "â¥¢",
  "LJcy;": "Ğ‰",
  "ljcy;": "Ñ™",
  "lnap;": "âª‰",
  "lneq;": "âª‡",
  "Lopf;": "ğ•ƒ",
  "lopf;": "ğ•",
  "lozf;": "â§«",
  "lpar;": "(",
  "Lscr;": "â„’",
  "lscr;": "ğ“",
  "lsim;": "â‰²",
  "lsqb;": "[",
  "ltcc;": "âª¦",
  "ltri;": "â—ƒ",
  "lvnE;": "â‰¨ï¸€",
  "macr;": "Â¯",
  "male;": "â™‚",
  "malt;": "âœ ",
  "micro": "Âµ",
  "mlcp;": "â«›",
  "mldr;": "â€¦",
  "Mopf;": "ğ•„",
  "mopf;": "ğ•",
  "Mscr;": "â„³",
  "mscr;": "ğ“‚",
  "nang;": "âˆ âƒ’",
  "napE;": "â©°Ì¸",
  "nbsp;": "Â ",
  "ncap;": "â©ƒ",
  "ncup;": "â©‚",
  "ngeq;": "â‰±",
  "nges;": "â©¾Ì¸",
  "ngtr;": "â‰¯",
  "nGtv;": "â‰«Ì¸",
  "nisd;": "â‹º",
  "NJcy;": "ĞŠ",
  "njcy;": "Ñš",
  "nldr;": "â€¥",
  "nleq;": "â‰°",
  "nles;": "â©½Ì¸",
  "nLtv;": "â‰ªÌ¸",
  "nmid;": "âˆ¤",
  "Nopf;": "â„•",
  "nopf;": "ğ•Ÿ",
  "npar;": "âˆ¦",
  "npre;": "âª¯Ì¸",
  "nsce;": "âª°Ì¸",
  "Nscr;": "ğ’©",
  "nscr;": "ğ“ƒ",
  "nsim;": "â‰",
  "nsub;": "âŠ„",
  "nsup;": "âŠ…",
  "ntgl;": "â‰¹",
  "ntlg;": "â‰¸",
  "nvap;": "â‰âƒ’",
  "nvge;": "â‰¥âƒ’",
  "nvgt;": ">âƒ’",
  "nvle;": "â‰¤âƒ’",
  "nvlt;": "<âƒ’",
  "oast;": "âŠ›",
  "ocir;": "âŠš",
  "Ocirc": "Ã”",
  "ocirc": "Ã´",
  "odiv;": "â¨¸",
  "odot;": "âŠ™",
  "ogon;": "Ë›",
  "oint;": "âˆ®",
  "omid;": "â¦¶",
  "Oopf;": "ğ•†",
  "oopf;": "ğ• ",
  "opar;": "â¦·",
  "ordf;": "Âª",
  "ordm;": "Âº",
  "oror;": "â©–",
  "Oscr;": "ğ’ª",
  "oscr;": "â„´",
  "osol;": "âŠ˜",
  "Ouml;": "Ã–",
  "ouml;": "Ã¶",
  "para;": "Â¶",
  "part;": "âˆ‚",
  "perp;": "âŠ¥",
  "phiv;": "Ï•",
  "plus;": "+",
  "Popf;": "â„™",
  "popf;": "ğ•¡",
  "pound": "Â£",
  "prap;": "âª·",
  "prec;": "â‰º",
  "prnE;": "âªµ",
  "prod;": "âˆ",
  "prop;": "âˆ",
  "Pscr;": "ğ’«",
  "pscr;": "ğ“…",
  "qint;": "â¨Œ",
  "Qopf;": "â„š",
  "qopf;": "ğ•¢",
  "Qscr;": "ğ’¬",
  "qscr;": "ğ“†",
  "QUOT;": "\"",
  "quot;": "\"",
  "race;": "âˆ½Ì±",
  "Rang;": "âŸ«",
  "rang;": "âŸ©",
  "raquo": "Â»",
  "Rarr;": "â† ",
  "rArr;": "â‡’",
  "rarr;": "â†’",
  "rcub;": "}",
  "rdca;": "â¤·",
  "rdsh;": "â†³",
  "real;": "â„œ",
  "rect;": "â–­",
  "rHar;": "â¥¤",
  "rhov;": "Ï±",
  "ring;": "Ëš",
  "Ropf;": "â„",
  "ropf;": "ğ•£",
  "rpar;": ")",
  "Rscr;": "â„›",
  "rscr;": "ğ“‡",
  "rsqb;": "]",
  "rtri;": "â–¹",
  "scap;": "âª¸",
  "scnE;": "âª¶",
  "sdot;": "â‹…",
  "sect;": "Â§",
  "semi;": ";",
  "sext;": "âœ¶",
  "SHcy;": "Ğ¨",
  "shcy;": "Ñˆ",
  "sime;": "â‰ƒ",
  "simg;": "âª",
  "siml;": "âª",
  "smid;": "âˆ£",
  "smte;": "âª¬",
  "solb;": "â§„",
  "Sopf;": "ğ•Š",
  "sopf;": "ğ•¤",
  "spar;": "âˆ¥",
  "Sqrt;": "âˆš",
  "squf;": "â–ª",
  "Sscr;": "ğ’®",
  "sscr;": "ğ“ˆ",
  "Star;": "â‹†",
  "star;": "â˜†",
  "subE;": "â«…",
  "sube;": "âŠ†",
  "succ;": "â‰»",
  "sung;": "â™ª",
  "sup1;": "Â¹",
  "sup2;": "Â²",
  "sup3;": "Â³",
  "supE;": "â«†",
  "supe;": "âŠ‡",
  "szlig": "ÃŸ",
  "tbrk;": "â´",
  "tdot;": "âƒ›",
  "THORN": "Ã",
  "thorn": "Ã¾",
  "times": "Ã—",
  "tint;": "âˆ­",
  "toea;": "â¤¨",
  "Topf;": "ğ•‹",
  "topf;": "ğ•¥",
  "tosa;": "â¤©",
  "trie;": "â‰œ",
  "Tscr;": "ğ’¯",
  "tscr;": "ğ“‰",
  "TScy;": "Ğ¦",
  "tscy;": "Ñ†",
  "Uarr;": "â†Ÿ",
  "uArr;": "â‡‘",
  "uarr;": "â†‘",
  "Ucirc": "Ã›",
  "ucirc": "Ã»",
  "uHar;": "â¥£",
  "Uopf;": "ğ•Œ",
  "uopf;": "ğ•¦",
  "Upsi;": "Ï’",
  "upsi;": "Ï…",
  "Uscr;": "ğ’°",
  "uscr;": "ğ“Š",
  "utri;": "â–µ",
  "Uuml;": "Ãœ",
  "uuml;": "Ã¼",
  "vArr;": "â‡•",
  "varr;": "â†•",
  "Vbar;": "â««",
  "vBar;": "â«¨",
  "Vert;": "â€–",
  "vert;": "|",
  "Vopf;": "ğ•",
  "vopf;": "ğ•§",
  "Vscr;": "ğ’±",
  "vscr;": "ğ“‹",
  "Wopf;": "ğ•",
  "wopf;": "ğ•¨",
  "Wscr;": "ğ’²",
  "wscr;": "ğ“Œ",
  "xcap;": "â‹‚",
  "xcup;": "â‹ƒ",
  "xmap;": "âŸ¼",
  "xnis;": "â‹»",
  "Xopf;": "ğ•",
  "xopf;": "ğ•©",
  "Xscr;": "ğ’³",
  "xscr;": "ğ“",
  "xvee;": "â‹",
  "YAcy;": "Ğ¯",
  "yacy;": "Ñ",
  "YIcy;": "Ğ‡",
  "yicy;": "Ñ—",
  "Yopf;": "ğ•",
  "yopf;": "ğ•ª",
  "Yscr;": "ğ’´",
  "yscr;": "ğ“",
  "YUcy;": "Ğ®",
  "yucy;": "Ñ",
  "Yuml;": "Å¸",
  "yuml;": "Ã¿",
  "Zdot;": "Å»",
  "zdot;": "Å¼",
  "Zeta;": "Î–",
  "zeta;": "Î¶",
  "ZHcy;": "Ğ–",
  "zhcy;": "Ğ¶",
  "Zopf;": "â„¤",
  "zopf;": "ğ•«",
  "Zscr;": "ğ’µ",
  "zscr;": "ğ“",
  "zwnj;": "â€Œ",
  "Aacute": "Ã",
  "aacute": "Ã¡",
  "Acirc;": "Ã‚",
  "acirc;": "Ã¢",
  "acute;": "Â´",
  "AElig;": "Ã†",
  "aelig;": "Ã¦",
  "Agrave": "Ã€",
  "agrave": "Ã ",
  "aleph;": "â„µ",
  "Alpha;": "Î‘",
  "alpha;": "Î±",
  "Amacr;": "Ä€",
  "amacr;": "Ä",
  "amalg;": "â¨¿",
  "angle;": "âˆ ",
  "angrt;": "âˆŸ",
  "angst;": "Ã…",
  "Aogon;": "Ä„",
  "aogon;": "Ä…",
  "Aring;": "Ã…",
  "aring;": "Ã¥",
  "asymp;": "â‰ˆ",
  "Atilde": "Ãƒ",
  "atilde": "Ã£",
  "awint;": "â¨‘",
  "bcong;": "â‰Œ",
  "bdquo;": "â€",
  "bepsi;": "Ï¶",
  "blank;": "â£",
  "blk12;": "â–’",
  "blk14;": "â–‘",
  "blk34;": "â–“",
  "block;": "â–ˆ",
  "boxDL;": "â•—",
  "boxDl;": "â•–",
  "boxdL;": "â••",
  "boxdl;": "â”",
  "boxDR;": "â•”",
  "boxDr;": "â•“",
  "boxdR;": "â•’",
  "boxdr;": "â”Œ",
  "boxHD;": "â•¦",
  "boxHd;": "â•¤",
  "boxhD;": "â•¥",
  "boxhd;": "â”¬",
  "boxHU;": "â•©",
  "boxHu;": "â•§",
  "boxhU;": "â•¨",
  "boxhu;": "â”´",
  "boxUL;": "â•",
  "boxUl;": "â•œ",
  "boxuL;": "â•›",
  "boxul;": "â”˜",
  "boxUR;": "â•š",
  "boxUr;": "â•™",
  "boxuR;": "â•˜",
  "boxur;": "â””",
  "boxVH;": "â•¬",
  "boxVh;": "â•«",
  "boxvH;": "â•ª",
  "boxvh;": "â”¼",
  "boxVL;": "â•£",
  "boxVl;": "â•¢",
  "boxvL;": "â•¡",
  "boxvl;": "â”¤",
  "boxVR;": "â• ",
  "boxVr;": "â•Ÿ",
  "boxvR;": "â•",
  "boxvr;": "â”œ",
  "Breve;": "Ë˜",
  "breve;": "Ë˜",
  "brvbar": "Â¦",
  "bsemi;": "â",
  "bsime;": "â‹",
  "bsolb;": "â§…",
  "bumpE;": "âª®",
  "bumpe;": "â‰",
  "caret;": "â",
  "caron;": "Ë‡",
  "ccaps;": "â©",
  "Ccedil": "Ã‡",
  "ccedil": "Ã§",
  "Ccirc;": "Äˆ",
  "ccirc;": "Ä‰",
  "ccups;": "â©Œ",
  "cedil;": "Â¸",
  "check;": "âœ“",
  "clubs;": "â™£",
  "Colon;": "âˆ·",
  "colon;": ":",
  "comma;": ",",
  "crarr;": "â†µ",
  "Cross;": "â¨¯",
  "cross;": "âœ—",
  "csube;": "â«‘",
  "csupe;": "â«’",
  "ctdot;": "â‹¯",
  "cuepr;": "â‹",
  "cuesc;": "â‹Ÿ",
  "cupor;": "â©…",
  "curren": "Â¤",
  "cuvee;": "â‹",
  "cuwed;": "â‹",
  "cwint;": "âˆ±",
  "Dashv;": "â«¤",
  "dashv;": "âŠ£",
  "dblac;": "Ë",
  "ddarr;": "â‡Š",
  "Delta;": "Î”",
  "delta;": "Î´",
  "dharl;": "â‡ƒ",
  "dharr;": "â‡‚",
  "diams;": "â™¦",
  "disin;": "â‹²",
  "divide": "Ã·",
  "doteq;": "â‰",
  "dtdot;": "â‹±",
  "dtrif;": "â–¾",
  "duarr;": "â‡µ",
  "duhar;": "â¥¯",
  "Eacute": "Ã‰",
  "eacute": "Ã©",
  "Ecirc;": "ÃŠ",
  "ecirc;": "Ãª",
  "eDDot;": "â©·",
  "efDot;": "â‰’",
  "Egrave": "Ãˆ",
  "egrave": "Ã¨",
  "Emacr;": "Ä’",
  "emacr;": "Ä“",
  "empty;": "âˆ…",
  "Eogon;": "Ä˜",
  "eogon;": "Ä™",
  "eplus;": "â©±",
  "epsiv;": "Ïµ",
  "eqsim;": "â‰‚",
  "Equal;": "â©µ",
  "equiv;": "â‰¡",
  "erarr;": "â¥±",
  "erDot;": "â‰“",
  "esdot;": "â‰",
  "exist;": "âˆƒ",
  "fflig;": "ï¬€",
  "filig;": "ï¬",
  "fjlig;": "fj",
  "fllig;": "ï¬‚",
  "fltns;": "â–±",
  "forkv;": "â«™",
  "frac12": "Â½",
  "frac14": "Â¼",
  "frac34": "Â¾",
  "frasl;": "â„",
  "frown;": "âŒ¢",
  "Gamma;": "Î“",
  "gamma;": "Î³",
  "Gcirc;": "Äœ",
  "gcirc;": "Ä",
  "gescc;": "âª©",
  "gimel;": "â„·",
  "gneqq;": "â‰©",
  "gnsim;": "â‹§",
  "grave;": "`",
  "gsime;": "âª",
  "gsiml;": "âª",
  "gtcir;": "â©º",
  "gtdot;": "â‹—",
  "Hacek;": "Ë‡",
  "harrw;": "â†­",
  "Hcirc;": "Ä¤",
  "hcirc;": "Ä¥",
  "hoarr;": "â‡¿",
  "Iacute": "Ã",
  "iacute": "Ã­",
  "Icirc;": "Ã",
  "icirc;": "Ã®",
  "iexcl;": "Â¡",
  "Igrave": "ÃŒ",
  "igrave": "Ã¬",
  "iiint;": "âˆ­",
  "iiota;": "â„©",
  "IJlig;": "Ä²",
  "ijlig;": "Ä³",
  "Imacr;": "Äª",
  "imacr;": "Ä«",
  "image;": "â„‘",
  "imath;": "Ä±",
  "imped;": "Æµ",
  "infin;": "âˆ",
  "Iogon;": "Ä®",
  "iogon;": "Ä¯",
  "iprod;": "â¨¼",
  "iquest": "Â¿",
  "isinE;": "â‹¹",
  "isins;": "â‹´",
  "isinv;": "âˆˆ",
  "Iukcy;": "Ğ†",
  "iukcy;": "Ñ–",
  "Jcirc;": "Ä´",
  "jcirc;": "Äµ",
  "jmath;": "È·",
  "Jukcy;": "Ğ„",
  "jukcy;": "Ñ”",
  "Kappa;": "Îš",
  "kappa;": "Îº",
  "lAarr;": "â‡š",
  "langd;": "â¦‘",
  "laquo;": "Â«",
  "larrb;": "â‡¤",
  "lates;": "âª­ï¸€",
  "lBarr;": "â¤",
  "lbarr;": "â¤Œ",
  "lbbrk;": "â²",
  "lbrke;": "â¦‹",
  "lceil;": "âŒˆ",
  "ldquo;": "â€œ",
  "lescc;": "âª¨",
  "lhard;": "â†½",
  "lharu;": "â†¼",
  "lhblk;": "â–„",
  "llarr;": "â‡‡",
  "lltri;": "â—º",
  "lneqq;": "â‰¨",
  "lnsim;": "â‹¦",
  "loang;": "âŸ¬",
  "loarr;": "â‡½",
  "lobrk;": "âŸ¦",
  "lopar;": "â¦…",
  "lrarr;": "â‡†",
  "lrhar;": "â‡‹",
  "lrtri;": "âŠ¿",
  "lsime;": "âª",
  "lsimg;": "âª",
  "lsquo;": "â€˜",
  "ltcir;": "â©¹",
  "ltdot;": "â‹–",
  "ltrie;": "âŠ´",
  "ltrif;": "â—‚",
  "mdash;": "â€”",
  "mDDot;": "âˆº",
  "micro;": "Âµ",
  "middot": "Â·",
  "minus;": "âˆ’",
  "mumap;": "âŠ¸",
  "nabla;": "âˆ‡",
  "napid;": "â‰‹Ì¸",
  "napos;": "Å‰",
  "natur;": "â™®",
  "nbump;": "â‰Ì¸",
  "ncong;": "â‰‡",
  "ndash;": "â€“",
  "neArr;": "â‡—",
  "nearr;": "â†—",
  "nedot;": "â‰Ì¸",
  "nesim;": "â‰‚Ì¸",
  "ngeqq;": "â‰§Ì¸",
  "ngsim;": "â‰µ",
  "nhArr;": "â‡",
  "nharr;": "â†®",
  "nhpar;": "â«²",
  "nlArr;": "â‡",
  "nlarr;": "â†š",
  "nleqq;": "â‰¦Ì¸",
  "nless;": "â‰®",
  "nlsim;": "â‰´",
  "nltri;": "â‹ª",
  "notin;": "âˆ‰",
  "notni;": "âˆŒ",
  "npart;": "âˆ‚Ì¸",
  "nprec;": "âŠ€",
  "nrArr;": "â‡",
  "nrarr;": "â†›",
  "nrtri;": "â‹«",
  "nsime;": "â‰„",
  "nsmid;": "âˆ¤",
  "nspar;": "âˆ¦",
  "nsubE;": "â«…Ì¸",
  "nsube;": "âŠˆ",
  "nsucc;": "âŠ",
  "nsupE;": "â«†Ì¸",
  "nsupe;": "âŠ‰",
  "Ntilde": "Ã‘",
  "ntilde": "Ã±",
  "numsp;": "â€‡",
  "nvsim;": "âˆ¼âƒ’",
  "nwArr;": "â‡–",
  "nwarr;": "â†–",
  "Oacute": "Ã“",
  "oacute": "Ã³",
  "Ocirc;": "Ã”",
  "ocirc;": "Ã´",
  "odash;": "âŠ",
  "OElig;": "Å’",
  "oelig;": "Å“",
  "ofcir;": "â¦¿",
  "Ograve": "Ã’",
  "ograve": "Ã²",
  "ohbar;": "â¦µ",
  "olarr;": "â†º",
  "olcir;": "â¦¾",
  "oline;": "â€¾",
  "Omacr;": "ÅŒ",
  "omacr;": "Å",
  "Omega;": "Î©",
  "omega;": "Ï‰",
  "operp;": "â¦¹",
  "oplus;": "âŠ•",
  "orarr;": "â†»",
  "order;": "â„´",
  "Oslash": "Ã˜",
  "oslash": "Ã¸",
  "Otilde": "Ã•",
  "otilde": "Ãµ",
  "ovbar;": "âŒ½",
  "parsl;": "â«½",
  "phone;": "â˜",
  "plusb;": "âŠ",
  "pluse;": "â©²",
  "plusmn": "Â±",
  "pound;": "Â£",
  "prcue;": "â‰¼",
  "Prime;": "â€³",
  "prime;": "â€²",
  "prnap;": "âª¹",
  "prsim;": "â‰¾",
  "quest;": "?",
  "rAarr;": "â‡›",
  "radic;": "âˆš",
  "rangd;": "â¦’",
  "range;": "â¦¥",
  "raquo;": "Â»",
  "rarrb;": "â‡¥",
  "rarrc;": "â¤³",
  "rarrw;": "â†",
  "ratio;": "âˆ¶",
  "RBarr;": "â¤",
  "rBarr;": "â¤",
  "rbarr;": "â¤",
  "rbbrk;": "â³",
  "rbrke;": "â¦Œ",
  "rceil;": "âŒ‰",
  "rdquo;": "â€",
  "reals;": "â„",
  "rhard;": "â‡",
  "rharu;": "â‡€",
  "rlarr;": "â‡„",
  "rlhar;": "â‡Œ",
  "rnmid;": "â«®",
  "roang;": "âŸ­",
  "roarr;": "â‡¾",
  "robrk;": "âŸ§",
  "ropar;": "â¦†",
  "rrarr;": "â‡‰",
  "rsquo;": "â€™",
  "rtrie;": "âŠµ",
  "rtrif;": "â–¸",
  "sbquo;": "â€š",
  "sccue;": "â‰½",
  "Scirc;": "Åœ",
  "scirc;": "Å",
  "scnap;": "âªº",
  "scsim;": "â‰¿",
  "sdotb;": "âŠ¡",
  "sdote;": "â©¦",
  "seArr;": "â‡˜",
  "searr;": "â†˜",
  "setmn;": "âˆ–",
  "sharp;": "â™¯",
  "Sigma;": "Î£",
  "sigma;": "Ïƒ",
  "simeq;": "â‰ƒ",
  "simgE;": "âª ",
  "simlE;": "âªŸ",
  "simne;": "â‰†",
  "slarr;": "â†",
  "smile;": "âŒ£",
  "smtes;": "âª¬ï¸€",
  "sqcap;": "âŠ“",
  "sqcup;": "âŠ”",
  "sqsub;": "âŠ",
  "sqsup;": "âŠ",
  "srarr;": "â†’",
  "starf;": "â˜…",
  "strns;": "Â¯",
  "subnE;": "â«‹",
  "subne;": "âŠŠ",
  "supnE;": "â«Œ",
  "supne;": "âŠ‹",
  "swArr;": "â‡™",
  "swarr;": "â†™",
  "szlig;": "ÃŸ",
  "Theta;": "Î˜",
  "theta;": "Î¸",
  "thkap;": "â‰ˆ",
  "THORN;": "Ã",
  "thorn;": "Ã¾",
  "Tilde;": "âˆ¼",
  "tilde;": "Ëœ",
  "times;": "Ã—",
  "TRADE;": "â„¢",
  "trade;": "â„¢",
  "trisb;": "â§",
  "TSHcy;": "Ğ‹",
  "tshcy;": "Ñ›",
  "twixt;": "â‰¬",
  "Uacute": "Ãš",
  "uacute": "Ãº",
  "Ubrcy;": "Ğ",
  "ubrcy;": "Ñ",
  "Ucirc;": "Ã›",
  "ucirc;": "Ã»",
  "udarr;": "â‡…",
  "udhar;": "â¥®",
  "Ugrave": "Ã™",
  "ugrave": "Ã¹",
  "uharl;": "â†¿",
  "uharr;": "â†¾",
  "uhblk;": "â–€",
  "ultri;": "â—¸",
  "Umacr;": "Åª",
  "umacr;": "Å«",
  "Union;": "â‹ƒ",
  "Uogon;": "Å²",
  "uogon;": "Å³",
  "uplus;": "âŠ",
  "upsih;": "Ï’",
  "UpTee;": "âŠ¥",
  "Uring;": "Å®",
  "uring;": "Å¯",
  "urtri;": "â—¹",
  "utdot;": "â‹°",
  "utrif;": "â–´",
  "uuarr;": "â‡ˆ",
  "varpi;": "Ï–",
  "vBarv;": "â«©",
  "VDash;": "âŠ«",
  "Vdash;": "âŠ©",
  "vDash;": "âŠ¨",
  "vdash;": "âŠ¢",
  "veeeq;": "â‰š",
  "vltri;": "âŠ²",
  "vnsub;": "âŠ‚âƒ’",
  "vnsup;": "âŠƒâƒ’",
  "vprop;": "âˆ",
  "vrtri;": "âŠ³",
  "Wcirc;": "Å´",
  "wcirc;": "Åµ",
  "Wedge;": "â‹€",
  "wedge;": "âˆ§",
  "xcirc;": "â—¯",
  "xdtri;": "â–½",
  "xhArr;": "âŸº",
  "xharr;": "âŸ·",
  "xlArr;": "âŸ¸",
  "xlarr;": "âŸµ",
  "xodot;": "â¨€",
  "xrArr;": "âŸ¹",
  "xrarr;": "âŸ¶",
  "xutri;": "â–³",
  "Yacute": "Ã",
  "yacute": "Ã½",
  "Ycirc;": "Å¶",
  "ycirc;": "Å·",
  "Aacute;": "Ã",
  "aacute;": "Ã¡",
  "Abreve;": "Ä‚",
  "abreve;": "Äƒ",
  "Agrave;": "Ã€",
  "agrave;": "Ã ",
  "andand;": "â©•",
  "angmsd;": "âˆ¡",
  "angsph;": "âˆ¢",
  "apacir;": "â©¯",
  "approx;": "â‰ˆ",
  "Assign;": "â‰”",
  "Atilde;": "Ãƒ",
  "atilde;": "Ã£",
  "barvee;": "âŠ½",
  "Barwed;": "âŒ†",
  "barwed;": "âŒ…",
  "becaus;": "âˆµ",
  "bernou;": "â„¬",
  "bigcap;": "â‹‚",
  "bigcup;": "â‹ƒ",
  "bigvee;": "â‹",
  "bkarow;": "â¤",
  "bottom;": "âŠ¥",
  "bowtie;": "â‹ˆ",
  "boxbox;": "â§‰",
  "bprime;": "â€µ",
  "brvbar;": "Â¦",
  "bullet;": "â€¢",
  "Bumpeq;": "â‰",
  "bumpeq;": "â‰",
  "Cacute;": "Ä†",
  "cacute;": "Ä‡",
  "capand;": "â©„",
  "capcap;": "â©‹",
  "capcup;": "â©‡",
  "capdot;": "â©€",
  "Ccaron;": "ÄŒ",
  "ccaron;": "Ä",
  "Ccedil;": "Ã‡",
  "ccedil;": "Ã§",
  "circeq;": "â‰—",
  "cirmid;": "â«¯",
  "Colone;": "â©´",
  "colone;": "â‰”",
  "commat;": "@",
  "compfn;": "âˆ˜",
  "Conint;": "âˆ¯",
  "conint;": "âˆ®",
  "coprod;": "âˆ",
  "copysr;": "â„—",
  "cularr;": "â†¶",
  "CupCap;": "â‰",
  "cupcap;": "â©†",
  "cupcup;": "â©Š",
  "cupdot;": "âŠ",
  "curarr;": "â†·",
  "curren;": "Â¤",
  "cylcty;": "âŒ­",
  "Dagger;": "â€¡",
  "dagger;": "â€ ",
  "daleth;": "â„¸",
  "Dcaron;": "Ä",
  "dcaron;": "Ä",
  "dfisht;": "â¥¿",
  "divide;": "Ã·",
  "divonx;": "â‹‡",
  "dlcorn;": "âŒ",
  "dlcrop;": "âŒ",
  "dollar;": "$",
  "DotDot;": "âƒœ",
  "drcorn;": "âŒŸ",
  "drcrop;": "âŒŒ",
  "Dstrok;": "Ä",
  "dstrok;": "Ä‘",
  "Eacute;": "Ã‰",
  "eacute;": "Ã©",
  "easter;": "â©®",
  "Ecaron;": "Äš",
  "ecaron;": "Ä›",
  "ecolon;": "â‰•",
  "Egrave;": "Ãˆ",
  "egrave;": "Ã¨",
  "egsdot;": "âª˜",
  "elsdot;": "âª—",
  "emptyv;": "âˆ…",
  "emsp13;": "â€„",
  "emsp14;": "â€…",
  "eparsl;": "â§£",
  "eqcirc;": "â‰–",
  "equals;": "=",
  "equest;": "â‰Ÿ",
  "Exists;": "âˆƒ",
  "female;": "â™€",
  "ffilig;": "ï¬ƒ",
  "ffllig;": "ï¬„",
  "ForAll;": "âˆ€",
  "forall;": "âˆ€",
  "frac12;": "Â½",
  "frac13;": "â…“",
  "frac14;": "Â¼",
  "frac15;": "â…•",
  "frac16;": "â…™",
  "frac18;": "â…›",
  "frac23;": "â…”",
  "frac25;": "â…–",
  "frac34;": "Â¾",
  "frac35;": "â…—",
  "frac38;": "â…œ",
  "frac45;": "â…˜",
  "frac56;": "â…š",
  "frac58;": "â…",
  "frac78;": "â…",
  "gacute;": "Çµ",
  "Gammad;": "Ïœ",
  "gammad;": "Ï",
  "Gbreve;": "Ä",
  "gbreve;": "ÄŸ",
  "Gcedil;": "Ä¢",
  "gesdot;": "âª€",
  "gesles;": "âª”",
  "gtlPar;": "â¦•",
  "gtrarr;": "â¥¸",
  "gtrdot;": "â‹—",
  "gtrsim;": "â‰³",
  "hairsp;": "â€Š",
  "hamilt;": "â„‹",
  "HARDcy;": "Ğª",
  "hardcy;": "ÑŠ",
  "hearts;": "â™¥",
  "hellip;": "â€¦",
  "hercon;": "âŠ¹",
  "homtht;": "âˆ»",
  "horbar;": "â€•",
  "hslash;": "â„",
  "Hstrok;": "Ä¦",
  "hstrok;": "Ä§",
  "hybull;": "âƒ",
  "hyphen;": "â€",
  "Iacute;": "Ã",
  "iacute;": "Ã­",
  "Igrave;": "ÃŒ",
  "igrave;": "Ã¬",
  "iiiint;": "â¨Œ",
  "iinfin;": "â§œ",
  "incare;": "â„…",
  "inodot;": "Ä±",
  "intcal;": "âŠº",
  "iquest;": "Â¿",
  "isinsv;": "â‹³",
  "Itilde;": "Ä¨",
  "itilde;": "Ä©",
  "Jsercy;": "Ğˆ",
  "jsercy;": "Ñ˜",
  "kappav;": "Ï°",
  "Kcedil;": "Ä¶",
  "kcedil;": "Ä·",
  "kgreen;": "Ä¸",
  "Lacute;": "Ä¹",
  "lacute;": "Äº",
  "lagran;": "â„’",
  "Lambda;": "Î›",
  "lambda;": "Î»",
  "langle;": "âŸ¨",
  "larrfs;": "â¤",
  "larrhk;": "â†©",
  "larrlp;": "â†«",
  "larrpl;": "â¤¹",
  "larrtl;": "â†¢",
  "lAtail;": "â¤›",
  "latail;": "â¤™",
  "lbrace;": "{",
  "lbrack;": "[",
  "Lcaron;": "Ä½",
  "lcaron;": "Ä¾",
  "Lcedil;": "Ä»",
  "lcedil;": "Ä¼",
  "ldquor;": "â€",
  "lesdot;": "â©¿",
  "lesges;": "âª“",
  "lfisht;": "â¥¼",
  "lfloor;": "âŒŠ",
  "lharul;": "â¥ª",
  "llhard;": "â¥«",
  "Lmidot;": "Ä¿",
  "lmidot;": "Å€",
  "lmoust;": "â°",
  "loplus;": "â¨­",
  "lowast;": "âˆ—",
  "lowbar;": "_",
  "lparlt;": "â¦“",
  "lrhard;": "â¥­",
  "lsaquo;": "â€¹",
  "lsquor;": "â€š",
  "Lstrok;": "Å",
  "lstrok;": "Å‚",
  "lthree;": "â‹‹",
  "ltimes;": "â‹‰",
  "ltlarr;": "â¥¶",
  "ltrPar;": "â¦–",
  "mapsto;": "â†¦",
  "marker;": "â–®",
  "mcomma;": "â¨©",
  "midast;": "*",
  "midcir;": "â«°",
  "middot;": "Â·",
  "minusb;": "âŠŸ",
  "minusd;": "âˆ¸",
  "mnplus;": "âˆ“",
  "models;": "âŠ§",
  "mstpos;": "âˆ¾",
  "Nacute;": "Åƒ",
  "nacute;": "Å„",
  "nbumpe;": "â‰Ì¸",
  "Ncaron;": "Å‡",
  "ncaron;": "Åˆ",
  "Ncedil;": "Å…",
  "ncedil;": "Å†",
  "nearhk;": "â¤¤",
  "nequiv;": "â‰¢",
  "nesear;": "â¤¨",
  "nexist;": "âˆ„",
  "nltrie;": "â‹¬",
  "notinE;": "â‹¹Ì¸",
  "nparsl;": "â«½âƒ¥",
  "nprcue;": "â‹ ",
  "nrarrc;": "â¤³Ì¸",
  "nrarrw;": "â†Ì¸",
  "nrtrie;": "â‹­",
  "nsccue;": "â‹¡",
  "nsimeq;": "â‰„",
  "Ntilde;": "Ã‘",
  "ntilde;": "Ã±",
  "numero;": "â„–",
  "nVDash;": "âŠ¯",
  "nVdash;": "âŠ®",
  "nvDash;": "âŠ­",
  "nvdash;": "âŠ¬",
  "nvHarr;": "â¤„",
  "nvlArr;": "â¤‚",
  "nvrArr;": "â¤ƒ",
  "nwarhk;": "â¤£",
  "nwnear;": "â¤§",
  "Oacute;": "Ã“",
  "oacute;": "Ã³",
  "Odblac;": "Å",
  "odblac;": "Å‘",
  "odsold;": "â¦¼",
  "Ograve;": "Ã’",
  "ograve;": "Ã²",
  "ominus;": "âŠ–",
  "origof;": "âŠ¶",
  "Oslash;": "Ã˜",
  "oslash;": "Ã¸",
  "Otilde;": "Ã•",
  "otilde;": "Ãµ",
  "Otimes;": "â¨·",
  "otimes;": "âŠ—",
  "parsim;": "â«³",
  "percnt;": "%",
  "period;": ".",
  "permil;": "â€°",
  "phmmat;": "â„³",
  "planck;": "â„",
  "plankv;": "â„",
  "plusdo;": "âˆ”",
  "plusdu;": "â¨¥",
  "plusmn;": "Â±",
  "preceq;": "âª¯",
  "primes;": "â„™",
  "prnsim;": "â‹¨",
  "propto;": "âˆ",
  "prurel;": "âŠ°",
  "puncsp;": "â€ˆ",
  "qprime;": "â—",
  "Racute;": "Å”",
  "racute;": "Å•",
  "rangle;": "âŸ©",
  "rarrap;": "â¥µ",
  "rarrfs;": "â¤",
  "rarrhk;": "â†ª",
  "rarrlp;": "â†¬",
  "rarrpl;": "â¥…",
  "Rarrtl;": "â¤–",
  "rarrtl;": "â†£",
  "rAtail;": "â¤œ",
  "ratail;": "â¤š",
  "rbrace;": "}",
  "rbrack;": "]",
  "Rcaron;": "Å˜",
  "rcaron;": "Å™",
  "Rcedil;": "Å–",
  "rcedil;": "Å—",
  "rdquor;": "â€",
  "rfisht;": "â¥½",
  "rfloor;": "âŒ‹",
  "rharul;": "â¥¬",
  "rmoust;": "â±",
  "roplus;": "â¨®",
  "rpargt;": "â¦”",
  "rsaquo;": "â€º",
  "rsquor;": "â€™",
  "rthree;": "â‹Œ",
  "rtimes;": "â‹Š",
  "Sacute;": "Åš",
  "sacute;": "Å›",
  "Scaron;": "Å ",
  "scaron;": "Å¡",
  "Scedil;": "Å",
  "scedil;": "ÅŸ",
  "scnsim;": "â‹©",
  "searhk;": "â¤¥",
  "seswar;": "â¤©",
  "sfrown;": "âŒ¢",
  "SHCHcy;": "Ğ©",
  "shchcy;": "Ñ‰",
  "sigmaf;": "Ï‚",
  "sigmav;": "Ï‚",
  "simdot;": "â©ª",
  "smashp;": "â¨³",
  "SOFTcy;": "Ğ¬",
  "softcy;": "ÑŒ",
  "solbar;": "âŒ¿",
  "spades;": "â™ ",
  "sqcaps;": "âŠ“ï¸€",
  "sqcups;": "âŠ”ï¸€",
  "sqsube;": "âŠ‘",
  "sqsupe;": "âŠ’",
  "Square;": "â–¡",
  "square;": "â–¡",
  "squarf;": "â–ª",
  "ssetmn;": "âˆ–",
  "ssmile;": "âŒ£",
  "sstarf;": "â‹†",
  "subdot;": "âª½",
  "Subset;": "â‹",
  "subset;": "âŠ‚",
  "subsim;": "â«‡",
  "subsub;": "â«•",
  "subsup;": "â«“",
  "succeq;": "âª°",
  "supdot;": "âª¾",
  "Supset;": "â‹‘",
  "supset;": "âŠƒ",
  "supsim;": "â«ˆ",
  "supsub;": "â«”",
  "supsup;": "â«–",
  "swarhk;": "â¤¦",
  "swnwar;": "â¤ª",
  "target;": "âŒ–",
  "Tcaron;": "Å¤",
  "tcaron;": "Å¥",
  "Tcedil;": "Å¢",
  "tcedil;": "Å£",
  "telrec;": "âŒ•",
  "there4;": "âˆ´",
  "thetav;": "Ï‘",
  "thinsp;": "â€‰",
  "thksim;": "âˆ¼",
  "timesb;": "âŠ ",
  "timesd;": "â¨°",
  "topbot;": "âŒ¶",
  "topcir;": "â«±",
  "tprime;": "â€´",
  "tridot;": "â—¬",
  "Tstrok;": "Å¦",
  "tstrok;": "Å§",
  "Uacute;": "Ãš",
  "uacute;": "Ãº",
  "Ubreve;": "Å¬",
  "ubreve;": "Å­",
  "Udblac;": "Å°",
  "udblac;": "Å±",
  "ufisht;": "â¥¾",
  "Ugrave;": "Ã™",
  "ugrave;": "Ã¹",
  "ulcorn;": "âŒœ",
  "ulcrop;": "âŒ",
  "urcorn;": "âŒ",
  "urcrop;": "âŒ",
  "Utilde;": "Å¨",
  "utilde;": "Å©",
  "vangrt;": "â¦œ",
  "varphi;": "Ï•",
  "varrho;": "Ï±",
  "Vdashl;": "â«¦",
  "veebar;": "âŠ»",
  "vellip;": "â‹®",
  "Verbar;": "â€–",
  "verbar;": "|",
  "vsubnE;": "â«‹ï¸€",
  "vsubne;": "âŠŠï¸€",
  "vsupnE;": "â«Œï¸€",
  "vsupne;": "âŠ‹ï¸€",
  "Vvdash;": "âŠª",
  "wedbar;": "â©Ÿ",
  "wedgeq;": "â‰™",
  "weierp;": "â„˜",
  "wreath;": "â‰€",
  "xoplus;": "â¨",
  "xotime;": "â¨‚",
  "xsqcup;": "â¨†",
  "xuplus;": "â¨„",
  "xwedge;": "â‹€",
  "Yacute;": "Ã",
  "yacute;": "Ã½",
  "Zacute;": "Å¹",
  "zacute;": "Åº",
  "Zcaron;": "Å½",
  "zcaron;": "Å¾",
  "zeetrf;": "â„¨",
  "alefsym;": "â„µ",
  "angrtvb;": "âŠ¾",
  "angzarr;": "â¼",
  "asympeq;": "â‰",
  "backsim;": "âˆ½",
  "Because;": "âˆµ",
  "because;": "âˆµ",
  "bemptyv;": "â¦°",
  "between;": "â‰¬",
  "bigcirc;": "â—¯",
  "bigodot;": "â¨€",
  "bigstar;": "â˜…",
  "bnequiv;": "â‰¡âƒ¥",
  "boxplus;": "âŠ",
  "Cayleys;": "â„­",
  "Cconint;": "âˆ°",
  "ccupssm;": "â©",
  "Cedilla;": "Â¸",
  "cemptyv;": "â¦²",
  "cirscir;": "â§‚",
  "coloneq;": "â‰”",
  "congdot;": "â©­",
  "cudarrl;": "â¤¸",
  "cudarrr;": "â¤µ",
  "cularrp;": "â¤½",
  "curarrm;": "â¤¼",
  "dbkarow;": "â¤",
  "ddagger;": "â€¡",
  "ddotseq;": "â©·",
  "demptyv;": "â¦±",
  "Diamond;": "â‹„",
  "diamond;": "â‹„",
  "digamma;": "Ï",
  "dotplus;": "âˆ”",
  "DownTee;": "âŠ¤",
  "dwangle;": "â¦¦",
  "Element;": "âˆˆ",
  "Epsilon;": "Î•",
  "epsilon;": "Îµ",
  "eqcolon;": "â‰•",
  "equivDD;": "â©¸",
  "gesdoto;": "âª‚",
  "gtquest;": "â©¼",
  "gtrless;": "â‰·",
  "harrcir;": "â¥ˆ",
  "Implies;": "â‡’",
  "intprod;": "â¨¼",
  "isindot;": "â‹µ",
  "larrbfs;": "â¤Ÿ",
  "larrsim;": "â¥³",
  "lbrksld;": "â¦",
  "lbrkslu;": "â¦",
  "ldrdhar;": "â¥§",
  "LeftTee;": "âŠ£",
  "lesdoto;": "âª",
  "lessdot;": "â‹–",
  "lessgtr;": "â‰¶",
  "lesssim;": "â‰²",
  "lotimes;": "â¨´",
  "lozenge;": "â—Š",
  "ltquest;": "â©»",
  "luruhar;": "â¥¦",
  "maltese;": "âœ ",
  "minusdu;": "â¨ª",
  "napprox;": "â‰‰",
  "natural;": "â™®",
  "nearrow;": "â†—",
  "NewLine;": "\n",
  "nexists;": "âˆ„",
  "NoBreak;": "â ",
  "notinva;": "âˆ‰",
  "notinvb;": "â‹·",
  "notinvc;": "â‹¶",
  "NotLess;": "â‰®",
  "notniva;": "âˆŒ",
  "notnivb;": "â‹¾",
  "notnivc;": "â‹½",
  "npolint;": "â¨”",
  "npreceq;": "âª¯Ì¸",
  "nsqsube;": "â‹¢",
  "nsqsupe;": "â‹£",
  "nsubset;": "âŠ‚âƒ’",
  "nsucceq;": "âª°Ì¸",
  "nsupset;": "âŠƒâƒ’",
  "nvinfin;": "â§",
  "nvltrie;": "âŠ´âƒ’",
  "nvrtrie;": "âŠµâƒ’",
  "nwarrow;": "â†–",
  "olcross;": "â¦»",
  "Omicron;": "ÎŸ",
  "omicron;": "Î¿",
  "orderof;": "â„´",
  "orslope;": "â©—",
  "OverBar;": "â€¾",
  "pertenk;": "â€±",
  "planckh;": "â„",
  "pluscir;": "â¨¢",
  "plussim;": "â¨¦",
  "plustwo;": "â¨§",
  "precsim;": "â‰¾",
  "Product;": "âˆ",
  "quatint;": "â¨–",
  "questeq;": "â‰Ÿ",
  "rarrbfs;": "â¤ ",
  "rarrsim;": "â¥´",
  "rbrksld;": "â¦",
  "rbrkslu;": "â¦",
  "rdldhar;": "â¥©",
  "realine;": "â„›",
  "rotimes;": "â¨µ",
  "ruluhar;": "â¥¨",
  "searrow;": "â†˜",
  "simplus;": "â¨¤",
  "simrarr;": "â¥²",
  "subedot;": "â«ƒ",
  "submult;": "â«",
  "subplus;": "âª¿",
  "subrarr;": "â¥¹",
  "succsim;": "â‰¿",
  "supdsub;": "â«˜",
  "supedot;": "â«„",
  "suphsol;": "âŸ‰",
  "suphsub;": "â«—",
  "suplarr;": "â¥»",
  "supmult;": "â«‚",
  "supplus;": "â«€",
  "swarrow;": "â†™",
  "topfork;": "â«š",
  "triplus;": "â¨¹",
  "tritime;": "â¨»",
  "UpArrow;": "â†‘",
  "Uparrow;": "â‡‘",
  "uparrow;": "â†‘",
  "Upsilon;": "Î¥",
  "upsilon;": "Ï…",
  "uwangle;": "â¦§",
  "vzigzag;": "â¦š",
  "zigrarr;": "â‡",
  "andslope;": "â©˜",
  "angmsdaa;": "â¦¨",
  "angmsdab;": "â¦©",
  "angmsdac;": "â¦ª",
  "angmsdad;": "â¦«",
  "angmsdae;": "â¦¬",
  "angmsdaf;": "â¦­",
  "angmsdag;": "â¦®",
  "angmsdah;": "â¦¯",
  "angrtvbd;": "â¦",
  "approxeq;": "â‰Š",
  "awconint;": "âˆ³",
  "backcong;": "â‰Œ",
  "barwedge;": "âŒ…",
  "bbrktbrk;": "â¶",
  "bigoplus;": "â¨",
  "bigsqcup;": "â¨†",
  "biguplus;": "â¨„",
  "bigwedge;": "â‹€",
  "boxminus;": "âŠŸ",
  "boxtimes;": "âŠ ",
  "bsolhsub;": "âŸˆ",
  "capbrcup;": "â©‰",
  "circledR;": "Â®",
  "circledS;": "â“ˆ",
  "cirfnint;": "â¨",
  "clubsuit;": "â™£",
  "cupbrcap;": "â©ˆ",
  "curlyvee;": "â‹",
  "cwconint;": "âˆ²",
  "DDotrahd;": "â¤‘",
  "doteqdot;": "â‰‘",
  "DotEqual;": "â‰",
  "dotminus;": "âˆ¸",
  "drbkarow;": "â¤",
  "dzigrarr;": "âŸ¿",
  "elinters;": "â§",
  "emptyset;": "âˆ…",
  "eqvparsl;": "â§¥",
  "fpartint;": "â¨",
  "geqslant;": "â©¾",
  "gesdotol;": "âª„",
  "gnapprox;": "âªŠ",
  "hksearow;": "â¤¥",
  "hkswarow;": "â¤¦",
  "imagline;": "â„",
  "imagpart;": "â„‘",
  "infintie;": "â§",
  "integers;": "â„¤",
  "Integral;": "âˆ«",
  "intercal;": "âŠº",
  "intlarhk;": "â¨—",
  "laemptyv;": "â¦´",
  "ldrushar;": "â¥‹",
  "leqslant;": "â©½",
  "lesdotor;": "âªƒ",
  "LessLess;": "âª¡",
  "llcorner;": "âŒ",
  "lnapprox;": "âª‰",
  "lrcorner;": "âŒŸ",
  "lurdshar;": "â¥Š",
  "mapstoup;": "â†¥",
  "multimap;": "âŠ¸",
  "naturals;": "â„•",
  "ncongdot;": "â©­Ì¸",
  "NotEqual;": "â‰ ",
  "notindot;": "â‹µÌ¸",
  "NotTilde;": "â‰",
  "otimesas;": "â¨¶",
  "parallel;": "âˆ¥",
  "PartialD;": "âˆ‚",
  "plusacir;": "â¨£",
  "pointint;": "â¨•",
  "Precedes;": "â‰º",
  "precneqq;": "âªµ",
  "precnsim;": "â‹¨",
  "profalar;": "âŒ®",
  "profline;": "âŒ’",
  "profsurf;": "âŒ“",
  "raemptyv;": "â¦³",
  "realpart;": "â„œ",
  "RightTee;": "âŠ¢",
  "rppolint;": "â¨’",
  "rtriltri;": "â§",
  "scpolint;": "â¨“",
  "setminus;": "âˆ–",
  "shortmid;": "âˆ£",
  "smeparsl;": "â§¤",
  "sqsubset;": "âŠ",
  "sqsupset;": "âŠ",
  "subseteq;": "âŠ†",
  "Succeeds;": "â‰»",
  "succneqq;": "âª¶",
  "succnsim;": "â‹©",
  "SuchThat;": "âˆ‹",
  "Superset;": "âŠƒ",
  "supseteq;": "âŠ‡",
  "thetasym;": "Ï‘",
  "thicksim;": "âˆ¼",
  "timesbar;": "â¨±",
  "triangle;": "â–µ",
  "triminus;": "â¨º",
  "trpezium;": "â¢",
  "Uarrocir;": "â¥‰",
  "ulcorner;": "âŒœ",
  "UnderBar;": "_",
  "urcorner;": "âŒ",
  "varkappa;": "Ï°",
  "varsigma;": "Ï‚",
  "vartheta;": "Ï‘",
  "backprime;": "â€µ",
  "backsimeq;": "â‹",
  "Backslash;": "âˆ–",
  "bigotimes;": "â¨‚",
  "CenterDot;": "Â·",
  "centerdot;": "Â·",
  "checkmark;": "âœ“",
  "CircleDot;": "âŠ™",
  "complexes;": "â„‚",
  "Congruent;": "â‰¡",
  "Coproduct;": "âˆ",
  "dotsquare;": "âŠ¡",
  "DoubleDot;": "Â¨",
  "DownArrow;": "â†“",
  "Downarrow;": "â‡“",
  "downarrow;": "â†“",
  "DownBreve;": "Ì‘",
  "gtrapprox;": "âª†",
  "gtreqless;": "â‹›",
  "gvertneqq;": "â‰©ï¸€",
  "heartsuit;": "â™¥",
  "HumpEqual;": "â‰",
  "LeftArrow;": "â†",
  "Leftarrow;": "â‡",
  "leftarrow;": "â†",
  "LeftFloor;": "âŒŠ",
  "lesseqgtr;": "â‹š",
  "LessTilde;": "â‰²",
  "lvertneqq;": "â‰¨ï¸€",
  "Mellintrf;": "â„³",
  "MinusPlus;": "âˆ“",
  "ngeqslant;": "â©¾Ì¸",
  "nleqslant;": "â©½Ì¸",
  "NotCupCap;": "â‰­",
  "NotExists;": "âˆ„",
  "NotSubset;": "âŠ‚âƒ’",
  "nparallel;": "âˆ¦",
  "nshortmid;": "âˆ¤",
  "nsubseteq;": "âŠˆ",
  "nsupseteq;": "âŠ‰",
  "OverBrace;": "â",
  "pitchfork;": "â‹”",
  "PlusMinus;": "Â±",
  "rationals;": "â„š",
  "spadesuit;": "â™ ",
  "subseteqq;": "â«…",
  "subsetneq;": "âŠŠ",
  "supseteqq;": "â«†",
  "supsetneq;": "âŠ‹",
  "Therefore;": "âˆ´",
  "therefore;": "âˆ´",
  "ThinSpace;": "â€‰",
  "triangleq;": "â‰œ",
  "TripleDot;": "âƒ›",
  "UnionPlus;": "âŠ",
  "varpropto;": "âˆ",
  "Bernoullis;": "â„¬",
  "circledast;": "âŠ›",
  "CirclePlus;": "âŠ•",
  "complement;": "âˆ",
  "curlywedge;": "â‹",
  "eqslantgtr;": "âª–",
  "EqualTilde;": "â‰‚",
  "Fouriertrf;": "â„±",
  "gtreqqless;": "âªŒ",
  "ImaginaryI;": "â…ˆ",
  "Laplacetrf;": "â„’",
  "LeftVector;": "â†¼",
  "lessapprox;": "âª…",
  "lesseqqgtr;": "âª‹",
  "Lleftarrow;": "â‡š",
  "lmoustache;": "â°",
  "longmapsto;": "âŸ¼",
  "mapstodown;": "â†§",
  "mapstoleft;": "â†¤",
  "nLeftarrow;": "â‡",
  "nleftarrow;": "â†š",
  "NotElement;": "âˆ‰",
  "NotGreater;": "â‰¯",
  "nsubseteqq;": "â«…Ì¸",
  "nsupseteqq;": "â«†Ì¸",
  "precapprox;": "âª·",
  "Proportion;": "âˆ·",
  "RightArrow;": "â†’",
  "Rightarrow;": "â‡’",
  "rightarrow;": "â†’",
  "RightFloor;": "âŒ‹",
  "rmoustache;": "â±",
  "sqsubseteq;": "âŠ‘",
  "sqsupseteq;": "âŠ’",
  "subsetneqq;": "â«‹",
  "succapprox;": "âª¸",
  "supsetneqq;": "â«Œ",
  "ThickSpace;": "âŸâ€Š",
  "TildeEqual;": "â‰ƒ",
  "TildeTilde;": "â‰ˆ",
  "UnderBrace;": "âŸ",
  "UpArrowBar;": "â¤’",
  "UpTeeArrow;": "â†¥",
  "upuparrows;": "â‡ˆ",
  "varepsilon;": "Ïµ",
  "varnothing;": "âˆ…",
  "backepsilon;": "Ï¶",
  "blacksquare;": "â–ª",
  "circledcirc;": "âŠš",
  "circleddash;": "âŠ",
  "CircleMinus;": "âŠ–",
  "CircleTimes;": "âŠ—",
  "curlyeqprec;": "â‹",
  "curlyeqsucc;": "â‹Ÿ",
  "diamondsuit;": "â™¦",
  "eqslantless;": "âª•",
  "Equilibrium;": "â‡Œ",
  "expectation;": "â„°",
  "GreaterLess;": "â‰·",
  "LeftCeiling;": "âŒˆ",
  "LessGreater;": "â‰¶",
  "MediumSpace;": "âŸ",
  "NotLessLess;": "â‰ªÌ¸",
  "NotPrecedes;": "âŠ€",
  "NotSucceeds;": "âŠ",
  "NotSuperset;": "âŠƒâƒ’",
  "nRightarrow;": "â‡",
  "nrightarrow;": "â†›",
  "OverBracket;": "â´",
  "preccurlyeq;": "â‰¼",
  "precnapprox;": "âª¹",
  "quaternions;": "â„",
  "RightVector;": "â‡€",
  "Rrightarrow;": "â‡›",
  "RuleDelayed;": "â§´",
  "SmallCircle;": "âˆ˜",
  "SquareUnion;": "âŠ”",
  "straightphi;": "Ï•",
  "SubsetEqual;": "âŠ†",
  "succcurlyeq;": "â‰½",
  "succnapprox;": "âªº",
  "thickapprox;": "â‰ˆ",
  "UpDownArrow;": "â†•",
  "Updownarrow;": "â‡•",
  "updownarrow;": "â†•",
  "VerticalBar;": "âˆ£",
  "blacklozenge;": "â§«",
  "DownArrowBar;": "â¤“",
  "DownTeeArrow;": "â†§",
  "ExponentialE;": "â…‡",
  "exponentiale;": "â…‡",
  "GreaterEqual;": "â‰¥",
  "GreaterTilde;": "â‰³",
  "HilbertSpace;": "â„‹",
  "HumpDownHump;": "â‰",
  "Intersection;": "â‹‚",
  "LeftArrowBar;": "â‡¤",
  "LeftTeeArrow;": "â†¤",
  "LeftTriangle;": "âŠ²",
  "LeftUpVector;": "â†¿",
  "NotCongruent;": "â‰¢",
  "NotHumpEqual;": "â‰Ì¸",
  "NotLessEqual;": "â‰°",
  "NotLessTilde;": "â‰´",
  "Proportional;": "âˆ",
  "RightCeiling;": "âŒ‰",
  "risingdotseq;": "â‰“",
  "RoundImplies;": "â¥°",
  "ShortUpArrow;": "â†‘",
  "SquareSubset;": "âŠ",
  "triangledown;": "â–¿",
  "triangleleft;": "â—ƒ",
  "UnderBracket;": "âµ",
  "varsubsetneq;": "âŠŠï¸€",
  "varsupsetneq;": "âŠ‹ï¸€",
  "VerticalLine;": "|",
  "ApplyFunction;": "â¡",
  "bigtriangleup;": "â–³",
  "blacktriangle;": "â–´",
  "DifferentialD;": "â…†",
  "divideontimes;": "â‹‡",
  "DoubleLeftTee;": "â«¤",
  "DoubleUpArrow;": "â‡‘",
  "fallingdotseq;": "â‰’",
  "hookleftarrow;": "â†©",
  "leftarrowtail;": "â†¢",
  "leftharpoonup;": "â†¼",
  "LeftTeeVector;": "â¥š",
  "LeftVectorBar;": "â¥’",
  "LessFullEqual;": "â‰¦",
  "LongLeftArrow;": "âŸµ",
  "Longleftarrow;": "âŸ¸",
  "longleftarrow;": "âŸµ",
  "looparrowleft;": "â†«",
  "measuredangle;": "âˆ¡",
  "NotEqualTilde;": "â‰‚Ì¸",
  "NotTildeEqual;": "â‰„",
  "NotTildeTilde;": "â‰‰",
  "ntriangleleft;": "â‹ª",
  "Poincareplane;": "â„Œ",
  "PrecedesEqual;": "âª¯",
  "PrecedesTilde;": "â‰¾",
  "RightArrowBar;": "â‡¥",
  "RightTeeArrow;": "â†¦",
  "RightTriangle;": "âŠ³",
  "RightUpVector;": "â†¾",
  "shortparallel;": "âˆ¥",
  "smallsetminus;": "âˆ–",
  "SucceedsEqual;": "âª°",
  "SucceedsTilde;": "â‰¿",
  "SupersetEqual;": "âŠ‡",
  "triangleright;": "â–¹",
  "UpEquilibrium;": "â¥®",
  "upharpoonleft;": "â†¿",
  "varsubsetneqq;": "â«‹ï¸€",
  "varsupsetneqq;": "â«Œï¸€",
  "VerticalTilde;": "â‰€",
  "VeryThinSpace;": "â€Š",
  "curvearrowleft;": "â†¶",
  "DiacriticalDot;": "Ë™",
  "doublebarwedge;": "âŒ†",
  "DoubleRightTee;": "âŠ¨",
  "downdownarrows;": "â‡Š",
  "DownLeftVector;": "â†½",
  "GreaterGreater;": "âª¢",
  "hookrightarrow;": "â†ª",
  "HorizontalLine;": "â”€",
  "InvisibleComma;": "â£",
  "InvisibleTimes;": "â¢",
  "LeftDownVector;": "â‡ƒ",
  "leftleftarrows;": "â‡‡",
  "LeftRightArrow;": "â†”",
  "Leftrightarrow;": "â‡”",
  "leftrightarrow;": "â†”",
  "leftthreetimes;": "â‹‹",
  "LessSlantEqual;": "â©½",
  "LongRightArrow;": "âŸ¶",
  "Longrightarrow;": "âŸ¹",
  "longrightarrow;": "âŸ¶",
  "looparrowright;": "â†¬",
  "LowerLeftArrow;": "â†™",
  "NestedLessLess;": "â‰ª",
  "NotGreaterLess;": "â‰¹",
  "NotLessGreater;": "â‰¸",
  "NotSubsetEqual;": "âŠˆ",
  "NotVerticalBar;": "âˆ¤",
  "nshortparallel;": "âˆ¦",
  "ntriangleright;": "â‹«",
  "OpenCurlyQuote;": "â€˜",
  "ReverseElement;": "âˆ‹",
  "rightarrowtail;": "â†£",
  "rightharpoonup;": "â‡€",
  "RightTeeVector;": "â¥›",
  "RightVectorBar;": "â¥“",
  "ShortDownArrow;": "â†“",
  "ShortLeftArrow;": "â†",
  "SquareSuperset;": "âŠ",
  "TildeFullEqual;": "â‰…",
  "trianglelefteq;": "âŠ´",
  "upharpoonright;": "â†¾",
  "UpperLeftArrow;": "â†–",
  "ZeroWidthSpace;": "â€‹",
  "bigtriangledown;": "â–½",
  "circlearrowleft;": "â†º",
  "CloseCurlyQuote;": "â€™",
  "ContourIntegral;": "âˆ®",
  "curvearrowright;": "â†·",
  "DoubleDownArrow;": "â‡“",
  "DoubleLeftArrow;": "â‡",
  "downharpoonleft;": "â‡ƒ",
  "DownRightVector;": "â‡",
  "leftharpoondown;": "â†½",
  "leftrightarrows;": "â‡†",
  "LeftRightVector;": "â¥",
  "LeftTriangleBar;": "â§",
  "LeftUpTeeVector;": "â¥ ",
  "LeftUpVectorBar;": "â¥˜",
  "LowerRightArrow;": "â†˜",
  "nLeftrightarrow;": "â‡",
  "nleftrightarrow;": "â†®",
  "NotGreaterEqual;": "â‰±",
  "NotGreaterTilde;": "â‰µ",
  "NotHumpDownHump;": "â‰Ì¸",
  "NotLeftTriangle;": "â‹ª",
  "NotSquareSubset;": "âŠÌ¸",
  "ntrianglelefteq;": "â‹¬",
  "OverParenthesis;": "âœ",
  "RightDownVector;": "â‡‚",
  "rightleftarrows;": "â‡„",
  "rightsquigarrow;": "â†",
  "rightthreetimes;": "â‹Œ",
  "ShortRightArrow;": "â†’",
  "straightepsilon;": "Ïµ",
  "trianglerighteq;": "âŠµ",
  "UpperRightArrow;": "â†—",
  "vartriangleleft;": "âŠ²",
  "circlearrowright;": "â†»",
  "DiacriticalAcute;": "Â´",
  "DiacriticalGrave;": "`",
  "DiacriticalTilde;": "Ëœ",
  "DoubleRightArrow;": "â‡’",
  "DownArrowUpArrow;": "â‡µ",
  "downharpoonright;": "â‡‚",
  "EmptySmallSquare;": "â—»",
  "GreaterEqualLess;": "â‹›",
  "GreaterFullEqual;": "â‰§",
  "LeftAngleBracket;": "âŸ¨",
  "LeftUpDownVector;": "â¥‘",
  "LessEqualGreater;": "â‹š",
  "NonBreakingSpace;": "Â ",
  "NotPrecedesEqual;": "âª¯Ì¸",
  "NotRightTriangle;": "â‹«",
  "NotSucceedsEqual;": "âª°Ì¸",
  "NotSucceedsTilde;": "â‰¿Ì¸",
  "NotSupersetEqual;": "âŠ‰",
  "ntrianglerighteq;": "â‹­",
  "rightharpoondown;": "â‡",
  "rightrightarrows;": "â‡‰",
  "RightTriangleBar;": "â§",
  "RightUpTeeVector;": "â¥œ",
  "RightUpVectorBar;": "â¥”",
  "twoheadleftarrow;": "â†",
  "UnderParenthesis;": "â",
  "UpArrowDownArrow;": "â‡…",
  "vartriangleright;": "âŠ³",
  "blacktriangledown;": "â–¾",
  "blacktriangleleft;": "â—‚",
  "DoubleUpDownArrow;": "â‡•",
  "DoubleVerticalBar;": "âˆ¥",
  "DownLeftTeeVector;": "â¥",
  "DownLeftVectorBar;": "â¥–",
  "FilledSmallSquare;": "â—¼",
  "GreaterSlantEqual;": "â©¾",
  "LeftDoubleBracket;": "âŸ¦",
  "LeftDownTeeVector;": "â¥¡",
  "LeftDownVectorBar;": "â¥™",
  "leftrightharpoons;": "â‡‹",
  "LeftTriangleEqual;": "âŠ´",
  "NegativeThinSpace;": "â€‹",
  "NotGreaterGreater;": "â‰«Ì¸",
  "NotLessSlantEqual;": "â©½Ì¸",
  "NotNestedLessLess;": "âª¡Ì¸",
  "NotReverseElement;": "âˆŒ",
  "NotSquareSuperset;": "âŠÌ¸",
  "NotTildeFullEqual;": "â‰‡",
  "RightAngleBracket;": "âŸ©",
  "rightleftharpoons;": "â‡Œ",
  "RightUpDownVector;": "â¥",
  "SquareSubsetEqual;": "âŠ‘",
  "twoheadrightarrow;": "â† ",
  "VerticalSeparator;": "â˜",
  "blacktriangleright;": "â–¸",
  "DownRightTeeVector;": "â¥Ÿ",
  "DownRightVectorBar;": "â¥—",
  "LongLeftRightArrow;": "âŸ·",
  "Longleftrightarrow;": "âŸº",
  "longleftrightarrow;": "âŸ·",
  "NegativeThickSpace;": "â€‹",
  "NotLeftTriangleBar;": "â§Ì¸",
  "PrecedesSlantEqual;": "â‰¼",
  "ReverseEquilibrium;": "â‡‹",
  "RightDoubleBracket;": "âŸ§",
  "RightDownTeeVector;": "â¥",
  "RightDownVectorBar;": "â¥•",
  "RightTriangleEqual;": "âŠµ",
  "SquareIntersection;": "âŠ“",
  "SucceedsSlantEqual;": "â‰½",
  "DoubleLongLeftArrow;": "âŸ¸",
  "DownLeftRightVector;": "â¥",
  "LeftArrowRightArrow;": "â‡†",
  "leftrightsquigarrow;": "â†­",
  "NegativeMediumSpace;": "â€‹",
  "NotGreaterFullEqual;": "â‰§Ì¸",
  "NotRightTriangleBar;": "â§Ì¸",
  "RightArrowLeftArrow;": "â‡„",
  "SquareSupersetEqual;": "âŠ’",
  "CapitalDifferentialD;": "â……",
  "DoubleLeftRightArrow;": "â‡”",
  "DoubleLongRightArrow;": "âŸ¹",
  "EmptyVerySmallSquare;": "â–«",
  "NestedGreaterGreater;": "â‰«",
  "NotDoubleVerticalBar;": "âˆ¦",
  "NotGreaterSlantEqual;": "â©¾Ì¸",
  "NotLeftTriangleEqual;": "â‹¬",
  "NotSquareSubsetEqual;": "â‹¢",
  "OpenCurlyDoubleQuote;": "â€œ",
  "ReverseUpEquilibrium;": "â¥¯",
  "CloseCurlyDoubleQuote;": "â€",
  "DoubleContourIntegral;": "âˆ¯",
  "FilledVerySmallSquare;": "â–ª",
  "NegativeVeryThinSpace;": "â€‹",
  "NotPrecedesSlantEqual;": "â‹ ",
  "NotRightTriangleEqual;": "â‹­",
  "NotSucceedsSlantEqual;": "â‹¡",
  "DiacriticalDoubleAcute;": "Ë",
  "NotSquareSupersetEqual;": "â‹£",
  "NotNestedGreaterGreater;": "âª¢Ì¸",
  "ClockwiseContourIntegral;": "âˆ²",
  "DoubleLongLeftRightArrow;": "âŸº",
  "CounterClockwiseContourIntegral;": "âˆ³"
}

const decodeHtml = (rawText, asAttr) => {
  let offset = 0
  const end = rawText.length
  let decodedText = ''

  function advance(length) {
    offset += length
    rawText = rawText.slice(length)
  }

  while (offset < end) {
    const head = /&(?:#x?)?/i.exec(rawText)
    if (!head || offset + head.index >= end) {
      const remaining = end - offset
      decodedText += rawText.slice(0, remaining)
      advance(remaining)
      break
    }

    // Advance to the "&".
    decodedText += rawText.slice(0, head.index)
    advance(head.index)

    if (head[0] === '&') {
      // Named character reference.
      let name = ''
      let value = undefined
      if (/[0-9a-z]/i.test(rawText[1])) {
        if (!maxCRNameLength) {
          maxCRNameLength = Object.keys(namedCharacterReferences).reduce(
            (max, name) => Math.max(max, name.length),
            0
          )
        }
        for (let length = maxCRNameLength; !value && length > 0; --length) {
          name = rawText.slice(1, 1 + length)
          value = namedCharacterReferences[name]
        }
        if (value) {
          const semi = name.endsWith(';')
          if (
            asAttr &&
            !semi &&
            /[=a-z0-9]/i.test(rawText[name.length + 1] || '')
          ) {
            decodedText += '&' + name
            advance(1 + name.length)
          } else {
            decodedText += value
            advance(1 + name.length)
          }
        } else {
          decodedText += '&' + name
          advance(1 + name.length)
        }
      } else {
        decodedText += '&'
        advance(1)
      }
    } else {
      // Numeric character reference.
      const hex = head[0] === '&#x'
      const pattern = hex ? /^&#x([0-9a-f]+);?/i : /^&#([0-9]+);?/
      const body = pattern.exec(rawText)
      if (!body) {
        decodedText += head[0]
        advance(head[0].length)
      } else {
        // https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state
        let cp = Number.parseInt(body[1], hex ? 16 : 10)
        if (cp === 0) {
          cp = 0xfffd
        } else if (cp > 0x10ffff) {
          cp = 0xfffd
        } else if (cp >= 0xd800 && cp <= 0xdfff) {
          cp = 0xfffd
        } else if ((cp >= 0xfdd0 && cp <= 0xfdef) || (cp & 0xfffe) === 0xfffe) {
          // noop
        } else if (
          (cp >= 0x01 && cp <= 0x08) ||
          cp === 0x0b ||
          (cp >= 0x0d && cp <= 0x1f) ||
          (cp >= 0x7f && cp <= 0x9f)
        ) {
          cp = CCR_REPLACEMENTS[cp] || cp
        }
        decodedText += String.fromCodePoint(cp)
        advance(body[0].length)
      }
    }
  }
  return decodedText
}

// https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state
const CCR_REPLACEMENTS = {
  0x80: 0x20ac,
  0x82: 0x201a,
  0x83: 0x0192,
  0x84: 0x201e,
  0x85: 0x2026,
  0x86: 0x2020,
  0x87: 0x2021,
  0x88: 0x02c6,
  0x89: 0x2030,
  0x8a: 0x0160,
  0x8b: 0x2039,
  0x8c: 0x0152,
  0x8e: 0x017d,
  0x91: 0x2018,
  0x92: 0x2019,
  0x93: 0x201c,
  0x94: 0x201d,
  0x95: 0x2022,
  0x96: 0x2013,
  0x97: 0x2014,
  0x98: 0x02dc,
  0x99: 0x2122,
  0x9a: 0x0161,
  0x9b: 0x203a,
  0x9c: 0x0153,
  0x9e: 0x017e,
  0x9f: 0x0178
}

let decoder

function decodeHtmlBrowser(raw, asAttr = false) {
  if (!decoder) {
    decoder = document.createElement('div')
  }
  if (asAttr) {
    decoder.innerHTML = `<div foo="${raw.replace(/"/g, '&quot;')}">`
    return decoder.children[0].getAttribute('foo')
  } else {
    decoder.innerHTML = raw
    return decoder.textContent
  }
}
#+end_src
#+end_details

#+html: <br>
#+begin_details dom-attrs :title-color green
#+name: dom-attrs
#+begin_src js -n -r

/**
 ,* On the client we only need to offer special cases for boolean attributes that
 ,* have different names from their corresponding dom properties:
 ,* - itemscope -> N/A
 ,* - allowfullscreen -> allowFullscreen
 ,* - formnovalidate -> formNoValidate
 ,* - ismap -> isMap
 ,* - nomodule -> noModule
 ,* - novalidate -> noValidate
 ,* - readonly -> readOnly
 ,*/
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`
const isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs)

/**
 ,* The full list is needed during SSR to produce the correct initial markup.
 ,*/
const isBooleanAttr = /*#__PURE__*/ makeMap(
  specialBooleanAttrs +
    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +
    `loop,open,required,reversed,scoped,seamless,` +
    `checked,muted,multiple,selected`
)

/**
 ,* Boolean attributes should be included if the value is truthy or ''.
 ,* e.g. `<select multiple>` compiles to `{ multiple: '' }`
 ,*/
function includeBooleanAttr(value) {
  return !!value || value === ''
}

const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/
const attrValidationCache = {}

function isSSRSafeAttrName(name) {
  if (attrValidationCache.hasOwnProperty(name)) {
    return attrValidationCache[name]
  }
  const isUnsafe = unsafeAttrCharRE.test(name)
  if (isUnsafe) {
    console.error(`unsafe attribute name: ${name}`)
  }
  return (attrValidationCache[name] = !isUnsafe)
}

const propsToAttrMap = {
  acceptCharset: 'accept-charset',
  className: 'class',
  htmlFor: 'for',
  httpEquiv: 'http-equiv'
}

/**
 ,* CSS properties that accept plain numbers
 ,*/
const isNoUnitNumericStyleProp = /*#__PURE__*/ makeMap(
  `animation-iteration-count,border-image-outset,border-image-slice,` +
    `border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,` +
    `columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,` +
    `grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,` +
    `grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,` +
    `line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,` +
    // SVG
    `fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,` +
    `stroke-miterlimit,stroke-opacity,stroke-width`
)

/**
 ,* Known attributes, this is used for stringification of runtime static nodes
 ,* so that we don't stringify bindings that cannot be set from HTML.
 ,* Don't also forget to allow `data-*` and `aria-*`!
 ,* Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes
 ,*/
const isKnownHtmlAttr = /*#__PURE__*/ makeMap(
  `accept,accept-charset,accesskey,action,align,allow,alt,async,` +
    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +
    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +
    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +
    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +
    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +
    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +
    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +
    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +
    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +
    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +
    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +
    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +
    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +
    `value,width,wrap`
)

/**
 ,* Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute
 ,*/
const isKnownSvgAttr = /*#__PURE__*/ makeMap(
  `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,` +
    `arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,` +
    `baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,` +
    `clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,` +
    `color-interpolation-filters,color-profile,color-rendering,` +
    `contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,` +
    `descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,` +
    `dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,` +
    `fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,` +
    `font-family,font-size,font-size-adjust,font-stretch,font-style,` +
    `font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,` +
    `glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,` +
    `gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,` +
    `horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,` +
    `k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,` +
    `lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,` +
    `marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,` +
    `mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,` +
    `name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,` +
    `overflow,overline-position,overline-thickness,panose-1,paint-order,path,` +
    `pathLength,patternContentUnits,patternTransform,patternUnits,ping,` +
    `pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,` +
    `preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,` +
    `rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,` +
    `restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,` +
    `specularConstant,specularExponent,speed,spreadMethod,startOffset,` +
    `stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,` +
    `strikethrough-position,strikethrough-thickness,string,stroke,` +
    `stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,` +
    `stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,` +
    `systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,` +
    `text-decoration,text-rendering,textLength,to,transform,transform-origin,` +
    `type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,` +
    `unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,` +
    `v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,` +
    `vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,` +
    `writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,` +
    `xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,` +
    `xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`
)

#+end_src
#+end_details

#+html: <br>
#+begin_details normalizeProp :title-color green
#+name: normalizeProp
#+begin_src js -n -r

function normalizeStyle(value) { (ref:normalizeStyle)
  if (isArray(value)) {
    const res = {}
    for (let i = 0; i < value.length; i++) {
      const item = value[i]
      const normalized = isString(item)
        ? parseStringStyle(item)
        : normalizeStyle(item)
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key]
        }
      }
    }
    return res
  } else if (isString(value)) {
    return value
  } else if (isObject(value)) {
    return value
  }
}

const listDelimiterRE = /;(?![^(]*\))/g
const propertyDelimiterRE = /:(.+)/

function parseStringStyle(cssText) { (ref:parseStringStyle)
  const ret = {}
  cssText.split(listDelimiterRE).forEach(item => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE)
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim())
    }
  })
  return ret
}

function stringifyStyle(styles) { (ref:stringifyStyle)
  let ret = ''
  if (!styles || isString(styles)) {
    return ret
  }
  for (const key in styles) {
    const value = styles[key]
    const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key)
    if (
      isString(value) ||
      (typeof value === 'number' && isNoUnitNumericStyleProp(normalizedKey))
    ) {
      // only render valid values
      ret += `${normalizedKey}:${value};`
    }
  }
  return ret
}

function normalizeClass(value) { (ref:normalizeClass)
  let res = ''
  if (isString(value)) {
    res = value
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i])
      if (normalized) {
        res += normalized + ' '
      }
    }
  } else if (isObject(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + ' '
      }
    }
  }
  return res.trim()
}

function normalizeProps(props) { (ref:normalizeProps)
  if (!props) return null
  let { class: klass, style } = props
  if (klass && !isString(klass)) {
    props.class = normalizeClass(klass)
  }
  if (style) {
    props.style = normalizeStyle(style)
  }
  return props
}

#+end_src
#+end_details

#+html: <br>
#+begin_details escapeHtml :title-color green
#+name: escapeHtml
#+begin_src js -n -r
const escapeRE = /["'&<>]/

function escapeHtml(string) {
  const str = '' + string
  const match = escapeRE.exec(str)

  if (!match) {
    return str
  }

  let html = ''
  let escaped
  let index
  let lastIndex = 0
  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34: // "
        escaped = '&quot;'
        break
      case 38: // &
        escaped = '&amp;'
        break
      case 39: // '
        escaped = '&#39;'
        break
      case 60: // <
        escaped = '&lt;'
        break
      case 62: // >
        escaped = '&gt;'
        break
      default:
        continue
    }

    if (lastIndex !== index) {
      html += str.slice(lastIndex, index)
    }

    lastIndex = index + 1
    html += escaped
  }

  return lastIndex !== index ? html + str.slice(lastIndex, index) : html
}

// https://www.w3.org/TR/html52/syntax.html#comments
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g

function escapeHtmlComment(src) {
  return src.replace(commentStripRE, '')
}

#+end_src
#+end_details

#+html: <br>
#+begin_details toDisplayString :title-color green
#+name: toDisplayString
#+begin_src js -n -r
const toDisplayString = (val) => {
  return isString(val)
    ? val
    : val == null
    ? ''
    : isArray(val) ||
      (isObject(val) &&
        (val.toString === objectToString || !isFunction(val.toString)))
    ? JSON.stringify(val, replacer, 2)
    : String(val)
}

const replacer = (_key, val) => {
  // can't use isRef here since @vue/shared has no deps
  if (val && val.__v_isRef) {
    return replacer(_key, val.value)
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {
        ;entries[`${key} =>`] = val
        return entries
      }, {})
    }
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    }
  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
    return String(val)
  }
  return val
}

#+end_src
#+end_details
* COMMENT Local Variables       :ARCHIVE:
# Local Variables:
# after-save-hook: gcl/org-html-export-to-html
# End:
