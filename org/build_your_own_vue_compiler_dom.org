:PROPERTIES:
:ID:       f17d718c-0d00-4c10-b3f9-e9e0d8295193
:END:
#+SETUPFILE:~/.gclrc/org/hugo_setup.org
#+HUGO_SLUG: build_your_own_vue_compiler_dom
#+HTML_HEAD: <meta name="category" content="vue"/>
#+HTML_HEAD: <meta name="tags" content="compiler-dom"/>
#+HTML_HEAD: <meta name="createdAt" content="2022-04-27 14:49:00"/>
#+PROPERTY: header-args :noweb no-export
#+TITLE: build your own vue compiler-dom
<badge: GCCLL | Homepage | green | / | gnu-emacs | tinder>

#+begin_box Vue3 compiler-dom :background-color green

[[https://www.cheng92.com/vue/vue-mind-map-compiler-dom/][Vue3 Ê∫êÁ†ÅÂ§¥ËÑëÈ£éÊö¥‰πã 4 ‚òûcompiler-dom - Ëã•Âè∂Áü•Áßã]]

ÊñáÁ´†ÊúÄÂêéÊúâ‰∫§‰∫íÂºèÁöÑ[[testing][ÊµãËØïÊñπÊ≥ï]]ÔºåÂèØËæìÂÖ•ÊÉ≥ÁúãÁöÑÊ®°ÊùøÂæóÂà∞ÂØπÂ∫îÁöÑ render ÂáΩÊï∞Âíå AST „ÄÇ
#+end_box

#+html: <br>
#+begin_details compiler-core ‰ª£Á†Å :title-color green
[[https://blog.cheng92.com/posts/build_your_own_vue_compiler_core.html][build your own vue compiler-core]]

#+name: compiler-core
#+include: ../assets/tests/compiler-core.js src js -n -r
#+end_details

* Global Variables

#+html: <br>
#+begin_details global variables :title-color green
#+name: globalVarsCD
#+begin_src js -n -r
<<namedChars>>
<<helpers-cd>>
<<dom-attrs>>
<<html-tags>>
<<normalizeProp>>
<<escapeHtml>>
<<toDisplayString>>

const noopDirectiveTransform = () => ({ props: [] })

const isRawTextContainer = /*#__PURE__*/ makeMap(
  'style,iframe,script,noscript',
  true
)

const DOMNamespaces = {
  HTML: Namespaces.HTML,
  SVG: 1,
  MATH_ML: 2
}

const parserOptions = {
  isVoidTag,
  isNativeTag: tag => isHTMLTag(tag) || isSVGTag(tag),
  isPreTag: tag => tag === 'pre',
  decodeEntities: __BROWSER__ ? decodeHtmlBrowser : decodeHtml,

  isBuiltInComponent: tag => {
    if (isBuiltInType(tag, `Transition`)) {
      return TRANSITION
    } else if (isBuiltInType(tag, `TransitionGroup`)) {
      return TRANSITION_GROUP
    }
  },

  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
  getNamespace(tag, parent) {
    let ns = parent ? parent.ns : DOMNamespaces.HTML

    if (parent && ns === DOMNamespaces.MATH_ML) {
      if (parent.tag === 'annotation-xml') {
        if (tag === 'svg') {
          return DOMNamespaces.SVG
        }
        if (
          parent.props.some(
            a =>
              a.type === NodeTypes.ATTRIBUTE &&
              a.name === 'encoding' &&
              a.value != null &&
              (a.value.content === 'text/html' ||
                a.value.content === 'application/xhtml+xml')
          )
        ) {
          ns = DOMNamespaces.HTML
        }
      } else if (
        /^m(?:[ions]|text)$/.test(parent.tag) &&
        tag !== 'mglyph' &&
        tag !== 'malignmark'
      ) {
        ns = DOMNamespaces.HTML
      }
    } else if (parent && ns === DOMNamespaces.SVG) {
      if (
        parent.tag === 'foreignObject' ||
        parent.tag === 'desc' ||
        parent.tag === 'title'
      ) {
        ns = DOMNamespaces.HTML
      }
    }

    if (ns === DOMNamespaces.HTML) {
      if (tag === 'svg') {
        return DOMNamespaces.SVG
      }
      if (tag === 'math') {
        return DOMNamespaces.MATH_ML
      }
    }
    return ns
  },

  // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
  getTextMode({ tag, ns }) {
    if (ns === DOMNamespaces.HTML) {
      if (tag === 'textarea' || tag === 'title') {
        return TextModes.RCDATA
      }
      if (isRawTextContainer(tag)) {
        return TextModes.RAWTEXT
      }
    }
    return TextModes.DATA
  }
}

function hasDynamicKeyVBind(node) {
  return node.props.some(
    p =>
      p.type === NodeTypes.DIRECTIVE &&
      p.name === 'bind' &&
      (!p.arg || // v-bind="obj"
        p.arg.type !== NodeTypes.SIMPLE_EXPRESSION || // v-bind:[_ctx.foo]
        !p.arg.isStatic) // v-bind:[foo]
  )
}


function hasMultipleChildren(node) {
  // #1352 filter out potential comment nodes.
  const children = (node.children = node.children.filter(
    c =>
      c.type !== NodeTypes.COMMENT &&
      !(c.type === NodeTypes.TEXT && !c.content.trim())
  ))
  const child = children[0]
  return (
    children.length !== 1 ||
    child.type === NodeTypes.FOR ||
    (child.type === NodeTypes.IF && child.branches.some(hasMultipleChildren))
  )
}

const warnTransitionChildren = (node, context) => {
  if (
    node.type === NodeTypes.ELEMENT &&
    node.tagType === ElementTypes.COMPONENT
  ) {
    const component = context.isBuiltInComponent(node.tag)
    if (component === TRANSITION) {
      return () => {
        if (node.children.length && hasMultipleChildren(node)) {
          console.warn(`X_TRANSITION_INVALID_CHILDREN`, node)
        }
      }
    }
  }
}


const ignoreSideEffectTags = (node, context) => {
  if (
    node.type === NodeTypes.ELEMENT &&
    node.tagType === ElementTypes.ELEMENT &&
    (node.tag === 'script' || node.tag === 'style')
  ) {
    console.warn(`X_IGNORED_SIDE_EFFECT_TAG`)
    context.removeNode()
  }
}
#+end_src
#+end_details

#+html: <br>
#+begin_details html-tags :title-color green
#+name: html-tags
#+begin_src js -n -r
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element
const HTML_TAGS =
  'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +
  'header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +
  'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +
  'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +
  'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +
  'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +
  'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +
  'option,output,progress,select,textarea,details,dialog,menu,' +
  'summary,template,blockquote,iframe,tfoot'

// https://developer.mozilla.org/en-US/docs/Web/SVG/Element
const SVG_TAGS =
  'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +
  'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +
  'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +
  'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +
  'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +
  'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +
  'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +
  'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +
  'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +
  'text,textPath,title,tspan,unknown,use,view'

const VOID_TAGS =
  'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr'

const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS)
/**
 ,* Compiler only.
 ,* Do NOT use in runtime code paths unless behind `__DEV__` flag.
 ,*/
const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS)
const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS)

#+end_src
#+end_details

#+html: <br>
#+begin_details helpers-cd :title-color  green
#+name: helpers-cd
#+begin_src js -n -r

const V_MODEL_RADIO = Symbol(__DEV__ ? `vModelRadio` : ``)
const V_MODEL_CHECKBOX = Symbol(__DEV__ ? `vModelCheckbox` : ``)
const V_MODEL_TEXT = Symbol(__DEV__ ? `vModelText` : ``)
const V_MODEL_SELECT = Symbol(__DEV__ ? `vModelSelect` : ``)
const V_MODEL_DYNAMIC = Symbol(__DEV__ ? `vModelDynamic` : ``)

const V_ON_WITH_MODIFIERS = Symbol(__DEV__ ? `vOnModifiersGuard` : ``)
const V_ON_WITH_KEYS = Symbol(__DEV__ ? `vOnKeysGuard` : ``)

const V_SHOW = Symbol(__DEV__ ? `vShow` : ``)

const TRANSITION = Symbol(__DEV__ ? `Transition` : ``)
const TRANSITION_GROUP = Symbol(__DEV__ ? `TransitionGroup` : ``)

registerRuntimeHelpers({
  [V_MODEL_RADIO]: `vModelRadio`,
  [V_MODEL_CHECKBOX]: `vModelCheckbox`,
  [V_MODEL_TEXT]: `vModelText`,
  [V_MODEL_SELECT]: `vModelSelect`,
  [V_MODEL_DYNAMIC]: `vModelDynamic`,
  [V_ON_WITH_MODIFIERS]: `withModifiers`,
  [V_ON_WITH_KEYS]: `withKeys`,
  [V_SHOW]: `vShow`,
  [TRANSITION]: `Transition`,
  [TRANSITION_GROUP]: `TransitionGroup`
})
#+end_src
#+end_details

#+html: <br>
#+begin_details namedChars :title-color green
#+name: namedChars
#+begin_src js -n -r
const namedCharacterReferences = {
  "GT": ">",
  "gt": ">",
  "LT": "<",
  "lt": "<",
  "ac;": "‚àæ",
  "af;": "‚Å°",
  "AMP": "&",
  "amp": "&",
  "ap;": "‚âà",
  "DD;": "‚ÖÖ",
  "dd;": "‚ÖÜ",
  "deg": "¬∞",
  "ee;": "‚Öá",
  "eg;": "‚™ö",
  "el;": "‚™ô",
  "ETH": "√ê",
  "eth": "√∞",
  "gE;": "‚âß",
  "ge;": "‚â•",
  "Gg;": "‚ãô",
  "gg;": "‚â´",
  "gl;": "‚â∑",
  "GT;": ">",
  "Gt;": "‚â´",
  "gt;": ">",
  "ic;": "‚Å£",
  "ii;": "‚Öà",
  "Im;": "‚Ñë",
  "in;": "‚àà",
  "it;": "‚Å¢",
  "lE;": "‚â¶",
  "le;": "‚â§",
  "lg;": "‚â∂",
  "Ll;": "‚ãò",
  "ll;": "‚â™",
  "LT;": "<",
  "Lt;": "‚â™",
  "lt;": "<",
  "mp;": "‚àì",
  "Mu;": "Œú",
  "mu;": "Œº",
  "ne;": "‚â†",
  "ni;": "‚àã",
  "not": "¬¨",
  "Nu;": "Œù",
  "nu;": "ŒΩ",
  "Or;": "‚©î",
  "or;": "‚à®",
  "oS;": "‚ìà",
  "Pi;": "Œ†",
  "pi;": "œÄ",
  "pm;": "¬±",
  "Pr;": "‚™ª",
  "pr;": "‚â∫",
  "Re;": "‚Ñú",
  "REG": "¬Æ",
  "reg": "¬Æ",
  "rx;": "‚Ñû",
  "Sc;": "‚™º",
  "sc;": "‚âª",
  "shy": "¬≠",
  "uml": "¬®",
  "wp;": "‚Ñò",
  "wr;": "‚âÄ",
  "Xi;": "Œû",
  "xi;": "Œæ",
  "yen": "¬•",
  "acd;": "‚àø",
  "acE;": "‚àæÃ≥",
  "Acy;": "–ê",
  "acy;": "–∞",
  "Afr;": "ùîÑ",
  "afr;": "ùîû",
  "AMP;": "&",
  "amp;": "&",
  "And;": "‚©ì",
  "and;": "‚àß",
  "ang;": "‚à†",
  "apE;": "‚©∞",
  "ape;": "‚âä",
  "ast;": "*",
  "Auml": "√Ñ",
  "auml": "√§",
  "Bcy;": "–ë",
  "bcy;": "–±",
  "Bfr;": "ùîÖ",
  "bfr;": "ùîü",
  "bne;": "=‚É•",
  "bot;": "‚ä•",
  "Cap;": "‚ãí",
  "cap;": "‚à©",
  "cent": "¬¢",
  "Cfr;": "‚Ñ≠",
  "cfr;": "ùî†",
  "Chi;": "Œß",
  "chi;": "œá",
  "cir;": "‚óã",
  "COPY": "¬©",
  "copy": "¬©",
  "Cup;": "‚ãì",
  "cup;": "‚à™",
  "Dcy;": "–î",
  "dcy;": "–¥",
  "deg;": "¬∞",
  "Del;": "‚àá",
  "Dfr;": "ùîá",
  "dfr;": "ùî°",
  "die;": "¬®",
  "div;": "√∑",
  "Dot;": "¬®",
  "dot;": "Àô",
  "Ecy;": "–≠",
  "ecy;": "—ç",
  "Efr;": "ùîà",
  "efr;": "ùî¢",
  "egs;": "‚™ñ",
  "ell;": "‚Ñì",
  "els;": "‚™ï",
  "ENG;": "≈ä",
  "eng;": "≈ã",
  "Eta;": "Œó",
  "eta;": "Œ∑",
  "ETH;": "√ê",
  "eth;": "√∞",
  "Euml": "√ã",
  "euml": "√´",
  "Fcy;": "–§",
  "fcy;": "—Ñ",
  "Ffr;": "ùîâ",
  "ffr;": "ùî£",
  "gap;": "‚™Ü",
  "Gcy;": "–ì",
  "gcy;": "–≥",
  "gEl;": "‚™å",
  "gel;": "‚ãõ",
  "geq;": "‚â•",
  "ges;": "‚©æ",
  "Gfr;": "ùîä",
  "gfr;": "ùî§",
  "ggg;": "‚ãô",
  "gla;": "‚™•",
  "glE;": "‚™í",
  "glj;": "‚™§",
  "gnE;": "‚â©",
  "gne;": "‚™à",
  "Hat;": "^",
  "Hfr;": "‚Ñå",
  "hfr;": "ùî•",
  "Icy;": "–ò",
  "icy;": "–∏",
  "iff;": "‚áî",
  "Ifr;": "‚Ñë",
  "ifr;": "ùî¶",
  "Int;": "‚à¨",
  "int;": "‚à´",
  "Iuml": "√è",
  "iuml": "√Ø",
  "Jcy;": "–ô",
  "jcy;": "–π",
  "Jfr;": "ùîç",
  "jfr;": "ùîß",
  "Kcy;": "–ö",
  "kcy;": "–∫",
  "Kfr;": "ùîé",
  "kfr;": "ùî®",
  "lap;": "‚™Ö",
  "lat;": "‚™´",
  "Lcy;": "–õ",
  "lcy;": "–ª",
  "lEg;": "‚™ã",
  "leg;": "‚ãö",
  "leq;": "‚â§",
  "les;": "‚©Ω",
  "Lfr;": "ùîè",
  "lfr;": "ùî©",
  "lgE;": "‚™ë",
  "lnE;": "‚â®",
  "lne;": "‚™á",
  "loz;": "‚óä",
  "lrm;": "‚Äé",
  "Lsh;": "‚Ü∞",
  "lsh;": "‚Ü∞",
  "macr": "¬Ø",
  "Map;": "‚§Ö",
  "map;": "‚Ü¶",
  "Mcy;": "–ú",
  "mcy;": "–º",
  "Mfr;": "ùîê",
  "mfr;": "ùî™",
  "mho;": "‚Ñß",
  "mid;": "‚à£",
  "nap;": "‚ââ",
  "nbsp": "¬†",
  "Ncy;": "–ù",
  "ncy;": "–Ω",
  "Nfr;": "ùîë",
  "nfr;": "ùî´",
  "ngE;": "‚âßÃ∏",
  "nge;": "‚â±",
  "nGg;": "‚ãôÃ∏",
  "nGt;": "‚â´‚Éí",
  "ngt;": "‚âØ",
  "nis;": "‚ãº",
  "niv;": "‚àã",
  "nlE;": "‚â¶Ã∏",
  "nle;": "‚â∞",
  "nLl;": "‚ãòÃ∏",
  "nLt;": "‚â™‚Éí",
  "nlt;": "‚âÆ",
  "Not;": "‚´¨",
  "not;": "¬¨",
  "npr;": "‚äÄ",
  "nsc;": "‚äÅ",
  "num;": "#",
  "Ocy;": "–û",
  "ocy;": "–æ",
  "Ofr;": "ùîí",
  "ofr;": "ùî¨",
  "ogt;": "‚ßÅ",
  "ohm;": "Œ©",
  "olt;": "‚ßÄ",
  "ord;": "‚©ù",
  "ordf": "¬™",
  "ordm": "¬∫",
  "orv;": "‚©õ",
  "Ouml": "√ñ",
  "ouml": "√∂",
  "par;": "‚à•",
  "para": "¬∂",
  "Pcy;": "–ü",
  "pcy;": "–ø",
  "Pfr;": "ùîì",
  "pfr;": "ùî≠",
  "Phi;": "Œ¶",
  "phi;": "œÜ",
  "piv;": "œñ",
  "prE;": "‚™≥",
  "pre;": "‚™Ø",
  "Psi;": "Œ®",
  "psi;": "œà",
  "Qfr;": "ùîî",
  "qfr;": "ùîÆ",
  "QUOT": "\"",
  "quot": "\"",
  "Rcy;": "–†",
  "rcy;": "—Ä",
  "REG;": "¬Æ",
  "reg;": "¬Æ",
  "Rfr;": "‚Ñú",
  "rfr;": "ùîØ",
  "Rho;": "Œ°",
  "rho;": "œÅ",
  "rlm;": "‚Äè",
  "Rsh;": "‚Ü±",
  "rsh;": "‚Ü±",
  "scE;": "‚™¥",
  "sce;": "‚™∞",
  "Scy;": "–°",
  "scy;": "—Å",
  "sect": "¬ß",
  "Sfr;": "ùîñ",
  "sfr;": "ùî∞",
  "shy;": "¬≠",
  "sim;": "‚àº",
  "smt;": "‚™™",
  "sol;": "/",
  "squ;": "‚ñ°",
  "Sub;": "‚ãê",
  "sub;": "‚äÇ",
  "Sum;": "‚àë",
  "sum;": "‚àë",
  "Sup;": "‚ãë",
  "sup;": "‚äÉ",
  "sup1": "¬π",
  "sup2": "¬≤",
  "sup3": "¬≥",
  "Tab;": "\t",
  "Tau;": "Œ§",
  "tau;": "œÑ",
  "Tcy;": "–¢",
  "tcy;": "—Ç",
  "Tfr;": "ùîó",
  "tfr;": "ùî±",
  "top;": "‚ä§",
  "Ucy;": "–£",
  "ucy;": "—É",
  "Ufr;": "ùîò",
  "ufr;": "ùî≤",
  "uml;": "¬®",
  "Uuml": "√ú",
  "uuml": "√º",
  "Vcy;": "–í",
  "vcy;": "–≤",
  "Vee;": "‚ãÅ",
  "vee;": "‚à®",
  "Vfr;": "ùîô",
  "vfr;": "ùî≥",
  "Wfr;": "ùîö",
  "wfr;": "ùî¥",
  "Xfr;": "ùîõ",
  "xfr;": "ùîµ",
  "Ycy;": "–´",
  "ycy;": "—ã",
  "yen;": "¬•",
  "Yfr;": "ùîú",
  "yfr;": "ùî∂",
  "yuml": "√ø",
  "Zcy;": "–ó",
  "zcy;": "–∑",
  "Zfr;": "‚Ñ®",
  "zfr;": "ùî∑",
  "zwj;": "‚Äç",
  "Acirc": "√Ç",
  "acirc": "√¢",
  "acute": "¬¥",
  "AElig": "√Ü",
  "aelig": "√¶",
  "andd;": "‚©ú",
  "andv;": "‚©ö",
  "ange;": "‚¶§",
  "Aopf;": "ùî∏",
  "aopf;": "ùïí",
  "apid;": "‚âã",
  "apos;": "'",
  "Aring": "√Ö",
  "aring": "√•",
  "Ascr;": "ùíú",
  "ascr;": "ùí∂",
  "Auml;": "√Ñ",
  "auml;": "√§",
  "Barv;": "‚´ß",
  "bbrk;": "‚éµ",
  "Beta;": "Œí",
  "beta;": "Œ≤",
  "beth;": "‚Ñ∂",
  "bNot;": "‚´≠",
  "bnot;": "‚åê",
  "Bopf;": "ùîπ",
  "bopf;": "ùïì",
  "boxH;": "‚ïê",
  "boxh;": "‚îÄ",
  "boxV;": "‚ïë",
  "boxv;": "‚îÇ",
  "Bscr;": "‚Ñ¨",
  "bscr;": "ùí∑",
  "bsim;": "‚àΩ",
  "bsol;": "\\",
  "bull;": "‚Ä¢",
  "bump;": "‚âé",
  "caps;": "‚à©Ô∏Ä",
  "Cdot;": "ƒä",
  "cdot;": "ƒã",
  "cedil": "¬∏",
  "cent;": "¬¢",
  "CHcy;": "–ß",
  "chcy;": "—á",
  "circ;": "ÀÜ",
  "cirE;": "‚ßÉ",
  "cire;": "‚âó",
  "comp;": "‚àÅ",
  "cong;": "‚âÖ",
  "Copf;": "‚ÑÇ",
  "copf;": "ùïî",
  "COPY;": "¬©",
  "copy;": "¬©",
  "Cscr;": "ùíû",
  "cscr;": "ùí∏",
  "csub;": "‚´è",
  "csup;": "‚´ê",
  "cups;": "‚à™Ô∏Ä",
  "Darr;": "‚Ü°",
  "dArr;": "‚áì",
  "darr;": "‚Üì",
  "dash;": "‚Äê",
  "dHar;": "‚••",
  "diam;": "‚ãÑ",
  "DJcy;": "–Ç",
  "djcy;": "—í",
  "Dopf;": "ùîª",
  "dopf;": "ùïï",
  "Dscr;": "ùíü",
  "dscr;": "ùíπ",
  "DScy;": "–Ö",
  "dscy;": "—ï",
  "dsol;": "‚ß∂",
  "dtri;": "‚ñø",
  "DZcy;": "–è",
  "dzcy;": "—ü",
  "ecir;": "‚âñ",
  "Ecirc": "√ä",
  "ecirc": "√™",
  "Edot;": "ƒñ",
  "eDot;": "‚âë",
  "edot;": "ƒó",
  "emsp;": "‚ÄÉ",
  "ensp;": "‚ÄÇ",
  "Eopf;": "ùîº",
  "eopf;": "ùïñ",
  "epar;": "‚ãï",
  "epsi;": "Œµ",
  "Escr;": "‚Ñ∞",
  "escr;": "‚ÑØ",
  "Esim;": "‚©≥",
  "esim;": "‚âÇ",
  "Euml;": "√ã",
  "euml;": "√´",
  "euro;": "‚Ç¨",
  "excl;": "!",
  "flat;": "‚ô≠",
  "fnof;": "∆í",
  "Fopf;": "ùîΩ",
  "fopf;": "ùïó",
  "fork;": "‚ãî",
  "Fscr;": "‚Ñ±",
  "fscr;": "ùíª",
  "Gdot;": "ƒ†",
  "gdot;": "ƒ°",
  "geqq;": "‚âß",
  "gesl;": "‚ãõÔ∏Ä",
  "GJcy;": "–É",
  "gjcy;": "—ì",
  "gnap;": "‚™ä",
  "gneq;": "‚™à",
  "Gopf;": "ùîæ",
  "gopf;": "ùïò",
  "Gscr;": "ùí¢",
  "gscr;": "‚Ñä",
  "gsim;": "‚â≥",
  "gtcc;": "‚™ß",
  "gvnE;": "‚â©Ô∏Ä",
  "half;": "¬Ω",
  "hArr;": "‚áî",
  "harr;": "‚Üî",
  "hbar;": "‚Ñè",
  "Hopf;": "‚Ñç",
  "hopf;": "ùïô",
  "Hscr;": "‚Ñã",
  "hscr;": "ùíΩ",
  "Icirc": "√é",
  "icirc": "√Æ",
  "Idot;": "ƒ∞",
  "IEcy;": "–ï",
  "iecy;": "–µ",
  "iexcl": "¬°",
  "imof;": "‚ä∑",
  "IOcy;": "–Å",
  "iocy;": "—ë",
  "Iopf;": "ùïÄ",
  "iopf;": "ùïö",
  "Iota;": "Œô",
  "iota;": "Œπ",
  "Iscr;": "‚Ñê",
  "iscr;": "ùíæ",
  "isin;": "‚àà",
  "Iuml;": "√è",
  "iuml;": "√Ø",
  "Jopf;": "ùïÅ",
  "jopf;": "ùïõ",
  "Jscr;": "ùí•",
  "jscr;": "ùíø",
  "KHcy;": "–•",
  "khcy;": "—Ö",
  "KJcy;": "–å",
  "kjcy;": "—ú",
  "Kopf;": "ùïÇ",
  "kopf;": "ùïú",
  "Kscr;": "ùí¶",
  "kscr;": "ùìÄ",
  "Lang;": "‚ü™",
  "lang;": "‚ü®",
  "laquo": "¬´",
  "Larr;": "‚Üû",
  "lArr;": "‚áê",
  "larr;": "‚Üê",
  "late;": "‚™≠",
  "lcub;": "{",
  "ldca;": "‚§∂",
  "ldsh;": "‚Ü≤",
  "leqq;": "‚â¶",
  "lesg;": "‚ãöÔ∏Ä",
  "lHar;": "‚•¢",
  "LJcy;": "–â",
  "ljcy;": "—ô",
  "lnap;": "‚™â",
  "lneq;": "‚™á",
  "Lopf;": "ùïÉ",
  "lopf;": "ùïù",
  "lozf;": "‚ß´",
  "lpar;": "(",
  "Lscr;": "‚Ñí",
  "lscr;": "ùìÅ",
  "lsim;": "‚â≤",
  "lsqb;": "[",
  "ltcc;": "‚™¶",
  "ltri;": "‚óÉ",
  "lvnE;": "‚â®Ô∏Ä",
  "macr;": "¬Ø",
  "male;": "‚ôÇ",
  "malt;": "‚ú†",
  "micro": "¬µ",
  "mlcp;": "‚´õ",
  "mldr;": "‚Ä¶",
  "Mopf;": "ùïÑ",
  "mopf;": "ùïû",
  "Mscr;": "‚Ñ≥",
  "mscr;": "ùìÇ",
  "nang;": "‚à†‚Éí",
  "napE;": "‚©∞Ã∏",
  "nbsp;": "¬†",
  "ncap;": "‚©É",
  "ncup;": "‚©Ç",
  "ngeq;": "‚â±",
  "nges;": "‚©æÃ∏",
  "ngtr;": "‚âØ",
  "nGtv;": "‚â´Ã∏",
  "nisd;": "‚ã∫",
  "NJcy;": "–ä",
  "njcy;": "—ö",
  "nldr;": "‚Ä•",
  "nleq;": "‚â∞",
  "nles;": "‚©ΩÃ∏",
  "nLtv;": "‚â™Ã∏",
  "nmid;": "‚à§",
  "Nopf;": "‚Ñï",
  "nopf;": "ùïü",
  "npar;": "‚à¶",
  "npre;": "‚™ØÃ∏",
  "nsce;": "‚™∞Ã∏",
  "Nscr;": "ùí©",
  "nscr;": "ùìÉ",
  "nsim;": "‚âÅ",
  "nsub;": "‚äÑ",
  "nsup;": "‚äÖ",
  "ntgl;": "‚âπ",
  "ntlg;": "‚â∏",
  "nvap;": "‚âç‚Éí",
  "nvge;": "‚â•‚Éí",
  "nvgt;": ">‚Éí",
  "nvle;": "‚â§‚Éí",
  "nvlt;": "<‚Éí",
  "oast;": "‚äõ",
  "ocir;": "‚äö",
  "Ocirc": "√î",
  "ocirc": "√¥",
  "odiv;": "‚®∏",
  "odot;": "‚äô",
  "ogon;": "Àõ",
  "oint;": "‚àÆ",
  "omid;": "‚¶∂",
  "Oopf;": "ùïÜ",
  "oopf;": "ùï†",
  "opar;": "‚¶∑",
  "ordf;": "¬™",
  "ordm;": "¬∫",
  "oror;": "‚©ñ",
  "Oscr;": "ùí™",
  "oscr;": "‚Ñ¥",
  "osol;": "‚äò",
  "Ouml;": "√ñ",
  "ouml;": "√∂",
  "para;": "¬∂",
  "part;": "‚àÇ",
  "perp;": "‚ä•",
  "phiv;": "œï",
  "plus;": "+",
  "Popf;": "‚Ñô",
  "popf;": "ùï°",
  "pound": "¬£",
  "prap;": "‚™∑",
  "prec;": "‚â∫",
  "prnE;": "‚™µ",
  "prod;": "‚àè",
  "prop;": "‚àù",
  "Pscr;": "ùí´",
  "pscr;": "ùìÖ",
  "qint;": "‚®å",
  "Qopf;": "‚Ñö",
  "qopf;": "ùï¢",
  "Qscr;": "ùí¨",
  "qscr;": "ùìÜ",
  "QUOT;": "\"",
  "quot;": "\"",
  "race;": "‚àΩÃ±",
  "Rang;": "‚ü´",
  "rang;": "‚ü©",
  "raquo": "¬ª",
  "Rarr;": "‚Ü†",
  "rArr;": "‚áí",
  "rarr;": "‚Üí",
  "rcub;": "}",
  "rdca;": "‚§∑",
  "rdsh;": "‚Ü≥",
  "real;": "‚Ñú",
  "rect;": "‚ñ≠",
  "rHar;": "‚•§",
  "rhov;": "œ±",
  "ring;": "Àö",
  "Ropf;": "‚Ñù",
  "ropf;": "ùï£",
  "rpar;": ")",
  "Rscr;": "‚Ñõ",
  "rscr;": "ùìá",
  "rsqb;": "]",
  "rtri;": "‚ñπ",
  "scap;": "‚™∏",
  "scnE;": "‚™∂",
  "sdot;": "‚ãÖ",
  "sect;": "¬ß",
  "semi;": ";",
  "sext;": "‚ú∂",
  "SHcy;": "–®",
  "shcy;": "—à",
  "sime;": "‚âÉ",
  "simg;": "‚™û",
  "siml;": "‚™ù",
  "smid;": "‚à£",
  "smte;": "‚™¨",
  "solb;": "‚ßÑ",
  "Sopf;": "ùïä",
  "sopf;": "ùï§",
  "spar;": "‚à•",
  "Sqrt;": "‚àö",
  "squf;": "‚ñ™",
  "Sscr;": "ùíÆ",
  "sscr;": "ùìà",
  "Star;": "‚ãÜ",
  "star;": "‚òÜ",
  "subE;": "‚´Ö",
  "sube;": "‚äÜ",
  "succ;": "‚âª",
  "sung;": "‚ô™",
  "sup1;": "¬π",
  "sup2;": "¬≤",
  "sup3;": "¬≥",
  "supE;": "‚´Ü",
  "supe;": "‚äá",
  "szlig": "√ü",
  "tbrk;": "‚é¥",
  "tdot;": "‚Éõ",
  "THORN": "√û",
  "thorn": "√æ",
  "times": "√ó",
  "tint;": "‚à≠",
  "toea;": "‚§®",
  "Topf;": "ùïã",
  "topf;": "ùï•",
  "tosa;": "‚§©",
  "trie;": "‚âú",
  "Tscr;": "ùíØ",
  "tscr;": "ùìâ",
  "TScy;": "–¶",
  "tscy;": "—Ü",
  "Uarr;": "‚Üü",
  "uArr;": "‚áë",
  "uarr;": "‚Üë",
  "Ucirc": "√õ",
  "ucirc": "√ª",
  "uHar;": "‚•£",
  "Uopf;": "ùïå",
  "uopf;": "ùï¶",
  "Upsi;": "œí",
  "upsi;": "œÖ",
  "Uscr;": "ùí∞",
  "uscr;": "ùìä",
  "utri;": "‚ñµ",
  "Uuml;": "√ú",
  "uuml;": "√º",
  "vArr;": "‚áï",
  "varr;": "‚Üï",
  "Vbar;": "‚´´",
  "vBar;": "‚´®",
  "Vert;": "‚Äñ",
  "vert;": "|",
  "Vopf;": "ùïç",
  "vopf;": "ùïß",
  "Vscr;": "ùí±",
  "vscr;": "ùìã",
  "Wopf;": "ùïé",
  "wopf;": "ùï®",
  "Wscr;": "ùí≤",
  "wscr;": "ùìå",
  "xcap;": "‚ãÇ",
  "xcup;": "‚ãÉ",
  "xmap;": "‚üº",
  "xnis;": "‚ãª",
  "Xopf;": "ùïè",
  "xopf;": "ùï©",
  "Xscr;": "ùí≥",
  "xscr;": "ùìç",
  "xvee;": "‚ãÅ",
  "YAcy;": "–Ø",
  "yacy;": "—è",
  "YIcy;": "–á",
  "yicy;": "—ó",
  "Yopf;": "ùïê",
  "yopf;": "ùï™",
  "Yscr;": "ùí¥",
  "yscr;": "ùìé",
  "YUcy;": "–Æ",
  "yucy;": "—é",
  "Yuml;": "≈∏",
  "yuml;": "√ø",
  "Zdot;": "≈ª",
  "zdot;": "≈º",
  "Zeta;": "Œñ",
  "zeta;": "Œ∂",
  "ZHcy;": "–ñ",
  "zhcy;": "–∂",
  "Zopf;": "‚Ñ§",
  "zopf;": "ùï´",
  "Zscr;": "ùíµ",
  "zscr;": "ùìè",
  "zwnj;": "‚Äå",
  "Aacute": "√Å",
  "aacute": "√°",
  "Acirc;": "√Ç",
  "acirc;": "√¢",
  "acute;": "¬¥",
  "AElig;": "√Ü",
  "aelig;": "√¶",
  "Agrave": "√Ä",
  "agrave": "√†",
  "aleph;": "‚Ñµ",
  "Alpha;": "Œë",
  "alpha;": "Œ±",
  "Amacr;": "ƒÄ",
  "amacr;": "ƒÅ",
  "amalg;": "‚®ø",
  "angle;": "‚à†",
  "angrt;": "‚àü",
  "angst;": "√Ö",
  "Aogon;": "ƒÑ",
  "aogon;": "ƒÖ",
  "Aring;": "√Ö",
  "aring;": "√•",
  "asymp;": "‚âà",
  "Atilde": "√É",
  "atilde": "√£",
  "awint;": "‚®ë",
  "bcong;": "‚âå",
  "bdquo;": "‚Äû",
  "bepsi;": "œ∂",
  "blank;": "‚ê£",
  "blk12;": "‚ñí",
  "blk14;": "‚ñë",
  "blk34;": "‚ñì",
  "block;": "‚ñà",
  "boxDL;": "‚ïó",
  "boxDl;": "‚ïñ",
  "boxdL;": "‚ïï",
  "boxdl;": "‚îê",
  "boxDR;": "‚ïî",
  "boxDr;": "‚ïì",
  "boxdR;": "‚ïí",
  "boxdr;": "‚îå",
  "boxHD;": "‚ï¶",
  "boxHd;": "‚ï§",
  "boxhD;": "‚ï•",
  "boxhd;": "‚î¨",
  "boxHU;": "‚ï©",
  "boxHu;": "‚ïß",
  "boxhU;": "‚ï®",
  "boxhu;": "‚î¥",
  "boxUL;": "‚ïù",
  "boxUl;": "‚ïú",
  "boxuL;": "‚ïõ",
  "boxul;": "‚îò",
  "boxUR;": "‚ïö",
  "boxUr;": "‚ïô",
  "boxuR;": "‚ïò",
  "boxur;": "‚îî",
  "boxVH;": "‚ï¨",
  "boxVh;": "‚ï´",
  "boxvH;": "‚ï™",
  "boxvh;": "‚îº",
  "boxVL;": "‚ï£",
  "boxVl;": "‚ï¢",
  "boxvL;": "‚ï°",
  "boxvl;": "‚î§",
  "boxVR;": "‚ï†",
  "boxVr;": "‚ïü",
  "boxvR;": "‚ïû",
  "boxvr;": "‚îú",
  "Breve;": "Àò",
  "breve;": "Àò",
  "brvbar": "¬¶",
  "bsemi;": "‚Åè",
  "bsime;": "‚ãç",
  "bsolb;": "‚ßÖ",
  "bumpE;": "‚™Æ",
  "bumpe;": "‚âè",
  "caret;": "‚ÅÅ",
  "caron;": "Àá",
  "ccaps;": "‚©ç",
  "Ccedil": "√á",
  "ccedil": "√ß",
  "Ccirc;": "ƒà",
  "ccirc;": "ƒâ",
  "ccups;": "‚©å",
  "cedil;": "¬∏",
  "check;": "‚úì",
  "clubs;": "‚ô£",
  "Colon;": "‚à∑",
  "colon;": ":",
  "comma;": ",",
  "crarr;": "‚Üµ",
  "Cross;": "‚®Ø",
  "cross;": "‚úó",
  "csube;": "‚´ë",
  "csupe;": "‚´í",
  "ctdot;": "‚ãØ",
  "cuepr;": "‚ãû",
  "cuesc;": "‚ãü",
  "cupor;": "‚©Ö",
  "curren": "¬§",
  "cuvee;": "‚ãé",
  "cuwed;": "‚ãè",
  "cwint;": "‚à±",
  "Dashv;": "‚´§",
  "dashv;": "‚ä£",
  "dblac;": "Àù",
  "ddarr;": "‚áä",
  "Delta;": "Œî",
  "delta;": "Œ¥",
  "dharl;": "‚áÉ",
  "dharr;": "‚áÇ",
  "diams;": "‚ô¶",
  "disin;": "‚ã≤",
  "divide": "√∑",
  "doteq;": "‚âê",
  "dtdot;": "‚ã±",
  "dtrif;": "‚ñæ",
  "duarr;": "‚áµ",
  "duhar;": "‚•Ø",
  "Eacute": "√â",
  "eacute": "√©",
  "Ecirc;": "√ä",
  "ecirc;": "√™",
  "eDDot;": "‚©∑",
  "efDot;": "‚âí",
  "Egrave": "√à",
  "egrave": "√®",
  "Emacr;": "ƒí",
  "emacr;": "ƒì",
  "empty;": "‚àÖ",
  "Eogon;": "ƒò",
  "eogon;": "ƒô",
  "eplus;": "‚©±",
  "epsiv;": "œµ",
  "eqsim;": "‚âÇ",
  "Equal;": "‚©µ",
  "equiv;": "‚â°",
  "erarr;": "‚•±",
  "erDot;": "‚âì",
  "esdot;": "‚âê",
  "exist;": "‚àÉ",
  "fflig;": "Ô¨Ä",
  "filig;": "Ô¨Å",
  "fjlig;": "fj",
  "fllig;": "Ô¨Ç",
  "fltns;": "‚ñ±",
  "forkv;": "‚´ô",
  "frac12": "¬Ω",
  "frac14": "¬º",
  "frac34": "¬æ",
  "frasl;": "‚ÅÑ",
  "frown;": "‚å¢",
  "Gamma;": "Œì",
  "gamma;": "Œ≥",
  "Gcirc;": "ƒú",
  "gcirc;": "ƒù",
  "gescc;": "‚™©",
  "gimel;": "‚Ñ∑",
  "gneqq;": "‚â©",
  "gnsim;": "‚ãß",
  "grave;": "`",
  "gsime;": "‚™é",
  "gsiml;": "‚™ê",
  "gtcir;": "‚©∫",
  "gtdot;": "‚ãó",
  "Hacek;": "Àá",
  "harrw;": "‚Ü≠",
  "Hcirc;": "ƒ§",
  "hcirc;": "ƒ•",
  "hoarr;": "‚áø",
  "Iacute": "√ç",
  "iacute": "√≠",
  "Icirc;": "√é",
  "icirc;": "√Æ",
  "iexcl;": "¬°",
  "Igrave": "√å",
  "igrave": "√¨",
  "iiint;": "‚à≠",
  "iiota;": "‚Ñ©",
  "IJlig;": "ƒ≤",
  "ijlig;": "ƒ≥",
  "Imacr;": "ƒ™",
  "imacr;": "ƒ´",
  "image;": "‚Ñë",
  "imath;": "ƒ±",
  "imped;": "∆µ",
  "infin;": "‚àû",
  "Iogon;": "ƒÆ",
  "iogon;": "ƒØ",
  "iprod;": "‚®º",
  "iquest": "¬ø",
  "isinE;": "‚ãπ",
  "isins;": "‚ã¥",
  "isinv;": "‚àà",
  "Iukcy;": "–Ü",
  "iukcy;": "—ñ",
  "Jcirc;": "ƒ¥",
  "jcirc;": "ƒµ",
  "jmath;": "»∑",
  "Jukcy;": "–Ñ",
  "jukcy;": "—î",
  "Kappa;": "Œö",
  "kappa;": "Œ∫",
  "lAarr;": "‚áö",
  "langd;": "‚¶ë",
  "laquo;": "¬´",
  "larrb;": "‚á§",
  "lates;": "‚™≠Ô∏Ä",
  "lBarr;": "‚§é",
  "lbarr;": "‚§å",
  "lbbrk;": "‚ù≤",
  "lbrke;": "‚¶ã",
  "lceil;": "‚åà",
  "ldquo;": "‚Äú",
  "lescc;": "‚™®",
  "lhard;": "‚ÜΩ",
  "lharu;": "‚Üº",
  "lhblk;": "‚ñÑ",
  "llarr;": "‚áá",
  "lltri;": "‚ó∫",
  "lneqq;": "‚â®",
  "lnsim;": "‚ã¶",
  "loang;": "‚ü¨",
  "loarr;": "‚áΩ",
  "lobrk;": "‚ü¶",
  "lopar;": "‚¶Ö",
  "lrarr;": "‚áÜ",
  "lrhar;": "‚áã",
  "lrtri;": "‚äø",
  "lsime;": "‚™ç",
  "lsimg;": "‚™è",
  "lsquo;": "‚Äò",
  "ltcir;": "‚©π",
  "ltdot;": "‚ãñ",
  "ltrie;": "‚ä¥",
  "ltrif;": "‚óÇ",
  "mdash;": "‚Äî",
  "mDDot;": "‚à∫",
  "micro;": "¬µ",
  "middot": "¬∑",
  "minus;": "‚àí",
  "mumap;": "‚ä∏",
  "nabla;": "‚àá",
  "napid;": "‚âãÃ∏",
  "napos;": "≈â",
  "natur;": "‚ôÆ",
  "nbump;": "‚âéÃ∏",
  "ncong;": "‚âá",
  "ndash;": "‚Äì",
  "neArr;": "‚áó",
  "nearr;": "‚Üó",
  "nedot;": "‚âêÃ∏",
  "nesim;": "‚âÇÃ∏",
  "ngeqq;": "‚âßÃ∏",
  "ngsim;": "‚âµ",
  "nhArr;": "‚áé",
  "nharr;": "‚ÜÆ",
  "nhpar;": "‚´≤",
  "nlArr;": "‚áç",
  "nlarr;": "‚Üö",
  "nleqq;": "‚â¶Ã∏",
  "nless;": "‚âÆ",
  "nlsim;": "‚â¥",
  "nltri;": "‚ã™",
  "notin;": "‚àâ",
  "notni;": "‚àå",
  "npart;": "‚àÇÃ∏",
  "nprec;": "‚äÄ",
  "nrArr;": "‚áè",
  "nrarr;": "‚Üõ",
  "nrtri;": "‚ã´",
  "nsime;": "‚âÑ",
  "nsmid;": "‚à§",
  "nspar;": "‚à¶",
  "nsubE;": "‚´ÖÃ∏",
  "nsube;": "‚äà",
  "nsucc;": "‚äÅ",
  "nsupE;": "‚´ÜÃ∏",
  "nsupe;": "‚äâ",
  "Ntilde": "√ë",
  "ntilde": "√±",
  "numsp;": "‚Äá",
  "nvsim;": "‚àº‚Éí",
  "nwArr;": "‚áñ",
  "nwarr;": "‚Üñ",
  "Oacute": "√ì",
  "oacute": "√≥",
  "Ocirc;": "√î",
  "ocirc;": "√¥",
  "odash;": "‚äù",
  "OElig;": "≈í",
  "oelig;": "≈ì",
  "ofcir;": "‚¶ø",
  "Ograve": "√í",
  "ograve": "√≤",
  "ohbar;": "‚¶µ",
  "olarr;": "‚Ü∫",
  "olcir;": "‚¶æ",
  "oline;": "‚Äæ",
  "Omacr;": "≈å",
  "omacr;": "≈ç",
  "Omega;": "Œ©",
  "omega;": "œâ",
  "operp;": "‚¶π",
  "oplus;": "‚äï",
  "orarr;": "‚Üª",
  "order;": "‚Ñ¥",
  "Oslash": "√ò",
  "oslash": "√∏",
  "Otilde": "√ï",
  "otilde": "√µ",
  "ovbar;": "‚åΩ",
  "parsl;": "‚´Ω",
  "phone;": "‚òé",
  "plusb;": "‚äû",
  "pluse;": "‚©≤",
  "plusmn": "¬±",
  "pound;": "¬£",
  "prcue;": "‚âº",
  "Prime;": "‚Ä≥",
  "prime;": "‚Ä≤",
  "prnap;": "‚™π",
  "prsim;": "‚âæ",
  "quest;": "?",
  "rAarr;": "‚áõ",
  "radic;": "‚àö",
  "rangd;": "‚¶í",
  "range;": "‚¶•",
  "raquo;": "¬ª",
  "rarrb;": "‚á•",
  "rarrc;": "‚§≥",
  "rarrw;": "‚Üù",
  "ratio;": "‚à∂",
  "RBarr;": "‚§ê",
  "rBarr;": "‚§è",
  "rbarr;": "‚§ç",
  "rbbrk;": "‚ù≥",
  "rbrke;": "‚¶å",
  "rceil;": "‚åâ",
  "rdquo;": "‚Äù",
  "reals;": "‚Ñù",
  "rhard;": "‚áÅ",
  "rharu;": "‚áÄ",
  "rlarr;": "‚áÑ",
  "rlhar;": "‚áå",
  "rnmid;": "‚´Æ",
  "roang;": "‚ü≠",
  "roarr;": "‚áæ",
  "robrk;": "‚üß",
  "ropar;": "‚¶Ü",
  "rrarr;": "‚áâ",
  "rsquo;": "‚Äô",
  "rtrie;": "‚äµ",
  "rtrif;": "‚ñ∏",
  "sbquo;": "‚Äö",
  "sccue;": "‚âΩ",
  "Scirc;": "≈ú",
  "scirc;": "≈ù",
  "scnap;": "‚™∫",
  "scsim;": "‚âø",
  "sdotb;": "‚ä°",
  "sdote;": "‚©¶",
  "seArr;": "‚áò",
  "searr;": "‚Üò",
  "setmn;": "‚àñ",
  "sharp;": "‚ôØ",
  "Sigma;": "Œ£",
  "sigma;": "œÉ",
  "simeq;": "‚âÉ",
  "simgE;": "‚™†",
  "simlE;": "‚™ü",
  "simne;": "‚âÜ",
  "slarr;": "‚Üê",
  "smile;": "‚å£",
  "smtes;": "‚™¨Ô∏Ä",
  "sqcap;": "‚äì",
  "sqcup;": "‚äî",
  "sqsub;": "‚äè",
  "sqsup;": "‚äê",
  "srarr;": "‚Üí",
  "starf;": "‚òÖ",
  "strns;": "¬Ø",
  "subnE;": "‚´ã",
  "subne;": "‚ää",
  "supnE;": "‚´å",
  "supne;": "‚äã",
  "swArr;": "‚áô",
  "swarr;": "‚Üô",
  "szlig;": "√ü",
  "Theta;": "Œò",
  "theta;": "Œ∏",
  "thkap;": "‚âà",
  "THORN;": "√û",
  "thorn;": "√æ",
  "Tilde;": "‚àº",
  "tilde;": "Àú",
  "times;": "√ó",
  "TRADE;": "‚Ñ¢",
  "trade;": "‚Ñ¢",
  "trisb;": "‚ßç",
  "TSHcy;": "–ã",
  "tshcy;": "—õ",
  "twixt;": "‚â¨",
  "Uacute": "√ö",
  "uacute": "√∫",
  "Ubrcy;": "–é",
  "ubrcy;": "—û",
  "Ucirc;": "√õ",
  "ucirc;": "√ª",
  "udarr;": "‚áÖ",
  "udhar;": "‚•Æ",
  "Ugrave": "√ô",
  "ugrave": "√π",
  "uharl;": "‚Üø",
  "uharr;": "‚Üæ",
  "uhblk;": "‚ñÄ",
  "ultri;": "‚ó∏",
  "Umacr;": "≈™",
  "umacr;": "≈´",
  "Union;": "‚ãÉ",
  "Uogon;": "≈≤",
  "uogon;": "≈≥",
  "uplus;": "‚äé",
  "upsih;": "œí",
  "UpTee;": "‚ä•",
  "Uring;": "≈Æ",
  "uring;": "≈Ø",
  "urtri;": "‚óπ",
  "utdot;": "‚ã∞",
  "utrif;": "‚ñ¥",
  "uuarr;": "‚áà",
  "varpi;": "œñ",
  "vBarv;": "‚´©",
  "VDash;": "‚ä´",
  "Vdash;": "‚ä©",
  "vDash;": "‚ä®",
  "vdash;": "‚ä¢",
  "veeeq;": "‚âö",
  "vltri;": "‚ä≤",
  "vnsub;": "‚äÇ‚Éí",
  "vnsup;": "‚äÉ‚Éí",
  "vprop;": "‚àù",
  "vrtri;": "‚ä≥",
  "Wcirc;": "≈¥",
  "wcirc;": "≈µ",
  "Wedge;": "‚ãÄ",
  "wedge;": "‚àß",
  "xcirc;": "‚óØ",
  "xdtri;": "‚ñΩ",
  "xhArr;": "‚ü∫",
  "xharr;": "‚ü∑",
  "xlArr;": "‚ü∏",
  "xlarr;": "‚üµ",
  "xodot;": "‚®Ä",
  "xrArr;": "‚üπ",
  "xrarr;": "‚ü∂",
  "xutri;": "‚ñ≥",
  "Yacute": "√ù",
  "yacute": "√Ω",
  "Ycirc;": "≈∂",
  "ycirc;": "≈∑",
  "Aacute;": "√Å",
  "aacute;": "√°",
  "Abreve;": "ƒÇ",
  "abreve;": "ƒÉ",
  "Agrave;": "√Ä",
  "agrave;": "√†",
  "andand;": "‚©ï",
  "angmsd;": "‚à°",
  "angsph;": "‚à¢",
  "apacir;": "‚©Ø",
  "approx;": "‚âà",
  "Assign;": "‚âî",
  "Atilde;": "√É",
  "atilde;": "√£",
  "barvee;": "‚äΩ",
  "Barwed;": "‚åÜ",
  "barwed;": "‚åÖ",
  "becaus;": "‚àµ",
  "bernou;": "‚Ñ¨",
  "bigcap;": "‚ãÇ",
  "bigcup;": "‚ãÉ",
  "bigvee;": "‚ãÅ",
  "bkarow;": "‚§ç",
  "bottom;": "‚ä•",
  "bowtie;": "‚ãà",
  "boxbox;": "‚ßâ",
  "bprime;": "‚Äµ",
  "brvbar;": "¬¶",
  "bullet;": "‚Ä¢",
  "Bumpeq;": "‚âé",
  "bumpeq;": "‚âè",
  "Cacute;": "ƒÜ",
  "cacute;": "ƒá",
  "capand;": "‚©Ñ",
  "capcap;": "‚©ã",
  "capcup;": "‚©á",
  "capdot;": "‚©Ä",
  "Ccaron;": "ƒå",
  "ccaron;": "ƒç",
  "Ccedil;": "√á",
  "ccedil;": "√ß",
  "circeq;": "‚âó",
  "cirmid;": "‚´Ø",
  "Colone;": "‚©¥",
  "colone;": "‚âî",
  "commat;": "@",
  "compfn;": "‚àò",
  "Conint;": "‚àØ",
  "conint;": "‚àÆ",
  "coprod;": "‚àê",
  "copysr;": "‚Ñó",
  "cularr;": "‚Ü∂",
  "CupCap;": "‚âç",
  "cupcap;": "‚©Ü",
  "cupcup;": "‚©ä",
  "cupdot;": "‚äç",
  "curarr;": "‚Ü∑",
  "curren;": "¬§",
  "cylcty;": "‚å≠",
  "Dagger;": "‚Ä°",
  "dagger;": "‚Ä†",
  "daleth;": "‚Ñ∏",
  "Dcaron;": "ƒé",
  "dcaron;": "ƒè",
  "dfisht;": "‚•ø",
  "divide;": "√∑",
  "divonx;": "‚ãá",
  "dlcorn;": "‚åû",
  "dlcrop;": "‚åç",
  "dollar;": "$",
  "DotDot;": "‚Éú",
  "drcorn;": "‚åü",
  "drcrop;": "‚åå",
  "Dstrok;": "ƒê",
  "dstrok;": "ƒë",
  "Eacute;": "√â",
  "eacute;": "√©",
  "easter;": "‚©Æ",
  "Ecaron;": "ƒö",
  "ecaron;": "ƒõ",
  "ecolon;": "‚âï",
  "Egrave;": "√à",
  "egrave;": "√®",
  "egsdot;": "‚™ò",
  "elsdot;": "‚™ó",
  "emptyv;": "‚àÖ",
  "emsp13;": "‚ÄÑ",
  "emsp14;": "‚ÄÖ",
  "eparsl;": "‚ß£",
  "eqcirc;": "‚âñ",
  "equals;": "=",
  "equest;": "‚âü",
  "Exists;": "‚àÉ",
  "female;": "‚ôÄ",
  "ffilig;": "Ô¨É",
  "ffllig;": "Ô¨Ñ",
  "ForAll;": "‚àÄ",
  "forall;": "‚àÄ",
  "frac12;": "¬Ω",
  "frac13;": "‚Öì",
  "frac14;": "¬º",
  "frac15;": "‚Öï",
  "frac16;": "‚Öô",
  "frac18;": "‚Öõ",
  "frac23;": "‚Öî",
  "frac25;": "‚Öñ",
  "frac34;": "¬æ",
  "frac35;": "‚Öó",
  "frac38;": "‚Öú",
  "frac45;": "‚Öò",
  "frac56;": "‚Öö",
  "frac58;": "‚Öù",
  "frac78;": "‚Öû",
  "gacute;": "«µ",
  "Gammad;": "œú",
  "gammad;": "œù",
  "Gbreve;": "ƒû",
  "gbreve;": "ƒü",
  "Gcedil;": "ƒ¢",
  "gesdot;": "‚™Ä",
  "gesles;": "‚™î",
  "gtlPar;": "‚¶ï",
  "gtrarr;": "‚•∏",
  "gtrdot;": "‚ãó",
  "gtrsim;": "‚â≥",
  "hairsp;": "‚Ää",
  "hamilt;": "‚Ñã",
  "HARDcy;": "–™",
  "hardcy;": "—ä",
  "hearts;": "‚ô•",
  "hellip;": "‚Ä¶",
  "hercon;": "‚äπ",
  "homtht;": "‚àª",
  "horbar;": "‚Äï",
  "hslash;": "‚Ñè",
  "Hstrok;": "ƒ¶",
  "hstrok;": "ƒß",
  "hybull;": "‚ÅÉ",
  "hyphen;": "‚Äê",
  "Iacute;": "√ç",
  "iacute;": "√≠",
  "Igrave;": "√å",
  "igrave;": "√¨",
  "iiiint;": "‚®å",
  "iinfin;": "‚ßú",
  "incare;": "‚ÑÖ",
  "inodot;": "ƒ±",
  "intcal;": "‚ä∫",
  "iquest;": "¬ø",
  "isinsv;": "‚ã≥",
  "Itilde;": "ƒ®",
  "itilde;": "ƒ©",
  "Jsercy;": "–à",
  "jsercy;": "—ò",
  "kappav;": "œ∞",
  "Kcedil;": "ƒ∂",
  "kcedil;": "ƒ∑",
  "kgreen;": "ƒ∏",
  "Lacute;": "ƒπ",
  "lacute;": "ƒ∫",
  "lagran;": "‚Ñí",
  "Lambda;": "Œõ",
  "lambda;": "Œª",
  "langle;": "‚ü®",
  "larrfs;": "‚§ù",
  "larrhk;": "‚Ü©",
  "larrlp;": "‚Ü´",
  "larrpl;": "‚§π",
  "larrtl;": "‚Ü¢",
  "lAtail;": "‚§õ",
  "latail;": "‚§ô",
  "lbrace;": "{",
  "lbrack;": "[",
  "Lcaron;": "ƒΩ",
  "lcaron;": "ƒæ",
  "Lcedil;": "ƒª",
  "lcedil;": "ƒº",
  "ldquor;": "‚Äû",
  "lesdot;": "‚©ø",
  "lesges;": "‚™ì",
  "lfisht;": "‚•º",
  "lfloor;": "‚åä",
  "lharul;": "‚•™",
  "llhard;": "‚•´",
  "Lmidot;": "ƒø",
  "lmidot;": "≈Ä",
  "lmoust;": "‚é∞",
  "loplus;": "‚®≠",
  "lowast;": "‚àó",
  "lowbar;": "_",
  "lparlt;": "‚¶ì",
  "lrhard;": "‚•≠",
  "lsaquo;": "‚Äπ",
  "lsquor;": "‚Äö",
  "Lstrok;": "≈Å",
  "lstrok;": "≈Ç",
  "lthree;": "‚ãã",
  "ltimes;": "‚ãâ",
  "ltlarr;": "‚•∂",
  "ltrPar;": "‚¶ñ",
  "mapsto;": "‚Ü¶",
  "marker;": "‚ñÆ",
  "mcomma;": "‚®©",
  "midast;": "*",
  "midcir;": "‚´∞",
  "middot;": "¬∑",
  "minusb;": "‚äü",
  "minusd;": "‚à∏",
  "mnplus;": "‚àì",
  "models;": "‚äß",
  "mstpos;": "‚àæ",
  "Nacute;": "≈É",
  "nacute;": "≈Ñ",
  "nbumpe;": "‚âèÃ∏",
  "Ncaron;": "≈á",
  "ncaron;": "≈à",
  "Ncedil;": "≈Ö",
  "ncedil;": "≈Ü",
  "nearhk;": "‚§§",
  "nequiv;": "‚â¢",
  "nesear;": "‚§®",
  "nexist;": "‚àÑ",
  "nltrie;": "‚ã¨",
  "notinE;": "‚ãπÃ∏",
  "nparsl;": "‚´Ω‚É•",
  "nprcue;": "‚ã†",
  "nrarrc;": "‚§≥Ã∏",
  "nrarrw;": "‚ÜùÃ∏",
  "nrtrie;": "‚ã≠",
  "nsccue;": "‚ã°",
  "nsimeq;": "‚âÑ",
  "Ntilde;": "√ë",
  "ntilde;": "√±",
  "numero;": "‚Ññ",
  "nVDash;": "‚äØ",
  "nVdash;": "‚äÆ",
  "nvDash;": "‚ä≠",
  "nvdash;": "‚ä¨",
  "nvHarr;": "‚§Ñ",
  "nvlArr;": "‚§Ç",
  "nvrArr;": "‚§É",
  "nwarhk;": "‚§£",
  "nwnear;": "‚§ß",
  "Oacute;": "√ì",
  "oacute;": "√≥",
  "Odblac;": "≈ê",
  "odblac;": "≈ë",
  "odsold;": "‚¶º",
  "Ograve;": "√í",
  "ograve;": "√≤",
  "ominus;": "‚äñ",
  "origof;": "‚ä∂",
  "Oslash;": "√ò",
  "oslash;": "√∏",
  "Otilde;": "√ï",
  "otilde;": "√µ",
  "Otimes;": "‚®∑",
  "otimes;": "‚äó",
  "parsim;": "‚´≥",
  "percnt;": "%",
  "period;": ".",
  "permil;": "‚Ä∞",
  "phmmat;": "‚Ñ≥",
  "planck;": "‚Ñè",
  "plankv;": "‚Ñè",
  "plusdo;": "‚àî",
  "plusdu;": "‚®•",
  "plusmn;": "¬±",
  "preceq;": "‚™Ø",
  "primes;": "‚Ñô",
  "prnsim;": "‚ã®",
  "propto;": "‚àù",
  "prurel;": "‚ä∞",
  "puncsp;": "‚Äà",
  "qprime;": "‚Åó",
  "Racute;": "≈î",
  "racute;": "≈ï",
  "rangle;": "‚ü©",
  "rarrap;": "‚•µ",
  "rarrfs;": "‚§û",
  "rarrhk;": "‚Ü™",
  "rarrlp;": "‚Ü¨",
  "rarrpl;": "‚•Ö",
  "Rarrtl;": "‚§ñ",
  "rarrtl;": "‚Ü£",
  "rAtail;": "‚§ú",
  "ratail;": "‚§ö",
  "rbrace;": "}",
  "rbrack;": "]",
  "Rcaron;": "≈ò",
  "rcaron;": "≈ô",
  "Rcedil;": "≈ñ",
  "rcedil;": "≈ó",
  "rdquor;": "‚Äù",
  "rfisht;": "‚•Ω",
  "rfloor;": "‚åã",
  "rharul;": "‚•¨",
  "rmoust;": "‚é±",
  "roplus;": "‚®Æ",
  "rpargt;": "‚¶î",
  "rsaquo;": "‚Ä∫",
  "rsquor;": "‚Äô",
  "rthree;": "‚ãå",
  "rtimes;": "‚ãä",
  "Sacute;": "≈ö",
  "sacute;": "≈õ",
  "Scaron;": "≈†",
  "scaron;": "≈°",
  "Scedil;": "≈û",
  "scedil;": "≈ü",
  "scnsim;": "‚ã©",
  "searhk;": "‚§•",
  "seswar;": "‚§©",
  "sfrown;": "‚å¢",
  "SHCHcy;": "–©",
  "shchcy;": "—â",
  "sigmaf;": "œÇ",
  "sigmav;": "œÇ",
  "simdot;": "‚©™",
  "smashp;": "‚®≥",
  "SOFTcy;": "–¨",
  "softcy;": "—å",
  "solbar;": "‚åø",
  "spades;": "‚ô†",
  "sqcaps;": "‚äìÔ∏Ä",
  "sqcups;": "‚äîÔ∏Ä",
  "sqsube;": "‚äë",
  "sqsupe;": "‚äí",
  "Square;": "‚ñ°",
  "square;": "‚ñ°",
  "squarf;": "‚ñ™",
  "ssetmn;": "‚àñ",
  "ssmile;": "‚å£",
  "sstarf;": "‚ãÜ",
  "subdot;": "‚™Ω",
  "Subset;": "‚ãê",
  "subset;": "‚äÇ",
  "subsim;": "‚´á",
  "subsub;": "‚´ï",
  "subsup;": "‚´ì",
  "succeq;": "‚™∞",
  "supdot;": "‚™æ",
  "Supset;": "‚ãë",
  "supset;": "‚äÉ",
  "supsim;": "‚´à",
  "supsub;": "‚´î",
  "supsup;": "‚´ñ",
  "swarhk;": "‚§¶",
  "swnwar;": "‚§™",
  "target;": "‚åñ",
  "Tcaron;": "≈§",
  "tcaron;": "≈•",
  "Tcedil;": "≈¢",
  "tcedil;": "≈£",
  "telrec;": "‚åï",
  "there4;": "‚à¥",
  "thetav;": "œë",
  "thinsp;": "‚Äâ",
  "thksim;": "‚àº",
  "timesb;": "‚ä†",
  "timesd;": "‚®∞",
  "topbot;": "‚å∂",
  "topcir;": "‚´±",
  "tprime;": "‚Ä¥",
  "tridot;": "‚ó¨",
  "Tstrok;": "≈¶",
  "tstrok;": "≈ß",
  "Uacute;": "√ö",
  "uacute;": "√∫",
  "Ubreve;": "≈¨",
  "ubreve;": "≈≠",
  "Udblac;": "≈∞",
  "udblac;": "≈±",
  "ufisht;": "‚•æ",
  "Ugrave;": "√ô",
  "ugrave;": "√π",
  "ulcorn;": "‚åú",
  "ulcrop;": "‚åè",
  "urcorn;": "‚åù",
  "urcrop;": "‚åé",
  "Utilde;": "≈®",
  "utilde;": "≈©",
  "vangrt;": "‚¶ú",
  "varphi;": "œï",
  "varrho;": "œ±",
  "Vdashl;": "‚´¶",
  "veebar;": "‚äª",
  "vellip;": "‚ãÆ",
  "Verbar;": "‚Äñ",
  "verbar;": "|",
  "vsubnE;": "‚´ãÔ∏Ä",
  "vsubne;": "‚ääÔ∏Ä",
  "vsupnE;": "‚´åÔ∏Ä",
  "vsupne;": "‚äãÔ∏Ä",
  "Vvdash;": "‚ä™",
  "wedbar;": "‚©ü",
  "wedgeq;": "‚âô",
  "weierp;": "‚Ñò",
  "wreath;": "‚âÄ",
  "xoplus;": "‚®Å",
  "xotime;": "‚®Ç",
  "xsqcup;": "‚®Ü",
  "xuplus;": "‚®Ñ",
  "xwedge;": "‚ãÄ",
  "Yacute;": "√ù",
  "yacute;": "√Ω",
  "Zacute;": "≈π",
  "zacute;": "≈∫",
  "Zcaron;": "≈Ω",
  "zcaron;": "≈æ",
  "zeetrf;": "‚Ñ®",
  "alefsym;": "‚Ñµ",
  "angrtvb;": "‚äæ",
  "angzarr;": "‚çº",
  "asympeq;": "‚âç",
  "backsim;": "‚àΩ",
  "Because;": "‚àµ",
  "because;": "‚àµ",
  "bemptyv;": "‚¶∞",
  "between;": "‚â¨",
  "bigcirc;": "‚óØ",
  "bigodot;": "‚®Ä",
  "bigstar;": "‚òÖ",
  "bnequiv;": "‚â°‚É•",
  "boxplus;": "‚äû",
  "Cayleys;": "‚Ñ≠",
  "Cconint;": "‚à∞",
  "ccupssm;": "‚©ê",
  "Cedilla;": "¬∏",
  "cemptyv;": "‚¶≤",
  "cirscir;": "‚ßÇ",
  "coloneq;": "‚âî",
  "congdot;": "‚©≠",
  "cudarrl;": "‚§∏",
  "cudarrr;": "‚§µ",
  "cularrp;": "‚§Ω",
  "curarrm;": "‚§º",
  "dbkarow;": "‚§è",
  "ddagger;": "‚Ä°",
  "ddotseq;": "‚©∑",
  "demptyv;": "‚¶±",
  "Diamond;": "‚ãÑ",
  "diamond;": "‚ãÑ",
  "digamma;": "œù",
  "dotplus;": "‚àî",
  "DownTee;": "‚ä§",
  "dwangle;": "‚¶¶",
  "Element;": "‚àà",
  "Epsilon;": "Œï",
  "epsilon;": "Œµ",
  "eqcolon;": "‚âï",
  "equivDD;": "‚©∏",
  "gesdoto;": "‚™Ç",
  "gtquest;": "‚©º",
  "gtrless;": "‚â∑",
  "harrcir;": "‚•à",
  "Implies;": "‚áí",
  "intprod;": "‚®º",
  "isindot;": "‚ãµ",
  "larrbfs;": "‚§ü",
  "larrsim;": "‚•≥",
  "lbrksld;": "‚¶è",
  "lbrkslu;": "‚¶ç",
  "ldrdhar;": "‚•ß",
  "LeftTee;": "‚ä£",
  "lesdoto;": "‚™Å",
  "lessdot;": "‚ãñ",
  "lessgtr;": "‚â∂",
  "lesssim;": "‚â≤",
  "lotimes;": "‚®¥",
  "lozenge;": "‚óä",
  "ltquest;": "‚©ª",
  "luruhar;": "‚•¶",
  "maltese;": "‚ú†",
  "minusdu;": "‚®™",
  "napprox;": "‚ââ",
  "natural;": "‚ôÆ",
  "nearrow;": "‚Üó",
  "NewLine;": "\n",
  "nexists;": "‚àÑ",
  "NoBreak;": "‚Å†",
  "notinva;": "‚àâ",
  "notinvb;": "‚ã∑",
  "notinvc;": "‚ã∂",
  "NotLess;": "‚âÆ",
  "notniva;": "‚àå",
  "notnivb;": "‚ãæ",
  "notnivc;": "‚ãΩ",
  "npolint;": "‚®î",
  "npreceq;": "‚™ØÃ∏",
  "nsqsube;": "‚ã¢",
  "nsqsupe;": "‚ã£",
  "nsubset;": "‚äÇ‚Éí",
  "nsucceq;": "‚™∞Ã∏",
  "nsupset;": "‚äÉ‚Éí",
  "nvinfin;": "‚ßû",
  "nvltrie;": "‚ä¥‚Éí",
  "nvrtrie;": "‚äµ‚Éí",
  "nwarrow;": "‚Üñ",
  "olcross;": "‚¶ª",
  "Omicron;": "Œü",
  "omicron;": "Œø",
  "orderof;": "‚Ñ¥",
  "orslope;": "‚©ó",
  "OverBar;": "‚Äæ",
  "pertenk;": "‚Ä±",
  "planckh;": "‚Ñé",
  "pluscir;": "‚®¢",
  "plussim;": "‚®¶",
  "plustwo;": "‚®ß",
  "precsim;": "‚âæ",
  "Product;": "‚àè",
  "quatint;": "‚®ñ",
  "questeq;": "‚âü",
  "rarrbfs;": "‚§†",
  "rarrsim;": "‚•¥",
  "rbrksld;": "‚¶é",
  "rbrkslu;": "‚¶ê",
  "rdldhar;": "‚•©",
  "realine;": "‚Ñõ",
  "rotimes;": "‚®µ",
  "ruluhar;": "‚•®",
  "searrow;": "‚Üò",
  "simplus;": "‚®§",
  "simrarr;": "‚•≤",
  "subedot;": "‚´É",
  "submult;": "‚´Å",
  "subplus;": "‚™ø",
  "subrarr;": "‚•π",
  "succsim;": "‚âø",
  "supdsub;": "‚´ò",
  "supedot;": "‚´Ñ",
  "suphsol;": "‚üâ",
  "suphsub;": "‚´ó",
  "suplarr;": "‚•ª",
  "supmult;": "‚´Ç",
  "supplus;": "‚´Ä",
  "swarrow;": "‚Üô",
  "topfork;": "‚´ö",
  "triplus;": "‚®π",
  "tritime;": "‚®ª",
  "UpArrow;": "‚Üë",
  "Uparrow;": "‚áë",
  "uparrow;": "‚Üë",
  "Upsilon;": "Œ•",
  "upsilon;": "œÖ",
  "uwangle;": "‚¶ß",
  "vzigzag;": "‚¶ö",
  "zigrarr;": "‚áù",
  "andslope;": "‚©ò",
  "angmsdaa;": "‚¶®",
  "angmsdab;": "‚¶©",
  "angmsdac;": "‚¶™",
  "angmsdad;": "‚¶´",
  "angmsdae;": "‚¶¨",
  "angmsdaf;": "‚¶≠",
  "angmsdag;": "‚¶Æ",
  "angmsdah;": "‚¶Ø",
  "angrtvbd;": "‚¶ù",
  "approxeq;": "‚âä",
  "awconint;": "‚à≥",
  "backcong;": "‚âå",
  "barwedge;": "‚åÖ",
  "bbrktbrk;": "‚é∂",
  "bigoplus;": "‚®Å",
  "bigsqcup;": "‚®Ü",
  "biguplus;": "‚®Ñ",
  "bigwedge;": "‚ãÄ",
  "boxminus;": "‚äü",
  "boxtimes;": "‚ä†",
  "bsolhsub;": "‚üà",
  "capbrcup;": "‚©â",
  "circledR;": "¬Æ",
  "circledS;": "‚ìà",
  "cirfnint;": "‚®ê",
  "clubsuit;": "‚ô£",
  "cupbrcap;": "‚©à",
  "curlyvee;": "‚ãé",
  "cwconint;": "‚à≤",
  "DDotrahd;": "‚§ë",
  "doteqdot;": "‚âë",
  "DotEqual;": "‚âê",
  "dotminus;": "‚à∏",
  "drbkarow;": "‚§ê",
  "dzigrarr;": "‚üø",
  "elinters;": "‚èß",
  "emptyset;": "‚àÖ",
  "eqvparsl;": "‚ß•",
  "fpartint;": "‚®ç",
  "geqslant;": "‚©æ",
  "gesdotol;": "‚™Ñ",
  "gnapprox;": "‚™ä",
  "hksearow;": "‚§•",
  "hkswarow;": "‚§¶",
  "imagline;": "‚Ñê",
  "imagpart;": "‚Ñë",
  "infintie;": "‚ßù",
  "integers;": "‚Ñ§",
  "Integral;": "‚à´",
  "intercal;": "‚ä∫",
  "intlarhk;": "‚®ó",
  "laemptyv;": "‚¶¥",
  "ldrushar;": "‚•ã",
  "leqslant;": "‚©Ω",
  "lesdotor;": "‚™É",
  "LessLess;": "‚™°",
  "llcorner;": "‚åû",
  "lnapprox;": "‚™â",
  "lrcorner;": "‚åü",
  "lurdshar;": "‚•ä",
  "mapstoup;": "‚Ü•",
  "multimap;": "‚ä∏",
  "naturals;": "‚Ñï",
  "ncongdot;": "‚©≠Ã∏",
  "NotEqual;": "‚â†",
  "notindot;": "‚ãµÃ∏",
  "NotTilde;": "‚âÅ",
  "otimesas;": "‚®∂",
  "parallel;": "‚à•",
  "PartialD;": "‚àÇ",
  "plusacir;": "‚®£",
  "pointint;": "‚®ï",
  "Precedes;": "‚â∫",
  "precneqq;": "‚™µ",
  "precnsim;": "‚ã®",
  "profalar;": "‚åÆ",
  "profline;": "‚åí",
  "profsurf;": "‚åì",
  "raemptyv;": "‚¶≥",
  "realpart;": "‚Ñú",
  "RightTee;": "‚ä¢",
  "rppolint;": "‚®í",
  "rtriltri;": "‚ßé",
  "scpolint;": "‚®ì",
  "setminus;": "‚àñ",
  "shortmid;": "‚à£",
  "smeparsl;": "‚ß§",
  "sqsubset;": "‚äè",
  "sqsupset;": "‚äê",
  "subseteq;": "‚äÜ",
  "Succeeds;": "‚âª",
  "succneqq;": "‚™∂",
  "succnsim;": "‚ã©",
  "SuchThat;": "‚àã",
  "Superset;": "‚äÉ",
  "supseteq;": "‚äá",
  "thetasym;": "œë",
  "thicksim;": "‚àº",
  "timesbar;": "‚®±",
  "triangle;": "‚ñµ",
  "triminus;": "‚®∫",
  "trpezium;": "‚è¢",
  "Uarrocir;": "‚•â",
  "ulcorner;": "‚åú",
  "UnderBar;": "_",
  "urcorner;": "‚åù",
  "varkappa;": "œ∞",
  "varsigma;": "œÇ",
  "vartheta;": "œë",
  "backprime;": "‚Äµ",
  "backsimeq;": "‚ãç",
  "Backslash;": "‚àñ",
  "bigotimes;": "‚®Ç",
  "CenterDot;": "¬∑",
  "centerdot;": "¬∑",
  "checkmark;": "‚úì",
  "CircleDot;": "‚äô",
  "complexes;": "‚ÑÇ",
  "Congruent;": "‚â°",
  "Coproduct;": "‚àê",
  "dotsquare;": "‚ä°",
  "DoubleDot;": "¬®",
  "DownArrow;": "‚Üì",
  "Downarrow;": "‚áì",
  "downarrow;": "‚Üì",
  "DownBreve;": "Ãë",
  "gtrapprox;": "‚™Ü",
  "gtreqless;": "‚ãõ",
  "gvertneqq;": "‚â©Ô∏Ä",
  "heartsuit;": "‚ô•",
  "HumpEqual;": "‚âè",
  "LeftArrow;": "‚Üê",
  "Leftarrow;": "‚áê",
  "leftarrow;": "‚Üê",
  "LeftFloor;": "‚åä",
  "lesseqgtr;": "‚ãö",
  "LessTilde;": "‚â≤",
  "lvertneqq;": "‚â®Ô∏Ä",
  "Mellintrf;": "‚Ñ≥",
  "MinusPlus;": "‚àì",
  "ngeqslant;": "‚©æÃ∏",
  "nleqslant;": "‚©ΩÃ∏",
  "NotCupCap;": "‚â≠",
  "NotExists;": "‚àÑ",
  "NotSubset;": "‚äÇ‚Éí",
  "nparallel;": "‚à¶",
  "nshortmid;": "‚à§",
  "nsubseteq;": "‚äà",
  "nsupseteq;": "‚äâ",
  "OverBrace;": "‚èû",
  "pitchfork;": "‚ãî",
  "PlusMinus;": "¬±",
  "rationals;": "‚Ñö",
  "spadesuit;": "‚ô†",
  "subseteqq;": "‚´Ö",
  "subsetneq;": "‚ää",
  "supseteqq;": "‚´Ü",
  "supsetneq;": "‚äã",
  "Therefore;": "‚à¥",
  "therefore;": "‚à¥",
  "ThinSpace;": "‚Äâ",
  "triangleq;": "‚âú",
  "TripleDot;": "‚Éõ",
  "UnionPlus;": "‚äé",
  "varpropto;": "‚àù",
  "Bernoullis;": "‚Ñ¨",
  "circledast;": "‚äõ",
  "CirclePlus;": "‚äï",
  "complement;": "‚àÅ",
  "curlywedge;": "‚ãè",
  "eqslantgtr;": "‚™ñ",
  "EqualTilde;": "‚âÇ",
  "Fouriertrf;": "‚Ñ±",
  "gtreqqless;": "‚™å",
  "ImaginaryI;": "‚Öà",
  "Laplacetrf;": "‚Ñí",
  "LeftVector;": "‚Üº",
  "lessapprox;": "‚™Ö",
  "lesseqqgtr;": "‚™ã",
  "Lleftarrow;": "‚áö",
  "lmoustache;": "‚é∞",
  "longmapsto;": "‚üº",
  "mapstodown;": "‚Üß",
  "mapstoleft;": "‚Ü§",
  "nLeftarrow;": "‚áç",
  "nleftarrow;": "‚Üö",
  "NotElement;": "‚àâ",
  "NotGreater;": "‚âØ",
  "nsubseteqq;": "‚´ÖÃ∏",
  "nsupseteqq;": "‚´ÜÃ∏",
  "precapprox;": "‚™∑",
  "Proportion;": "‚à∑",
  "RightArrow;": "‚Üí",
  "Rightarrow;": "‚áí",
  "rightarrow;": "‚Üí",
  "RightFloor;": "‚åã",
  "rmoustache;": "‚é±",
  "sqsubseteq;": "‚äë",
  "sqsupseteq;": "‚äí",
  "subsetneqq;": "‚´ã",
  "succapprox;": "‚™∏",
  "supsetneqq;": "‚´å",
  "ThickSpace;": "‚Åü‚Ää",
  "TildeEqual;": "‚âÉ",
  "TildeTilde;": "‚âà",
  "UnderBrace;": "‚èü",
  "UpArrowBar;": "‚§í",
  "UpTeeArrow;": "‚Ü•",
  "upuparrows;": "‚áà",
  "varepsilon;": "œµ",
  "varnothing;": "‚àÖ",
  "backepsilon;": "œ∂",
  "blacksquare;": "‚ñ™",
  "circledcirc;": "‚äö",
  "circleddash;": "‚äù",
  "CircleMinus;": "‚äñ",
  "CircleTimes;": "‚äó",
  "curlyeqprec;": "‚ãû",
  "curlyeqsucc;": "‚ãü",
  "diamondsuit;": "‚ô¶",
  "eqslantless;": "‚™ï",
  "Equilibrium;": "‚áå",
  "expectation;": "‚Ñ∞",
  "GreaterLess;": "‚â∑",
  "LeftCeiling;": "‚åà",
  "LessGreater;": "‚â∂",
  "MediumSpace;": "‚Åü",
  "NotLessLess;": "‚â™Ã∏",
  "NotPrecedes;": "‚äÄ",
  "NotSucceeds;": "‚äÅ",
  "NotSuperset;": "‚äÉ‚Éí",
  "nRightarrow;": "‚áè",
  "nrightarrow;": "‚Üõ",
  "OverBracket;": "‚é¥",
  "preccurlyeq;": "‚âº",
  "precnapprox;": "‚™π",
  "quaternions;": "‚Ñç",
  "RightVector;": "‚áÄ",
  "Rrightarrow;": "‚áõ",
  "RuleDelayed;": "‚ß¥",
  "SmallCircle;": "‚àò",
  "SquareUnion;": "‚äî",
  "straightphi;": "œï",
  "SubsetEqual;": "‚äÜ",
  "succcurlyeq;": "‚âΩ",
  "succnapprox;": "‚™∫",
  "thickapprox;": "‚âà",
  "UpDownArrow;": "‚Üï",
  "Updownarrow;": "‚áï",
  "updownarrow;": "‚Üï",
  "VerticalBar;": "‚à£",
  "blacklozenge;": "‚ß´",
  "DownArrowBar;": "‚§ì",
  "DownTeeArrow;": "‚Üß",
  "ExponentialE;": "‚Öá",
  "exponentiale;": "‚Öá",
  "GreaterEqual;": "‚â•",
  "GreaterTilde;": "‚â≥",
  "HilbertSpace;": "‚Ñã",
  "HumpDownHump;": "‚âé",
  "Intersection;": "‚ãÇ",
  "LeftArrowBar;": "‚á§",
  "LeftTeeArrow;": "‚Ü§",
  "LeftTriangle;": "‚ä≤",
  "LeftUpVector;": "‚Üø",
  "NotCongruent;": "‚â¢",
  "NotHumpEqual;": "‚âèÃ∏",
  "NotLessEqual;": "‚â∞",
  "NotLessTilde;": "‚â¥",
  "Proportional;": "‚àù",
  "RightCeiling;": "‚åâ",
  "risingdotseq;": "‚âì",
  "RoundImplies;": "‚•∞",
  "ShortUpArrow;": "‚Üë",
  "SquareSubset;": "‚äè",
  "triangledown;": "‚ñø",
  "triangleleft;": "‚óÉ",
  "UnderBracket;": "‚éµ",
  "varsubsetneq;": "‚ääÔ∏Ä",
  "varsupsetneq;": "‚äãÔ∏Ä",
  "VerticalLine;": "|",
  "ApplyFunction;": "‚Å°",
  "bigtriangleup;": "‚ñ≥",
  "blacktriangle;": "‚ñ¥",
  "DifferentialD;": "‚ÖÜ",
  "divideontimes;": "‚ãá",
  "DoubleLeftTee;": "‚´§",
  "DoubleUpArrow;": "‚áë",
  "fallingdotseq;": "‚âí",
  "hookleftarrow;": "‚Ü©",
  "leftarrowtail;": "‚Ü¢",
  "leftharpoonup;": "‚Üº",
  "LeftTeeVector;": "‚•ö",
  "LeftVectorBar;": "‚•í",
  "LessFullEqual;": "‚â¶",
  "LongLeftArrow;": "‚üµ",
  "Longleftarrow;": "‚ü∏",
  "longleftarrow;": "‚üµ",
  "looparrowleft;": "‚Ü´",
  "measuredangle;": "‚à°",
  "NotEqualTilde;": "‚âÇÃ∏",
  "NotTildeEqual;": "‚âÑ",
  "NotTildeTilde;": "‚ââ",
  "ntriangleleft;": "‚ã™",
  "Poincareplane;": "‚Ñå",
  "PrecedesEqual;": "‚™Ø",
  "PrecedesTilde;": "‚âæ",
  "RightArrowBar;": "‚á•",
  "RightTeeArrow;": "‚Ü¶",
  "RightTriangle;": "‚ä≥",
  "RightUpVector;": "‚Üæ",
  "shortparallel;": "‚à•",
  "smallsetminus;": "‚àñ",
  "SucceedsEqual;": "‚™∞",
  "SucceedsTilde;": "‚âø",
  "SupersetEqual;": "‚äá",
  "triangleright;": "‚ñπ",
  "UpEquilibrium;": "‚•Æ",
  "upharpoonleft;": "‚Üø",
  "varsubsetneqq;": "‚´ãÔ∏Ä",
  "varsupsetneqq;": "‚´åÔ∏Ä",
  "VerticalTilde;": "‚âÄ",
  "VeryThinSpace;": "‚Ää",
  "curvearrowleft;": "‚Ü∂",
  "DiacriticalDot;": "Àô",
  "doublebarwedge;": "‚åÜ",
  "DoubleRightTee;": "‚ä®",
  "downdownarrows;": "‚áä",
  "DownLeftVector;": "‚ÜΩ",
  "GreaterGreater;": "‚™¢",
  "hookrightarrow;": "‚Ü™",
  "HorizontalLine;": "‚îÄ",
  "InvisibleComma;": "‚Å£",
  "InvisibleTimes;": "‚Å¢",
  "LeftDownVector;": "‚áÉ",
  "leftleftarrows;": "‚áá",
  "LeftRightArrow;": "‚Üî",
  "Leftrightarrow;": "‚áî",
  "leftrightarrow;": "‚Üî",
  "leftthreetimes;": "‚ãã",
  "LessSlantEqual;": "‚©Ω",
  "LongRightArrow;": "‚ü∂",
  "Longrightarrow;": "‚üπ",
  "longrightarrow;": "‚ü∂",
  "looparrowright;": "‚Ü¨",
  "LowerLeftArrow;": "‚Üô",
  "NestedLessLess;": "‚â™",
  "NotGreaterLess;": "‚âπ",
  "NotLessGreater;": "‚â∏",
  "NotSubsetEqual;": "‚äà",
  "NotVerticalBar;": "‚à§",
  "nshortparallel;": "‚à¶",
  "ntriangleright;": "‚ã´",
  "OpenCurlyQuote;": "‚Äò",
  "ReverseElement;": "‚àã",
  "rightarrowtail;": "‚Ü£",
  "rightharpoonup;": "‚áÄ",
  "RightTeeVector;": "‚•õ",
  "RightVectorBar;": "‚•ì",
  "ShortDownArrow;": "‚Üì",
  "ShortLeftArrow;": "‚Üê",
  "SquareSuperset;": "‚äê",
  "TildeFullEqual;": "‚âÖ",
  "trianglelefteq;": "‚ä¥",
  "upharpoonright;": "‚Üæ",
  "UpperLeftArrow;": "‚Üñ",
  "ZeroWidthSpace;": "‚Äã",
  "bigtriangledown;": "‚ñΩ",
  "circlearrowleft;": "‚Ü∫",
  "CloseCurlyQuote;": "‚Äô",
  "ContourIntegral;": "‚àÆ",
  "curvearrowright;": "‚Ü∑",
  "DoubleDownArrow;": "‚áì",
  "DoubleLeftArrow;": "‚áê",
  "downharpoonleft;": "‚áÉ",
  "DownRightVector;": "‚áÅ",
  "leftharpoondown;": "‚ÜΩ",
  "leftrightarrows;": "‚áÜ",
  "LeftRightVector;": "‚•é",
  "LeftTriangleBar;": "‚ßè",
  "LeftUpTeeVector;": "‚•†",
  "LeftUpVectorBar;": "‚•ò",
  "LowerRightArrow;": "‚Üò",
  "nLeftrightarrow;": "‚áé",
  "nleftrightarrow;": "‚ÜÆ",
  "NotGreaterEqual;": "‚â±",
  "NotGreaterTilde;": "‚âµ",
  "NotHumpDownHump;": "‚âéÃ∏",
  "NotLeftTriangle;": "‚ã™",
  "NotSquareSubset;": "‚äèÃ∏",
  "ntrianglelefteq;": "‚ã¨",
  "OverParenthesis;": "‚èú",
  "RightDownVector;": "‚áÇ",
  "rightleftarrows;": "‚áÑ",
  "rightsquigarrow;": "‚Üù",
  "rightthreetimes;": "‚ãå",
  "ShortRightArrow;": "‚Üí",
  "straightepsilon;": "œµ",
  "trianglerighteq;": "‚äµ",
  "UpperRightArrow;": "‚Üó",
  "vartriangleleft;": "‚ä≤",
  "circlearrowright;": "‚Üª",
  "DiacriticalAcute;": "¬¥",
  "DiacriticalGrave;": "`",
  "DiacriticalTilde;": "Àú",
  "DoubleRightArrow;": "‚áí",
  "DownArrowUpArrow;": "‚áµ",
  "downharpoonright;": "‚áÇ",
  "EmptySmallSquare;": "‚óª",
  "GreaterEqualLess;": "‚ãõ",
  "GreaterFullEqual;": "‚âß",
  "LeftAngleBracket;": "‚ü®",
  "LeftUpDownVector;": "‚•ë",
  "LessEqualGreater;": "‚ãö",
  "NonBreakingSpace;": "¬†",
  "NotPrecedesEqual;": "‚™ØÃ∏",
  "NotRightTriangle;": "‚ã´",
  "NotSucceedsEqual;": "‚™∞Ã∏",
  "NotSucceedsTilde;": "‚âøÃ∏",
  "NotSupersetEqual;": "‚äâ",
  "ntrianglerighteq;": "‚ã≠",
  "rightharpoondown;": "‚áÅ",
  "rightrightarrows;": "‚áâ",
  "RightTriangleBar;": "‚ßê",
  "RightUpTeeVector;": "‚•ú",
  "RightUpVectorBar;": "‚•î",
  "twoheadleftarrow;": "‚Üû",
  "UnderParenthesis;": "‚èù",
  "UpArrowDownArrow;": "‚áÖ",
  "vartriangleright;": "‚ä≥",
  "blacktriangledown;": "‚ñæ",
  "blacktriangleleft;": "‚óÇ",
  "DoubleUpDownArrow;": "‚áï",
  "DoubleVerticalBar;": "‚à•",
  "DownLeftTeeVector;": "‚•û",
  "DownLeftVectorBar;": "‚•ñ",
  "FilledSmallSquare;": "‚óº",
  "GreaterSlantEqual;": "‚©æ",
  "LeftDoubleBracket;": "‚ü¶",
  "LeftDownTeeVector;": "‚•°",
  "LeftDownVectorBar;": "‚•ô",
  "leftrightharpoons;": "‚áã",
  "LeftTriangleEqual;": "‚ä¥",
  "NegativeThinSpace;": "‚Äã",
  "NotGreaterGreater;": "‚â´Ã∏",
  "NotLessSlantEqual;": "‚©ΩÃ∏",
  "NotNestedLessLess;": "‚™°Ã∏",
  "NotReverseElement;": "‚àå",
  "NotSquareSuperset;": "‚äêÃ∏",
  "NotTildeFullEqual;": "‚âá",
  "RightAngleBracket;": "‚ü©",
  "rightleftharpoons;": "‚áå",
  "RightUpDownVector;": "‚•è",
  "SquareSubsetEqual;": "‚äë",
  "twoheadrightarrow;": "‚Ü†",
  "VerticalSeparator;": "‚ùò",
  "blacktriangleright;": "‚ñ∏",
  "DownRightTeeVector;": "‚•ü",
  "DownRightVectorBar;": "‚•ó",
  "LongLeftRightArrow;": "‚ü∑",
  "Longleftrightarrow;": "‚ü∫",
  "longleftrightarrow;": "‚ü∑",
  "NegativeThickSpace;": "‚Äã",
  "NotLeftTriangleBar;": "‚ßèÃ∏",
  "PrecedesSlantEqual;": "‚âº",
  "ReverseEquilibrium;": "‚áã",
  "RightDoubleBracket;": "‚üß",
  "RightDownTeeVector;": "‚•ù",
  "RightDownVectorBar;": "‚•ï",
  "RightTriangleEqual;": "‚äµ",
  "SquareIntersection;": "‚äì",
  "SucceedsSlantEqual;": "‚âΩ",
  "DoubleLongLeftArrow;": "‚ü∏",
  "DownLeftRightVector;": "‚•ê",
  "LeftArrowRightArrow;": "‚áÜ",
  "leftrightsquigarrow;": "‚Ü≠",
  "NegativeMediumSpace;": "‚Äã",
  "NotGreaterFullEqual;": "‚âßÃ∏",
  "NotRightTriangleBar;": "‚ßêÃ∏",
  "RightArrowLeftArrow;": "‚áÑ",
  "SquareSupersetEqual;": "‚äí",
  "CapitalDifferentialD;": "‚ÖÖ",
  "DoubleLeftRightArrow;": "‚áî",
  "DoubleLongRightArrow;": "‚üπ",
  "EmptyVerySmallSquare;": "‚ñ´",
  "NestedGreaterGreater;": "‚â´",
  "NotDoubleVerticalBar;": "‚à¶",
  "NotGreaterSlantEqual;": "‚©æÃ∏",
  "NotLeftTriangleEqual;": "‚ã¨",
  "NotSquareSubsetEqual;": "‚ã¢",
  "OpenCurlyDoubleQuote;": "‚Äú",
  "ReverseUpEquilibrium;": "‚•Ø",
  "CloseCurlyDoubleQuote;": "‚Äù",
  "DoubleContourIntegral;": "‚àØ",
  "FilledVerySmallSquare;": "‚ñ™",
  "NegativeVeryThinSpace;": "‚Äã",
  "NotPrecedesSlantEqual;": "‚ã†",
  "NotRightTriangleEqual;": "‚ã≠",
  "NotSucceedsSlantEqual;": "‚ã°",
  "DiacriticalDoubleAcute;": "Àù",
  "NotSquareSupersetEqual;": "‚ã£",
  "NotNestedGreaterGreater;": "‚™¢Ã∏",
  "ClockwiseContourIntegral;": "‚à≤",
  "DoubleLongLeftRightArrow;": "‚ü∫",
  "CounterClockwiseContourIntegral;": "‚à≥"
}

const decodeHtml = (rawText, asAttr) => {
  let offset = 0
  const end = rawText.length
  let decodedText = ''

  function advance(length) {
    offset += length
    rawText = rawText.slice(length)
  }

  while (offset < end) {
    const head = /&(?:#x?)?/i.exec(rawText)
    if (!head || offset + head.index >= end) {
      const remaining = end - offset
      decodedText += rawText.slice(0, remaining)
      advance(remaining)
      break
    }

    // Advance to the "&".
    decodedText += rawText.slice(0, head.index)
    advance(head.index)

    if (head[0] === '&') {
      // Named character reference.
      let name = ''
      let value = undefined
      if (/[0-9a-z]/i.test(rawText[1])) {
        if (!maxCRNameLength) {
          maxCRNameLength = Object.keys(namedCharacterReferences).reduce(
            (max, name) => Math.max(max, name.length),
            0
          )
        }
        for (let length = maxCRNameLength; !value && length > 0; --length) {
          name = rawText.slice(1, 1 + length)
          value = namedCharacterReferences[name]
        }
        if (value) {
          const semi = name.endsWith(';')
          if (
            asAttr &&
            !semi &&
            /[=a-z0-9]/i.test(rawText[name.length + 1] || '')
          ) {
            decodedText += '&' + name
            advance(1 + name.length)
          } else {
            decodedText += value
            advance(1 + name.length)
          }
        } else {
          decodedText += '&' + name
          advance(1 + name.length)
        }
      } else {
        decodedText += '&'
        advance(1)
      }
    } else {
      // Numeric character reference.
      const hex = head[0] === '&#x'
      const pattern = hex ? /^&#x([0-9a-f]+);?/i : /^&#([0-9]+);?/
      const body = pattern.exec(rawText)
      if (!body) {
        decodedText += head[0]
        advance(head[0].length)
      } else {
        // https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state
        let cp = Number.parseInt(body[1], hex ? 16 : 10)
        if (cp === 0) {
          cp = 0xfffd
        } else if (cp > 0x10ffff) {
          cp = 0xfffd
        } else if (cp >= 0xd800 && cp <= 0xdfff) {
          cp = 0xfffd
        } else if ((cp >= 0xfdd0 && cp <= 0xfdef) || (cp & 0xfffe) === 0xfffe) {
          // noop
        } else if (
          (cp >= 0x01 && cp <= 0x08) ||
          cp === 0x0b ||
          (cp >= 0x0d && cp <= 0x1f) ||
          (cp >= 0x7f && cp <= 0x9f)
        ) {
          cp = CCR_REPLACEMENTS[cp] || cp
        }
        decodedText += String.fromCodePoint(cp)
        advance(body[0].length)
      }
    }
  }
  return decodedText
}

// https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state
const CCR_REPLACEMENTS = {
  0x80: 0x20ac,
  0x82: 0x201a,
  0x83: 0x0192,
  0x84: 0x201e,
  0x85: 0x2026,
  0x86: 0x2020,
  0x87: 0x2021,
  0x88: 0x02c6,
  0x89: 0x2030,
  0x8a: 0x0160,
  0x8b: 0x2039,
  0x8c: 0x0152,
  0x8e: 0x017d,
  0x91: 0x2018,
  0x92: 0x2019,
  0x93: 0x201c,
  0x94: 0x201d,
  0x95: 0x2022,
  0x96: 0x2013,
  0x97: 0x2014,
  0x98: 0x02dc,
  0x99: 0x2122,
  0x9a: 0x0161,
  0x9b: 0x203a,
  0x9c: 0x0153,
  0x9e: 0x017e,
  0x9f: 0x0178
}

let decoder

function decodeHtmlBrowser(raw, asAttr = false) {
  if (!decoder) {
    decoder = document.createElement('div')
  }
  if (asAttr) {
    decoder.innerHTML = `<div foo="${raw.replace(/"/g, '&quot;')}">`
    return decoder.children[0].getAttribute('foo')
  } else {
    decoder.innerHTML = raw
    return decoder.textContent
  }
}
#+end_src
#+end_details

#+html: <br>
#+begin_details dom-attrs :title-color green
#+name: dom-attrs
#+begin_src js -n -r

/**
 ,* On the client we only need to offer special cases for boolean attributes that
 ,* have different names from their corresponding dom properties:
 ,* - itemscope -> N/A
 ,* - allowfullscreen -> allowFullscreen
 ,* - formnovalidate -> formNoValidate
 ,* - ismap -> isMap
 ,* - nomodule -> noModule
 ,* - novalidate -> noValidate
 ,* - readonly -> readOnly
 ,*/
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`
const isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs)

/**
 ,* The full list is needed during SSR to produce the correct initial markup.
 ,*/
const isBooleanAttr = /*#__PURE__*/ makeMap(
  specialBooleanAttrs +
    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +
    `loop,open,required,reversed,scoped,seamless,` +
    `checked,muted,multiple,selected`
)

/**
 ,* Boolean attributes should be included if the value is truthy or ''.
 ,* e.g. `<select multiple>` compiles to `{ multiple: '' }`
 ,*/
function includeBooleanAttr(value) {
  return !!value || value === ''
}

const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/
const attrValidationCache = {}

function isSSRSafeAttrName(name) {
  if (attrValidationCache.hasOwnProperty(name)) {
    return attrValidationCache[name]
  }
  const isUnsafe = unsafeAttrCharRE.test(name)
  if (isUnsafe) {
    console.error(`unsafe attribute name: ${name}`)
  }
  return (attrValidationCache[name] = !isUnsafe)
}

const propsToAttrMap = {
  acceptCharset: 'accept-charset',
  className: 'class',
  htmlFor: 'for',
  httpEquiv: 'http-equiv'
}

/**
 ,* CSS properties that accept plain numbers
 ,*/
const isNoUnitNumericStyleProp = /*#__PURE__*/ makeMap(
  `animation-iteration-count,border-image-outset,border-image-slice,` +
    `border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,` +
    `columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,` +
    `grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,` +
    `grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,` +
    `line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,` +
    // SVG
    `fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,` +
    `stroke-miterlimit,stroke-opacity,stroke-width`
)

/**
 ,* Known attributes, this is used for stringification of runtime static nodes
 ,* so that we don't stringify bindings that cannot be set from HTML.
 ,* Don't also forget to allow `data-*` and `aria-*`!
 ,* Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes
 ,*/
const isKnownHtmlAttr = /*#__PURE__*/ makeMap(
  `accept,accept-charset,accesskey,action,align,allow,alt,async,` +
    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +
    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +
    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +
    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +
    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +
    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +
    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +
    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +
    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +
    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +
    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +
    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +
    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +
    `value,width,wrap`
)

/**
 ,* Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute
 ,*/
const isKnownSvgAttr = /*#__PURE__*/ makeMap(
  `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,` +
    `arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,` +
    `baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,` +
    `clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,` +
    `color-interpolation-filters,color-profile,color-rendering,` +
    `contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,` +
    `descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,` +
    `dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,` +
    `fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,` +
    `font-family,font-size,font-size-adjust,font-stretch,font-style,` +
    `font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,` +
    `glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,` +
    `gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,` +
    `horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,` +
    `k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,` +
    `lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,` +
    `marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,` +
    `mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,` +
    `name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,` +
    `overflow,overline-position,overline-thickness,panose-1,paint-order,path,` +
    `pathLength,patternContentUnits,patternTransform,patternUnits,ping,` +
    `pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,` +
    `preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,` +
    `rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,` +
    `restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,` +
    `specularConstant,specularExponent,speed,spreadMethod,startOffset,` +
    `stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,` +
    `strikethrough-position,strikethrough-thickness,string,stroke,` +
    `stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,` +
    `stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,` +
    `systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,` +
    `text-decoration,text-rendering,textLength,to,transform,transform-origin,` +
    `type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,` +
    `unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,` +
    `v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,` +
    `vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,` +
    `writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,` +
    `xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,` +
    `xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`
)

#+end_src
#+end_details

#+html: <br>
#+begin_details normalizeProp :title-color green
#+name: normalizeProp
#+begin_src js -n -r

function normalizeStyle(value) { (ref:normalizeStyle)
  if (isArray(value)) {
    const res = {}
    for (let i = 0; i < value.length; i++) {
      const item = value[i]
      const normalized = isString(item)
        ? parseStringStyle(item)
        : normalizeStyle(item)
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key]
        }
      }
    }
    return res
  } else if (isString(value)) {
    return value
  } else if (isObject(value)) {
    return value
  }
}

const listDelimiterRE = /;(?![^(]*\))/g
const propertyDelimiterRE = /:(.+)/

function parseStringStyle(cssText) { (ref:parseStringStyle)
  const ret = {}
  cssText.split(listDelimiterRE).forEach(item => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE)
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim())
    }
  })
  return ret
}

function stringifyStyle(styles) { (ref:stringifyStyle)
  let ret = ''
  if (!styles || isString(styles)) {
    return ret
  }
  for (const key in styles) {
    const value = styles[key]
    const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key)
    if (
      isString(value) ||
      (typeof value === 'number' && isNoUnitNumericStyleProp(normalizedKey))
    ) {
      // only render valid values
      ret += `${normalizedKey}:${value};`
    }
  }
  return ret
}

function normalizeClass(value) { (ref:normalizeClass)
  let res = ''
  if (isString(value)) {
    res = value
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i])
      if (normalized) {
        res += normalized + ' '
      }
    }
  } else if (isObject(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + ' '
      }
    }
  }
  return res.trim()
}

function normalizeProps(props) { (ref:normalizeProps)
  if (!props) return null
  let { class: klass, style } = props
  if (klass && !isString(klass)) {
    props.class = normalizeClass(klass)
  }
  if (style) {
    props.style = normalizeStyle(style)
  }
  return props
}

#+end_src
#+end_details

#+html: <br>
#+begin_details escapeHtml :title-color green
#+name: escapeHtml
#+begin_src js -n -r
const escapeRE = /["'&<>]/

function escapeHtml(string) {
  const str = '' + string
  const match = escapeRE.exec(str)

  if (!match) {
    return str
  }

  let html = ''
  let escaped
  let index
  let lastIndex = 0
  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34: // "
        escaped = '&quot;'
        break
      case 38: // &
        escaped = '&amp;'
        break
      case 39: // '
        escaped = '&#39;'
        break
      case 60: // <
        escaped = '&lt;'
        break
      case 62: // >
        escaped = '&gt;'
        break
      default:
        continue
    }

    if (lastIndex !== index) {
      html += str.slice(lastIndex, index)
    }

    lastIndex = index + 1
    html += escaped
  }

  return lastIndex !== index ? html + str.slice(lastIndex, index) : html
}

// https://www.w3.org/TR/html52/syntax.html#comments
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g

function escapeHtmlComment(src) {
  return src.replace(commentStripRE, '')
}

#+end_src
#+end_details

#+html: <br>
#+begin_details toDisplayString :title-color green
#+name: toDisplayString
#+begin_src js -n -r
const toDisplayString = (val) => {
  return isString(val)
    ? val
    : val == null
    ? ''
    : isArray(val) ||
      (isObject(val) &&
        (val.toString === objectToString || !isFunction(val.toString)))
    ? JSON.stringify(val, replacer, 2)
    : String(val)
}

const replacer = (_key, val) => {
  // can't use isRef here since @vue/shared has no deps
  if (val && val.__v_isRef) {
    return replacer(_key, val.value)
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {
        ;entries[`${key} =>`] = val
        return entries
      }, {})
    }
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    }
  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
    return String(val)
  }
  return val
}

#+end_src
#+end_details
* APIs

compiler-dom ÂåÖÂåÖÂê´‰ª•‰∏ã APIs Ëøô‰∏™ÂåÖ‰∏ªË¶ÅÊòØÈíàÂØπ‰∏Ä‰∫õÊåá‰ª§ËøõË°åÂä†Â∑•Â§ÑÁêÜÔºåÂ¶ÇÔºö ~v-html~,
~v-text~ Á≠âÁ≠â„ÄÇ

| name             | description                                      |
|------------------+--------------------------------------------------|
| [[transformStyleCD][transformStyle()]] | combine & normalize, result to object ~{a:b, c:d}~ |
| [[transformVHtml][transformVHtml()]] | v-html                                           |
| [[transformVText][transformVText()]] | v-text                                           |
| [[transformModel][transformModel()]] | v-model, transform bind value and event handler  |
| [[transformOn][transformOn()]]    | v-on, handle the event modifiers                 |
| [[transformShow][transformShow()]]  | v-show                                           |

code:

#+name: compiler-dom
#+begin_src js -n -r
<<compiler-core>>
<<globalVarsCD>>
<<transformStyleCD>>
<<transformVHtml>>
<<transformVText>>
<<transformModelCD>>
<<transformOnCD>>
<<transformShowCD>>
<<stringifyStatic>>
<<DOMDirectiveTransforms>>
<<DOMNodeTransforms>>
<<compile>>
<<parse>>
#+end_src

export to file:
#+html: <br>
#+begin_details compiler-dom :title-color red
#+begin_src js -n -r :noweb yes :tangle "~/github/mine/blog.cheng92.com/assets/tests/compiler-dom.js"
<<compiler-dom>>
#+end_src
#+end_details

* transforms

#+name: DOMDirectiveTransforms
#+begin_src js -n -r
const DOMDirectiveTransforms = {
  cloak: noopDirectiveTransform,
  html: transformVHtml,
  text: transformVText,
  model: transformModelCD, // override compiler-core
  on: transformOnCD, // override compiler-core
  show: transformShowCD
}
#+end_src

#+name: DOMNodeTransforms
#+begin_src js -n -r
const DOMNodeTransforms = [
  transformStyleCD,
  ...(__DEV__ ? [warnTransitionChildren] : [])
]
#+end_src

** style

compiler-dom ‰πãÂâçÔºö

#+name: test-before-cd
#+begin_src js -n -r :exports both
<<compiler-core>>

logOff()
const { code } = baseCompile('<div style="width:200px" :style="{height: `200px`}" />', { filename: 'foo.vue' })
logOn()
logg('<div style="width:200px" />', code)
#+end_src

ÂØπ style Â±ûÊÄßËøõË°åÂä†Â∑•Â§ÑÁêÜÔºåÂ≠óÁ¨¶‰∏≤ÊãÜÊàêÂØπË±°ÔºåÁÑ∂ÂêéÂêàÂπ∂Âà∞ÔºåÂêåÊó∂ÊîØÊåÅÂ§öÁßç‰ΩøÁî®ÊñπÂºè

1. ~<div style="width:100px">~ => ~{width:'100px'}~
2. ~<div :style="{width:'100px'}">~ => ~{width:'100px'}~
3. ~<div :style="{width:'100px'} style="height:100px">~ => ~{width:'100px',height:'100px'}~

#+name: transformStyleCD
#+begin_src js -n -r

// Parse inline CSS strings for static style attributes into an object.
// This is a NodeTransform since it works on the static `style` attribute and
// converts it into a dynamic equivalent:
// style="color: red" -> :style='{ "color": "red" }'
// It is then processed by `transformElement` and included in the generated
// props.
const transformStyleCD = node => {
  if (node.type === NodeTypes.ELEMENT) {
    node.props.forEach((p, i) => {
      if (p.type === NodeTypes.ATTRIBUTE && p.name === 'style' && p.value) {
        // replace p with an expression node
        node.props[i] = {
          type: NodeTypes.DIRECTIVE,
          name: `bind`,
          arg: createSimpleExpression(`style`, true, p.loc),
          exp: parseInlineCSS(p.value.content, p.loc),
          modifiers: [],
          loc: p.loc
        }
      }
    })
  }
}

const parseInlineCSS = (cssText, loc) => {
  const normalized = parseStringStyle(cssText)
  return createSimpleExpression(
    JSON.stringify(normalized),
    false,
    loc,
    ConstantTypes.CAN_STRINGIFY
  )
}
#+end_src

[[(parseStringStyle)][parseStringStyle]] Â∞ÜÂ≠óÁ¨¶‰∏≤Ëß£ÊûêÊàêÂØπË±° ~"width:100px"~ => ~{ width: '100px' }~

[[(stringifyStyle)][stringifyStyle]] Â∞ÜÂØπË±°ËΩ¨ÊàêÂ≠óÁ¨¶‰∏≤ ~{ width: '100px' }~ => ~"width:100px"~

[[(normalizeStyle)][normalizeStyle]] Ëß£Êûê style ÁöÑÂÄºÔºåÂèØËÉΩÊòØ ~"width:100px"~ Êàñ ~{width:'100px'}~ ‰πüÂèØ‰ª•ÊòØ
~['width:100px', {height:'100px'}]~ ÁöÑÊ∑∑ÂêàÊñπÂºèÔºåÊúÄÁªàÈÉΩ‰ºöË¢´Ëß£ÊûêÊàêÂØπË±°
~{width:'100px', height: '100px'}~ „ÄÇ

#+begin_src js -n -r :exports both
<<compiler-dom>>
const pss = s => parseStringStyle(s)
let r = pss('width:100px;height:100px')
logg('parseStringStyle', r)
const sfs = s => stringifyStyle(s)
const s = sfs(r)
logg('stringifyStyle', s)
logg('normalizeStyle', normalizeStyle([r, s, 'font-size:12px', { 'line-height': 1.2 }]))
#+end_src

red:Testing

#+begin_src js -n -r :exports both
<<compiler-dom>>

logOff()
const { code } = compile('<div style="width:200px" :style="{height: `200px`}" />', { filename: 'foo.vue' })
logOn()
logg('<div style="width:200px" />', code)
#+end_src

#+RESULTS:
#+begin_example
--------- createStructuralDirectiveTransform ---------
name=for, matches=(n) => n === name
--------- createStructuralDirectiveTransform ---------
name=/^(if|else|else-if)$/, matches=(n) => name.test(n)
--------- <div style="width:200px" /> ---------
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { normalizeStyle: _normalizeStyle, openBlock: _openBlock, createElementBlock: _createElementBlock } = _Vue

    return (_openBlock(), _createElementBlock("div", {
      style: _normalizeStyle([
        {"width":"200px"},
        {height: `200px`}
      ])
    }, null, 4))
  }
}
undefined
#+end_example

Ê≥®ÊÑè‰∏é [[test-before-cd][ÂÆûÁé∞ compiler-dom ‰πãÂâçÊµãËØïÁªìÊûú]] ÂØπÊØîÁªìÊûúÔºå‰ºöÂèëÁé∞ÂêéËÄÖÁöÑ ~style~ ÈÉΩ‰ºöË¢´ËΩ¨ÊàêÂØπ
Ë±°ÂΩ¢Âºè„ÄÇ

‰πãÂâçÔºö
#+begin_src js
 style: _normalizeStyle([
   "width:200px",
   {height: `200px`}
 ])
#+end_src

‰πãÂêéÔºö

#+begin_src js
style: _normalizeStyle([
  {"width":"200px"},
  {height: `200px`}
])
#+end_src

** v-html

#+name: transformVHtml
#+begin_src js -n -r
const transformVHtml = (dir, node, context) => {
  const { exp, loc } = dir
  if (!exp) {
    logg("v-html no exp")
  }
  if (node.children.length) {
    logg('v-html can not has children')
    node.children.length = 0
  }
  return {
    props: [
      createObjectProperty(
        createSimpleExpression(`innerHTML`, true, loc),
        exp || createSimpleExpression('', true)
      )
    ]
  }
}
#+end_src

red:Testing

before: ‰∏ç‰ºöË¢´Â§ÑÁêÜ
#+begin_src js -n -r :exports both
<<compiler-core>>
logOff()
const { code } = baseCompile("<div v-html='foo'><span/></div>", { filename: 'foo.vue' })
logOn()
logg('v-html', code)
#+end_src

after:

#+begin_src js -n -r :exports both
<<compiler-dom>>
logOff()
const { code } = compile("<div v-html='foo'><span/></div>", { filename: 'foo.vue' })
logOn()
logg('v-html', code)
#+end_src

Ê≥®ÊÑèÁúãÂâçÂêéÁöÑÁªìÊûúÔºå compile-core Èò∂ÊÆµÊòØÊ≤°ÊúâÂØπ v-html ËøõË°åÂ§ÑÁêÜÁöÑÔºå‰∏î after ÁªìÊûú‰∏≠
ÁöÑ ~<span/>~ Â∑≤ÁªèÊ≤°Êúâ‰∫ÜÔºå‰∏îÂ¢ûÂä†‰∫Ü ~{ innerHTML }~ Â±ûÊÄß„ÄÇ

** v-text

#+name: transformVText
#+begin_src js -n -r
const transformVText = (dir, node, context) => {
  const { exp, loc } = dir
  if (!exp) {
    logg('v-text no exp')
  }
  if (node.children.length) {
    logg('v-text can not have children')
    node.children.length = 0
  }
  return {
    props: [
      createObjectProperty(
        createSimpleExpression(`textContent`, true),
        exp
          ? createCallExpression(
              context.helperString(TO_DISPLAY_STRING),
              [exp],
              loc
            )
          : createSimpleExpression('', true)
      )
    ]
  }
}
#+end_src

red:Testing

before: compiler-core ‰∏≠‰πüÊ≤°ÊúâÂØπ v-text Êåá‰ª§ÁöÑÂ§ÑÁêÜ

#+begin_src js -n -r :exports both
<<compiler-core>>
logOff()
const { code } = baseCompile("<div v-text='foo'><span/></div>", { filename: 'foo.vue' })
logOn()
logg('v-text', code)
#+end_src

after: ~<span/>~ ÊâÄÊúâÂ≠êËäÇÁÇπÈÉΩ‰ºöË¢´Âà†Èô§ÔºåÂ¢ûÂä† ~{ textContent }~ Â±ûÊÄß„ÄÇ
#+begin_src js -n -r :exports both
<<compiler-dom>>
logOff()
const { code } = compile("<div v-text='foo'><span/></div>", { filename: 'foo.vue' })
logOn()
logg('v-text', code)
#+end_src

** v-model

#+name: transformModelCD
#+begin_src js -n -r
const transformModelCD = (dir, node, context) => {
  const baseResult = transformModel(dir, node, context)
  // base transform has errors OR component v-model (only need props)
  if (!baseResult.props.length || node.tagType === ElementTypes.COMPONENT) {
    return baseResult
  }

  if (dir.arg) {
    logg("transfromModelCD - X_V_MODEL_ARG_ON_ELEMENT")
  }

  function checkDuplicatedValue() {
    const value = findProp(node, 'value')
    if (value) {
      logg("transfromModelCD - X_V_MODEL_UNNECESSARY_VALUE")
    }
  }

  const { tag } = node
  const isCustomElement = context.isCustomElement(tag)
  if (
    tag === 'input' ||
    tag === 'textarea' ||
    tag === 'select' ||
    isCustomElement
  ) {
    let directiveToUse = V_MODEL_TEXT
    let isInvalidType = false
    if (tag === 'input' || isCustomElement) {
      const type = findProp(node, `type`)
      if (type) {
        if (type.type === NodeTypes.DIRECTIVE) {
          // :type="foo"
          directiveToUse = V_MODEL_DYNAMIC
        } else if (type.value) {
          switch (type.value.content) {
            case 'radio':
              directiveToUse = V_MODEL_RADIO
              break
            case 'checkbox':
              directiveToUse = V_MODEL_CHECKBOX
              break
            case 'file':
              isInvalidType = true
              logg("[DOM]transformModel - X_V_MODEL_ON_FILE_INPUT_ELEMENT")
              break
            default:
              // text type
              __DEV__ && checkDuplicatedValue()
              break
          }
        }
      } else if (hasDynamicKeyVBind(node)) {
        // element has bindings with dynamic keys, which can possibly contain
        // "type".
        directiveToUse = V_MODEL_DYNAMIC
      } else {
        // text type
        __DEV__ && checkDuplicatedValue()
      }
    } else if (tag === 'select') {
      directiveToUse = V_MODEL_SELECT
    } else {
      // textarea
      __DEV__ && checkDuplicatedValue()
    }
    // inject runtime directive
    // by returning the helper symbol via needRuntime
    // the import will replaced a resolveDirective call.
    if (!isInvalidType) {
      baseResult.needRuntime = context.helper(directiveToUse)
    }
  } else {
    logg("[DOM]transformModel - X_V_MODEL_ON_INVALID_ELEMENT")
  }

  // native vmodel doesn't need the `modelValue` props since they are also
  // passed to the runtime as `binding.value`. removing it reduces code size.
  baseResult.props = baseResult.props.filter(
    p =>
      !(
        p.key.type === NodeTypes.SIMPLE_EXPRESSION &&
        p.key.content === 'modelValue'
      )
  )

  return baseResult
}
#+end_src

1. Âè™Â§ÑÁêÜ input, textarea, select ÊñáÊú¨Ê°ÜÊ†áÁ≠æÔºåÊàñËá™ÂÆö‰πâÁöÑÊ†áÁ≠æ

2. <input> Ê†áÁ≠æÁ±ªÂûãÂàÜ‰∏∫ radio Âíå checkbox ÂçïÂ§çÈÄâÈ°πÊ°ÜÂ§ÑÁêÜÔºå‰∏çËÉΩ‰ΩøÁî® type='file' Á±ªÂûã

3. <select> ‰∏ãÊãâÈÄâÈ°πÊ°ÜÁöÑÂ§ÑÁêÜ

4. ËøáÊª§Êéâ transform ‰πãÂêéÁöÑ ~{modelValue: value, 'onUpdate:value': $event => value
   = $event}~ ÈáåÈù¢ÁöÑ ~modelValueÔºövalue~ Â±ûÊÄßÔºåÂõ†‰∏∫Âú® runtime-core Êó∂ÊúüÁöÑ
   [[withDirectives][withDirectives(]]) Â§ÑÁêÜÈáåÈù¢‰ºöË¢´ÁªëÂÆöÂà∞ value Â±ûÊÄß‰∏ä

red:Testing

before:

#+begin_src js -n -r :exports both
<<compiler-core>>

logOff()
const { code } = baseCompile("<input type='text' v-model='value' />", { filename: 'foo.vue' })
logOn()
log('v-model', code)
#+end_src

after: Â§ö‰∫Ü‰∏ÄÂ±ÇÂåÖË£Ö ~_withDirectives()~
#+begin_src js -n -r :exports both
<<compiler-dom>>

logOff()
const { code } = compile("<input type='text' v-model='value' />", { filename: 'foo.vue' })
logOn()
log('v-model', code)
#+end_src

ÈÇ£Êù•Áúã‰∏ã ~_withDirectives()~ ÈáåÈù¢ÂÅö‰∫Ü‰ªÄ‰πàÔºü

#+name: withDirectives
#+begin_src js -n -r
function withDirectives(vnode, directives) {
  const internalInstance = currentRenderingInstance
  if (internalInstance === null) {
    return vnode
  }
  // ÂèñÂΩìÂâçÂ∫îÁî®ÂÆû‰æã
  const instance = getExposeProxy(internalInstance) || internalInstance.proxy
  const bindings = vnode.dirs || (vnode.dirs = [])
  for (let i = 0; i < directives.length; i++) {

    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i]
    if (isFunction(dir)) {
      dir = {
        mounted: dir,
        updated: dir
      }
    }
    if (dir.deep) {
      traverse(value)
    }
    bindings.push({
      dir,
      instance,
      value,
      oldValue: void 0,
      arg,
      modifiers
    })
  }
  return vnode
}
#+end_src
** v-on

#+name: transformOnCD
#+begin_src js -n -r
const isEventOptionModifier = /*#__PURE__*/ makeMap(`passive,once,capture`)
const isNonKeyModifier = /*#__PURE__*/ makeMap(
  // event propagation management
  `stop,prevent,self,` +
    // system modifiers + exact
    `ctrl,shift,alt,meta,exact,` +
    // mouse
    `middle`
)
// left & right could be mouse or key modifiers based on event type
const maybeKeyModifier = /*#__PURE__*/ makeMap('left,right')
const isKeyboardEvent = /*#__PURE__*/ makeMap(
  `onkeyup,onkeydown,onkeypress`,
  true
)

// Â∞Ü‰øÆÈ•∞Á¨¶ÂàÜÁ±ª
const resolveModifiers = (key, modifiers, context, loc) => {
  const keyModifiers = []
  const nonKeyModifiers = []
  const eventOptionModifiers = []

  for (let i = 0; i < modifiers.length; i++) {
    const modifier = modifiers[i]

    if (isEventOptionModifier(modifier)) {
      // eventOptionModifiers: modifiers for addEventListener() options,
      // e.g. .passive & .capture
      eventOptionModifiers.push(modifier)
    } else {
      // runtimeModifiers: modifiers that needs runtime guards
      if (maybeKeyModifier(modifier)) {
        if (isStaticExp(key)) {
          if (isKeyboardEvent(key.content)) {
            keyModifiers.push(modifier)
          } else {
            nonKeyModifiers.push(modifier)
          }
        } else {
          keyModifiers.push(modifier)
          nonKeyModifiers.push(modifier)
        }
      } else {
        if (isNonKeyModifier(modifier)) {
          nonKeyModifiers.push(modifier)
        } else {
          keyModifiers.push(modifier)
        }
      }
    }
  }

  return {
    keyModifiers,
    nonKeyModifiers,
    eventOptionModifiers
  }
}

// ÂéüÁîü click ‰∫ã‰ª∂
const transformClick = (key, event) => {
  const isStaticClick =
    isStaticExp(key) && key.content.toLowerCase() === 'onclick'
  return isStaticClick
    ? createSimpleExpression(event, true)
    : key.type !== NodeTypes.SIMPLE_EXPRESSION
    ? createCompoundExpression([
        `(`,
        key,
        `) === "onClick" ? "${event}" : (`,
        key,
        `)`
      ])
    : key
}

const transformOnCD = (dir, node, context) => {
  return transformOn(dir, node, context, baseResult => {
    const { modifiers } = dir
    if (!modifiers.length) return baseResult

    let { key, value: handlerExp } = baseResult.props[0]
    const { keyModifiers, nonKeyModifiers, eventOptionModifiers } =
      resolveModifiers(key, modifiers, context, dir.loc)

    // normalize click.right and click.middle since they don't actually fire
    if (nonKeyModifiers.includes('right')) { (ref:transformOnCD-right)
      key = transformClick(key, `onContextmenu`)
    }
    if (nonKeyModifiers.includes('middle')) {
      key = transformClick(key, `onMouseup`)
    }

    if (nonKeyModifiers.length) {
      handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
        handlerExp,
        JSON.stringify(nonKeyModifiers)
      ])
    }

    if (
      keyModifiers.length &&
      // if event name is dynamic, always wrap with keys guard
      (!isStaticExp(key) || isKeyboardEvent(key.content))
    ) {
      handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [
        handlerExp,
        JSON.stringify(keyModifiers)
      ])
    }

    if (eventOptionModifiers.length) {
      const modifierPostfix = eventOptionModifiers.map(capitalize).join('')
      key = isStaticExp(key)
        ? createSimpleExpression(`${key.content}${modifierPostfix}`, true)
        : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`])
    }

    return {
      props: [createObjectProperty(key, handlerExp)]
    }
  })
}
#+end_src

red:Testing

before: Ê≥®ÊÑèÁúãÁªìÊûú‰ºöÂèëÁé∞‰øÆÈ•∞Á¨¶Âπ∂Ê≤°ÊúâÂá∫Áé∞Âú® render ÂáΩÊï∞‰∏≠
#+begin_src js -n -r :exports both
<<compiler-core>>

logOff()
const { code } = baseCompile(`<div @click.enter.passive="handleClick" />`, { filename: 'foo.vue' })
logOn()
log('onclick', code)
#+end_src

after:
#+begin_src js -n -r :exports both
<<compiler-dom>>

logOff()
const { code } = compile(`<div @click.right.passive="handleClick" />`, { filename: 'foo.vue' })
logOn()
log('onclick', code)
#+end_src

1. right ‰øÆÈ•∞Á¨¶‰∏ãÁöÑ click ‰∫ã‰ª∂Ë¢´ËΩ¨Êàê‰∫Ü ~onContextmenu~ Âè≥ÈîÆÁÇπÂáª‰∫ã‰ª∂
2. passive ‰øÆÈ•∞Á¨¶Áõ¥Êé•Ë¢´ËøΩÂä†Âà∞‰∫Ü‰∫ã‰ª∂ key ÂêéÈù¢ ~onContextmenuPassive~, Ëøô‰πüÊòØ vue ‰∏≠
   ÂØπ‰øÆÈ•∞Á¨¶ÁöÑÂ§ÑÁêÜÊñπÂºè(Â¶ÇÔºö ~@click.right.once~ => ~onContextmenuOnce~)


ÂΩìÊúâ‰øÆÈ•∞Á¨¶ÁöÑÊó∂ÂÄô‰ºö‰ΩøÁî®Âà∞ withModifiers, ÊØè‰∏™‰øÆÈ•∞Á¨¶ÈÉΩÊúâËá™Â∑±ÂØπÂ∫îÁöÑ‰∏Ä‰∏™ÂáΩÊï∞ÔºåÂè™ÊúâÂΩì
Êª°Ë∂≥Êù°‰ª∂ÁöÑÊâç‰ºöËÆ©‰∫ã‰ª∂ÁªßÁª≠Ôºå‰πüÂ∞±ÊòØÊúÄÂêéÁöÑ ~fn(event, ...args)~ ÊâßË°å:

#+begin_src typescript -n -r
const modifierGuards: Record<
  string,
  (e: Event, modifiers: string[]) => void | boolean
> = {
  stop: e => e.stopPropagation(),
  prevent: e => e.preventDefault(),
  self: e => e.target !== e.currentTarget,
  ctrl: e => !(e as KeyedEvent).ctrlKey,
  shift: e => !(e as KeyedEvent).shiftKey,
  alt: e => !(e as KeyedEvent).altKey,
  meta: e => !(e as KeyedEvent).metaKey,
  left: e => 'button' in e && (e as MouseEvent).button !== 0,
  middle: e => 'button' in e && (e as MouseEvent).button !== 1,
  right: e => 'button' in e && (e as MouseEvent).button !== 2,
  exact: (e, modifiers) =>
    systemModifiers.some(m => (e as any)[`${m}Key`] && !modifiers.includes(m))
}

const withModifiers = (fn: Function, modifiers: string[]) => {
  return (event: Event, ...args: unknown[]) => {
    for (let i = 0; i < modifiers.length; i++) {
      const guard = modifierGuards[modifiers[i]]
      if (guard && guard(event, modifiers)) return
    }
    return fn(event, ...args)
  }
}
#+end_src

#+begin_box Â∞èÁªì
compiler-dom ÂØπ v-on Êåá‰ª§ÁöÑÂ§ÑÁêÜÂ∞±ÊòØÂØπ‰øÆÈ•∞Á¨¶ÁöÑÂ§ÑÁêÜÔºåÂ∞Ü‰∫ã‰ª∂ÂáΩÊï∞ËøõË°åËΩ¨Êç¢Ôºå‰ΩøÁî®
~withModifiers()~ ËøõË°åÂ∞ÅË£Ö„ÄÇ

‰øÆÈ•∞Á¨¶Êúâ‰∏âÁ±ªÔºö

1. ‰∫ã‰ª∂ÈÄâÈ°πkbd:passive,once,capture

   [[https://segmentfault.com/a/1190000017247263][passiveÁöÑ‰ΩúÁî®ÂíåÂéüÁêÜ - SegmentFault ÊÄùÂê¶]]

   [[https://blog.techbridge.cc/2017/07/15/javascript-event-propagation/][DOM ÁöÑ‰∫ã‰ª∂ÂÇ≥ÈÅûÊ©üÂà∂ÔºöÊçïÁç≤ËàáÂÜíÊ≥°]]

2. ÂÜíÊ≥°Áõ∏ÂÖ≥ kbd:stop,prevent,self, Á≥ªÁªüÁªÑÂêàÈîÆ kbd:ctrl,shift,alt,meta,exact, Èº†
   Ê†áÊåâÈîÆ kbd:middle
3. <kbd:left, right> ÂèØËÉΩÊòØÈº†Ê†á‰πüÂèØ‰ª•ÊòØÈîÆÁõò‰∏äÁöÑÂ∑¶Âè≥ÈîÆ


‰øÆÈ•∞Á¨¶ÂΩ±Âìç‰∫ã‰ª∂Á±ªÂûãÔºö

1. click.right ËΩ¨ÊàêÂè≥ÈîÆËèúÂçïÈîÆ ~onContextmenu~
2. click.middle ËΩ¨ÊàêÈº†Ê†á‰∏≠ÈîÆ ~onMouseUp~
#+end_box

** v-show

v-show Âú®ËøôÈáåÂπ∂Ê≤°ÊúâÁúüÊ≠£ÁöÑË¢´Â§ÑÁêÜÂà∞ÔºåËÄåÂú® runtime ËøêË°åÊó∂Êâç‰ºöË¢´Â§ÑÁêÜÔºå‰πüÂ∞±ÊòØÂêéÈù¢‰ºöÂÆå
ÊàêÁöÑ ~runtime-dom~ ÂåÖÈáåÔºåÂÆûÁé∞ÂéüÁêÜÂÖ∂ÂÆûÂ∞±ÊòØÊéßÂà∂ÂÖÉÁ¥† ~display~ Â±ûÊÄßÔºåËøôÈáåÂè™ÊòØÂ∞ÜÂÖ∂Ê†áËØÜ‰∫Ü
‰∏ãÈúÄË¶ÅËøêË°åÊó∂ÂéªÂ§ÑÁêÜ„ÄÇ

ÊóßÂçöÂÆ¢‰∏≠ÊúâÁõ∏ÂÖ≥ÂàÜÊûêÔºö[[https://www.cheng92.com/vue/vue-mind-map-runtime-dom/#v-show][Vue3 Ê∫êÁ†ÅÂ§¥ËÑëÈ£éÊö¥‰πã 8 ‚òû runtime-dom - Ëã•Âè∂Áü•Áßã]]

#+name: transformShowCD
#+begin_src js -n -r
const transformShowCD = (dir, node, context) => {
  const { exp, loc } = dir
  if (!exp) {
    logg('transformShowCD no exp.')
  }

  return {
    props: [],
    needRuntime: context.helper(V_SHOW)
  }
}
#+end_src

** stringifyStatic

Âú®Â§ÑÁêÜÈùôÊÄÅÊèêÂçá‰ª£Á†ÅÊó∂ÈúÄË¶ÅÁî®Âà∞ ~stringifyStatic~, ÂÆÉ‰ºöÂ∞ÜÈùôÊÄÅÊèêÂçáÁöÑËäÇÁÇπÁõ¥Êé•Â≠óÁ¨¶‰∏≤ÂåñÔºå
ÁÑ∂ÂêéÂàõÂª∫‰∏Ä‰∏™ off-dom ËäÇÁÇπÊù•‰øùÂ≠òÂÆÉÔºåÁ≠âÂà∞ÈúÄË¶Å‰ΩøÁî®ÁöÑÊó∂ÂÄôÁõ¥Êé•‰ΩøÁî®Ëøô‰∏™ off-dom ËäÇÁÇπ„ÄÇ

#+name: stringifyStatic
#+begin_src js -n -r
 const StringifyThresholds = {
   ELEMENT_WITH_BINDING_COUNT: 5,
   NODE_COUNT: 20
}

/**
 ,* Regex for replacing placeholders for embedded constant variables
 ,* (e.g. import URL string constants generated by compiler-sfc)
 ,*/
const expReplaceRE = /__VUE_EXP_START__(.*?)__VUE_EXP_END__/g

/**
 ,* Turn eligible hoisted static trees into stringified static nodes, e.g.
 ,*
 ,* ```js
 ,* const _hoisted_1 = createStaticVNode(`<div class="foo">bar</div>`)
 ,* ```
 ,*
 ,* A single static vnode can contain stringified content for **multiple**
 ,* consecutive nodes (element and plain text), called a "chunk".
 ,* `@vue/runtime-dom` will create the content via innerHTML in a hidden
 ,* container element and insert all the nodes in place. The call must also
 ,* provide the number of nodes contained in the chunk so that during hydration
 ,* we can know how many nodes the static vnode should adopt.
 ,*
 ,* The optimization scans a children list that contains hoisted nodes, and
 ,* tries to find the largest chunk of consecutive hoisted nodes before running
 ,* into a non-hoisted node or the end of the list. A chunk is then converted
 ,* into a single static vnode and replaces the hoisted expression of the first
 ,* node in the chunk. Other nodes in the chunk are considered "merged" and
 ,* therefore removed from both the hoist list and the children array.
 ,*
 ,* This optimization is only performed in Node.js.
 ,*/
const stringifyStatic = (children, context, parent) => {
  // bail stringification for slot content
  if (context.scopes.vSlot > 0) {
    return
  }

  let nc = 0 // current node count
  let ec = 0 // current element with binding count
  const currentChunk = []

  logg(`stringifyStatic - children.length = ${children.length}`)
  const stringifyCurrentChunk = (currentIndex) => {
    if (
      nc >= StringifyThresholds.NODE_COUNT ||
      ec >= StringifyThresholds.ELEMENT_WITH_BINDING_COUNT
    ) {
      logg(`stringifyCurrentChunk - index = ${currentIndex}`)
      // combine all currently eligible nodes into a single static vnode call
      const staticCall = createCallExpression(context.helper(CREATE_STATIC), [
        JSON.stringify(
          currentChunk.map(node => stringifyNode(node, context)).join('')
        ).replace(expReplaceRE, `" + $1 + "`),
        // the 2nd argument indicates the number of DOM nodes this static vnode
        // will insert / hydrate
        String(currentChunk.length)
      ])
      // replace the first node's hoisted expression with the static vnode call
      replaceHoist(currentChunk[0], staticCall, context)

      if (currentChunk.length > 1) {
        for (let i = 1; i < currentChunk.length; i++) {
          // for the merged nodes, set their hoisted expression to null
          replaceHoist(currentChunk[i], null, context)
        }

        // also remove merged nodes from children
        const deleteCount = currentChunk.length - 1
        children.splice(currentIndex - currentChunk.length + 1, deleteCount)
        return deleteCount
      }
    }
    return 0
  }

  let i = 0
  for (; i < children.length; i++) {
    const child = children[i]
    const hoisted = getHoistedNode(child)
    if (hoisted) {
      // presence of hoisted means child must be a stringifiable node
      const node = child
      const result = analyzeNode(node)
      if (result) {
        // node is stringifiable, record state
        nc += result[0]
        ec += result[1]
        currentChunk.push(node)
        continue
      }
    }
    // we only reach here if we ran into a node that is not stringifiable
    // check if currently analyzed nodes meet criteria for stringification.
    // adjust iteration index
    i -= stringifyCurrentChunk(i)
    // reset state
    nc = 0
    ec = 0
    currentChunk.length = 0
  }
  // in case the last node was also stringifiable
  stringifyCurrentChunk(i)
}

const getHoistedNode = (node) =>
  ((node.type === NodeTypes.ELEMENT && node.tagType === ElementTypes.ELEMENT) ||
    node.type == NodeTypes.TEXT_CALL) &&
  node.codegenNode &&
  node.codegenNode.type === NodeTypes.SIMPLE_EXPRESSION &&
  node.codegenNode.hoisted

const dataAriaRE = /^(data|aria)-/
const isStringifiableAttr = (name, ns) => {
  return (
    (ns === DOMNamespaces.HTML
      ? isKnownHtmlAttr(name)
      : ns === DOMNamespaces.SVG
      ? isKnownSvgAttr(name)
      : false) || dataAriaRE.test(name)
  )
}

const replaceHoist = (node,replacement,context) => {
  const hoistToReplace = node.codegenNode.hoisted
  context.hoists[context.hoists.indexOf(hoistToReplace)] = replacement
}

const isNonStringifiable = /*#__PURE__*/ makeMap(
  `caption,thead,tr,th,tbody,td,tfoot,colgroup,col`
)

/**
 ,* for a hoisted node, analyze it and return:
 ,* - false: bailed (contains non-stringifiable props or runtime constant)
 ,* - [nc, ec] where
 ,*   - nc is the number of nodes inside
 ,*   - ec is the number of element with bindings inside
 ,*/
function analyzeNode(node) {
  if (node.type === NodeTypes.ELEMENT && isNonStringifiable(node.tag)) {
    return false
  }

  if (node.type === NodeTypes.TEXT_CALL) {
    return [1, 0]
  }

  let nc = 1 // node count
  let ec = node.props.length > 0 ? 1 : 0 // element w/ binding count
  let bailed = false
  const bail = () => {
    bailed = true
    return false
  }

  // TODO: check for cases where using innerHTML will result in different
  // output compared to imperative node insertions.
  // probably only need to check for most common case
  // i.e. non-phrasing-content tags inside `<p>`
  function walk(node) {
    for (let i = 0; i < node.props.length; i++) {
      const p = node.props[i]
      // bail on non-attr bindings
      if (
        p.type === NodeTypes.ATTRIBUTE &&
        !isStringifiableAttr(p.name, node.ns)
      ) {
        return bail()
      }
      if (p.type === NodeTypes.DIRECTIVE && p.name === 'bind') {
        // bail on non-attr bindings
        if (
          p.arg &&
          (p.arg.type === NodeTypes.COMPOUND_EXPRESSION ||
            (p.arg.isStatic && !isStringifiableAttr(p.arg.content, node.ns)))
        ) {
          return bail()
        }
        if (
          p.exp &&
          (p.exp.type === NodeTypes.COMPOUND_EXPRESSION ||
            p.exp.constType < ConstantTypes.CAN_STRINGIFY)
        ) {
          return bail()
        }
      }
    }
    for (let i = 0; i < node.children.length; i++) {
      nc++
      const child = node.children[i]
      if (child.type === NodeTypes.ELEMENT) {
        if (child.props.length > 0) {
          ec++
        }
        walk(child)
        if (bailed) {
          return false
        }
      }
    }
    return true
  }

  return walk(node) ? [nc, ec] : false
}

function stringifyNode(node, context) {
  if (isString(node)) {
    return node
  }
  if (isSymbol(node)) {
    return ``
  }
  switch (node.type) {
    case NodeTypes.ELEMENT:
      return stringifyElement(node, context)
    case NodeTypes.TEXT:
      return escapeHtml(node.content)
    case NodeTypes.COMMENT:
      return `<!--${escapeHtml(node.content)}-->`
    case NodeTypes.INTERPOLATION:
      return escapeHtml(toDisplayString(evaluateConstant(node.content)))
    case NodeTypes.COMPOUND_EXPRESSION:
      return escapeHtml(evaluateConstant(node))
    case NodeTypes.TEXT_CALL:
      return stringifyNode(node.content, context)
    default:
      // static trees will not contain if/for nodes
      return ''
  }
}

function stringifyElement(node, context) {
  let res = `<${node.tag}`
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i]
    if (p.type === NodeTypes.ATTRIBUTE) {
      res += ` ${p.name}`
      if (p.value) {
        res += `="${escapeHtml(p.value.content)}"`
      }
    } else if (p.type === NodeTypes.DIRECTIVE && p.name === 'bind') {
      const exp = p.exp
      if (exp.content[0] === '_') {
        // internally generated string constant references
        // e.g. imported URL strings via compiler-sfc transformAssetUrl plugin
        res += ` ${p.arg.content}="__VUE_EXP_START__${
          exp.content
        }__VUE_EXP_END__"`
        continue
      }
      // constant v-bind, e.g. :foo="1"
      let evaluated = evaluateConstant(exp)
      if (evaluated != null) {
        const arg = p.arg && p.arg.content
        if (arg === 'class') {
          evaluated = normalizeClass(evaluated)
        } else if (arg === 'style') {
          evaluated = stringifyStyle(normalizeStyle(evaluated))
        }
        res += ` ${p.arg.content}="${escapeHtml(evaluated)}"`
      }
    }
  }
  if (context.scopeId) {
    res += ` ${context.scopeId}`
  }
  res += `>`
  for (let i = 0; i < node.children.length; i++) {
    res += stringifyNode(node.children[i], context)
  }
  if (!isVoidTag(node.tag)) {
    res += `</${node.tag}>`
  }
  return res
}

// __UNSAFE__
// Reason: eval.
// It's technically safe to eval because only constant expressions are possible
// here, e.g. `{{ 1 }}` or `{{ 'foo' }}`
// in addition, constant exps bail on presence of parens so you can't even
// run JSFuck in here. But we mark it unsafe for security review purposes.
// (see compiler-core/src/transformExpressions)
function evaluateConstant(exp) {
  if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {
    return new Function(`return ${exp.content}`)()
  } else {
    // compound
    let res = ``
    exp.children.forEach(c => {
      if (isString(c) || isSymbol(c)) {
        return
      }
      if (c.type === NodeTypes.TEXT) {
        res += c.content
      } else if (c.type === NodeTypes.INTERPOLATION) {
        res += toDisplayString(evaluateConstant(c.content))
      } else {
        res += evaluateConstant(c)
      }
    })
    return res
  }
}

#+end_src

red:Testing

#+name: stringifyStatic-test-utils
#+begin_src js -n -r
<<compiler-dom>>

function compileWithStringify(template) {
    return compile(template, {
      hoistStatic: true,
      prefixIdentifiers: true,
      transformHoist: stringifyStatic
    })
  }

  function repeat(code, n) {
    return new Array(n)
      .fill(0)
      .map(() => code)
      .join('')
  }
#+end_src

#+html: <br>
#+begin_details should bail on non-eligible static trees :title-color red
#+begin_src js -n -r :exports both
<<stringifyStatic-test-utils>>

logOff()
const { ast, code } = compileWithStringify(
  `<div><div><div>hello</div><div>hello</div></div></div>`
)
logOn()
logg('ast hoists', ast.hoists)
logg('code', code)
#+end_src
#+end_details

#+html: <br>
#+begin_details should work on eligible content (elements with binding > 5) :title-color red
#+begin_src js -n -r :exports both
<<stringifyStatic-test-utils>>

logOff()
const { ast, code } = compileWithStringify(
  `<div><div>${repeat(
        `<span class="foo"/>`,
        StringifyThresholds.ELEMENT_WITH_BINDING_COUNT
      )}</div></div><div></div>`
  //`<div><div><div>hello</div><div>hello</div></div></div>`
)
logOn()
logg('ast hoists', ast.hoists)
logg('code', code)
#+end_src
#+end_details

#+html: <br>
#+begin_details should work on eligible content (elements > 20) :title-color red
#+begin_src js -n -r :exports both
<<stringifyStatic-test-utils>>

logOff()
const { ast, code } = compileWithStringify(
  `<div><div>${repeat(
        `<span/>`,
        StringifyThresholds.NODE_COUNT
      )}</div></div>`
)
logOn()
logg('ast hoists', ast.hoists)
logg('code', code)
#+end_src
#+end_details

#+html: <br>
#+begin_details serializing constant bindings :title-color red
#+begin_src js -n -r :exports both
<<stringifyStatic-test-utils>>

logOff()
const { ast, code } = compileWithStringify(
  `<div><div :style="{ color: 'red' }">${repeat(
        `<span :class="[{ foo: true }, { bar: true }]">{{ 1 }} + {{ false }}</span>`,
        StringifyThresholds.ELEMENT_WITH_BINDING_COUNT
      )}</div></div>`
)
logOn()
logg('ast hoists', ast.hoists)
logg('code', code)
#+end_src
#+end_details

createStaticVNode:

#+begin_src typescript -n -r
function createStaticVNode(
  content: string,
  numberOfNodes: number
): VNode {
  // A static vnode can contain multiple stringified elements, and the number
  // of elements is necessary for hydration.
  const vnode = createVNode(Static, null, content)
  vnode.staticCount = numberOfNodes
  return vnode
}
#+end_src

* compile()

#+name: compile
#+begin_src js -n -r
function compile(template, options = {}) {
  return baseCompile(
    template,
    extend({}, parserOptions, options, {
      nodeTransforms: [
        // ignore <script> and <tag>
        // this is not put inside DOMNodeTransforms because that list is used
        // by compiler-ssr to generate vnode fallback branches
        ignoreSideEffectTags,
        ...DOMNodeTransforms,
        ...(options.nodeTransforms || [])
      ],
      directiveTransforms: extend(
        {},
        DOMDirectiveTransforms,
        options.directiveTransforms || {}
      ),
      transformHoist: __BROWSER__ ? null : stringifyStatic
    })
  )
}
#+end_src
* parse

#+name: parse
#+begin_src js -n -r
function parse(template, options = {}) {
  return baseParse(template, extend({}, parserOptions, options))
}
#+end_src
* testing

Êõ¥Â§öÊµãËØï([[https://github.com/vuejs/core/blob/main/packages/compiler-dom/__tests__/transforms/stringifyStatic.spec.ts][core/stringifyStatic.spec.ts at main ¬∑ vuejs/core]])Ôºö

#+name: testing
#+begin_export html
<script src="/assets/tests/compiler-dom.js"></script>
<div id="h1Mvr33k"></div>
<script src="/assets/js/vue-json-viewer/index.js"></script>
<script src="/assets/tests/h1Mvr33k.js"></script>
#+end_export

* COMMENT Local Variables       :ARCHIVE:
# Local Variables:
# after-save-hook: gcl/org-html-export-to-html
# End:
